---
title: 
URL: 
Tags/Keywords: # # # # #
lang: es-AR
---
# titulo
![[306.B5_Tokenizando_activos_en_Ethereum_V.mp4]]
[Titulo](URL)

En este vídeo vamos a ver otro ejemplo de tokenización. En este caso, vamos a representar cómo sería tokenizar energía renovable o energía verde. Actualmente, está muy demandado que distintas empresas, incluso particulares, quieran que la energía que consumen tenga un origen renovable. Entonces, para eso se generan certificados que indican que determinado porcentaje o determinada cantidad de energía tiene un origen renovable. Podemos utilizar blockchain y la tokenización para, en lugar de tener que esperar a esos certificados oficiales que son lentos, que igual tardan un año en darte un certificado, poder realizar esa trazabilidad de la energía y, mediante la tokenización, convertir a un servicio esa energía que se produce y se comercializa en un token.

Entonces, para ello, vamos a crear un nuevo smart contract y lo vamos a llamar "Green Energy Token". Vamos a copiar la versión y la licencia y vamos a crear el contrato "Green Energy Token". La diferencia con el de música es que aquí no hay una diferencia sustancial entre una energía y otra. Así que vamos a utilizar un token fungible como es el ERC20. No nos da igual un kilovatio que otro; al final, son energía. Esto puede ser un token equivalente, como pueden ser las monedas virtuales, etc. No nos da igual tener una moneda que otra, pues nos da igual consumir un kilovatio que otro, siempre que sea de energía renovable, que en este caso todos lo van a ser. Así que, en lugar de utilizar los tokens ERC721, vamos a utilizar el token ERC20. Para ello, lo importamos, al igual que hemos hecho otras veces, y hacemos `is ERC20`.

Entonces, tenemos que hacer el constructor. No le vamos a pasar ningún parámetro y le vamos a decir directamente cuál es el nombre y cuál es el símbolo. El nombre será "GreenEnergyToken" y el símbolo, las iniciales "GET". Vale. ¿Cómo vamos a modelar esto? Vamos a suponer que quien despliegue este contrato va a ser el gestor de este ecosistema, de esta manera de gestionar la energía. Entonces, además del gestor, vamos a tener productoras de energía, como puede ser Acciona, Endesa, etc. Lo que queremos hacer es que solo las compañías energéticas puedan producir energía, lo que aquí se traduce en mintear el token, y solo ellas van a poder transferirlo, para, digamos, emular cómo sería la vida real. La compañía energética produce la energía y la transfiere. No vamos a permitir que el usuario final o la compañía final, que ya ha recibido esa energía y la consume, luego pueda transferir ese token, porque en el momento en el que se transfiere a un usuario final se está simulando que esa energía ya ha sido consumida.

Entonces, ¿cómo vamos a gestionar lo de tener aquí distintos roles y que cada uno pueda hacer unas cosas u otras? Para ello, vamos a utilizar otro smart contract de OpenZeppelin que se llama "Access Control". Es parecido al de "Ownable" que hemos visto antes, pero el de "Ownable" solo permite que haya un propietario, mientras que aquí vamos a permitir que existan roles diferenciados. Así que vamos a importar `@openzeppelin/contracts/access/AccessControl.sol`. Entonces, también tenemos que hacer aquí que heredemos de ese smart contract: `AccessControl`. Vale, pues entonces, primero tenemos que definir los roles. Cada rol va a estar representado por un `bytes32`. Aquí los vamos a llamar, `bytes32 public constant`, porque estos no van a cambiar nunca, y entonces aquí vamos a poner los nombres, por ejemplo, "MANAGER". Y entonces aquí lo que vamos a hacer es un hash del nombre del rol. Aquí podríamos poner directamente un `bytes32` aleatorio, pero comúnmente lo que se hace y lo que indica la documentación de OpenZeppelin es que aquí hagamos un hash 256 y aquí pongamos "MANAGER", por ejemplo, y vamos a hacer lo mismo para la productora: "PRODUCER".

Vale, pues ya tenemos estos dos roles. El usuario que está desplegando este smart contract va a ser el manager. Para eso, llamaríamos a la función `setupRole`, que está dentro de la documentación; es la manera que tenemos de generar este rol llamando a esta función interna `setupRole`. Entonces, le vamos a dar el rol "MANAGER" al `msg.sender`. Muy bien, entonces ahora el manager es el que va a poder dar de alta a las productoras. ¿Cómo vamos a hacer eso? Pues vamos a hacer una función `addProducer` que recibe un parámetro `address newProducer` y esto va a ser público. Pero tenemos que hacer la comprobación de que solo el manager puede hacerlo. Para eso, vamos a hacer un `require`, vamos a llamar a la función pública del smart contract de "Access Control" que se llama `hasRole` y entonces aquí comprobamos que tiene el rol "MANAGER" quien está mandando la transacción en `msg.sender`. Y si no lo tiene, falla la transacción y ponemos un mensaje: "Only manager can add producers".

Una vez que ya comprobamos que quien está haciendo esta transacción es el manager, podemos asignarle el rol. Entonces hacemos `setupRole(PRODUCER, newProducer)`. Con esto ya hemos dado de alta productoras. Entonces, ahora lo que vamos a hacer es una función que nos permita producir energía. Al final, es mintear el token, pero bueno, vamos a llamarlo `produceEnergy` para diferenciarlo un poco. Al final, es lo mismo. ¿Cuánta cantidad? Esto sería una cantidad en kilovatios hora o megavatios hora, o incluso vatios hora, porque como sabéis que los decimales aquí no funcionan bien, incluso podría ser escalado kilovatios hora por 10 elevado a 18 y luego ya se desescala en el frontal de la aplicación que hiciésemos, lo que sea. Entonces, esta es una función pública y llama a la función de `mint` del ERC20. ¿Para quién está minteando? Pues la productora está produciendo para sí misma: `msg.sender` y la cantidad es `amount`.

Vale, entonces aquí tenemos que hacer lo mismo. Para que esta función solo la pueda llamar la productora, tenemos que hacer un `require`. `require(hasRole(PRODUCER, msg.sender))`. Y si no, mensaje de error: "Only producer can do this". Pues con esto ya tenemos las productoras que podrían producir la energía y podrían luego transferirlas a cualquier usuario, usuario final, etc. ¿Qué pasa ahora mismo? Que no tenemos manera de evitar que luego el usuario, por ejemplo, si la productora me manda a mí esos tokens, que luego yo los pueda reenviar a otra persona. Entonces, esto ya es un poco más avanzado, pero lo que vamos a hacer es sobreescribir la función interna del ERC20 de `transfer` con un guion bajo para evitar que cualquiera pueda transferir, excepto si es productora.

Entonces, la función de `transfer` interna, lo podéis ver si queréis en la documentación, aquí hace `address from`, `address to` y la cantidad. Y entonces esto va a seguir siendo `internal`, pero hacemos un `override` para que digamos que estamos sobreescribiéndola. Entonces, lo que estamos haciendo aquí, vamos a llamar, hacemos `super._transfer(from, to, amount)`, que aquí lo que estamos haciendo es llamar a la misma función de `transfer`, a la misma función interna. Entonces, `from`, `to` y `amount`. Ahora mismo, con esto no estaríamos haciendo nada, pero lo que vamos a hacer es copiar esta restricción, el `require` de que solo la productora va a poder hacer una transferencia. Pero como ya tenemos el mismo `require` en dos sitios, ¿qué vamos a hacer? Pues vamos a hacer un modifier: `modifier onlyProducer`. Como recordatorio, los modifiers son como un decorador, entonces es algo que se va a ejecutar antes o después de la transacción. En este caso, va a ser antes. Lo que hacemos es, en este modifier, comprobamos que es una productora el `msg.sender` y luego, guion bajo, punto y coma, que esto es, ejecute el cuerpo de la transacción a la que le estamos haciendo el modifier.

Entonces, ya no hace falta que tengamos aquí el `require` y lo cambiamos por poner aquí este modificador `onlyProducer` y aquí lo mismo, lo quitamos aquí, `onlyProducer`, con lo cual queda el código mucho más limpio. Vale, pues vamos a probar a hacer un despliegue. Desplegamos el token y aquí tenemos todas las funciones. Como vemos, hay unas cuantas que no nos interesan mucho, de tema de roles y demás. Aquí podríamos comprobar, por ejemplo, si el rol de la productora lo tiene una cuenta o no. El caso es que si yo ahora intento producir energía desde la cuenta que ha desplegado el contrato, que es la manager, me va a decir que no. Voy a producir todo esto, "Transact", y dice: "Solo la productora puede hacer esto". Vale, pues entonces, para eso tenemos que añadir una productora. Nos vamos a... Vale, lo estamos haciendo desde esta, desde la AV8. Vamos a coger la primera, copiamos su dirección, y entonces hemos vuelto, estamos ahora con el manager, ¿vale? Entonces vamos a añadir productora. Vamos a decir que esta va a ser una productora y le damos. Se ha realizado con éxito, entonces ahora nos vamos a esta cuenta que ahora es productora y esta cuenta sí que va a poder producir. La transacción se ha realizado con éxito, entonces ahora la productora tiene toda esa cantidad de tokens que representan, como hemos dicho, kilovatios hora, o megavatios hora, lo que sea.

Entonces, vamos a transferírselo a esta cuenta. Me he copiado la dirección, no he hecho nada más, y entonces desde aquí le puedo transferir a esta cuenta que sería un usuario final, una empresa, lo que sea. Le vamos a transferir esta cantidad porque esto lo que está representando es que está consumiendo esta energía renovable. Haríamos la transferencia y podríamos hacerlo. Si utilizásemos cualquier otra cuenta para intentar hacer una transferencia, nos diría que este mismo error, que solo la productora puede hacerlo. Solo la productora es capaz de transferir y de producir energía, y el manager lo único que puede hacer es añadir productoras. Bueno, pues este es un ejemplo muy sencillito y muy reducido de cómo podríamos gestionar, mediante blockchain, la tokenización de energía renovable para garantizar que los usuarios, las empresas, etc., están consumiendo energía renovable con una trazabilidad en la red blockchain de Ethereum.