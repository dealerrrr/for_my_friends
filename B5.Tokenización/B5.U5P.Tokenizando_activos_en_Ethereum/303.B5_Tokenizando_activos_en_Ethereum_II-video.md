---
title: 
URL: 
Tags/Keywords: # # # # #
lang: es-AR
---
# titulo
![[303.B5_Tokenizando_activos_en_Ethereum_II.mp4]]
[Titulo](URL)

Una vez que hemos visto cómo se crean los scripts de despliegue en Hardhat, vamos a crear nuestro propio script basándonos en este mismo. Para ello, vamos a crear aquí un nuevo fichero, al que le vamos a llamar deployNFTContra.js. Vamos a basarnos un poco en él, así que lo ponemos aquí a un lado y nos vamos a ir fijando. Lo primero que hace aquí es importar hre desde Hardhat. Hre significa Hardhat Runtime Environment. Y realmente, lo único que está haciendo es acceder a la propiedad ethers. Hay otra manera, en mi opinión, un poco más limpia de hacerlo, que es hacer `const ethers = require('hardhat').ethers`. Esto no supone una gran diferencia. Simplemente, en lugar de traernos todo el objeto hre y acceder a ethers con esta nomenclatura, con las llaves, ya directamente obtenemos el objeto ethers.

Luego, aquí tenemos una función asíncrona llamada main. Tiene que ser asíncrona porque casi todo lo que se hace relacionado con la blockchain se realiza de manera asíncrona. Después, aquí se llama a la función main, intentando hacer un catch si hubiese algún error, etc. Vamos a copiar esta misma fórmula y, entonces, ahora dentro de main tenemos que hacer lo que nosotros queramos. Aquí se están inicializando una serie de variables, más bien constantes, de cara a hacer el despliegue, pero nosotros lo vamos a hacer de otra manera porque no necesitamos nada de esto. Si recordamos, el constructor tiene el nombre y el símbolo. Vamos a instanciar esas constantes. Vamos a poner `const name = "myNBANFT"` y el símbolo lo vamos a llamar `MNFT`.

¿Cómo se hace aquí para desplegar un Smart Contract? Primero, se obtiene el Contract Factory, pasándole como parámetro el nombre del contrato, que es "log". Entonces, una vez que tiene esto, simplemente con ese factory hace un deploy y ya le pasa los parámetros, etc. Si os fijáis, aquí no se está diciendo en ningún momento desde qué cuenta se está haciendo. Si no especificas, va a coger por defecto la primera que esté disponible. Hardhat, como he dicho, monta su propia red y pone una serie de cuentas disponibles con cierto ether y ya está. Nosotros vamos a ir un poco más allá y vamos a especificar qué cuenta queremos. Para eso, hay una función del objeto ethers que es `getSigners`. Entonces, vamos a crear una constante. `getSigners` nos devuelve un array de las cuentas que pueden firmar transacciones, es decir, que están dentro de la red y tenemos acceso a su clave privada, por lo que podríamos firmar con ellas. Vamos a llamarle `owner`. Normalmente se les llama owner porque va a ser el dueño del contrato. Entonces hacemos `await ethers.getSigners()`. Vale, aquí podríamos tener varias, pero por el momento solo estamos cogiendo `owner`.

Como esto es un script y vamos a querer ir viendo qué es lo que está haciendo, vamos a ir poniendo `console.log`. Entonces aquí vamos a decir "Deploying NFT with account" y aquí vamos a poner la dirección de la cuenta. Va a ser `owner.address`. Ahora vamos a coger el factory de la misma manera, `const nftFactory = await ethers.getContractFactory("NBA NFT")`. Entonces, ahora vamos a inicializar el contrato. Vamos a desplegarlo. Entonces, `nftContract` es igual a `await nftFactory.deploy(name, symbol)`. Si os fijáis, aquí se está haciendo el nombre del factory.deploy. En lugar de decir el deploy, vamos a hacer `.connect(owner)`, que ahora mismo no es necesario porque si solo estamos utilizando una cuenta nos da igual, pero cuando estemos con varias, el connect es para indicarle con qué cuenta vamos a hacer la acción, en este caso la acción de despliegue. Hacemos `connect(owner)`, como digo, esto no es necesario, pero creo que es una buena práctica para que se vea claramente quién está haciendo qué.

Aquí hay que pasarle los argumentos. ¿Qué argumentos tiene? Pues el nombre y el símbolo: `name`, `symbol`. Aquí, si os fijáis, se está pasando un parámetro y luego entre llaves, estas son como las opciones de la transacción que estás enviando. En este caso, tiene un `value`. Esto significa que está mandando Ether al Smart Contract. En nuestro caso, nada de eso, simplemente los dos parámetros que queremos mandar, el nombre y el símbolo. Con esto ya se desplegaría. Pero además, vamos a hacer un `await nftContract.deploy()`. ¿Qué hace esto? Esto dice que espere hasta que este contrato se haya desplegado porque en estas redes que crea Hardhat se hace instantáneo, pero, por ejemplo, en una red mainnet o lo que sea, puede tardar unos segundos, 15, 30 segundos en desplegarse, dependiendo de cuánta congestión haya en la red. Entonces, queremos esperar a que esté desplegado para estar seguros de que ya lo ha hecho todo.

Y entonces vamos a hacer aquí también unos cuantos `console.log` para decir... Vamos a decir "NFT deployed to..." ¿A dónde se ha desplegado? Pues `nftContract.address`. Como esto es un objeto contrato, podemos acceder a su dirección directamente. ¿Qué más? Podemos ver el hash de la transacción que lo ha desplegado: `console.log("Transaction hash:", nftContract.deployTransaction.hash)`. Y entonces este nos da el identificador de la transacción que lo ha hecho. ¿Qué más cosas podemos poner? Podemos consultar otra información del Smart Contract de NFT. `console.log("Name:", await nftContract.name())`. Y esto es una función, así que lo ponemos con un solo paréntesis. Y podemos hacer lo mismo con el símbolo: `console.log("Symbol:", await nftContract.symbol())`.

Vale, pues yo creo que con esto tenemos ya suficiente. Y ahora podemos hacer un despliegue de este Smart Contract. Entonces, `npx hardhat run scripts/deployNFTContra.js`. Muy bien, pues entonces lo ha desplegado con esta cuenta, que es la cuenta por defecto, lo ha desplegado a esta dirección, este es el address de nuestro NFT, este es el hash de la transacción y el nombre y el símbolo los ha puesto correctamente. Vale, pues ya podemos desplegar. El problema es que, como he dicho, la red solo se levanta mientras dura el script, entonces, como es una red de desarrollo, no podemos interactuar con ella. No podemos, ahora mismo, mintear NFTs, es decir, podríamos mintearlos en este mismo script, pero creo que no es eso lo que queremos. Entonces, vamos a ver cómo podemos hacer para desplegar en otras redes.

Tenemos aquí un fichero que se llama hardhat-config.js, que contiene toda la configuración de Hardhat. Ahora mismo no tiene prácticamente nada, como veis. Lo único que dice es que la versión de Solidity es la 0.8.17, que es la que estamos usando. Si vais a la documentación, veréis que aquí en el módulo de exports, además de la versión de Solidity, podéis poner un montón de cosas. Entre ellas, ¿qué es lo que nos interesa a nosotros ahora mismo? Networks. Aquí podemos decir las redes que vamos a poner. Así que vamos a crear una red que, por ejemplo, vamos a hacerlo con Ganache. Entonces vamos a poner aquí Ganache y aquí tenemos que poner la URL del Ganache que vamos a hacer. Por hecho que habéis instalado ya Ganache, lo podéis hacer tanto en la versión de consola como en la versión con el GUI, con la interfaz visual. En este caso, vamos a hacerlo con la interfaz visual para poder verlo de una manera más sencilla. Vamos a crear un nuevo workspace y aquí lo vamos a llamar "workspace mba.nft". Guardamos el workspace y ahora vamos a ver qué información hay aquí.

¿Qué es lo que necesitamos sí o sí para esto? Pues la URL. Entonces, la URL de esto va a ser la que nos indique aquí, el rpc0. Lo copiamos y lo pegamos. El HTTP lo voy a poner en minúscula, pero eso ya es una cuestión de gustos. Entonces, esto está accediendo al que es el local, al puerto 7545, que es donde está ahora mismo esto. Y si veis aquí, tenemos una serie de cuentas con su ether y demás con las que vamos a poder interactuar directamente. Vemos aquí el líder de la red, etc. Y aquí vamos a poder ver las transacciones. Entonces, hemos visto cómo se despliega aquí. Si ahora fuésemos a desplegar, no lo va a hacer directamente en la red de Ganache. Como vemos aquí, no ha hecho nada. Si estamos haciendo una red que no sea la por defecto, la de desarrollo, hay que especificarlo. Para eso se utiliza el flag `--network` y el nombre de la red que le hayamos puesto en el hardhat.config, en este caso Ganache. Y entonces, aquí, como veis, está utilizando una cuenta distinta y eso significa que algo diferente ha pasado.

Entonces, si ahora vamos a Ganache, aquí vemos que hay una transacción. Comprobamos que su hash corresponde a e0ccc y e0ccc, es el mismo y esto ha creado un Smart Contract 0xe9df y aquí está 0xe9df. Vale, pues ya tenemos nuestro Smart Contract de NFT en una red persistente de Ganache. Entonces, ahora mismo podríamos hacer nuestro otro script, por ejemplo, para mintear NFT. Vale, pues podemos hacerlo, vamos a crear aquí otro script, vamos a llamarle mint-nft.js, siempre estamos usando JavaScript. Vamos a copiar la estructura que hemos creado aquí, entonces esto lo vamos a quitar y ahora vamos a decir, ¿qué queremos hacer? Pues lo primero que necesitamos, ¿qué información necesitamos? Primero, ¿cuál es la dirección del Smart Contract del NFT al que vamos a atacar? Así que vamos a hacer una constante `NFT_ADDRESS`. ¿Y cuál va a ser? Pues en este caso vamos a copiar la dirección donde se ha desplegado. Entonces venimos aquí y lo pegamos. Cada vez que despleguemos un nuevo Smart Contract, tendremos que cambiar esta información. Si estamos utilizando una red distinta, en este Smart Contract no va a ser. Por ejemplo, si yo no le pusiera el `--network ganache`, cuando llame a este script, no va a encontrar el Smart Contract en esta dirección. Porque esta dirección es el NFT de nuestro Ganache que tenemos aquí. Este. No está en ninguna otra red.

Entonces, como siempre, vamos a poner aquí un `console.log` y vamos a decir, pues, venga, "Using NFT contract at" y entonces vamos a poner aquí en qué lugar está, `NFT_ADDRESS`. Ahora lo que queremos es... ya no queremos utilizar un factory porque ya no vamos a desplegar un contrato, vamos a coger uno que ya exista. Para eso, el objeto ethers también nos provee de funciones que nos permiten coger una instancia ya desplegada de un Smart Contract. Entonces, vamos a coger aquí `const NFTContract = await ethers.getContractAt("MBA_NFT", NFT_ADDRESS)`. Esto nos dice el nombre, o el ABI, vamos a usar el nombre, claro, que esto es, como lo habíamos llamado, "MBA_NFT". Y la dirección, pues la dirección que hemos puesto. Y con esto ya tendríamos el objeto NFT. De hecho, si nos copiásemos esta información, el nombre, el símbolo, para comprobar que estamos haciendo justo lo que queremos, nos lo va a mostrar correctamente.

¿A qué función podemos llamar para mintear? Pues a la función de mint que hemos creado. ¿Qué parámetros recibe? Un `addressTo` y un `tokenUri`. Vale, pues entonces aquí vamos a... perdón, aquí en el Mint NFT. Vamos a hacer `const mintTx = await NFTContract.connect(owner).mint(owner.address, "testURI")`. Esto es equivalente a que cuando estamos desplegando hacemos un `await deployed`, pues aquí es `await mintTx.wait()`. Esto espera que la transacción se haya confirmado. Una vez que se ha confirmado, podemos mostrar algunas cosas, por ejemplo, vamos a poner un `console.log` que nos diga aquí "Minted NFT with ID" y entonces aquí vamos a mostrar el ID de la transacción. Perdón, el ID de la transacción, no, el ID del NFT. Entonces, ¿cuál es el ID del NFT? Pues entonces será, si os acordáis, el total supply es el último... es cuántos NFTs hay. Entonces, si el total supply es 1, el NFT que hemos minteado va a ser el 1. Entonces aquí hacemos `const NFTID = await NFTContract.totalSupply()`. Aquí no pongo el connect porque esto es un call, no estamos mandando una transacción, así que no lo hacemos desde ninguna cuenta, simplemente que nos dé ese valor. Entonces aquí decimos, vale, pues este es el NFT, el ID del NFT.

¿Qué más podemos sacar? Por ejemplo, podemos ver cuál es el URI. Entonces lo mismo, voy a copiar esta línea, `console.log("Token URI:", await NFTContract.tokenURI(NFTID))`. Esto lo podéis comprobar si queréis en OpenCPLIN. Pues `tokenURI`. Esto es una función pública que le indicas el token ID y te devuelve el URI. En este caso, el URI va a ser lo que le hemos puesto, que es "testURI", que no sirve de nada. Normalmente, esto tiene que ser una URL o un URI en un servidor o en IPFS o donde sea. En este caso, es simplemente para comprobar que ha metido este campo de texto correctamente. Vale, pues entonces `await NFTContract.tokenURI(NFTID)`.

¿Qué más información podemos sacar? Podemos coger el owner. El owner de este NFT. Esto es una función que se llama `ownerOf`. Esto lo podéis ver, esto es parte del estándar ERC721. Podéis comprobar todas sus funciones en la documentación oficial o, como hemos visto antes, aquí en los contratos de Open Zeppelin, `ownerOf`. Voy a ampliar un poco el tamaño. Vale, ampliamos aquí un poquito para que se vea un poco mejor. Vale, pues entonces con esto estamos minteando un token, un NFT a esta cuenta con este URI. Vale, pues yo creo que con esto ya tenemos todo. ¿O necesitamos algo más? Bueno, yo creo que con esto ya podemos... Vale, también podemos ver, por ejemplo, el hash de la transacción: `console.log("Mint transaction hash:", mintTx.hash)`. Como tenemos aquí el `mintTx`, esto va a ser... aquí no hace falta un await porque es simplemente acceder a una propiedad que ya está guardada dentro de esto.

Ahora vamos a llamar al script `scripts/mint-nft.js` en la red de Ganache, porque como hemos dicho, este Smart Contract está en la red de Ganache. Acabamos de mintear un NFT, tenemos aquí el hash de la transacción, el owner que es el que ha creado el contrato, el token URI, en efecto, este es el URI, el ID es 1. Y ahora, si lo comprobamos mirando Ganache, aquí tenemos la transacción nueva que se ha creado, el hash F710, coincide, F710. ¿Al contrato del NFT? Sí, coincide. Pues entonces, ahora nuestro address ya tiene ese NFT. Con esto hemos conseguido desplegar un NFT y mintearlo en una red, que en este caso es la red de Ganache. A continuación, vamos a ver cómo hacerlo en una red testnet, como por ejemplo en Mumbai, que es la red testnet de Polygon, de Matic.