---
title: 
URL: 
Tags/Keywords: # # # # #
lang: es-AR
---
# titulo
![[302.B5_Tokenizando_activos_en_Ethereum_I.mp4]]
[Titulo](URL)

En este vídeo vamos a crear un proyecto en el que desarrollaremos un smart contract de un NFT para posteriormente desplegarlo en una red de pruebas. Para ello, comenzaremos creando una carpeta; en este caso, yo la he llamado mbAnft, y esta será la base de nuestro proyecto. Como se ha visto en otros vídeos, uno de los entornos de desarrollo posibles es Truffle, pero para explorar otras opciones, lo haremos en Hardhat. Si buscamos Hardhat en Google, la primera opción que aparece es la de este entorno de programación. Vamos a "Get Started" y aquí tenemos una documentación completa sobre cómo funciona y cómo utilizarlo. Es necesario tener instalado Node para poder utilizar esto. No vamos a entrar en detalles sobre cómo se instala Node, pero sí veremos cómo instalar Hardhat y cómo empezar a utilizarlo, asumiendo que ya tenemos el entorno configurado. Para ello, primero debemos instalarlo con el comando `npm install --save-dev hardhat`. Así que copiamos esto, abrimos un terminal, y desde allí, podemos abrir un nuevo terminal o usar el atajo de teclado, como he hecho yo, y pegamos estas entradas. Mientras se instala, que puede tardar un poco, podemos ver qué más podemos hacer.

Lo primero que haremos será crear el contrato, específicamente el contrato del NFT. Para ello, como hemos visto en otros vídeos, utilizaremos lo que ya nos ofrece OpenZeppelin. Así que vamos a la web de OpenZeppelin, en la sección de Contratos, y buscamos el estándar ERC721, que es el que se utiliza para los NFTs. Aquí nos proporciona información sobre cómo implementarlo. Vamos a elegir un NFT de tipo URI Storage. ¿Qué significa esto? Que cada NFT que emitamos tendrá una URI, es decir, un enlace al contenido. Si no utilizáramos el tipo URI Storage, y simplemente utilizáramos un ERC721, tendríamos una base URI, que sería una URL base, más el número de cada uno de los NFTs, como barra 1, barra 2, etc. Lo que haremos es que sea URI Storage para que podamos definir la URI completa de cada NFT. A ver si ya se ha terminado de instalar... Bien. Una vez que esté instalado, como hemos mencionado, podemos usar `npx hardhat` o `hardhat init`, cualquiera de las opciones es válida. Nos aparecerá un asistente; vamos a crear un proyecto de JavaScript. La raíz será la carpeta en la que estamos ahora mismo. Si queremos añadir un gitignore, lo haremos en caso de que luego queramos subir esto a un repositorio. Si deseamos instalar las dependencias que vienen por defecto, en general, aceptaremos todas las opciones que nos proponga, ya que será el ejemplo más básico de un proyecto en Hardhat. Mientras se instalan las dependencias, observamos que ya se ha generado una estructura de carpetas. La que nos interesa ahora es la de Contracts, que ya incluye un contrato de ejemplo que podemos usar como referencia para crear el nuestro. En esta misma carpeta, crearemos nuestro contrato, que llamaremos MVANFT, por ejemplo. Copiamos la licencia y la versión de Solidity, y aquí podemos hacer los cambios necesarios. Podemos usar `pragma solidity ^0.8.17;`, que en el momento de grabar este vídeo es la versión más reciente. Entonces, como hemos hecho en otras ocasiones, definimos el contrato con el nombre `MVANFT`.

Si nos fijamos en lo que queremos hacer aquí, debemos importar los contratos de OpenZeppelin que utilizaremos. Por defecto, no tenemos instaladas las dependencias de OpenZeppelin, así que debemos acceder a ellas. Si volvemos al principio, nos indica cómo instalarlas: `npm install @openzeppelin/contracts`. Copiamos esto y, con ello, ya podremos acceder a los contratos de OpenZeppelin. Vamos a importar el `ERC721URIStorage`, y luego diremos que este contrato `MVANFT` es un `ERC721URIStorage`. Una vez que tengamos esto, debemos definir el constructor. Aquí, como estamos viendo, utiliza un constructor que no recibe ningún parámetro y establece directamente el nombre y el símbolo del token. Usaremos esto como base y luego lo modificaremos según sea necesario. Por defecto, sería así, pero quizás queramos poder cambiarlo para cada contrato que despleguemos, estableciendo el nombre y el símbolo.

Para ello, podemos definir `string memory name` y `string memory symbol`. Simplemente pasaremos estos parámetros al constructor.

No es necesario incluir nada más en el constructor. Hay muchas otras modificaciones posibles; por ejemplo, aquí se está utilizando el tema del control de acceso, se están utilizando contadores, y se están realizando varias acciones. El tema del control de acceso sí nos interesa. Si recordáis otros vídeos, había un smart contract de OpenZeppelin llamado Ownable, que es relevante para que el propietario del contrato sea el único que pueda mintear NFTs. Así que, nos dirigimos a la sección de control de acceso y vemos que se está importando el Ownable, como hicimos en el otro vídeo. Además de ser URI Storage, lo configuraremos como Ownable. Así, en el momento de desplegar este smart contract, la dirección que lo despliegue será el propietario de este contrato.

¿Qué más podemos hacer ahora mismo? Este contrato es muy básico, pero queremos que se pueda mintear NFTs. Actualmente, no se puede hacer, ya que solo tenemos el NFT vacío. Para ello, crearemos una función de minteo, que será muy similar a lo que hemos visto en el ERC20. Si recordáis, revisamos el GitHub de los contratos y vimos cómo estaban implementados. Vamos a la carpeta de Contratos, Token, 721. Allí encontraremos una función interna de mint.

Dado que esta función es interna, a menos que definamos una función pública, como hicimos con el ERC20, no podremos acceder a ella. Así que crearemos una función mint que sea pública y que llame a esta función interna. Creamos aquí una función mint y los parámetros que recibirá serán la dirección a la que se le minte este NFT. También, como hemos mencionado, esto es un URI Storage, así que cada NFT tendrá un URI específico. Por lo tanto, también especificaremos este URI en esta función. Esta función será externa, ya que solo se llamará desde fuera del contrato, y tendrá el modificador `onlyOwner`, es decir, solo el propietario de este contrato podrá mintear. Si os habéis fijado, en el mint lo que realmente está recibiendo es la dirección `to` y el `tokenId`. El `tokenId` será autoincremental. Podríamos establecer que cada vez que mintamos un NFT definamos un ID, pero tiene más sentido que el primer NFT sea el 1, el siguiente el 2, etc. El tema del token URI, aunque no aparece en esta función de minteo, está en el smart contract de URI Storage, que a su vez sobrescribe la función mint del ERC721.

¿Cómo haremos que los IDs de los NFTs sean autoincrementales? Para ello, podemos tener una propiedad que sea `totalSupply`. Así que definimos aquí un `uint256 public totalSupply`. De este modo, también podremos consultar de manera fácil y pública cuántos NFTs se han minteado ya. Lo primero que haremos en la función mint será incrementar el valor de `totalSupply`. Inicialmente, como ya sabéis, se inicializa en 0, así que al mintear, diremos que esto será 1. Luego, crearemos una variable que será `tokenId`, y el `tokenId` tendrá el mismo valor que `totalSupply`, es decir, el primero será el 1; si ya hay 3, este nuevo será el 4. Ahora llamamos a la función mint, minteando a la dirección que hemos especificado y estableciendo el `tokenId` que acabamos de crear. Además, al mintear, estableceremos el URI de ese token. Esto tiene una función interna llamada `setTokenURI`. Así que diremos que este `tokenId` ahora tendrá este `tokenURI`. Al igual que hemos hecho con el mint, que tiene una función interna, pero accedemos a ella a través de una función externa, también estamos haciendo esto con el URI. Si quisiéramos poder cambiar el URI de un token posteriormente, podríamos crear una función pública llamada `setTokenURI` para modificar el URI de cualquier token. Sin embargo, por ahora, no lo haremos. Os recomiendo que echéis un vistazo a los contratos de OpenZeppelin, para ver cómo funcionan internamente y qué cosas podéis modificar o experimentar con los contratos. Con esto, ya tendríamos un contrato básico de NFT. Simplemente estamos desplegándolo y minteándolo. Como veis, no he implementado ninguna función de transferencia ni nada, porque eso lo maneja el propio smart contract de OpenZeppelin.

Bien, ya se han instalado las dependencias y tenemos el contrato listo. Ahora lo que haremos es compilar este contrato y comprobar si hay algún error. Para ello, utilizamos `npx hardhat compile`. Nos indica que se ha compilado con éxito. Esto ha creado una carpeta llamada Artifacts, donde dentro de Contracts tendremos cada uno de los contratos que hemos creado. Está el log, que no nos interesa, de hecho, incluso podríamos borrarlo, y el que hemos creado nosotros, el `mbAnft.sol`. Aquí se genera un JSON que es similar a lo que vimos en Remix. Por un lado, tenemos el ABI y más abajo el bytecode, que es el código compilado; como veis, esto es enorme. Esto tampoco es muy necesario saberlo, pero que sepáis que dentro de Artifacts tenéis la información de los contratos que se han compilado. Lo ideal sería que ahora creáramos una serie de tests. Por ejemplo, aquí tenemos un test de ejemplo para el LOCKS, donde se intenta acceder a las distintas funcionalidades y comprobar que los smart contracts que has desplegado funcionan como se espera. ¿Qué tipo de test podríamos hacer? Podríamos comprobar que si una cuenta que no es el propietario del contrato no puede mintear, o que no puede transferir un NFT que no le corresponde. Todos esos tests se realizarían aquí. Se crearía un archivo, en este caso `mbAnft.js`, y allí se testearía. Para ejecutarlos, usaríamos `npx hardhat test`, y se ejecutarían todos los tests que haya en la carpeta test. Los tests del smart contract de log han pasado correctamente. No nos pondremos a crear tests, ya que esto podría alargarse demasiado.

Para desplegar los smart contracts, tenemos un script en la carpeta scripts, donde se colocarán todos los scripts que queramos ejecutar. En este caso, como vemos, hay un script que es deploy. Este script deploy es para el smart contract de ejemplo de log; al ejecutar este script, desplegará automáticamente el smart contract de log y realizará las acciones que corresponden a ese smart contract. A continuación, crearemos un script de despliegue para el contrato de NFT, pero primero lanzaremos el script de deploy que ya existe, el de log, solo para ver cómo funciona antes de hacer el nuestro.

`npx hardhat run scripts/deploy.js`

Aquí nos dice que ha desplegado el smart contract de log y lo ha hecho en esta dirección. Entonces, os preguntaréis, ¿en qué red lo ha desplegado? Hardhat, como he mencionado, es una herramienta que me gusta mucho; es muy intuitiva y tiene muchas funcionalidades. Cuando hacemos algún tipo de despliegue o similar, por defecto crea una red temporal, que solo existe durante el tiempo que dura el script. Al lanzar el script, crea la red con sus cuentas que ya tienen su ether, y al finalizar el script, separa esa red. También hay otras opciones para mantener la red abierta y así tener cierta persistencia entre distintas ejecuciones. Esto, como primer acercamiento, nos puede ser útil; simplemente estaríamos desplegando en la red y probando que funciona, y luego, posteriormente, intentaríamos desplegar en otras redes, como puede ser Ganache, donde sí podemos tener cierta persistencia y ver qué está ocurriendo, y posteriormente desplegar en Testnet.