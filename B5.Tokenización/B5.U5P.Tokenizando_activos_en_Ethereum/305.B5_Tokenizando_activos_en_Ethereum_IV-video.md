---
title: 
URL: 
Tags/Keywords: # # # # #
lang: es-AR
---
# titulo
![[305.B5_Tokenizando_activos_en_Ethereum_IV.mp4]]
[Titulo](URL)

En este vídeo vamos a hablar sobre la tokenización. La tokenización es el proceso por el cual convertimos activos físicos o digitales en tokens, que son activos digitales que se pueden transferir de forma segura y sin intermediarios en la red blockchain, como en este caso es Ethereum. Los tokens pueden seguir estándares como el ERC20, que ya hemos visto anteriormente, el ERC721, que es el estándar de los NFTs, o pueden no seguir ningún estándar. En este caso, vamos a hacer algunos ejemplos de distintos activos que se pueden tokenizar. Por ejemplo, vamos a hacer un caso en el que podamos tokenizar canciones. De este modo, las canciones que tokenicemos ya estarán en la blockchain, con lo cual podremos tener trazabilidad de que han sido registradas, evitando así el posible plagio, incluso pudiendo transferir el token de esa canción para transferir los derechos que ello conlleva.

Para ello, vamos a crear un smart contract que llamaremos "MusicToken". Vamos a copiar la información de la licencia y vamos a modificar el número de versión del compilador de Solidity, como hemos hecho en otros vídeos. Este contrato lo vamos a llamar "MusicToken". ¿Cómo queremos que sea este contrato? Vale, pues lo que tiene sentido es que sea un token no fungible, un NFT, porque cada canción va a ser distinta de las demás y no pueden ser intercambiables, que es lo que diferencia los tokens ERC20 de los ERC721. Entonces, primero vamos a definir cómo es una canción. Vamos a crear un struct, le damos a "MarkSong" y aquí le podemos poner una serie de propiedades. Por ejemplo, le podemos poner un título, le podemos poner el artista; ambos los vamos a poner de tipo string, el año en el que se realizó la canción y luego un tipo bytes32, que es una ristra de 32 bytes. Por ejemplo, cuando se realiza un hash, al final es lo que tenemos: un hash de una transacción o un hash de un fichero o lo que sea, y entonces lo vamos a llamar simplemente "hash". Este va a ser el hash del fichero de la canción.

Los hashes tienen la propiedad de que, con nada que cambie, aunque cambie un solo byte del contenido del fichero o del string que se esté haseando, el hash va a ser totalmente distinto. Con esto nos aseguramos de que cada canción va a tener únicamente un hash y cada hash se va a corresponder únicamente a una canción. Vamos a hacer ahora un mapping en el que vamos a asociar el identificador de la canción, que va a ser un identificador numérico, con este struct de tipo canción. Va a ser una variable pública, vamos a llamarla "songs". Y además, también queremos, como hemos dicho, que los hashes no pueden repetirse y no puede haber dos canciones con el mismo hash. Lo que vamos a hacer es una comprobación para ello utilizando un mapping que nos asocie el hash con el identificador de la canción. Y aquí lo vamos a llamar "hashesToIDs". La clave de este emparejamiento será el hash y el valor será el identificador de la canción. Mientras que aquí la clave es el identificador y el valor es la canción en sí misma, el struct de canción.

Queremos que este smart contract sea un ERC721. Entonces, igual que hicimos en vídeos anteriores con el ERC20, vamos a importar desde OpenZeppelin el smart contract del ERC721. Para ello, hacemos un import: `@openzeppelin/contracts/token/ERC721/ERC721.sol`. Esto os recomiendo que lo consultéis en la página web porque, como he dicho, hay un montón de contratos de OpenZeppelin. Entonces, podéis ir mirando en el GitHub o en la documentación dónde se encuentra cada uno y cuál es la ruta adecuada para importarlos. Entonces, este smart contract, para que sea un ERC721, hacemos `is ERC721`. Vale, entonces con esto ya lo estaríamos transformando en un NFT.

Entonces... ¿Qué es lo que nos dice? Vale, pues aquí nos salta un error porque, en cuanto estamos implementando este smart contract, estamos haciendo un contrato que hereda del ERC721. Nos dice que necesitamos tener un constructor, un constructor que siga una estructura: `constructor` y aquí `ERC721` y hay que pasarle cuál va a ser el nombre y el símbolo del smart contract del token. Por ejemplo, lo podemos llamar "MusicToken" y el símbolo, pues "MVS", por ejemplo. Y esto sería un constructor vacío, no necesitamos hacer nada más. Entonces, aquí Remix ya no se queja, ya funciona todo correctamente. Y entonces ya tendríamos una manera de tener un smart contract de tokens de música.

¿Qué sería lo siguiente? Pues sería la opción de mintear el NFT. Ahora mismo no podemos mintearlo, solo tenemos el contrato, pero no hay manera de mintearlo. Entonces vamos a crear una nueva función que se va a llamar `createSong`, en la que vamos a generar un nuevo struct y lo vamos a mintear, el NFT asociado a esa canción. Podríamos hacer esto de múltiples maneras. Por ejemplo, podríamos hacer que el contrato sea "Ownable", es decir, que tenga un propietario y solo el propietario pueda crear las canciones. Pero esto vamos a visualizarlo como si fuese una plataforma abierta para que cada artista pudiese registrar su música. Así que no vamos a añadir esa modificación y vamos a hacer que esta función sea pública y cualquiera pueda utilizarla.

Esta función requiere los parámetros para poblar la estructura de canción. Empezamos con un `string memory`. Si recordáis, cada vez que lo pasamos como parámetro, le tenemos que poner `memory`. Aquí indicamos el título, el artista. Voy a copiar: `string memory artist`, un `uint256` que va a ser `year`. Y por último, el `bytes32` que va a ser el hash. Esta función va a ser pública y no es una view porque esto sí que modifica el estado de la blockchain. Entonces, para que sea autoincremental, es decir, que cada nuevo NFT que se genere, cada canción nueva tenga un identificador que vaya aumentando, tenemos que crear una propiedad que sea el total supply. No es necesario que se llame `totalSupply`, podríamos llamarle `Counter` o `SongNumber`, etc. Normalmente, `totalSupply` creo que está claro para saber cuántos tokens hay; es un nombre bastante representativo. Así que vamos a aumentar inicialmente el `totalSupply` cuando estamos creando una canción. La primera canción que creemos ya tendrá el identificador 1. Entonces, `songs[totalSupply]`, que la primera será 1, igual a `Song`. Y esto es igual que lo que hicimos en otros vídeos anteriores para crear un struct y meterle los datos. Simplemente los vamos metiendo de manera ordenada. Así. Entonces, aquí sería primero `title`, `artist`, `year` y el `hash`.

Ya hemos creado la canción, la hemos metido dentro de `songs` y ahora también lo que vamos a hacer es meterla dentro de `hashesToIDs` para que tengamos esta relación hecha. Ya hemos hecho esta, pero nos faltaría esta de aquí. Así que hacemos `hashesToIDs`. Entonces tenemos que introducir como clave el hash. Me estoy dando cuenta de que me falta una barra baja. El hash va a ser igual al ID de este token, que es `totalSupply`. Vale, entonces ya hemos creado una estructura `Song`, la hemos metido dentro del mapping de `songs`, hemos guardado su... hemos linkeado su hash y su identificador aquí, y ahora nos quedaría mintear el NFT. Para mintearlo, vamos a llamar a la función interna del ERC721: `mint` y entonces aquí tenemos que indicar a qué usuario lo vamos a mintear, que lo vamos a hacer a `msg.sender`, que esto ya lo hemos visto anteriormente, que es la dirección que está mandando esta transacción. Y vamos a indicar cuál es el identificador de este token, que como hemos dicho, pues ahora mismo es `totalSupply`. Con esto ya estaríamos creando la canción, minteando el token y dándoselo al que está enviando la transacción.

Pero ahora lo que vamos a hacer, además de esto, es poner un `require`. Vamos a poner una restricción para que no se pueda registrar dos veces la misma canción y eso lo vamos a hacer teniendo en cuenta el hash. Para eso tenemos aquí nuestro mapping de `hashesToIDs`. Entonces, si el hash ya se hubiese registrado previamente, este hash se correspondería con un número que es mayor que 0 porque en la primera canción que se registre va a tener un identificador de 1. Entonces, si se ha registrado, sabemos que va a tener un identificador mayor que 1. Así que para ello vamos a hacer un `require` en el que vamos a comprobar que el ID asociado a ese hash tiene que ser 0, lo que significa que la canción no se ha registrado. Así que `hashesToIDs[hash]` tiene que ser igual a 0. De lo contrario, damos un mensaje de error que es "Song already exists".

Muy bien, pues vamos a compilar. Tenemos un autocompiler, así que ya se habrá compilado. Así que ahora vamos a desplegar el token. Lo hemos desplegado, aquí vemos todas las funciones. Vamos a crear una canción. Para ello, el título lo vamos a llamar "My Song", el artista va a ser "Artist", el nombre del artista, el año 2022 y ahora el hash de la canción. Para eso, ¿cómo vamos a hacer? Pues tendremos que hashear el fichero en mp3 de la canción, mp3 o flac o el archivo que sea. Para esto lo podemos buscar simplemente online, "hash file online". Y entonces aquí tendremos alguna web, por ejemplo, esta de aquí, que nos permite hashear cualquier fichero que arrastremos con distintos algoritmos. Vamos a utilizar SHA-256, que es muy común. Entonces nos traemos aquí... vamos a coger "mysha1.mp3", lo arrastramos y entonces este es el hash que nos genera. Así que lo vamos a poner aquí. Hay que poner `0x` para indicar que es un `bytes32`, que es un string hexadecimal. Vale, entonces ahora realizaríamos la transacción. La transacción se ha realizado correctamente. Y entonces, podríamos ahora, si metemos este hash aquí en `hashesToIDs`, nos va a decir que este hash se corresponde al token 1. Y entonces aquí, si buscásemos la canción número 1, nos dice el título, el artista, el año y el hash, de modo que si, por ejemplo, alguien me robara la canción y fuese a comercializarla sin mi permiso, yo podría demostrar, porque esto está en blockchain y lo que hay en blockchain es inmutable, que esta canción ya fue registrada.

Incluso lo suyo sería que, una vez que la registrásemos, nos guardásemos el hash de la transacción y esto lo consultásemos a un explorador público y nos dijese: "Vale, esta transacción fue registrada en blockchain el día tal de tal de tal". Entonces sabemos que esto ya ha sido registrado, esta canción ya existía y ya fue registrada a mi nombre en blockchain tal día a tal hora, evitando así que nos puedan plagiar o que nos puedan intentar comercializar cosas en nuestro nombre. Con esto ya tendríamos una manera de demostrar que la canción es nuestra. Luego, si quisiéramos ceder los derechos de esa canción a otra persona, podríamos simplemente transferir este NFT a otra dirección. Simplemente haríamos un `safeTransferFrom`, etc., de qué dirección a qué dirección y cuál es el identificador. En este caso, sería el número 1.

¿Qué más funcionalidad podríamos ponerle? Por ejemplo, podríamos poner un evento que, cuando se cree la canción, emita un evento, como hemos visto otras veces, y con esa información, de modo que sea más sencillo desde una aplicación externa poder ver cuándo se están registrando canciones. Si yo tengo una canción y no sé a quién pertenece, ¿cómo lo podría hacer? Ahora mismo tendría que ir canción por canción comprobando cuál es el token. En la canción número 1 vemos que el bytes es esto y le diríamos: "¿Quién es el owner de la canción 1?" y aquí nos lo diría. Pero se me ocurre que podemos hacer otra funcionalidad muy sencilla para que directamente con el hash ya sepamos quién es el owner. Vamos a crear aquí una función que se llama `getSongOwner`, que va a recibir un `bytes32`, que es el hash. Esta función va a ser pública, va a ser view porque no modifica el estado, simplemente es para leer información y nos va a devolver un address. Queremos que nos devuelva el `ownerOf`, que es una función pública que ya nos ofrece el ERC721, de hecho la tenemos aquí. Y lo que vamos a hacer es transformar el hash en el ID y para eso utilizamos este mapping que tenemos: `hashesToIDs[hash]`.

Entonces... A ver qué error hay aquí... Ah, vale, sí. He escrito mal esto. Es `returns`, no era `return`. Vale, entonces, volvemos a hacer lo mismo. Nos cargamos el smart contract, lo desplegamos de nuevo, vamos a crear la canción, el hash vamos a coger este de aquí de nuevo, realizamos la transacción. Entonces, si yo quisiera aquí `getSongOwner`, imaginemos que yo no he registrado nada, yo no sé nada, yo simplemente me han pasado un fichero con la canción. Porque digamos que yo soy un juez que voy a resolver la disputa de quién es el autor real de esta canción porque ha habido un plagio o lo que sea. Entonces yo tendría, como hemos hecho antes, el fichero. Aquí, y lo vamos a actualizar para hacerlo de nuevo, tengo el fichero, saco el hash y digo: "Vale, me vengo aquí a blockchain, 0x y el hash, ¿quién es el dueño de esta canción?" Le doy, y entonces aquí me saldría el address, y entonces el dueño de esta wallet diría: "Está confirmado, yo soy el dueño", y con esto se resolverían las disputas.

Vale, pues con esto hemos visto una manera bastante sencilla, más bien, bastante simple, de cómo tokenizar un activo digital, que en este caso son canciones, y la funcionalidad que puede tener y para todo lo que puede valer.