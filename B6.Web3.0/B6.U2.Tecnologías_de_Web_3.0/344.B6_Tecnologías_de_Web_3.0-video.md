---
title: Tecnologías de Web 3.0 | Joan Mora
URL: https://app.web3mba.io/courses/take/bloque-6-web3/lessons/39803721-u2-tecnologias-de-web-3-0-joan-mora
Tags/Keywords: #Bloque 6 #web 3.0 #B6U2 #tecnologias web 3.0 #Joan Mora
lang: es-AR
---
# Tecnologías de Web 3.0
![[344.B6_Tecnologías_de_Web_3.0.mp4]]
[Tecnologias de Web 3.0](https://app.web3mba.io?wvideo=8lr7qcd0dj)

Web3JS ha surgido como una solución a los tradicionales protocolos de Ethereum, que son bastante complejos. Esta complejidad hace que desarrollar aplicaciones para Web3 sea, en términos de tiempo, bastante costoso, pero también caro. Con Web3JS, simplemente con unas líneas de código, puedes conectarte a uno de Ethereum. Basta con importar el paquete de npm, un gestor de paquetes de JavaScript, y luego ingresar tu wallet y la URL de tu nodo. Los casos de uso de Web3JS son infinitos, y te diré por qué. JavaScript, el lenguaje que es el motor de Web3JS, se utilizó en un principio en el navegador, pero desde que ha surgido Node.js, también se utiliza en el servidor. Esto permite desarrollar cualquier tipo de aplicación que puedas ver en un navegador o incluso en tu escritorio, o que pueda reunirse en un servidor, desde aplicaciones relacionadas con Machine Learning hasta casos de uso como el almacenamiento de archivos, entre otros.

Para entender el almacenamiento distribuido, es necesario comprender un poco su contrapartida: el almacenamiento centralizado, que es el habitual, donde tenemos una base de datos en un servidor o cualquier otro sistema que generalmente consta de un nodo o varias réplicas de ese nodo. Este modelo presenta problemas bastante importantes, como, por ejemplo, ¿qué pasa si ese nodo es atacado? Puede que todos los datos que contiene se vean comprometidos. ¿Qué ocurre si ese nodo se cae? La disponibilidad de ese nodo también puede verse afectada. En un modelo descentralizado, lo que encontramos es que si cae un nodo, habrá muchos más nodos disponibles para satisfacer esas demandas de datos. No solo eso, si se ataca un nodo, la red en general no queda afectada. ¿Por qué? Porque hay un sistema de alertas que puede aislar a un nodo.

Los datos en un sistema distribuido no se replican en todos los nodos de la misma manera. Eso sería... ir a un sistema centralizado y simplemente añadir un montón de nodos. Lo que se hace es realizar una copia inteligente de los datos, suficiente para que, si un nodo cae por cualquier motivo, como un fallo eléctrico o cualquier otro tipo de problema, podamos ser capaces de recuperar esos datos. Pero no solo eso, muchas veces los datos son tokenizados y repartidos. Existen mecanismos como los algoritmos de Reed-Solomon, por ejemplo, que permiten recuperar un 20% de la información a partir de un 80% de los datos. Es decir, no se realiza una replicación exacta, sino una replicación inteligente y suficiente.

En general, esto no tiene por qué hacer que el sistema sea más lento, aunque eso depende mucho del nodo y de las condiciones de la red. Lo que se intenta es distribuir las redes alrededor de zonas; por ejemplo, si estás en Europa, puedes tener una red descentralizada dentro de Europa. En términos de rendimiento, si tenemos nodos distribuidos por todo el mundo, obviamente la performance dependerá, especialmente, del hardware que tenga ese nodo y de las condiciones en las que esté trabajando, por ejemplo, si tiene mucha carga o poca. Aunque se distribuya la carga, muchas veces una red puede saturarse, y es un poco la performance de una red, que puede depender de muchísimas variables. Sin embargo, en general, suelen comportarse mejor que las redes centralizadas.

Existen diferentes sistemas de almacenamiento centralizado y distribuido. Por ejemplo, tenemos Postgres o Mongo como sistemas centralizados y luego Cassandra como sistema distribuido. Estos proporcionan, por un lado, mayor disponibilidad, pero comprometen la consistencia en los sistemas distribuidos. Por otro lado, aunque se garantice la consistencia en bases de datos como Mongo o Postgres, la disponibilidad no está siempre asegurada y muchas veces colapsan debido a un gran número de peticiones, entre otros factores.

En general, tu navegador, cuando necesita acceder a un portal web, tiene direcciones, como las que tiene tu casa. Esa dirección se compone de números, que se llaman direcciones IP. Por lo tanto, una dirección IP es casi imposible de recordar para cualquier ser humano. Imagínate recordar las direcciones IP de los 20 sitios que más visitas. Para ello, se inventó el DNS, que permite que, con un nombre, el sistema pueda emparejar ese nombre con una dirección IP y pueda buscarlo. Los servicios de DNS, aunque estén distribuidos por todo el mundo, tienen un gran problema: hay pocos nodos que sirven estos nombres, y suelen colapsarse. El DNS, como buen sistema distribuido, funciona por diferentes niveles, y aunque sea distribuido, hay relativamente pocos nodos. Imagina que, en el primer nivel, tendríamos nodos normales y corrientes, pero si subimos un par de niveles, tenemos los nodos DNS. Entonces, el primer nivel lo que hace es preguntar: "¿existe esta dirección de...?", por ejemplo, Google. Si estás en Europa, puede que te devuelva la respuesta, pero si pides una universidad en Australia, es posible que el nodo en Europa no tenga esa información. Vamos al siguiente nivel, hacia arriba; este nodo puede decirte: "Oye, esto es Australia, yo sé dónde está Australia", y te manda a otro nodo. Luego volvemos a subir y bajamos nuevamente; así es como funciona el DNS. Esto, obviamente, genera problemas porque no está suficientemente replicado. Sería ideal que tuvieras todos los nombres disponibles en tu zona, pero al mismo tiempo, como no hay disponibilidad de instancias, tienes que preguntar hacia arriba.

En la blockchain también existen sistemas parecidos a los DNS que emparejan tu wallet con un nombre. Así, no tienes que recordar estos dígitos en notación decimal y puedes usar un nombre en lugar de un número. En blockchain también contamos con DNS, que simplemente almacenan el número de la wallet y lo emparejan con un nombre, por lo que puedes dar un nombre en vez de un número exacto. IPFS, que proviene de las siglas de InterPlanetary File System, fue inventado por Protocol Labs, y básicamente busca un sistema donde no necesites IPs para almacenar información, sino que guardes la propia información. Así, lo que se busca es, en lugar de usar tu IP, utilizar el hash de tu información. Como consecuencia directa, la búsqueda es directa: buscas un hash y encuentras tu archivo. Básicamente, cuando quieres guardar un archivo en IPFS, lo que se hace es particionar tu unidad de datos en 256K, y el primer elemento es el que se indexa; el resto pasa a una tabla de índices referenciada por ese elemento indexado. Entonces, la búsqueda de un elemento tiene una complejidad lineal: se busca un hash y se encuentra el resultado. Esto también presenta problemas. ¿Por qué? Porque tenemos el archivo muy fragmentado y hay complejidades, por ejemplo, ¿cómo sé que un nodo tiene disponible ese trozo de archivo? Hay que realizar pruebas criptográficas para validar que tiene ese fragmento y, no solo eso, que la integridad se cumple, es decir, que en ninguno de los nodos se ha editado ese archivo.

A nivel de seguridad, este tipo de manejo es mucho más seguro que el sistema que tenemos hoy en día, porque se realizan pruebas criptográficas del contenido que realmente se guarda. Además, es una red que está bastante protegida, ya que no se puede manipular. Los fragmentos no solo se encuentran en un nodo, sino que están replicados, y es prácticamente imposible robar cualquier tipo de información. Hemos pasado por un tiempo en el que ha habido un enfoque mucho más especulador dentro de Web3, y ha habido un montón de empresas que, en este momento, no han logrado tener éxito. Sin embargo, eso no supone un problema de cara al futuro. ¿Por qué? Porque realmente lo que estamos construyendo es el siguiente Internet, y lo que debemos focalizar es en qué problema estamos intentando solucionar. Actualmente, tenemos un problema de privacidad del usuario, y no podemos, o simplemente no debemos, permitir que el usuario sea tratado como un producto dentro de la red. El usuario se merece algo más que unos anuncios cuando busca algo en Google. Debemos ofrecerle valor, y es ahí donde reside el futuro de la Web3: en ofrecer valor y no especulación.

No solo existe este punto de que tú puedes conectar un nodo a una red y ganar dinero por almacenar datos de terceros, sino también desde el punto de vista del usuario. Lo que puede conseguir dentro de la Web3 es no vender sus datos, no ser un producto dentro de la red. No solo eso, sino que la forma en que se construyen productos dentro de la red debe cambiar; no se debe hacer tanto en "te vamos a vender esto o lo otro porque te conocemos", sino "te vamos a ofrecer un valor y tú decidirás si pagas o no por ese valor". Así, el usuario puede estar más seguro de que todos sus datos le pertenecen. Por ejemplo, con todo el tema de la pandemia y el COVID, se podría haber gestionado de manera mucho más eficiente todos los datos, como los historiales médicos, utilizando tecnologías impulsadas por Web3.