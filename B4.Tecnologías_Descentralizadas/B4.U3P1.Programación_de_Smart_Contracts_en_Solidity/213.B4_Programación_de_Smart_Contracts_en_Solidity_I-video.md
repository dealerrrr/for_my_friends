---
title: 
URL: 
Tags/Keywords: # # # # #
lang: es-AR
---
# titulo
![[213.B4_Programación_de_Smart_Contracts_en_Solidity_I.mp4]]
[Titulo](URL)

Primero, vamos a entrar en doc.soliditylang.org, que contiene información sobre el lenguaje Solidity. Como veréis, al ingresar, nos lleva a la última versión, que es la 0.8.17 en el momento de grabar este vídeo. Esta documentación contiene todo lo que necesitáis saber sobre cómo funciona el lenguaje, qué tipos de datos hay, sus operadores, etc. Os recomiendo que, dado que en este curso solo vamos a hacer una pequeña introducción, si queréis profundizar en el tema, exploréis la documentación, que está muy bien redactada.

La siguiente página que creo que es muy interesante, de cara a ver las cosas de un modo más práctico y no tan teórico, es "Solidity by Example". En esta web encontraremos un montón de ejemplos de Solidity utilizando aspectos concretos, como, por ejemplo, variables, constantes, structs, etc. Al principio son cosas muy básicas, pero si hacéis scroll, encontraréis ejemplos cada vez más avanzados. Sin más, vamos a pasar a desarrollar nuestros propios smart contracts. Vamos a entrar en Remix.

Remix, para quien no lo conozca, es un entorno de desarrollo de Solidity que nos permite desarrollar, compilar e incluso desplegar tanto en redes virtuales como en redes de prueba o en mainnet. Por ahora, vamos a hacer cosas muy sencillas simplemente dentro del navegador, sin realizar ningún despliegue real. Esta es la página de inicio; como veis, aquí tenemos distintos apartados. Este es el del "file explorer", donde desarrollaremos nuestros contratos y demás. Si hacéis clic en la carpeta de "contracts", veréis que ya hay una serie de contratos de ejemplo que nos ofrece Remix. Ahora los veremos en más detalle.

Si nos dirigimos al símbolo de "Solidity Compiler", desde aquí podremos compilar los distintos smart contracts que hayamos desarrollado. En este caso, podríamos compilar automáticamente el smart contract "storage" que hemos abierto. Luego lo veremos también en más detalle. En este último panel, tenemos el de despliegue y realización de transacciones. Aquí podemos seleccionar el entorno en el que vamos a hacer el despliegue. Los que indican "vm" son en máquinas virtuales; esto sucederá solo a nivel de este navegador, pero podemos utilizar otros proveedores, como Hardhat, Ganache, una wallet, etc., para desplegar e interactuar con estos smart contracts en otras redes.

Este smart contract se llama "Storage.sol". La extensión "sol" es del lenguaje Solidity. Cada vez que hagáis un smart contract, mi recomendación es utilizar el mismo nombre que el contrato. Lo primero que vemos aquí es la licencia; realmente este no es un campo necesario, pero es recomendable. Si no lo indicáis en el contrato, el compilador de Solidity os lanzará un warning; en este caso, se está utilizando GPL3. Luego, lo siguiente que se indica es la versión de Solidity a la que apunta este smart contract, es decir, con qué versión de Solidity se va a poder compilar este contrato. En este caso, está utilizando una versión compatible con las versiones menores que la 0.9.

Entonces se pone "pragma solidity" y a continuación la versión. "uint256" significa que es un entero, un "integer"; "u" es "unsigned", es decir, no tiene signo, por lo que todos serían números positivos y de 256 bits. Esta es una propiedad del contrato. Luego aquí tenemos dos funciones: una función que es "store", que lo que hace es guardar un nuevo valor, actualizando la propiedad "number" pasándole un parámetro "num". Aquí lo que hacemos es definir la función, el nombre de la función, el parámetro que recibe, indicando primero el tipo y luego el nombre del parámetro, y luego un modificador de la función, indicando cuál es su visibilidad. En este caso es "public", por lo que esta función es accesible por cualquiera, incluso desde el propio contrato o desde contratos externos.

El cuerpo de la función simplemente realiza una asignación. La variable "number", que es esta propiedad que hemos mencionado, se iguala a "num", que es el parámetro que está recibiendo. Esta es una función que modifica el estado del smart contract, por lo que requeriría una transacción que modifique el estado y, por tanto, requiere un coste de gas. Luego tenemos esta otra función que se llama "retrieve". Esta función, como veis, no recibe ningún parámetro, también es pública, pero es "view". "View" significa que es una función que no modifica el estado de la blockchain ni del smart contract. Por lo tanto, no es necesario realizar una transacción para ejecutarla.

Esto se podría hacer desde la consola, por ejemplo, accediendo a esta función, que se ejecutaría automáticamente sin necesidad de ninguna transacción. Esta función nos devuelve... Aquí dice "returns", lo que significa que nos devuelve, y entre paréntesis nos indica el tipo que tiene que devolver. En este caso, nos devuelve la propiedad "number". Como veis, este smart contract es muy sencillo; simplemente modifica y permite visualizar una propiedad. Vamos a crear una carpeta dentro de "contracts", la llamaremos "mba". Dentro de esta carpeta, vamos a crear un nuevo archivo que llamaremos "simplecontract.sol".

Lo primero, como hemos visto antes, es establecer la licencia. Vamos a copiar esta de aquí, por ejemplo. Hay múltiples tipos de licencia, como podéis ver en la documentación de Solidity. Podéis poner "unlicense" si queréis, pero en este caso vamos a utilizar "MIT", que es una licencia muy conocida y recomendada por la documentación. El siguiente paso es establecer la versión. Para ello, como hemos visto antes, utilizamos la palabra clave "pragma", seguida de "solidity", que es el lenguaje. En el smart contract de ejemplo "storage" que hemos visto antes, se indicaba que la versión tenía que ser superior a una e inferior a otra. Nosotros lo que vamos a hacer es ponerle "0.8.17", lo que significa que el compilador que vamos a permitir que compile este smart contract tiene que ser 0.8.17 o superior, pero inferior a 0.9.

Ahora, lo siguiente es crear el contrato. Utilizamos la palabra "contract", seguido del nombre del contrato, que será "simplecontract", abrimos la llave y ya está. Con esto ya tendríamos la primera parte de nuestro contrato. De la misma manera que antes, vamos a crear aquí una variable que será de tipo "uint256", la llamaremos "number". Solo que si hacemos esto, la visibilidad de este parámetro no está indicada, así que lo que vamos a hacer es que sea pública. Además de números, también podemos utilizar otros tipos de datos; por ejemplo, vamos a utilizar "address", que es una dirección de Ethereum, como "0x...". También la vamos a declarar como pública y la llamaremos "myAddress".

Luego, vamos a utilizar un constructor. Los smart contracts pueden tener o no tener constructor; en este caso, sí que lo vamos a crear. ¿Para qué sirve un constructor? Para inicializar una serie de datos o realizar una serie de operaciones en el momento de creación del smart contract. En este caso, simplemente ponemos "constructor", abrimos paréntesis y le pasamos una serie de parámetros; puede que reciba parámetros o puede que no. Por ejemplo, si no queremos que reciba parámetros, podríamos decir "number = 42". Entonces, cuando creásemos el smart contract, automáticamente la propiedad "number" tendría el valor 42. O podemos establecer nosotros el parámetro, lo ponemos aquí, "uint256 _number", y entonces aquí "number = _number".

¿Por qué lo pongo con barra baja? Esto es algo que se suele hacer para que los parámetros vayan precedidos por una barra baja, lo que permite diferenciarlos fácilmente en el cuerpo de una función del resto de propiedades o variables temporales. Además, también nos permite, en casos como este, utilizar variables que representan lo mismo; este parámetro será el valor de "number", así que sabemos que si tiene barra baja, es el que le estamos estableciendo desde cero. Aquí vemos que nos ha salido una alerta. Esto nos indica que el compilador al que estamos apuntando, que es al menos 0.8.17, no se corresponde con el compilador que está definido actualmente.

Entonces, podemos ir a la pestaña de "compilador" y, como veis, está preseleccionado el 0.8.7. Abrimos el desplegable y seleccionamos el que queramos, en este caso el 0.8.17, que como hemos comentado, es el último. Muy bien, pues ya tenemos un smart contract muy simple creado. De manera que tenemos aquí estos botones que nos permiten copiar el ABI y el bytecode. El bytecode es el código compilado del smart contract y el ABI es la interfaz, es decir, contiene todos los elementos del smart contract. El ABI nos indica que hay una propiedad pública que es un "uint256", que es "number", y que hay una propiedad pública de tipo "address", que es "myAddress". También nos dice que el constructor recibe ciertos parámetros y contiene las firmas de todas las funciones.

Esto nos indica qué funciones hay, qué reciben, qué devuelven, etcétera, pero no contienen funcionalidad alguna; simplemente nos dice de qué manera se puede interactuar con este smart contract, mientras que el bytecode, como digo, es todo el código del smart contract compilado. Necesitamos ambas cosas para poder desplegar el smart contract, pero luego, para interactuar con él, necesitamos el ABI, que es la interfaz, y la dirección en la que se ha desplegado. Una vez que ya lo tenemos compilado y funciona correctamente, vamos a proceder a hacer el despliegue.

Tenemos aquí el smart contract y aquí lo podríamos desplegar, pero nos pide todos los parámetros que tengamos en el constructor. Actualmente, solo tenemos "number". Si ponemos aquí 36, por ejemplo, esto realmente lo único que hace es desplegarlo y se verá un poco más en detalle. Así también nos serviría. Le daríamos a "desplegar". De acuerdo, pues entonces aquí nos sale un tick que indica que ha ido todo bien; se ha desplegado. Aquí vemos la información. En resumen, esto nos ha desplegado un nuevo smart contract que aparece en "deployed smart contracts", y nos indica también en qué dirección se ha desplegado este contrato.

Aquí tenemos dos botones que se corresponden con las funciones con las que podemos interactuar, que son "number" y "myAddress". Entonces, le damos a "myAddress", que nos dice que nos devuelve "0x000000" porque no hemos establecido ningún valor para esta propiedad, así que es el valor por defecto, que son ceros. El "number", ¿cuál será? Pues el que le hayamos indicado como parámetro en el constructor, que nos devolverá 36. Aquí está. Como veis, esto pone que son "calls". Cuando pone "call", significa que realmente no está realizando ninguna transacción, a diferencia de lo que hicimos antes al desplegar el contrato, que aquí sí que hubo una transacción. Esto, como solo es una consulta de información, porque al final son funciones de tipo "view", no requieren de ninguna transacción.

Muy bien, pues con esto ya tenemos un contrato muy sencillo y vamos a pasar a ampliarlo un poco. ¿Qué podemos hacer? Podemos añadir un setter a estas propiedades, a ambas. Lo recomendable, tal como indica la documentación o como veréis en la mayoría de contratos, es seguir un orden de qué cosas se ponen en qué orden. Por ejemplo, primero se ponen las propiedades del contrato, el constructor iría después y luego las funciones. Hay otra serie de elementos que ya veremos, como los structs, los eventos, los modifiers, etc. La idea es esa. En este caso, que solo tenemos propiedades, constructor y ahora funciones, se hace en este orden.

Vale, pues entonces, como hemos visto, utilizamos la palabra "function". Vamos a poner el nombre de la función, "setNumber" en este caso. Los parámetros que va a recibir serán "uint256 _number", como hemos dicho, es una buena práctica que los parámetros empiecen siempre con barra baja. Vamos a poner "public" porque esta función va a ser pública, ya que queremos que podamos interactuar con ella desde fuera. Abrimos las llaves. No he puesto un "return" porque esto no devuelve nada; solo vamos a modificar la función. Haremos exactamente lo mismo que estamos haciendo aquí. Podemos copiarlo y pegarlo para facilitar un poco.

Muy bien, entonces al final esto simplemente es un "set"; solo estamos modificando este valor y podemos hacer lo mismo para el "address". Vamos a poner "setMyAddress"; aquí el parámetro que recibe es de tipo "address" y lo vamos a llamar "_myAddress". Realmente, el nombre del parámetro, como digo, es simplemente una manera de hacerlo, pero aquí podríamos llamarlo "ADDR" si queremos. Como he dicho, es mejor que empiece con barra baja. Pero bueno, "myAddress", también de tipo público. Y aquí lo mismo, "myAddress" pasa a ser lo que haya almacenado en "_myAddress". Punto y coma.

Esta diferencia con otros lenguajes como Python es que siempre todas las sentencias deben acabar en punto y coma, como en JavaScript, aunque JavaScript es menos estricto. Vale, entonces hemos añadido estas nuevas funciones. Así que lo que vamos a hacer es ir de nuevo al compilador de Solidity, compilar de nuevo y luego ir a la pestaña de despliegue. Entonces, este smart contract que teníamos previamente lo vamos a desechar y vamos a desplegar de nuevo. Esta vez vamos a ponerle un 12, por ejemplo, para que sea distinto y le damos a "deploy". Entonces ya se nos ha desplegado aquí el smart contract. Como veis, antes teníamos solo estos dos botones de "number" y "myAddress", y ahora tenemos otros dos en naranja que son las funciones.

Estas sí que implican transacciones y, como veis, estas reciben parámetros, a diferencia de las otras. Entonces, si comprobamos, el "number" va a ser 12, "myAddress" seguirá siendo "0x0000" y vamos a establecer un nuevo número, por ejemplo, 17. Ahora, como veis, sí que ha enviado una transacción, del mismo modo que cuando se desplegó el smart contract. Aquí podréis consultar la información de la transacción, el hash de la transacción, desde qué dirección ha ido, a qué dirección ha ido, que en este caso es a la dirección del smart contract, que es esta de aquí, y el gas que ha consumido, etcétera.

Entonces, una vez que hemos cambiado el número, esta transacción ha ido correctamente. Si volvemos a consultar el número, ha cambiado y ahora pone 17. Muy bien, ahora también podemos cambiar el "address". Vamos a coger, por ejemplo, el propio "address" del smart contract. Remix nos permite muchas veces, cada vez que hay un "address" o un hash, poner el botón de copiar para facilitarlo todo. Entonces ya lo hemos copiado y lo vamos a pegar aquí. Le damos al botón y esto nos ha hecho una transacción. Entonces ya ha cambiado el "address" de la variable "myAddress". Cuando le damos aquí, ha cambiado; ahora es esta nueva información.

Esto está pidiendo un "address", así que no podríamos poner otra cosa; no podemos poner aquí el string "hola". Si lo hacemos, va a fallar. Como veis, aquí dice que la transacción a esta función ha fallado y nos indica que es un "invalid address"; se esperaba un argumento de tipo "address", pero el valor es "hola", así que no es válido. Como no es válido, no se ha podido realizar y si vamos a "myAddress", nos sigue devolviendo el valor que habíamos indicado inicialmente. Vale, pues vamos a seguir ampliando nuestro smart contract para añadirle más funcionalidad.

Vamos a añadir una función que sea de tipo "view". Como lo que hemos visto antes era simplemente un getter, aquí vamos a ponerle un poco más de funcionalidad. Vamos a crear una función que se llame "isThisNumberLarger". Vamos a pasarle un parámetro que será "number". Va a ser una función de tipo público y de tipo "view" porque no va a modificar el estado del smart contract. Además, nos va a devolver un valor de tipo booleano. Entonces, ¿qué va a hacer esto? Nos va a decir si nuestra propiedad "number" es mayor que el parámetro que le hemos pasado.

Además, también vamos a explorar otro tipo de funciones. Hemos hablado de las funciones que son de tipo "view" y ahora vamos a hablar de las que son de tipo "pure". Vamos a crear una función "sum". Recibirá dos parámetros, que llamaremos "number1" y "number2". También será de tipo público. En lugar de "view", será "pure" y lo que nos devuelve es un "uint256". Esta función simplemente devolverá la suma de "number1" más "number2". ¿Por qué es de tipo "pure" y no "view"? Porque las funciones de tipo "view" no modifican el estado del smart contract, pero sí leen el estado del mismo.

Es decir, aquí estamos accediendo a la propiedad "number", mientras que en esta función de suma, le estamos pasando dos parámetros y nos está devolviendo la suma de ellos. No importa lo que contenga el smart contract, ya que no lo vamos a consultar. Entonces, esta función... ¡Uy! Perdón, esto no lo he puesto correctamente. Esta función, al no leer el estado del smart contract, se puede clasificar con este tipo más restrictivo, lo que además ahorra gas. En Solidity, es muy importante hacer las cosas de la manera más económica posible, ya que esto supone un ahorro de dinero real cuando está desplegado en redes públicas, especialmente en mainnet, que es bastante caro.

Entonces, es muy importante intentar ahorrar el máximo posible. Muy bien, pues vamos a ir de nuevo aquí a la compilación. Como tenemos "auto compile", esto no sería necesario, pero simplemente lo hacemos para comprobarlo. Vamos a desechar el smart contract que teníamos desplegado y vamos a desplegar este nuevo. Vamos a poner aquí un parámetro que será 10, por ejemplo. Desplegamos y ya lo tenemos aquí desplegado. Aquí tenemos lo mismo de antes; "myAddress" es "0x0000", el "number" es 10, que es lo que hemos puesto, todo eso es lo mismo de antes.

Vamos a probar las cosas nuevas que son "isThisNumberLarger" y "sum". Como es 10, si le pongo aquí un valor de 8, este me devolverá "false". Si le pongo un valor de 13, nos devolverá "true". "bool" es otro tipo de dato, igual que hemos visto ya con "uint256" y "address"; esto es un valor booleano que solo puede tomar los valores "true" o "false". Ahora vamos a probar la función de suma. Aquí sí que tenemos, como son varios parámetros, los suyos que hagamos aquí el despliegue. Entonces aquí podemos poner los parámetros de cada uno de ellos; vamos a poner 5 y 3, hacemos el "call" y nos devuelve 8.

De nuevo, los que tienen el cuadradito azul significan que no modifican el estado; son "calls", así que no hay que realizar transacciones, mientras que estos sí requieren transacciones. Entonces ya hemos visto varias cosas: hemos visto las propiedades, la visibilidad pública, pero todavía no hemos visto ninguna de tipo privada, así que más adelante lo veremos. Hemos visto los modificadores de "view" y "pure", así que ahora vamos a ver algo nuevo: los eventos. Los eventos son algo muy importante en Solidity y son bastante interesantes.

Los eventos son sucesos que nosotros marcamos o se emiten en el smart contract en algún momento de su funcionalidad para que puedan ser leídos off-chain, es decir, desde fuera de la blockchain, por ejemplo, aplicaciones o servicios que estén escuchando la blockchain y estén atentos a que suceda algo. Por ejemplo, cuando se realiza una transferencia de un token ERC20, se emite un evento "Transfer". Esto se hace para que se esté escuchando y, cuando se detecte que se ha producido una transferencia, se realice alguna acción en un backend, en un servidor, etc. Estos eventos son para ser detectados desde fuera; no es algo que desde un smart contract puedas detectar que se ha producido un evento en otro smart contract.

Los eventos los pondríamos debajo de las propiedades y antes del constructor. Este será un evento que se disparará cuando se modifique la propiedad "number". Aquí se le pasarán una serie de parámetros; ¿cuáles vamos a pasar? Pues "oldNumber" y otro parámetro que será "newNumber", acabando en punto y coma, como siempre. Entonces, ¿de qué nos servirá esto? Cada vez que se cambie el número, si estamos escuchando los eventos del smart contract, sabremos cuándo alguien ha cambiado ese número. Podremos ver de qué número ha cambiado a qué número. Esto lo podemos hacer, por ejemplo, aquí, cuando hacemos el "setNumber".

Entonces aquí utilizamos la palabra "emit", que es para emitir el evento, seguido del nombre del evento, que será "newNumberSet", y los parámetros que recibe. ¿Cuál será el viejo número? Pues aquí lo que actualmente es "number". ¿Cuál será el nuevo? El que estamos pasando por parámetro, "number" con barra baja. Muy bien, desechamos el smart contract anterior, desplegamos de nuevo y, como vemos, vale 5. Ahora vamos a ponerle un valor de 8, por ejemplo. "SetNumber" llamamos a la función y aquí se ha enviado una transacción. La consola de Remix nos permitirá comprobar el evento que se ha emitido.

Aquí dentro de "logs", observamos que hay una propiedad que dice "event" y nos indica el número del evento, que es "newNumberSet", y aquí los argumentos. Los argumentos del evento nos los muestra de dos maneras distintas: o bien por el orden, que es 0 y 1, o bien por el nombre de la propiedad, que son "oldNumber" y "newNumber", que en este caso ha pasado de 5 a 8. Esto es una manera bastante útil de poder observar los cambios que se han producido en el smart contract desde fuera.

Otra cosa interesante de Remix, que no he comentado, es que además de desplegar aquí, podemos cargar un smart contract que ya se haya desplegado previamente. Por ejemplo, si copiamos su dirección, lo descartamos y pegamos aquí la dirección, al darle, nos mostrará el smart contract que ya hemos desplegado anteriormente. Esto, en el entorno de una máquina virtual, no tiene mucho sentido, pero si estamos utilizando un proveedor distinto, por ejemplo, en una red de pruebas como Rinkeby, si queremos interactuar con un smart contract que ya existe y que hemos desplegado en otra sesión, simplemente podemos copiar su dirección y darle al botón.

Como vemos, aquí ya está; si le damos al "number", está en 8, que es el valor que le habíamos puesto anteriormente. Con esto ya hemos visto los eventos, pero también podemos decir que queremos emitir este evento en el constructor, porque en el constructor también estamos cambiando el número de 0, que es el valor inicial, al parámetro que le estamos pasando. Podríamos copiar esto aquí y entonces estaríamos emitiendo el evento y cambiando el número tanto en el constructor como en esta función. Sin embargo, lo que estamos haciendo es algo que a mí personalmente no me gusta: repetir código.

Todo lo que se puede hacer para evitar repetir código es mejor, porque facilita la legibilidad y el mantenimiento. Si tienes el mismo código repetido en varias funciones y luego, por alguna razón, lo cambias en una, pero no en otra, te encuentras con comportamientos inconsistentes. Cada vez que se repite código, en este caso son solo dos líneas, pero en otros casos puede ser más complejo. Entonces, ¿qué vamos a hacer? Vamos a extraer esta funcionalidad de emitir el evento y cambiar el valor de esa propiedad a otra función externa.

Vamos a crear una función y esta función será de tipo privado. ¿Qué implica eso? Que no podremos interactuar con ella desde fuera. Es decir, ¿veis aquí todas las funciones a las que podemos acceder? Esta función que vamos a crear no estará aquí, porque al ser de tipo privado, solo se podrá acceder desde el propio smart contract. Entonces, ¿para qué se utilizan este tipo de funciones? Por ejemplo, para lo que hemos hecho, cuando internamente el smart contract tiene que realizar algunas acciones que solo serán llamadas desde el propio smart contract, que no queremos que se llamen desde fuera.

Muchas veces, las funciones privadas se nombran con un guion bajo delante del nombre de la función. Esto permite visualizar rápidamente que esta función es privada, es algo interno del smart contract. Entonces, vamos a hacer lo mismo. "_setNumber". Esta función hará exactamente lo mismo; recibirá el parámetro "number", solo que en lugar de ser "public", será "private". Hará exactamente lo mismo que hemos mencionado aquí: emitirá el evento y cambiará la propiedad. Entonces, donde estamos haciendo estas acciones, llamaremos a esta función privada: "_setNumber(number);".

El smart contract se ha compilado correctamente. Desechamos este, desplegamos de nuevo, poniéndole un 5, por ejemplo. Cuando vengamos aquí y veamos la transacción, esta es la transacción que ha desplegado el smart contract; vemos que se ha llamado al evento, pasando de 0 a 5. Si lo cambiásemos a 12, por ejemplo, generará una nueva transacción que lanzará otro evento de 5 a 12. Con esto hemos aprovechado para ver cómo funcionan las funciones privadas y cómo evitar repetir código, logrando un código más reutilizable.