---
title: 
URL: 
Tags/Keywords: # # # # #
lang: es-AR
---
# titulo
![[214.B4_Programación_de_Smart_Contracts_en_Solidity_II.mp4]]
[Titulo](URL)

En este nuevo vídeo, vamos a crear otro contrato para seguir explorando las posibilidades que nos ofrece el lenguaje Solidity. Vamos a desarrollar una especie de juego y comenzaremos creando un archivo que llamaremos "game.sol". Primero, estableceremos la licencia, que será MIT, y luego definiremos la versión de Solidity. Como dijimos en el vídeo anterior, utilizaremos "pragma" y la versión será la 0.8.17, es decir, desde la 0.8.17 hasta la 0.9.

El contrato se llamará "Game" y en este pequeño juego, cada usuario podrá crear un héroe, y los héroes podrán luchar entre ellos. Para ello, introduciremos un nuevo concepto llamado "struct". Un struct es como un tipo de dato, y lo llamaremos "Hero". Aquí detallaremos las propiedades que este tipo de dato tendrá. El héroe tendrá un nombre, un nivel, un nivel de ataque y un nivel de defensa. Como mencioné en otros vídeos, es una buena idea mantener un orden sobre qué va antes y qué va después. Los tipos de datos, en este caso los structs, deben ir antes de las propiedades. Esto definirá el tipo de dato "Hero" con todas sus propiedades, y ahora veremos cómo asociar a cada usuario con uno de estos héroes.

Para ello, introduciremos un nuevo tipo de dato que es el "mapping". El mapping es como un hashmap o un diccionario en otros lenguajes, que asocia una clave con un valor. En este caso, la clave será un "address", que será la dirección del usuario. Luego, el valor será un objeto de tipo "Hero". La variable será pública y la llamaremos "heroes". Ya tenemos el tipo de dato y esta propiedad que indica la asociación entre los usuarios y los héroes. Podríamos crear un constructor, pero en este caso lo omitiremos, ya que no es necesario que existan constructores en el contrato.

Lo que sí haremos es crear una función para poder crear el héroe. Entonces, ¿qué parámetros le pasaremos? Vamos a pasarle el nombre. En cuanto a los strings, cuando se pasan como parámetro, hay que usar la palabra clave "memory", porque es un string que está en memoria. Hay otros tipos de modificadores, pero para este caso, siempre será de tipo "memory". Así que indicamos el parámetro "name" y el resto les daremos un valor por defecto. Vamos a asociar en este mapping, en nuestra propiedad de "heroes", el address de la dirección que está enviando la transacción a un nuevo héroe.

Hay una serie de variables globales que se pueden acceder desde Solidity y que nos permiten obtener cierta información. Por ejemplo, desde cualquier smart contract, podemos saber cuál es la dirección que está enviando la transacción a este smart contract. En este caso, es "msg.sender". Esta variable siempre contendrá la dirección que está enviando la transacción y será la clave de nuestro par que vamos a crear aquí. Entonces, haremos que "heroes[msg.sender]" sea igual a un nuevo objeto "Hero". Esto se puede hacer de múltiples maneras. Una forma es poner "Hero()" y pasar directamente los valores de todas las propiedades, en este caso sería "name", el nivel será uno por defecto, y el ataque y la defensa serán 100.

Esta es una manera de hacerlo. Otra forma sería, en lugar de hacerlo así, indicar mediante clave y valor cómo será. Lo voy a poner... Comentamos esto. Por cierto, los comentarios en Solidity se hacen con doble barra "//". También se puede hacer con barra y asterisco "/* ... */" si queremos hacer un comentario de bloque. Otra opción que podríamos utilizar aquí sería lo mismo, "Hero()" y aquí introducimos el objeto, pero para eso introducimos unas llaves y aquí sí que iríamos poniendo cada uno de los parámetros: "name", "name", "level", 1, etc. Pero como son pocas cosas y es sencillo, lo dejaremos de esta manera.

Con esto ya crearíamos el héroe. Podemos ir compilando y ver qué pasa. Compilamos "game", nos vamos a la pestaña de despliegue, tenemos todo marcado como en los vídeos anteriores, y desplegamos. El despliegue ha sido exitoso y aquí tenemos las dos funciones: la propiedad pública "heroes" y la función "createHero". Esta recibe como parámetro un address y, como decimos clave-valor, si introducimos el address, nos devolverá la propiedad "Hero". Por ejemplo, si ponemos el address de la cuenta con la que hemos hecho el despliegue, lo pegamos aquí y nos devuelve el objeto vacío con todos los valores por defecto. Como veis, el string está vacío y tanto el nivel como el ataque y la defensa están a cero.

Ahora mismo podemos crear un héroe. Cuando lo llamemos, vamos a llamarlo "Pedro". Esto nos dice que ya ha enviado una transacción, que ha ido correctamente, y vemos el parámetro que hemos mandado. Si volvemos a llamar a esta función, aquí vemos que lo que nos ha devuelto es un objeto "Hero" con todas sus propiedades: "Héroe Pedro", nivel 1, ataque 100, defensa 100. Entonces, ¿qué podemos hacer para ampliar esto? ¿Qué pasa si llamo a la función "createHero" varias veces? Lo que sucederá es que se sobrescribirá. Si ahora me creo otro héroe que se llame "Antonio" y vuelvo a llamar a esto, me lo ha sobrescrito.

Con esto hay que tener cuidado; igual no queremos que este sea el comportamiento. Quizás alguien llama a esta función sin querer y tenía ya un héroe de nivel 200 y lo pierde. Así que aquí vamos a introducir un nuevo concepto que es muy importante: el "require". En Solidity, "require" comprueba que se cumple una condición y, si no se cumple, revierte la transacción. Es decir, anula la transacción. Cualquier cosa que se hubiese hecho previamente no se guardará. Si hubiésemos hecho cambios en el smart contract, da igual; esa transacción se cancela y no se lleva a cabo.

En este caso, lo que vamos a comprobar es que no existe ya un héroe para este address, para "msg.sender". Como el objeto "Hero" tiene toda esta información, el nombre, el nivel, etc., lo que podemos hacer es comprobar el nivel. Si el nivel es cero, sabemos que no existe un héroe, porque si se hubiese creado un héroe, sería por lo menos uno, ya que se crea con uno, o puede que sea más y luego suba el nivel si desarrollamos esa funcionalidad. Entonces, para eso vamos a hacer un "require".

Ponemos la condición booleana que en este caso será que "heroes[msg.sender].level" sea igual a 0. Es decir, tenemos que asegurarnos de que se cumple esta condición: no puede haber un héroe asociado a esta dirección. El "require" nos permite además poner un mensaje de error, de modo que si una transacción falla, podemos saber por qué ha fallado. En este caso, vamos a poner "You already have a hero". Entonces guardamos, borramos el smart contract que teníamos desplegado. Como lo tenemos en "autocompile", no hay que volver a darle. Desplegamos de nuevo.

Vamos a hacer lo mismo de antes. Creamos un héroe que se llama "Pedro". Y ahora creamos otro héroe que se llame "Antonio". Aquí, la transacción ha fallado, como podéis ver, sale una "X" y nos dice "revert", la transacción se ha revertido. Y aquí, "Reason provided by the contract", esto es el mensaje que le hemos puesto: "You already have a hero". Ahora hemos añadido esta restricción: no puedes crear otro héroe si ya tienes uno.

¿Qué es lo siguiente que vamos a hacer? Creo que podemos implementar una función de lucha, para que los héroes puedan enfrentarse entre sí. La función se llamará "fight". ¿Cómo vamos a hacer esto? Haremos que, al enviar una transacción llamando a "fight", se indique contra qué enemigo queremos enfrentarnos. Así que pondremos un "address enemy". Esto también será de tipo público. Aquí realizaremos la lucha. Vamos a pensar qué restricciones podemos poner a esta transacción.

Lo primero es que, si quiero luchar contra alguien, necesito tener un héroe. Así que aquí haremos lo mismo de antes. Vamos a hacer un "require" que verifique que "heroes[msg.sender].level" sea mayor que cero. Acordémonos de siempre poner la condición booleana y luego el mensaje. El mensaje será "You don't have a hero". Si no tienes un héroe, no puedes luchar. Muy bien.

¿Qué otra restricción podríamos poner? Que el enemigo al que nos estamos enfrentando también debe tener un héroe. Así que vamos a copiar y pegar. La propiedad "heroes[enemy].level" tiene que ser mayor que cero. Si el nivel es 0, significa que el objeto está vacío. Si el nivel es mayor que 0, significa que ya hay un objeto ahí. Entonces queremos que el enemigo tenga un héroe; si no, no podemos luchar. El mensaje de error será "Enemy doesn't have a hero".

Vale, ya tenemos dos restricciones que parecen bastante buenas. ¿Se nos ocurre alguna otra? A mí se me ocurre que no puedas luchar contra ti mismo. Si yo aquí en el address me pongo mi misma dirección, el héroe estaría luchando contra sí mismo y eso no es algo que queramos hacer. Así que hacemos "require(msg.sender != enemy)". Esta es la condición y el mensaje que pondremos será "You can't fight yourself".

Muy bien, pues ya hemos cubierto todas las condiciones que podemos poner. ¿Cómo va a ganar un jugador? Si su nivel de ataque es mayor o igual que la defensa del enemigo, eso tendría sentido. Entonces, "heroes[msg.sender]" es el objeto "Hero". Para acceder a cualquiera de sus propiedades, utilizamos el punto y la propiedad que queremos. En este caso, "attack". Si el ataque es mayor o igual que la defensa del enemigo, entonces habremos ganado el combate.

¿Qué pasa si ganamos el combate? Si ganamos, podemos hacer que suba de nivel. Aquí ahora mismo no tenemos nada. Vamos a poner aquí un "TODO". Ahora vamos a crear una función que nos suba de nivel. Esta función debe tener visibilidad. Si la hacemos pública, cualquiera podría subir el nivel de su héroe. No queremos eso, porque entonces el usuario llamaría constantemente a esta función y estaría muy OP. Así que lo que vamos a hacer es que sea una función privada. Como es privada, le pondremos la barra baja al inicio. Esto no es necesario, pero es una buena práctica. Al final, el estilo de programación depende de cada uno.

¿Qué pasa cuando un jugador sube de nivel? Vamos a hacer que su héroe suba algunas de sus propiedades. "heroes[msg.sender].level" será el nivel más uno. Así que sube uno en su nivel. ¿Qué más cosas vamos a subir? El nombre no va a cambiar, pero vamos a subir el ataque y la defensa. El ataque lo subiremos en 15, por ejemplo, y la defensa la subiremos en 10. Entonces ahora tenemos que llamar a la función simplemente, "levelUp". Como veis, no hace falta pasarle ningún parámetro.

Podríamos hacer que "levelUp" recibiese un parámetro con el address y entonces aquí, en lugar de "heroes[msg.sender]", sería "heroes[address]". Ojo, aquí, aunque estemos llamando a una función distinta, "msg.sender" sigue siendo la dirección que ha llamado la transacción. Es decir, aunque la llamada a esta función venga de otra función, "msg.sender" no cambia, porque quien ha iniciado la transacción es la dirección que manda la transacción. Ahora, si este contrato estuviese llamando a otro contrato, ahí sí que "msg.sender" cambiaría. Pero eso no aplica en este momento.

Ahora mismo, estamos haciendo como 6 puntos en DER. Otra opción sería indicarle aquí el address del héroe al que queremos subir. Son dos maneras distintas de hacerlo. Vale, pues con esto podemos ir probándolo. De nuevo, descartamos el contrato anterior y lo desplegamos de nuevo. ¿Por qué lo estamos desplegando de nuevo? Porque cada vez que hacemos un cambio, el contrato anterior sigue adelante con el código compilado y la interfaz que tenía antes. Por eso hay que volver a desplegarlo.

Esto es un tema que tiene Solidity. Si descubres un bug en tu smart contract, no puedes simplemente parchearlo y que siga funcionando. Toda la información que tuvieras almacenada se pierde. Es decir, si despliego este smart contract con esta nueva funcionalidad e intento acceder a cuál es mi héroe, estará vacío. Así que el héroe "Pedro" que creé antes ya no existe. Bueno, existe, pero en el contrato anterior. En este ya no existe; son dos contratos distintos. No podemos actualizar un contrato como tal, al menos no de esta manera. Así que cada vez que se hace un cambio, es un contrato nuevo.

Por eso hay que tener cuidado al utilizar smart contracts. Cuando despleguemos smart contracts, debemos estar muy seguros de que todo funciona, porque si no, hay que hacer todo desde cero y los datos que tengamos en el contrato anterior no se podrán migrar de manera sencilla a este. Vamos a crear un héroe. Comprobamos el nombre. Vale, "Pedro", ataque 100, defensa 100. Ahora necesitamos crear un enemigo. Aquí tenemos una serie de cuentas. La que estamos utilizando inicialmente es la de 5, B3, etc. Vamos a coger la segunda cuenta. Esta segunda cuenta no tiene un héroe. Comprobamos. No tiene un héroe, así que lo vamos a crear. Este se llamará "Antonio". Creamos un héroe.

Vale, ahora tenemos a "Antonio", que es nivel 1, de la cuenta A, B, etc. Y luego la de 5B tiene a "Pedro". Vamos a hacer que "Pedro" se enfrente a "Antonio". Para eso, ahora mismo estamos con la de 5B, que es "Antonio". Vamos a copiar la dirección de "Pedro". Entonces, estamos con 5B y vamos a luchar contra la A, B, lo que sea. "Fight". Vale, parece que ha ido todo correctamente. La transacción ha funcionado. Ahora volvemos a ver las características de este héroe.

Vale, "Pedro" ha subido al nivel 2. Ha subido al nivel 2 y ahora su ataque es 115 y su defensa es 110. Muy bien. ¿Qué pasa si intentamos...? Vamos a comprobar que los requisitos que hemos puesto funcionen bien. Intentemos utilizar a un héroe que aún no exista. Le damos a luchar. Ha fallado. No tienes un héroe. Entonces esta primera condición ya funciona bien. Vamos a intentar luchar contra nosotros mismos. Así que nos vamos a poner el de... Entonces, si estamos luchando contra AB8, vamos a ponernos el usuario AB8. "Luchar". Vale, nos sale "You can't fight yourself".

¿Qué pasa si intentamos luchar contra un address que no tiene un héroe? Copiamos esta dirección, la pegamos y vamos a luchar. Ah, disculpad, no, tengo que... No había cambiado, me había puesto con otro héroe, perdón, con otra dirección que no tenía un héroe. Me he vuelto a coger la primera. "Luchar". Enemigos en Javagirum. Vale, hemos comprobado ya todos los casos posibles. También hemos comprobado el caso exitoso, que es el que hemos hecho antes.

¿Qué más podemos hacer? Se me ocurre que podemos hacer una función de entrenamiento, de modo que podamos subir de nivel a un héroe sin necesidad de luchar contra otro. Por eso creamos la función "train". No le pasamos ningún parámetro. Será una función pública. Vamos a pensar qué "require" le podemos poner. Tiene sentido que tengas que tener un héroe. Si no tienes un héroe, no puedes entrenar. Si tienes un héroe, podrás entrenar, así que vamos a hacer que subas de nivel.

Y vosotros diréis, ¿qué diferencia hay entre poner "levelUp" como función pública? Al final, con llamar a "train" ya estás subiendo de nivel. Es como puede ser, ¿verdad? ¿Cómo podríamos hacer esto más restrictivo para que no puedas estar entrenando constantemente? Podemos ponerle un límite de tiempo. En Solidity, puedes acceder al momento actual. Igual que podemos acceder a "msg.sender", otra de las variables que existen es el timestamp del bloque en el que se ha minado esta transacción. Entonces, podemos utilizar eso para comprobar el tiempo. Podemos decir que solo se puede entrenar una vez al día, por ejemplo.

Así que vamos a añadir una propiedad nueva al héroe. También será un "uint256" y lo llamaremos "lastTraining". Este contendrá el timestamp de la última vez que se llamó a la función "train". El timestamp es un entero porque es un número de segundos. Es un número largo de segundos y, como no nos interesa exactamente qué significa ese número, sino solo la variación de ese número, si ha pasado suficiente tiempo desde la última vez.

Para eso, en "train" tendremos que añadir otro "require". Este "require" será que se pueda entrenar. Entonces, ¿cómo lo haremos? El timestamp, "block.timestamp", es la variable que hemos mencionado que se puede utilizar para acceder al momento actual, que es cuando estás enviando esa transacción. Esta tomará el valor del timestamp de ese momento. Entonces, tenemos que comprobar que el timestamp sea mayor.

Vamos a hacerlo de otra manera. Si le restamos el último momento en el que el héroe pudo entrenar, es decir, "heroes[msg.sender].lastTraining", la diferencia entre el momento actual y la última vez que entrenó tiene que ser mayor que lo que digamos. Solidity nos permite utilizar, si pusiéramos un número de segundos, por ejemplo, si quisiéramos poner una hora, serían 60 segundos por 60. Entonces esto sería una hora. O podríamos, si quisiéramos que fuese un día, multiplicar por 24. Pero Solidity nos permite ponerlo de una manera más sencilla: "1 days". Esto también funcionará de la misma manera.

Con esto estamos haciendo una comprobación de que ha pasado al menos un día desde la última vez que entrenó. Si no ha entrenado nunca el héroe, automáticamente "lastTraining" estará a 0. Entonces, el timestamp será un número bastante más alto, así que de primeras podrá entrenar. ¿Qué pasa aquí también? Al haber puesto esta nueva propiedad, nos está saliendo un mensaje de error. Porque claro, nos está diciendo que esto espera 5 argumentos, pero solo hemos pasado 4. Aquí hemos pasado el nombre, el nivel, el ataque, la defensa, pero no hemos puesto "lastTraining".

Vamos a poner ahora que sea 0. Así, de esta manera, podrá entrenar desde el primer momento. Muy bien, pues entonces ya estaría... No, realmente no, porque tenemos que actualizar el valor de "lastTraining". Si no lo actualizamos, estará siempre a cero y siempre podrá entrenar. Así que vamos a coger esta propiedad del héroe y la igualaremos al momento actual: "block.timestamp". También podríamos estar aquí poniendo eventos, por ejemplo, cuando suba de nivel podríamos poner un evento o cuando entrene, pero como eso ya lo hemos cubierto en vídeos anteriores, tampoco vamos a repetirnos demasiado.

Y ya tenemos listo nuestro vídeo de hoy. Espero que os haya gustado. Si es así, no olvidéis darle al botón de suscripción, al botón de "like" y compartir el vídeo con vuestros amigos. Y ya sabéis, si queréis ver más vídeos así, seguidme en Instagram, Facebook, Twitter, y también en Twitter. Nos vemos en el próximo vídeo. Como hemos dicho, lo tenemos en autocompilación. Descartamos los smart contracts anteriores y desplegamos. Se ha desplegado correctamente. Vamos a crear nuestro héroe. Se ha creado bien. Copiamos la dirección para ver su información. Nivel 1, ataque 100, defensa 100, "lastTraining" 0.

Vale, ahora vamos a entrenar. La transacción se ejecuta correctamente. Entonces, según esto, ya deberíamos haber subido de nivel. Vamos a comprobarlo. Se ha actualizado. Ha subido al nivel 2. Aquí, ataque 115, defensa 110. "LastTraining" es el timestamp del momento en que se ejecutó, que fue hace unos segundos. ¿Qué pasa si volvemos a darle a "train"? Ha fallado la transacción. Ah, claro, aquí nos dice que se ha revertido, pero no nos está dando información. ¿Por qué? Porque se me ha olvidado poner aquí el mensaje.

El mensaje, como digo, no es necesario, pero es bastante recomendable. Si ponemos aquí "You can only train once a day", solo puedes entrenar una vez al día. Bueno, pues vamos a destruir el contrato, desplegamos uno nuevo, creamos el héroe, observamos su información y entrenamos. Bien, volvemos a entrenar. Mal. "You can only train once a day". Esto ya funciona correctamente.

¿Qué más cosas podemos hacer? Cuando quiero ver mi héroe, que me esté devolviendo mi address todo el rato, si hemos dicho que lo podemos sacar de "msg.sender". Vamos a crear una función pública que se llame "getMyHero" que no reciba ningún parámetro. Entonces, esto lo que hará, como nos va a devolver el héroe, pondremos "returns (Hero)". Y aquí vamos a poner "return heroes[msg.sender]".

Ahora aquí nos dice, un momento, aquí pasa algo. ¿Qué es lo que pasa? Como he dicho antes, a veces hay que poner con algunos tipos de datos más complejos, con los tipos básicos, como booleano, int, etc., no hace falta. Pero con tipos más complejos, como es string o en este caso como es struct, hay que especificar un modificador de "memory", "calldata" o "storage". En este caso, le vamos a poner "memory". Entonces, "Hero memory". Guardamos. Esto es muy interesante; Remix nos avisa cuando algo se nos pasa.

Aquí lo que nos está diciendo es que esta función la podemos restringir a "view" y es cierto, porque esta función, como hemos dicho, será un "call", no será una transacción. Así que no requiere transacción, así que será "view". Vamos a probar. Desplegamos de nuevo. Vamos a "getMyHero". Nos devuelve aquí... Esto ahora nos lo pone de una manera un poquito más fea. Al final es lo mismo que si lo ponemos aquí. Lo que pasa es que aquí sí que nos devuelve cada uno de los valores.

Entonces, creamos un héroe. Si le damos aquí, nos saldrá "Pedro" y si le damos a "getMyHero", también nos vendrá "Pedro", nivel 1, ataque 100, "lastTraining" 0. Con lo cual, esto simplemente era un poco para facilitarlo. Al final, si esta información... esto simplemente es la manera de representarlo. Cuando estéis vosotros haciendo un servidor o recogiendo esa información para hacer algo, al final os da igual cómo aparezca, porque lo vais a gestionar como queráis.

¿Qué más cosas podemos hacer? Ya parece que está bastante completo, pero podemos hacer alguna otra cosa. Como he dicho en otros vídeos, no me gusta repetir código y si puedo evitarlo, lo evito. Así que, ¿qué código tenemos aquí repetido? Alguno que veáis. Yo veo uno claramente, que es el "require" de que no tengas un héroe. Esto lo tenemos que hacer cada vez que realizamos alguna acción que necesita un héroe. En este caso, es muy simple; solo tenemos "luchar" y "entrenar", así que tenemos este "require".

Podríamos extraerlo a una función que realice ese "require". Pero hay una funcionalidad de Solidity que está muy bien y que nos sirve precisamente para esto: los "modifiers". Los "modifiers" son como los decoradores que hay en otros lenguajes. Es algo que hace que se ejecute código antes o después de la ejecución de una función. Normalmente, se utilizan para hacer este tipo de comprobaciones. Ahora mismo solo tenemos "luchar" y "entrenar", pero imaginad que tenemos 10 funcionalidades distintas que puede hacer un héroe y en todas tenemos que hacer ese "require".

Utilizando este "modifier", de una manera muy sencilla, lo podríamos tener. Vamos a crearlo aquí, debajo del mapping, antes de las funciones. Hacemos un "modifier". Lo llamaremos "hasHero", es decir, que tiene un héroe. A los "modifiers" se les puede pasar un parámetro o se les puede omitir. En este caso, lo omitiremos porque no lo necesitamos. ¿Qué le vamos a poner aquí? El "require" que hemos mencionado para comprobar que tiene un héroe. Luego, lo que vamos a poner es "_;".

Esto es un poco raro, ¿qué es esto de " _ "? Pues como esto es un decorador, el guion bajo significa la función que estamos decorando. Este es el código que se ejecuta antes de la función y luego sigue haciendo lo que sea que haga la función. En este caso, vamos a ponerle ese decorador a estas funciones: la de "luchar" y la de "entrenar". Entonces, los "modifiers" los ponemos al final, después de "public", antes del cuerpo de la función. "hasHero". Y aquí también, "hasHero".

Entonces ya podemos quitar este "require". "requireHero". Vale. Vamos a comprobar que esto funciona. Desplegamos. Intento llamar a "entrenar". Ah, no funciona. "You don't have a hero". Eso es porque, como está funcionando en el sistema de "require", ha intentado ejecutar esto y no ha funcionado. Muy bien, pues yo creo que con esto tenemos ya un juego muy sencillo pero bastante completo.

Para hacer un repaso de las cosas nuevas que hemos visto en este vídeo, hemos visto los structs, cómo se crean, cómo se accede a sus propiedades, y hemos visto los mappings, que son asociaciones clave-valor, como si fuese un diccionario. Una cosa que no he comentado, pero que se puede hacer, es que se pueden encadenar distintos mappings. Puedo hacer un mapping cuya clave sea un número, por ejemplo, y cuyo valor sea otro mapping. Este mapping puede ser "address" y "bool", por ejemplo. Esto es algo que está permitido; podéis asociar tantos como queráis.

Los mappings son una de las estructuras de datos más importantes que hay en Solidity. Por ejemplo, para representar los balances de un token, se utiliza un mapping donde la clave es la dirección y el valor es un "uint256". Así es como se representan. Así que no dejéis de mirar el tema de los mappings, que es importante. ¿Qué más hemos visto aquí? Hemos repasado el tema de las funciones, la visibilidad, por ejemplo, esta función que es privada. También hemos revisado el tema de si es una función de tipo "view" o si es de transacción.

Hemos visto también los "modifiers", que son los decoradores. También hemos visto el tema de los "requires", que es muy importante, sobre todo en cuestiones de seguridad, porque habrá funciones que no pueden ser ejecutadas por cualquiera. Por ejemplo, si quiero hacer una transferencia de tokens, tenemos que comprobar que el dueño de los tokens es quien está llamando la transacción. Si no, cualquiera podría transferir tokens ajenos. Bueno, eso es todo por hoy. Gracias por ver el vídeo. Nos vemos en el próximo. Esta parte también es bastante importante. Así que, por ahora, ya está y ahora vamos a pasar a hacer más contratos y ver más funcionalidades de Solidity.