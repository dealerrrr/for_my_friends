---
title: 
URL: 
Tags/Keywords: #Bloque 4 #tecnologias descentralizadas #B4U3 #smart contracts #programacion de smart contracts #solidity
lang: es-AR
---
# titulo
![[216.B4_Programación_de_Smart_Contracts_en_Solidity_IV.mp4]]
[Titulo](URL)

En este vídeo vamos a hablar de OpenZeppelin. OpenZeppelin es una compañía que implementa una serie de contratos en Solidity, es decir, smart contracts. Muchas veces, implementa los estándares de una manera que está muy probada, auditada y es muy segura. Por lo tanto, en lugar de tener que implementar nosotros mismos smart contracts muy extendidos, como pueden ser el ERC20 o el ERC721, OpenZeppelin ya nos proporciona contratos que son muy seguros y fiables. Así que, en lugar de reinventar la rueda, es muy recomendable utilizar estos contratos que ya existen y que son tan confiables. Vamos a ver algunos ejemplos, los integraremos en Remix y observaremos cómo funcionan.

Nos unimos aquí a los contratos. Esta es la documentación de OpenZeppelin. Como podemos ver, tiene multitud de recursos, incluyendo temas de control de acceso, tokens, gobernanza y otras utilidades. Comenzaremos, por ejemplo, con el tema del control de accesos. También podemos revisar directamente el código fuente en GitHub, lo cual es bastante útil. Aquí accedemos a su repositorio de contratos. Esta es la última versión, pero se pueden seleccionar versiones anteriores si deseamos utilizar otros compiladores. Aquí podemos ver todas las versiones disponibles.

Vamos a ir a Remix y crearemos un contrato que utilice el control de acceso. Si habéis echado un vistazo a los smart contracts que vienen por defecto en Remix, notaréis que hay uno que se llama Owner. Este contrato permite utilizar un modificador que restringe quién puede acceder a ciertas funciones. Esto es similar a lo que hemos visto en un vídeo anterior, donde solo algunas direcciones pueden realizar ciertas acciones. En este caso, las funciones que tengan ese modificador OnlyOwner solo pueden ser utilizadas si la cuenta que lo envía es la que se ha establecido como owner.

OpenZeppelin ya nos proporciona una funcionalidad muy similar a esta, de modo que podemos simplemente utilizar su modificador en lugar de tener que implementarlo nosotros mismos. Así que, vamos a crear una carpeta que llamaremos OpenZeppelin y crearemos un contrato que llamaremos ContractWithOwner, por ejemplo. Vamos a copiar, como hacemos siempre, la licencia y la versión, y ahora importaremos el smart contract. Hay varias maneras de hacerlo. Si nos fijamos en la documentación, aquí nos explican cómo instalarlo, pero desde Remix no es necesario hacer ninguna instalación, ya que automáticamente detecta si estás utilizándolo y te instala el paquete directamente.

Entonces, se puede hacer de esta manera, con `@openzeppelin/contracts` y la ruta hacia el contrato que queramos, o incluso se puede hacer referencia directamente al smart contract desde GitHub. Si copiásemos esta URL de OpenZeppelin contracts, nos llevaría hasta allí. Pero, por ahora, nos quedaremos simplemente con el AccessControl. Vamos a copiar aquí lo que nos viene de ejemplo. En este caso, queremos el de Ownable. Aquí podéis comprobar que lo que viene es muy similar al ejemplo que se encuentra en Remix. Tenemos una propiedad privada que se llama Owner, y también tenemos una serie de eventos, etc. Lo importante es el modificador OnlyOwner, que comprueba que el owner del contrato es el mismo que el messageSender y, si no, nos lanza un error: "OwnableCaller is not the owner".

Así que, tenemos importado el smart contract de Ownable, y vamos a crear nuestro contrato, que hemos llamado ContractWithOwner. De una manera muy similar a como hicimos antes con las interfaces, para que un contrato implemente el nombre de la interfaz, este contrato lo que hará es heredar del contrato Ownable. Así que utilizamos `is` y el nombre del contrato que estamos heredando, `is Ownable`. Con esto, nuestro contrato es como si estuviese embebido dentro del contrato Ownable, lo que nos da acceso a todas las funciones y modificadores que esto permite.

Ahora que tenemos esto, vamos a probar a crear una propiedad uint256 que será pública y la llamaremos number, como hemos hecho en otras ocasiones. No creo que haga falta ni hacer un constructor, así que simplemente haremos la función de set. Esta función recibirá un parámetro llamado _number, será pública y aquí asignaremos `number = _number`. Así que, esto es como lo hicimos inicialmente, de modo que cualquier dirección puede hacer esta modificación. Pero si ahora añadimos aquí el modificador OnlyOwner, que de nuevo es el que nos viene en el contrato Ownable que estamos heredando, ya no permitirá que cualquiera lo modifique, solo el owner.

¿Y quién es el owner por defecto? El address que despliega el contrato. Muy bien, vamos a hacer una prueba. Vamos a desplegar este contrato. Además de las funciones que hemos definido, que son el number, que es la propiedad pública, y el setNumber, que es la función para establecer esa propiedad, vemos que aparecen aquí algunas otras funciones o propiedades. Por ejemplo, esta owner, que también será una función pública que nos ofrece el contrato Ownable y que nos devuelve el address del owner. Como vemos, coincide con el address de la cuenta que ha desplegado el smart contract, y el number inicialmente es cero.

Podemos establecerlo, por ejemplo, en 15, y si le damos a number, nos aparecerá porque hemos podido cambiar ese número. Si ahora utilizásemos otra cuenta distinta, por ejemplo, la segunda de la lista que nos aparece aquí, e intentásemos cambiar ese número, por ejemplo, a 7, mandaríamos una transacción y nos daría un fallo. La transacción ha revertido, y el motivo que nos da es "OwnableCaller is not the owner", que es el mensaje que se muestra cuando el require falla, al comprobar que el owner no coincide con quien está enviando la transacción.

Entonces, ¿qué más opciones nos proporciona este contrato Ownable? Una opción es renunciar a la propiedad del contrato. Pero hay que tener cuidado con esto, porque una vez que renuncias a la propiedad, ya no puedes recuperarla, de modo que todas las funciones clave que están protegidas bajo el OnlyOwner ya no serían accesibles. Así que recomiendo tener mucho cuidado al hacer esto. Lo que sí se permite, y que en muchas ocasiones es bastante útil, es transferir la propiedad del contrato a otra cuenta. Por ejemplo, ahora estamos con esta cuenta, y no nos ha dejado cambiar el número, pero si cambiásemos la propiedad del contrato a otra cuenta, si lo hacemos desde la propia cuenta, no nos dejará, solo el owner puede hacerlo.

Entonces, si volvemos a enviar esa transacción con el owner, nos permitirá cambiarla, y ahora el que antes era owner ya no podrá hacer estos cambios porque ya no es el owner. Tendría que ser esta nueva cuenta quien realice ese cambio. Una vez que lo hace, ya sí que nos ha permitido cambiarlo y comprobamos que efectivamente ha cambiado este número. Este es uno de los ejemplos de smart contracts que facilita bastante el desarrollo con OpenZeppelin.

Ahora vamos a hacer otro ejemplo, vamos a crear un token ERC20. Si quisiéramos hacer un token ERC20 desde cero, deberíamos crear la propiedad de los balances, que sería un mapping, como hemos mencionado en otro vídeo, de cuánto balance tiene cada usuario. Tendríamos que implementar la función de minteo, de transferencia, y todas las que vienen definidas en el estándar. Pero como eso es algo muy habitual y ya está hecho mil veces, en lugar de hacerlo desde cero, vamos a importar el smart contract ERC20 que nos ofrece OpenZeppelin.

En la sección de contratos, tenemos un apartado que es tokens, donde encontramos distintos estándares. En este caso, nos centraremos en el ERC20. Vemos que está el ERC20 y también está el IERC20, que es la interfaz de utilización del ERC20. El que vamos a utilizar es el ERC20. Lo dejo aquí abierto para que luego consultemos alguna cosa, pero como veis, es básicamente la implementación del estándar de una manera muy segura y totalmente probada.

Así que vamos a crear un nuevo contrato y lo llamaremos MyToken.sol. Copiamos esto y la importación ya no será en AccessControl, sino que será en ERC20.sol. Entonces, aquí, igual que antes, declaramos el contrato, en este caso MyToken, que hereda de ERC20. Ahora, ¿qué tenemos que hacer aquí? Debemos definir el constructor, porque el contrato de OpenZeppelin requiere que se le indique el nombre y el símbolo del token. Por lo tanto, es necesario tener un constructor, ya que el contrato padre, que en este caso es el ERC20 de OpenZeppelin, requiere estos parámetros.

La manera de realizar el constructor es un poco diferente. Haremos el constructor, le pasaremos los parámetros que necesitamos, y luego debemos llamar a ERC20, que es el nombre del contrato padre, y entre paréntesis, pasaremos los parámetros que nos pide, que son el nombre del token, que será "MyToken", y el símbolo del token, que será "TKN". Este sería el constructor, así que, haciendo únicamente esto, ya tendríamos un smart contract de un token ERC20.

El problema es que ahora mismo no se ha minteado ningún token, es decir, sería un token con un total supply de 0. Así que hay que mintear algo, es decir, debemos generar una cantidad de tokens para alguien. Lo común aquí es dárselo al que ha desplegado el smart contract. Entonces, accederíamos a la función mint y diríamos para quién estamos minteando, que será el message.sender. ¿Y cuánto estamos minteando? Vamos a poner aquí un 1 seguido de un montón de ceros.

¿Por qué llamamos a mint? Estamos invocando una función que no estamos viendo, pero esta función es interna y nos ofrece el ERC20. Antes hemos hablado de las funciones públicas, privadas y externas, y ahora nos queda hablar de las funciones internas. Si buscamos mint, vemos que esta es una función interna. ¿Qué implica eso? Las funciones privadas solo se pueden acceder desde el mismo contrato, mientras que las funciones internas también se pueden acceder desde subcontratos, es decir, desde un smart contract que herede de este.

Y eso es justo lo que estamos haciendo. Desde el constructor del smart contract, llamamos a mint, indicando a qué cuenta y la cantidad, y esto, después de hacer ciertas comprobaciones, realizará la acción. Como vemos, está aumentando el total supply, emitiendo un evento, cambiando el balance y realizando una serie de acciones. Si hacemos esto, nuestro smart contract, nuestro token ERC20, tendrá esta cantidad de tokens, y nunca se podrá modificar la cantidad total porque no hay manera desde fuera de llamar a esta función. Al ser una función interna, no tendremos acceso a ella.

Vamos a hacer la demostración. Desplegamos el contrato anterior y desplegamos MyToken. Aquí ya vemos que hay un montón de información. Cuando no hemos dado ninguna función, todas estas son propias internas del ERC20 de OpenZeppelin. Entonces, ¿qué vemos aquí? El name, que es MyToken, el símbolo, que es TKN, y el totalSupply, que es la cantidad que hemos definido. TotalSupply indica cuántos tokens hay de este ERC20. ¿Hemos minteado todos estos? Eso es lo que hay. Los decimales, por defecto, son 18, que es muy común.

Podemos hacer una prueba de sobrescribir alguno de esos valores. También podemos comprobar el balance. Si vemos el balance del usuario que ha desplegado el smart contract, veremos lo que hemos minteado. Tiene sentido. Si cogiésemos otro, por ejemplo, este de aquí, nos dirá que es cero, por supuesto, porque no ha recibido ningún token. Aquí tenemos también las funciones de approve, transfer, etc. El allowance permite que otra cuenta use tus tokens de alguna manera, que pueda transferirlos o hacer lo que quiera con ellos.

Entonces, si estamos así, lo único que podemos hacer para que estos tokens cambien de mano es que el usuario los transfiera. Es la única manera. Vamos a probar a hacer la transferencia. Transferimos a esta otra cuenta que hemos puesto la mitad de los tokens. Si aquí hay esto que empieza por 1, 0, borramos 2, ponemos un 5, y hacemos la transacción. Se ha realizado la transferencia. De hecho, ahora, si lo vemos, vamos a notar que se ha generado un evento de transferencia. Aquí está: evento transfer desde esta cuenta hasta esta cuenta por el valor correspondiente.

Ahora, el balance que antes era 0, ahora será un 5 seguido de todos esos ceros. Como hemos mencionado, no hay manera de que se puedan mintear nuevos tokens. Es decir, nunca habrá más de estos tokens, ni menos, porque no se permite mintear ni quemar ninguno de esos tokens. Para modificar eso, deberíamos implementar una función de minteo. Aquí le pondríamos, digamos, que la forma de la función será muy similar a esto, que queremos mandárselo a una cuenta y una cantidad. Hacemos addressToMintAmount y lo pondremos de manera pública.

Aquí llamaremos a la función interna, que es esta de aquí. Entonces, lo que hacemos es mintear con la función que nos provee OpenZeppelin, mint, para la dirección y la cantidad. Como es una función interna, aquí no nos aparece, pero en cuanto damos una puerta de salida al exterior, que es una función pública, al desplegar el token de nuevo, veremos que ahora sí tenemos esta función de mint. El total supply sigue siendo el mismo, y si minteamos otra cantidad para quien sea, para la misma cuenta que lo ha desplegado, el total supply se duplicará.

Con esto, sí podemos aumentar la cantidad. ¿Qué más podríamos hacer? Antes de continuar, no es muy seguro tener una función de mint que sea pública, porque cualquiera podría venir y mintear tokens gratis para sí mismo. Entonces, ¿qué tenemos que hacer? Limitar quién puede mintear. Una manera clara de hacerlo es importar también el contrato Ownable de OpenZeppelin. Así, haremos que este smart contract, además de ser un ERC20, también sea Ownable. Solo el propietario de este smart contract podrá mintear.

Si volvemos, eliminamos este smart contract, lo desplegamos de nuevo y lo hacemos con la cuenta de arriba del todo, ahora solo el propietario, que aquí vemos de nuevo owner, será el único que podrá mintear. Si yo ahora quiero mintear con esta cuenta, puedo hacerlo. Pero si llega otra cuenta, por ejemplo, la última que hemos seleccionado antes, e intenta mintear para sí misma, se encontrará con que no puede. Esto combina lo que hemos visto del ERC20 con lo que hemos visto previamente del Ownable.

Estas son pequeñas piezas del rompecabezas que vamos uniendo, y sin apenas haber desarrollado nosotros prácticamente nada, ya estamos dando una funcionalidad más compleja. ¿Qué más podríamos hacer? De la misma manera que estamos minteando con el OnlyOwner, podríamos implementar una función para quemar tokens. La función de quemar tokens hace justo lo contrario, como podéis imaginar. También tenemos aquí una función interna dentro del ERC20 que permite quemar tokens de una cuenta específica.

Entonces, de manera sencilla, hacemos una copia y donde ponemos burn, ya está. Ahora, vamos a quemar un 10%. Le he quitado un 0 y de esta misma cuenta, porque hay que quitárselo a alguien que tenga los tokens, sino no podremos. La transacción ha ido correctamente y esto nos ha generado un evento. Como vemos, no hay un evento específico de quemar. Cuando se están quemando tokens, internamente se está haciendo una transferencia a un address que, al final, es lo mismo, porque nadie posee el wallet y, por lo tanto, nadie puede hacer nada con ello.

Así que, básicamente, esto es lo que hemos hecho. Si comprobamos el total supply, en lugar de 1,0 ahora hay un 9. Y aquí lo mismo, no podríamos quemar tokens desde otra cuenta que no tenga tokens. Por ejemplo, si intentamos quemar desde aquí, nos fallará. Primero, nos fallará porque estamos haciéndolo desde una cuenta que no es la 1, y si cambiamos al owner y lo intentamos de nuevo, nos fallará porque la cantidad que estamos intentando quemar excede el balance de esa cuenta. Lo mismo ocurre si intentamos hacer una transferencia; no puedes transferir más de lo que tienes, etc.

Este es un ejemplo sencillo de cómo modificar un ERC20. Os recomiendo que le echéis un vistazo a la implementación para ver cómo lo hace y demás. Otras opciones que se podrían cambiar, como he mencionado, son los decimales. En este caso, se podría sobrescribir esta función que es pública. Utilizando el override, igual que hemos hecho antes con las interfaces, en lugar de que los decimales sean 18, podríamos cambiarlos a 6, 12 o cualquier otro número que nos sea más manejable. Si no lo veis claro, de todos modos, id a la documentación. En la documentación se explica bastante bien los contratos y cómo hacer este tipo de modificaciones, por ejemplo, cómo modificar el tema de los decimales.