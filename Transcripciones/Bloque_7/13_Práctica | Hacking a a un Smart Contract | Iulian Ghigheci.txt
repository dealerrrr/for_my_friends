Speaker 0 | 00:12.438
En este video vamos a hacer una demostración de un hackeo a un contrato inteligente que contiene una vulnerabilidad y para ello hemos elegido el mismo tipo de ataque que provocó en 2016 la separación de la red ethereum en dos redes, ethereum y ethereum classic, en el que el atacante logró robar 60 millones de dólares. Ese ataque se llamará entrance attack y es muy peligroso ya que permite robar todos los ethereum del contrato víctima. esa demostración, vamos a usar el entorno de desarrollo Remix, el cual nos proporciona una red blockchain local para poder desplegar los contratos e interaccionar con ellas. El contrato que vamos a atacar es un contrato sencillo que representa un banco y implementa la misma vulnerabilidad que el contrato DAO del mismo ataque de 2016. Este contrato contiene un mapping para guardar las direcciones de los usuarios y el balance de sus cuentas. También implementa un método para hacer depósitos y que simplemente incrementa el valor, el balance del usuario con el valor que ha enviado y tiene una función de para de tiro, la cual comprueba. que el usuario tiene saldo positivo en su cuenta, imprime por pantalla el balance del banco y el balance del usuario y después hace el envío del total del balance del usuario a su cuenta, a su wallet, después de lo cual actualiza el saldo de su cuenta a cero ya que ha enviado todo el saldo que tenía. un método para comprobar el balance de la cuenta del banco, el balance total del banco. Vamos a desplegar el contrato y comprobar cómo funciona. Aquí lo tenemos. Vamos a hacer algún depósito. Vamos a depositar y efectivamente tenemos 10 ETH en la cuenta del banco y el usuario tiene 10 ETH aquí se ven los decimales de ETH y son 10 ETH vamos a hacer otro depósito con otra cuenta Aquí tenemos 25 ETH en la cuenta del banco, en balance total del banco y el usuario tiene en su cuenta 15 ETH. Vamos a hacer un retiro de esos 15 ETH. Podemos comprobar que el banco tenía 25 ETH y el usuario tenía 15 ETH y después de la excusión el balance del banco está en 10 ETH. Vamos a intentar hacer otro retiro, a ver si nos deja. Y efectivamente no ha pasado el check de aquí, el requerd, ya que el usuario ya no tenía saldo. El usuario actualmente tiene 0 saldo. Entonces no ha funcionado. Por lo que vemos que aparentemente el contrato funciona correctamente. Pero como sabemos. Con un contrato podemos interaccionar a través de una cuenta de un usuario privado o a través de otro smart contract con lo que hay una forma de poder hackear este contrato Aquí tenemos un contrato atacante que usaremos para atacarlo y el cual define una interfaz que representa el contrato del banco que contiene la dirección del contrato a atacar, la dirección del owner del contrato atacante, al cual lo setea en el constructor. Aquí tenemos un método para poder setear el contrato que vamos a atacar. Y el método para atacar ese método va a ser un depósito y acto seguido un retiro. Como sabemos, para que un contrato pueda recibir Ethereum necesita implementar un método que sea payable esta parte sería mejor explicarla con una imagen así que de esa manera se entiende mejor. El ataque funciona de la siguiente manera se llama este método y se haría un depósito, se llamaría el método depósito del contrato del banco se incrementaría el valor del balance del usuario y después sería un retiro. Se llamaría la función de retiro se comprueba en esa función que el balance es positivo el balance del usuario por lo cual se procede a enviar el dinero al usuario en el momento de hacer el envío al contrato se ejecutaría el método Reset del contrato que es Payment. Este método lo que hace es comprobar que el banco todavía tiene dinero y en este caso volvería a llamar, haría una llamada recursiva a la función de retiro Hay que tener en cuenta aquí que todavía no hemos llegado a esta línea de código esta línea de código es la que actualiza el estado del balance del usuario a cero por lo tanto cuando lleguemos aquí el usuario todavía tiene el mismo saldo que antes, un saldo positivo por lo que esta aprobación se cumpliría y se volvería a hacer la llamada para enviarle fondos otra vez al usuario, que en este caso es el contrato. Y esto se haría de forma recursiva hasta que esta condición se deje de cumplir, es decir, que el banco ya no tenga ningún saldo en su cuenta, en la cuenta del contrato. En ese momento entraría en el ELS y se haría una transferencia de la cuenta del contrato atacante a la cuenta del wallet del atacante. Podemos comprobar cómo funciona desplegando el contrato. Vamos a desplegar el contrato. Seleccionamos una cuenta diferente para el atacante. y vamos a desplegar el contrato atacante. Por aquí tenemos el contrato atacante. En el banco todavía tenemos 10 ETH. Vamos a setear el contrato al que vamos a atacar. Ya lo tenemos seteado y ahora lo único que nos queda es atacar. Vamos a hacer un depósito de 2 ETH en el contrato a través del método ATTACK. lo retiramos y ya vamos de forma recursiva hasta que se vacile la cuenta del contrato. Vamos a verlo en acción. Ampliamos un poco. Como podemos comprobar, el contrato anteriormente tenía 10 ETH. Se han depositado los 2 ETH del atacante desde el contrato atacante. Por lo tanto, el usuario que representa el contrato atacante tiene 2 ETH en balance. y se devuelve al contrato esos dos ETH por lo cual el contrato del banco solamente tiene 10 ETH se le vuelve a enviar dos de forma recursiva hasta que el banco se queda sin fondos como podemos comprobar el banco tiene cero ETH por lo que se le vació la cuenta Para poder solucionar esta vulnerabilidad lo podemos hacer de dos formas. Una de ellas es simplemente, aquí en el contrato del banco, actualizar el estado de la cuenta del banco antes de hacer envío del valor al usuario o al contrato. En este caso lo tenemos aquí cambiado. Aquí lo único que cambia es lo que hemos dicho, es subir esta línea arriba para actualizar antes de hacer la llamada. Eso es usar el padrón check effects interactions. Este padrón lo que dice es que primero se hagan las comprobaciones, luego se actualiza el estado y después se interactúe con un contrato que no conocemos, un contrato inseguro. Podemos. podemos desplegar este contrato y ver que realmente soluciona el ataque. Vamos a seleccionarlo, contrato A, desplegamos y aquí tenemos el contrato A, el contrato anterior. el vulnerable, vamos a hacer algún depósito en este contrato, vamos a depositar 40 dollars, 40 ethereum, desde otra cuenta hemos dicho, vale, depositamos, efectivamente tenemos, creo que he marcado otra cosa, vamos a probar otra vez, vamos a depositar 40 aquí y depositamos 40, 40, efectivamente. Vale, ahora el banco tiene 40 vamos a perdón, la cuenta del usuario tiene 40 Ethereum en su cuenta y que es lo mismo que la cuenta del banco. Vamos a intentar atacarlo por lo que vamos a CTR el contrato a tacar y vamos a atacarlo haciendo depósito, un depósito de 5 ETA. El contrato que vamos a atacar es 8CA 8c6a, es el mismo. Genial, pues vamos a proceder a pagarlo. Y efectivamente podemos comprobar que el banco tenía 40 ETH. Se ha intentado depositar 5 ETH, por lo que el banco tendría 45 ETH y 5 ETH el usuario. Pero al intentar hacer la segunda llamada para poder retirar más fondos, el banco ha decidido que no se puede hacer. Por lo tanto, el banco ha decidido que no se puede hacer. como el estado ya se había actualizado en la segunda llamada, ya no se pasaba este require, por lo que ya no se podía hackear. La segunda forma de... La segunda forma de solucionar esta vulnerabilidad es haciendo uso de esta librería de OpenSeparate. Esta librería nos proporciona un modificador de acceso que se llama NodeRender, el cual funciona de la misma forma que un candado. Tiene un booleano que se crea true antes de que se ejecute el código. Como podemos ver aquí, es el mismo código de antes, del mismo código vulnerable. Pero al usar este no-re-entrant, que es un candado, antes de ejecutar todo este código, se setea ese valor a true. Y se comprueba, cada vez que se ejecuta ese método, que ese valor esté a false. inicialmente está a false, cuando se ejecuta antes de ejecutar el código se setea a true y al final de la ejecución se setea a false otra vez, por lo que mientras se esté ejecutando ese código no se podría volver a llamar a este método. Vamos a desplegar este contrato y comprobar que realmente funciona. aquí lo tenemos, vamos a hacer algún depósito desde una cuenta vamos a poner 50 ETH y hacemos un depósito, efectivamente el banco ahora tiene 50 ETH por lo que vamos a intentar hackearlo, vamos a la cuenta del atacante vamos a cifrar el contrato que vamos a atacar que es este, lo he copiado citamos ya está seteado y ahora vamos a atacarlo 5 Ethereum, depositamos 5 Ethereum y lo retiramos de forma iterativa hasta que hasta que se vacíe, vamos a intentarlo lo normal es que no funcione y ya está Y efectivamente se ha revertido la transacción. Se ha intentado depositar los 5 dólares, los 5 ETH, por lo que el banco tendría 55, pero en la segunda ya se ha revertido. Por lo cual esta solución también funciona. Espero que os haya gustado el vídeo y que ha ayudado a entender cómo funciona esta vulnerabilidad. ¡Muchas gracias!