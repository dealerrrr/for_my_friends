En este vídeo vamos a hablar de Open Zeppelin. Open Zeppelin es una compañía que implementa una serie de contratos de solidity, unos smart contracts, muchas veces implementa los estándares de una manera que está muy probada, muy auditada y es muy segura. Entonces, muchas veces en lugar de tener que nosotros implementar smart contracts muy extendidos como pueden ser el RC20 o el RC721, Open Zeppelin ya nos provee de unos contratos que son muy seguros. que son muy fiables. Entonces en lugar de tener que reinventar la rueda es muy recomendable utilizar estos contratos que ya existen y que son tan fiables. Entonces vamos a ver algunos de los ejemplos, vamos a integrarlos nosotros en Remix y vamos a ver cómo funciona. Nos unimos aquí a contratos. Vale, pues entonces esta es la documentación de Open Zeppelin. Como vemos tiene multitud de cosas, tiene temas de control de acceso, de tokens, de gobernanza, otras utilidades, etc. Entonces vamos a empezar por ejemplo con el tema del control de accesos. También podemos mirar directamente el código fuente en GitHub, lo cual es bastante útil. Aquí entramos en su repositorio de contratos. Esta es la última versión pero se puede seleccionar versiones anteriores si queremos otras versiones de compilador. Aquí podemos ver todas las que contiene. Vamos a ir a Remix y vamos a hacernos un contrato que utilice el control de acceso de Remix. Si habéis echado un ojo a los smart contracts que vienen por defecto en Remix, veis que hay uno que se llama Owner. Este contrato permite utilizar un modificador y sonar. que lo que hace es que restringe quién puede acceder a algunas funciones. Esto es algo similar a lo que hemos visto en un vídeo anterior con el juego de que sólo algunas direcciones pueden realizar algunas acciones. En este caso las funciones que tengan ese modificador y owners sólo pueden ser utilizadas si la cuenta que lo envía es la propiedad que se ha establecido como owner. OpenZeppelin nos provee ya de una funcionalidad muy similar a esta, de modo que nosotros podemos simplemente utilizar su modificador en lugar de tener que estar implementándolo nosotros mismos. Así que bueno, vamos a crearnos una carpeta, vamos a llamarla OpenZeppelin, y vamos a crearnos un contrato que lo vamos a llamar ContractWithOwner, por ejemplo. Vamos a copiar, como hacemos siempre, la licencia y la versión y ahora nos vamos a importar el smart contract. Aquí hay varias maneras de hacerlo. Si nos fijamos en la documentación... Aquí nos explican cómo instalarlo, pero desde Remix no es necesario hacer ninguna instalación, sino que automáticamente Remix detecta si estás utilizándolo y te instala el paquete directamente. Entonces se puede hacer de esta manera, con arroba opencpaling barra contracts y ya la ruta hacia el contrato que queramos, o incluso se puede hacer referencia directamente al smart contract desde GitHub. Si copiásemos esta url de Open Zeppelin contracts nos llevaría hasta allí. Pero bueno, nos vamos a quedar simplemente con el accessContracts. Vamos a copiar aquí lo que nos viene de ejemplo. Vale, y entonces en este caso queremos el de ownable. Vale. Aquí podéis comprobar que lo que viene aquí es muy similar al ejemplo que te viene en Remix. Tenemos una propiedad privada que se llama Owner, solo que aquí también tenemos una serie de eventos, etc. Lo importante es el modificador OnlyOwner, que lo que hace es que comprueba que el owner del contrato es el mismo que el messageSender y si no, nos lanza este error. OwnableCaller es no el owner. Vale, pues entonces tenemos importado el smart contract de ownable, entonces vamos a crear nuestro contrato. Contract with owner, lo hemos llamado. De una manera muy similar a como hemos hecho antes con las interfaces, que para que un contrato implementase el nombre de la interfaz, este contrato lo que va a hacer es heredar del contrato a Unabolt. Así que también utilizamos is y el nombre del contrato que estamos heredando, isUnabolt. Con esto ya nuestro contrato es como si estuviese embebido dentro del contrato A1. Así que tenemos acceso a todas las funciones y todos los modifiers que esto nos permite. Entonces, como ya tenemos esto, vamos a probar a hacer una propiedad Win256. que va a ser en este caso público y lo vamos a llamar number, como hemos hecho otras tantas veces. No creo que haga falta ni hacer un constructor, vamos a hacer simplemente la función de set. Lo mismo, recibe un parámetro barra baja number, public y aquí ponemos number es barra baja number. Vale, entonces esto es como lo hicimos inicialmente, de modo que así cualquier adres puede hacer esta modificación. Pero si ahora añadimos aquí el modificador only owner, que de nuevo es este que nos viene aquí en el contrato 1 o el que estamos heredando, ya no va a permitir que cualquiera lo pueda modificar, simplemente el owner. ¿Y quién es el owner por defecto? El adres que despliega el contrato. Muy bien, pues vamos a hacer una prueba. Vamos a desplegar este contrato. Deploy. Vale, entonces, además de las funciones que hemos puesto nosotros, que son el number, que es la propiedad pública, y el setNumber, que es esta función para setear esa propiedad, vemos que aparecen aquí algunas otras funciones o propiedades. Por ejemplo, esta owner, owner también será una función pública que nos ofrece el contrato ownable y que nos devuelve el adres de la owner. Como vemos coincide con el adres de la cuenta que ha desplegado el smart contract. Y el number pues inicialmente es cero. Entonces nosotros aquí podemos setearlo, podemos poner 15. y si le damos a number nos aparecerá porque hemos podido cambiar ese número. Si ahora utilizásemos otra cuenta distinta, por ejemplo la segunda de la lista que nos viene aquí e intentásemos cambiar ese número, por ejemplo a 7, mandaríamos una transacción y nos estaría dando un fallo. Entonces la transacción ha revertido. Y el motivo que nos da aquí es ownable color is not the owner, que esto es lo que vemos aquí el mensaje que da cuando el require falla, cuando se comprueba que el owner no coincide con quien está mandando el mensaje, la transacción, perdón. Entonces, ¿qué podemos hacer aquí? ¿Qué más opciones nos provee este contrato ownable? Pues tenemos una opción que es renunciar a la propiedad del contrato. Pero hay que tener cuidado con esto porque una vez que renuncias a la propiedad ya no puedes recuperarla, de modo que todas las funciones clave que están protegidas bajo el Only Owner ya no podrían ser accesibles. Así que esto recomiendo tener mucho cuidado cuando se esté haciendo. Lo que sí que se permite también, lo que en muchas ocasiones es bastante útil, es transferir la propiedad del contrato. a otra cuenta. Por ejemplo, ahora estamos con esta, con la A, B, etc. y no nos ha dejado cambiar el número, pero si nosotros cambiásemos la propiedad del contrato a esta, si lo hacemos desde la propia cuenta, obviamente no nos va a dejar, solo el owner, solo el dueño del contrato puede hacerlo. Entonces, si volvemos a mandar esa transacción con el owner, nos va a permitir cambiarla y entonces ahora el que antiguamente era loaner ya no va a poder hacer estos cambios porque ya no es el loaner. Entonces tendría que ser esta nueva cuenta quien haga ese cambio. Y una vez que lo hace ya sí que nos ha permitido cambiarlo y comprobamos que en efecto ha cambiado este número. Bueno pues este es uno de los ejemplos de smart contracts que nos facilita bastante el desarrollo de OpenCPLin. Ahora vamos a hacer otro ejemplo, vamos a hacer un token R20. Si quisiéramos nosotros hacer un token R20 desde cero, deberíamos crear la propiedad de los balances, que sería un mapping, como hemos dicho por encima en otro vídeo, de cuánto balance tiene cada usuario. Tendríamos que implementarnos la función de minteado, de transferencia, todas las que vienen definidas en el estándar. Pero como eso es algo que es muy habitual y ya está hecho mil veces, pues entonces en lugar de hacerlo desde cero, lo que hacemos es vamos a importar el smart contract RC20 que nos ofrece OpenCPP. Para eso aquí en contratos tenemos aquí un apartado que es tokens, donde nos encontramos distintos estándares. En este caso nos vamos a centrar en el RC20. y vemos aquí que está el RC20 y también está IRC20, que esto pues como supondréis es la interfaz de utilización del RC20. El que vamos a utilizar es este. Lo dejo aquí abierto para que luego consultemos alguna cosa, pero como veis es básicamente la implementación del estándar de una manera muy segura y totalmente probada. Así que vamos a crearnos aquí un nuevo contrato y lo vamos a llamar mytoken.sual. Copiamos esto y entonces el contrato, perdona, la importación ya no va a ser en AccessAvailable sino que va a ser aquí, lo que viene aquí. Token rc20, rc20.sol. Vale, entonces aquí, igual que antes, contract, en este caso myToken, is, rc20. Vale, entonces aquí, igual que antes, contract, en este caso myToken, está en el contrato y ya no va a ser en AccessAvailable sino que va a ser aquí, lo que viene aquí. Vale, entonces aquí, igual que antes, contract, en este caso myToken, está en el contrato y ya no va a ser en AccessAvailable sino que va a ser aquí, lo que viene aquí. Estamos diciendo que este smart contract hereda del RC20 de OpenZeppelin. Vale, entonces, ¿qué tenemos que hacer aquí? Pues tenemos que ponerle el constructor. porque el contrato de OpenCPPLin en el constructor se le está indicando cuál es el nombre y el símbolo del token. Entonces es necesario, aquí no podemos no tener un constructor, porque si el contrato padre, que en este caso es el RC20 de OpenCPPLin, requiere estos parámetros, pues los tenemos que mandar. Entonces aquí la manera de realizar el constructor es un poco diferente. Haríamos el constructor, le pasaríamos los parámetros si quisiéramos, que ahora eso vemos cómo es. y luego tenemos que poner aquí RC20 que es el nombre del contrato padre y entre paréntesis hay que pasarle ya directamente los parámetros que nos pide que son como hemos dicho el nombre del token, vamos a ponerle myToken y el símbolo del token, vamos a poner TKN. Vale y este sería el constructor, entonces haciendo únicamente esto ya tendríamos un smart contract de un token, tendríamos un RC20 El problema es que ahora mismo no se ha minteado ningún token. Sería un token con un total supply de 0. Así que hay que mintear algo, es decir, tenemos que generar una cantidad de tokens para alguien. Lo común aquí es dárselo al que ha desplegado el smart contract. Entonces accederíamos a //mint y diríamos, para quien estamos minteando, para el message.sender, ¿Y cuánto estamos minteando? Vamos a poner aquí un 1 seguido de un montón de ceros. ¿Por qué barra baja mint? Estamos llamando aquí a una función que nosotros no estamos viendo. Pero claro, esta función es una función que nos ofrece el RC20. Antes hemos hablado ya de las funciones públicas, de las funciones privadas, de las funciones externas, y entonces por completitud nos queda hablar de las funciones internas. Entonces si aquí buscamos mint... vemos que esta es una función interna. ¿Qué implica eso? Las funciones privadas, habíamos dicho, que sólo se pueden acceder desde el mismo contrato. Las funciones internas son más o menos igual, pero un poco diferentes. Significa que también se pueden acceder desde subcontratos, es decir, desde un smart contract herede de este, también se podrá acceder a esta función. Y es justo lo que estamos haciendo. desde el constructor del smart contract llamamos a mint que indicamos a qué cuenta y la cantidad y esto después de hacer ciertas comprobaciones va a realizar eso. Como vemos está aumentando el total supply, está emitiendo un evento, está cambiando el balance, está haciendo una serie de cosas. Si hiciésemos esto, nuestro smart contract, nuestro token R20 tendría esta cantidad de tokens. y nunca se podría modificar la cantidad total porque no hay manera desde fuera de llamar a esta función. Al ser una función interna nosotros no vamos a tener acceso a ella. Vamos a hacer la demostración. Desplegamos el anterior y desplegamos MyToken. Aquí ya vemos que hay un montón de información. Cuando nosotros no hemos dado ninguna función pero todas estas son propias internas del RC20 de OpenCPL. Entonces, ¿qué vemos aquí? Pues el name, que es myToken, el símbolo, que es TKN, el totalSupply, que es la cantidad que hemos hecho. TotalSupply es cuántos tokens hay de este R20. Pues ahí los que le hemos puesto. ¿Hemos minteado todos estos? Pues eso es lo que hay. Los decimales, por defecto, como he dicho, es muy común que sean 18 decimales. Luego hay mucha información que podemos sobreescribir. Nosotros podríamos hacer de alguna manera que el número de decimales, en lugar de 18, fuese 6 o 12 o algo que nos sea más manejable, si es lo que queremos nosotros. Pero por defecto se hace en 18. Luego podemos hacer una prueba de sobreescribir alguno de esos valores. Entonces vemos aquí también, podemos comprobar el balance. Si vemos el balance del usuario que ha desplegado, del adres que ha desplegado este smart contract, vamos a ver que es lo que hemos minteado. Tiene sentido. Si cogiésemos otro, por ejemplo este de aquí, nos va a decir que es cero, por supuesto, porque no ha recibido ningún token. Aquí tenemos también las funciones de approve, de transfer, etc. el allowance, allowance lo que hace es que te permite que otra cuenta use tus tokens de alguna manera, que pueda transferirlos, que pueda hacer lo que quiera con ellos. Entonces claro, si estamos aquí así de esta manera, lo único que podemos hacer para que estos tokens cambien de mano es que el usuario este los transfiera. Es la única manera. Entonces pues bueno, vamos a probar a hacer la transferencia. Transferimos a esta otra cuenta que hemos puesto. la mitad de los tokens. Si aquí hay esto empieza por 1, 0, borramos 2, ponemos un 5, Transact. Vale, pues se ha hecho la transferencia. De hecho, ahora si lo vemos vamos a ver que esto se ha tenido que generar un evento de transferencia. Aquí está. Evento transfer desde esta cuenta hasta esta cuenta por tanto valor. Y ahora el balance que antes era 0, ahora va a ser pues un 5 seguido de todos esos ceros. Como hemos dicho, ahora mismo no hay manera de que se puedan mintear nuevos tokens. Es decir, nunca va a haber más de estos tokens, ni menos, porque no se permite mintear ni quemar ninguno de esos tokens. Entonces, para modificar eso, lo que deberíamos hacer nosotros es una función de minteo. Entonces aquí le pondríamos, digamos que la forma de la función será muy similar a esto, que queremos mandárselo a una cuenta y una cantidad. Hacemos addressToWinAmount. Y vamos a ponerlo por ahora de manera pública. Y entonces aquí vamos a llamar a la función interna, que es esta de aquí. Entonces lo que hacemos es... Minteamos con la función que nos provee OpenCPPLink, To and Amount. Como es una función interna, aquí no nos aparece, no tenemos esa opción, pero en cuanto ya estamos dando una puerta de salida al exterior, que es una función pública, en cuanto desplegamos el token de nuevo, vamos a ver que ahora sí que tenemos esta función de mint. ¿Ves aquí el total supply sigue siendo esto? y si yo minteo otra cantidad igual para quien sea, para la misma cuenta que lo he desplegado, el total supply se ha duplicado. Entonces con esto sí que podemos aumentar. ¿Qué más podríamos hacer? Bueno, antes de pasar de esto, No es muy seguro tener... claro, si tenemos una función de mint que es público, cualquiera, es decir, puede venir la cuenta esta de aquí, por ejemplo, y decir, joe, tokens gratis, voy a mintear para mí. Y se mintea todo lo que quiera y más, llama la función todas las veces que quiera. Y entonces su balance va a empezar a crecer y crecer. Entonces, obviamente, raro sería el caso en el que nosotros quisiéramos que esto fuese de esta manera. Entonces, ¿qué tenemos que hacer? Limitar quién puede mintear. ¿Qué manera se os ocurre de hacer esto? Teniendo en cuenta lo que acabamos de hacer, hay una manera muy clara. Vamos a importar también el contrato ownable de OpenCPLin. Y entonces vamos a hacer que esto, además de ser un RC20, también sea un ownable. Y entonces vamos a hacer que sólo el propietario de este smart contract pueda mintear. Entonces ahora mismo, si volvemos, nos cargamos este smart contract, lo desplegamos de nuevo, nos vamos a poner con la cuenta de arriba del todo. Lo desplegamos. Vale, entonces ahora solo el propietario, solo el owner, que aquí vemos de nuevo owner, la función que nos ha aparecido por coger el ownable, es el único que va a poder mintear. Si yo ahora quiero mintear con esta cuenta, lo puedo hacer de nuevo. O sea, minteo para mí mismo. toda esta cantidad. Puedo hacerlo. Pero ahora si llega otra cuenta, por ejemplo la última, la que hemos seleccionado antes, e intenta mintear para sí mismo, se va a encontrar con que no puede. Pues esto estamos combinando lo que hemos visto del RC20 de ahora con lo que hemos visto previamente del Unaball. Entonces, estos son como pequeñas piezas del puzzle que vamos poniendo juntas y sin apenas haber desarrollado nosotros prácticamente nada, no hay apenas líneas de código aquí nuestras, ya estamos dando una funcionalidad que es un poco más compleja. Entonces, ¿qué más podríamos hacer? De la misma manera que estamos minteando con el Only Owner, podemos hacerlo al contrario, podríamos hacerla... una función de quemar tokens. La función de quemar tokens hace justo lo contrario, como os podéis imaginar. También tenemos aquí una función interna dentro del RC20 que dice para esta cuenta voy a quemar tantos tokens. Entonces esos tokens van a desaparecer. Van a desaparecer de esa cuenta y van a desaparecer del conteo total de tokens de este RC20. Entonces, de una manera muy sencilla, hacemos aquí una copia. y donde ponemos burn y ya está. Entonces tenemos aquí un total supply de lo que hemos dicho y entonces ahora vamos a quemarlo. Pues vamos a quemar un 10%. Le he quitado un 0 y de esta misma cuenta porque claro, hay que quitárselo a alguien que tenga los tokens sino no vamos a poder. el Transact, la función ha ido correctamente, esto nos ha generado un evento. Como vemos aquí no hay un evento específico de quemar. Cuando se está quemando tokens, internamente está haciendo una transferencia al adres que al final es lo mismo. Porque nadie posee el wallet entonces nadie puede hacer nada con ello. Así que básicamente esto es lo que hemos hecho. Y si comprobamos el total supply... En lugar de 1,0 ahora hay un 9. Y aquí lo mismo, no podríamos quemar tokens desde otra cuenta y no podemos quemar los tokens de una cuenta que no exista. Perdón, de una cuenta que no tenga tokens. Por ejemplo, si intentamos quemar de aquí, nos falla. Primero nos ha fallado porque estamos haciéndolo desde una cuenta que no es la 1. y si nos cambiamos al owner y le damos de nuevo, nos falla porque dice la cantidad que estamos intentando quemar excede el balance de esa cuenta. Lo mismo pasa si estamos intentando hacer una transferencia, no puedes transferir más de lo que tienes, etc. Y bueno, pues esto es un ejemplo así muy sencillito de cómo modificar un RC20. Os recomiendo que le echéis un ojo a la implementación para ver cómo lo hace y demás. Otras opciones que se podrían cambiar, como he dicho, se podría modificar el tema de los decimales. En este caso se sobreescribiría esta función que es pública. Utilizando el override, igual que hemos hecho antes con las interfaces, en lugar de que los decimales sean 18, lo podríamos cambiar a 6, a 12, lo que sea. Y bueno, si no lo veis claro, de todos modos, ir a la documentación. En la documentación explica bastante bien los contratos, cómo hacer este tipo de modificaciones, por ejemplo, aquí está diciendo cómo modificar el tema de los decimales, etc.