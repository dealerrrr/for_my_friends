Speaker 0 | 00:13.314
En este nuevo vídeo vamos a explorar otro concepto de Solidity, que son las interfaces. Las interfaces básicamente proveen una lista de funciones que los smart contracts que las implementen deben tener y deben implementar todas sus funciones. Las interfaces contienen simplemente el nombre de la función, los parámetros, lo que devuelven, etc. Pero no contienen la funcionalidad, lo que es la implementación de esa función. No contienen un código ejecutable, son simplemente como una guía de qué deben tener los smart contracts que implementen esa interfaz. Para ello vamos a hacer una interfaz de oráculo y una serie de oráculos que lo que hacen estos oráculos van a ser darnos el precio de unos tokens. Por ejemplo, vamos a hacer que nos den el precio de USDT y el precio de MATIC en la red de mainnet de Ethereum. De acuerdo, pues vamos a crear primero una carpeta llamada oracles. y dentro de esta carpeta vamos a empezar creando la interfaz Ioracle. Es recomendable que las interfaces, el nombre de la interfaz empiece por I para que de una manera sencilla se pueda observar que es una interfaz en lugar de un contrato normal. Por acelerar vamos a copiar la licencia y la versión. Normalmente cuando hemos creado otros contratos hemos puesto contract y el nombre del contrato pero al ser esto una interfaz hay que poner interface y el nombre de la interfaz que es Ioracle. ¿Qué es lo que queremos de esto? Queremos que contenga las funciones que va a tener la interfaz. En este caso sólo nos interesa una, que es obtener el precio. Así que vamos a llamarlo function getPrice, no recibe nada. y lo que nos va a devolver es el precio. Hemos visto antes otros tipos de visibilidad. Hemos visto público y privado. Public y private. Pues aquí vamos a poner external. Porque las funciones de las interfaces deben ser externas. External significa que únicamente se puede llamar la función desde fuera del contrato. Es decir, o desde otro contrato o desde otra dirección, desde una wallet, pero no desde el propio contrato. Todas las interfaces sus funciones son externas. En este caso va a ser una View porque no va a modificar el estado de la blockchain, simplemente va a leer y devuelve un tipo Win256. De acuerdo, entonces pues bueno, esta sería nuestra interfaz. Como veis es muy sencillita, únicamente contiene esta función. Vamos ahora a crear un oráculo que implemente esta interfaz. Creamos un nuevo fichero, vamos a llamarlo stableoracle.sol. ¿Por qué stable? Porque este va a ser un oráculo que nos va a dar el precio de los tokens que son, de las monedas que son stables, una stable coin, como puede ser USDT, USDC, DAI u otros similares. Entonces aquí para simplificar lo que vamos a hacer es un contrato que nos va a devolver siempre un valor fijo que va a ser 1. Normalmente cuando se obtienen los precios de tokens y demás se suelen hacer relativos al dólar americano, al USD. Entonces aquí hacemos contract stable oracle. Entonces este sería el contrato, pero lo que queremos es que implemente la interfaz. Y entonces para eso tenemos que importarla en este contrato. Así que utilizamos la palabra import. Tenemos que poner la ruta relativa donde está el contrato, que al estar, como vemos aquí, en la misma carpeta, punto barra ioracle punto sol. Y ahora tenemos que decirle, vale, este contrato es un ioracle. ¿Qué implica eso? Estamos diciendo que este contrato tiene que implementar todas las funciones de esta interfaz. Si no lo hace, nos sale aquí un error. Oye, esta función de la interfaz no está siendo implementada, tienes que implementarla. Vale, pues sin problema. Vamos a hacerlo. La tenemos que llamar igual, por supuesto. Tiene que recibir los mismos parámetros, en este caso es ninguno. Esto sería una external view. Vamos a poner lo mismo. Aquí vamos a poner override porque lo que estamos diciendo es que está sobreescribiendo la función de la interfaz. De esta manera vemos que esta es una función de interfaz. Y devuelve lo mismo. Como esto va a ser en stablecoin y lo vamos a hacer de una manera muy sencilla, vamos a decir que va a devolver 1 porque es 1$, 1 USDT. Lo que pasa es que las... como hemos dicho, en Solidity no existen los decimales, lo que se hace es que se escala, es decir, se multiplica, se pone un montón de ceros. en lugar de poner decimales. Normalmente, depende también de la moneda, pero muchas veces es un estándar utilizar 18 decimales, que es lo que utiliza Solidity para, por ejemplo, en el Ether son 10 elevado 18 Ways. Entonces vamos a multiplicar esto por 10 elevado 18, es decir, va a ser un 1 seguido de 18 ceros. De una manera simplificada se puede poner como 1e18. Es 1 por 10 elevado a 18. Entonces aquí nos sale un warning que nos dice, bueno, pero esto no está leyendo de nada de este smart contract, así que en lugar de view se puede poner view. Sin problema. Lo ponemos como view. Pues ya está, con esto ya tenemos un oráculo que implementa esta interfaz. Ahora podemos crear otro oráculo que implemente esta interfaz. Vamos a hacer uno para Matic. Lo vamos a llamar MaticOracle.sol Por acelerar vamos a copiar esto y lo pegamos aquí. En lugar de stable ahora es Matic. Pero como Matic no es una stablecoin, tiene un valor que varía, lo que vamos a hacer es poner una propiedad que va a ser el precio y... que es la que vamos a devolver cada vez. Entonces creamos la propiedad, Windows 256, Price, pero lo vamos a poner privada porque lo que queremos es que no se interactúe con este contrato directamente, sino que se interactúe a través de la interfaz Ioracle. Entonces para eso ya tenemos la función GetPrice. Así que ponemos un nuevo private y ya está. Y ahora aquí lo que podremos es, en lugar de devolver 10 o 18, devolver la propiedad price. Entonces, claro, esto ya no es view, esto ahora es view, porque ahora sí que estamos leyendo algo del smart contract. Lo que pasa es que ahora mismo no le estamos asignando valor. Pues venga, vamos a cambiar esto. Lo que vamos a hacer es que cuando despleguemos el smart contract, le vamos a poner en el constructor. un parámetro price que es el que vamos a asignar a la propiedad price. Esto es lo mismo que hemos hecho otras tantas veces. Entonces cuando desplegamos el smart contract le decimos vale pues el matic vale tanto. y entonces se almacena esa variable y cuando llamemos a getPrice será ese. Pero claro, Matic es un token que va cambiando su valor, entonces deberíamos tener aquí una función que nos permita cambiar ese valor. Así que vamos a hacer un setPrice, esto es muy parecido a cosas que hemos hecho en vídeos anteriores. establecemos el price, esto es public, no es view porque estamos cambiando el precio, entonces esto es una transacción que modifica el estado. vale pues ya tenemos dos contratos distintos dos fraculos distintos pero ambos implementan la misma interfaz y oracle Así que lo dicho, nos da igual cómo esté implementado cada uno de estos smart contracts, porque nosotros sólo vamos a utilizar esta interfaz. Vamos a llamar a getPrice. Nos da igual cómo esté implementado, qué tiene por dentro, si llama a otros contratos, eso nos es indiferente. Vale, pues entonces ahora vamos a crear otro smart contract que nos permita interactuar con estos. Pues entonces vamos a crear uno que se llame PriceChecker. copiamos esto, el contrato se llama price checker, vale, este contrato no le ponemos is y oracle porque no va a implementar is oracle, lo que va a hacer es va a llamar a esos otros oráculos En lugar de importar cada uno de ellos, podríamos hacer un import matic.bat, matic.oracle, matic.sol e interactuar con matic.oracle. Pero la gracia de esto es que basta con tener esta interfaz, podemos comunicarnos con cualquiera de ellos simplemente usando la interfaz y haciendo referencia al adres de cada uno de esos contratos. Vamos a hacerlo bastante genérico. Vamos a hacer un mapping, que es algo que ya hemos visto en el vídeo anterior, cuya clave va a ser un address, que va a ser el address del token que queremos comprobar el precio, y cuyo valor va a ser un Ioracle, es decir, un objeto, un contrato que implementa la interfaz de Ioracle. Lo vamos a poner como público. y lo vamos a llamar oracles. Básicamente es un mapping que nos dice para cada token cuál es su oráculo. ¿Qué tenemos que hacer ahora? Hacemos un setter para poder rellenar eso. Va a recibir el token al que queremos consultar el precio y el adres del oráculo que nos va a dar esa información. Público. y entonces lo que hacemos, lo mismo que hemos hecho en otros vídeos. Oracles de token, la clave del par y el valor va a ser iOracle de Oracle. Con esto lo que estamos haciendo es estamos instanciando un contrato que sigue esta interfaz con esta dirección. Entonces esto es un objeto que vamos a poder llamar a todas sus funciones. Bueno, a todas, en este caso es únicamente GetPrice. Entonces con esto ya no necesitamos nada más. Con acceder a oracles de token ya vamos a tener el acceso a esa función. Pero también queremos que nos diga el precio, así que vamos a crear una función que la vamos a llamar checkPrice. Aquí vamos a decirle... la dirección del token. Es decir, para que yo cuando le diga aquí la dirección del token usdt, por ejemplo, me va a devolver uno, porque va a llamar internamente a través de la interfaz de Oracle, va a llamar al stable Oracle y me va a devolver lo que sea que implemente esa función. Vale, pues esto es un public view y nos devuelve un win256. Vale, entonces esto nos va a devolver Lo que haya en oracles de token, esto nos está devolviendo el objeto y oracle, pues de esto llamamos a su función getPrice. Y ya está. Con esto ya tendríamos un contrato que lo podemos surtir de todos los álculos que creamos asociados cada uno a un token y podemos consultar los precios de cada uno de esos tokens. Ahora vamos a desplegarlos, vamos a compilarlos y vamos a ver que todo funciona bien. Como está el autocompile, aquí no va a haber ningún problema. Vamos a empezar desplegando por ejemplo el Stable Oracle, que es el primero que hemos hecho. La interfaz no se despliega, lo que desplegamos es cada uno de estos oráculos que implementa esa interfaz. Desplegamos en Stable Oracle. Ha ido todo bien y aquí lo tenemos. De hecho si le diésemos aquí a GetPrice nos va a devolver un 1 seguido de 18 ceros. Perfecto, lo mismo que esperábamos. Ahora vamos a desplegar el de Matic. Aquí nos pide un parámetro. Nos venimos aquí y decimos ¿cuánto vale ahora mismo un matic en USD? Y es Esto lo tenemos que transformar a... Lo tenemos que escalar para que tenga multiplicar por 10 elevado a 18. Para que tenga el mismo número de decimales que todos los demás oráculos. Así que lo que hacemos es pegar aquí el número, cambiamos la coma por un punto y decimos por... 10, 9, 18. Y entonces esto nos tiene que devolver el valor. Aquí está. Vale, pues cogemos este número que es 0,84 x 10, 9, 18, lo pegamos aquí y desplegamos el Smart Contract. Vale, ya tenemos aquí desplegados el Stable Oracle y el Matic Oracle. Lo mismo aquí, si le damos a Get Price nos devuelve ese valor. Podríamos actualizar el valor si luego cambiásemos, pero ahora no lo vamos a hacer. Por último vamos a desplegar. el price checker. Lo desplegamos y aquí lo tenemos. Ahora mismo no tenemos ningún oráculo dentro de este mapping, así que lo que vamos a hacer es rellenarlo. Vamos a poner un oráculo para el USDT y otro oráculo para MATI. ¿Cuál es el adres del token? Yo lo tengo aquí ya abierto. En Etherscan tú puedes buscar cualquier token. Aquí los SDT, que son los más famosos. Aquí nos viene su dirección, que es la dirección del contrato. Al final, todos los tokens... Esto es un RC20, esto es un smart contract que está desplegado. Copiamos su adres y lo ponemos aquí en set oracle. El token va a ser este. y el oráculo va a ser el stable, así que como lo tenemos aquí desplegado le damos aquí al botón de copiar y aquí lo pegamos, entonces estamos asociando la dirección de este token con la dirección de este oráculo llamamos la transacción, se ha hecho correctamente vale y ahora vamos a añadir, vamos a borrarlo para que no haya confusión, ahora vamos a añadir el de Matic vale, pues aquí lo mismo, tenemos aquí el token Matic en la mainnet de ethereum copiamos el address adresa del token y ahora copiamos la dirección del oráculo de Matic que es este de aquí que tenemos. Copiamos, lo pegamos, Transact. Muy bien, pues ya tenemos ambos oráculos. Si quisiésemos hacer una comprobación, copiamos aquí el adres de Matic y si le doy me va a devolver. 0.8.1 que es 0.8.1 que es el oráculo de Matic. Vale, pues entonces ya podemos consultar directamente los precios de cada uno de ellos. Vamos a consultar el de Matic, que lo tenemos aquí a mano. Meto el adres, estamos llamando a esta función de aquí, CheckPrice. Le vamos a meter el adres del token de Matic y a ver que nos devuelve. Vale, pues esto es lo que hemos puesto antes. 0.84 por 10 sale 18. ¡Gracias por ver el vídeo! Y si queremos comprobar el precio del USDT, lo mismo. Vamos aquí, al CheckPrice. 1, 6 y 18 ceros. Funciona perfectamente. Como veis aquí estamos utilizando simplemente iOracle para atacar a distintos smart contracts que están implementados de distinta manera. Cada uno tiene aquí sus cosas, son distintos, pero la interfaz lo que nos permite es ser agnósticos a la implementación de ese smart contract. Lo único que nos interesa es la interfaz que presenta y es la función getPrice. También podemos hacer ahora una modificación. Supongamos que el Matic ahora ha cambiado de precio. pues vamos a simular que ha cambiado. Aquí tenemos este número, vamos a decir que en lugar de 0.84 que sube a 0.87. Hacemos la transacción y copiamos de nuevo el número. la dirección de Matic, checkPrice, 0.87. Hemos cambiado el valor dentro del contrato del oráculo de Matic y entonces eso nos ha permitido que cuando lo volvemos a consultar desde el contrato de PriceChecker obtenemos un valor distinto. Y bueno pues esto sería todo. Con esto hemos por repasar un poco. Hemos visto cómo funcionan las interfaces. Hemos visto que es simplemente la función sin cuerpo. Hemos visto cómo se importan contratos o interfaces de uno a otro. Hemos visto cómo hacer que un smart contract implemente una interfaz, poniéndole aquí IS, el nombre de la interfaz que hemos importado, y poniendo el cuerpo de la función, indicando que estamos haciendo un override de esa función. Y luego desde aquí hemos visto cómo interactuar con distintos contratos a través de una interfaz unificada. ¡Gracias por ver el vídeo!