En este nuevo vídeo vamos a crear otro contrato para seguir explorando las posibilidades que nos ofrece el lenguaje Solidity. Vamos a crear una especie de juego y vamos a empezar creando un fichero que vamos a llamar game.sol Vamos a poner el fichero de licencia, vamos a poner de nuevo que sea MIT, vamos a establecer la versión de Solidity, como dijimos en el vídeo anterior, pragma. y la versión que va a ser la 0817 la 0817 de 0817 en adelante hasta la 09 vale entonces el contrato se va a llamar game Y en este pequeño juego lo que vamos a hacer es que cada usuario se vaya a poder crear un héroe y los héroes van a poder luchar entre ellos. Entonces para eso vamos a introducir un nuevo concepto que se llama struct. Struct al final es como un tipo de dato, lo llamamos hero. Y entonces aquí vamos a detallar las propiedades que este tipo de dato tiene. Entonces el héroe va a tener un nombre, va a tener un nivel. También le vamos a poner un nivel de ataque y un nivel de defensa. Como dije en otros vídeos, es una buena idea tenerlo ordenado qué va antes y qué va después. Los tipos de datos, en este caso los structs, van antes de las propiedades. Esto definiría el tipo de dato héroe con todas sus propiedades y ahora vamos a ver cómo asociamos que cada usuario tenga uno de estos héroes. Para eso introducimos un nuevo tipo de dato que es el mapping. El mapping al final es como si fuese un hashmap o un diccionario en otros lenguajes que lo que hace es asociar una clave con un valor. En este caso la clave va a ser un adres, que va a ser la dirección del usuario. Ponemos una flechita. y el valor va a ser un objeto de tipo héroe. La variable la vamos a considerar de tipo pública y la vamos a llamar héroes. Ya tenemos el tipo de dato, tenemos esta propiedad que nos indica que asocia los usuarios con los héroes. Podríamos crear un constructor pero en este caso lo vamos a omitir, no es necesario que existan constructores en el contrato. Entonces lo que sí que vamos a hacer es una función para poder crear el héroe. Vale, entonces... ¿Qué parámetros vamos a pasarle? Pues vamos a pasarle el nombre. Respecto a los strings, cuando se pasan como parámetro hay que poner esta palabra clave en memory, porque es un string que está en memory. Hay otros tipos de modificadores, pero para este caso siempre es de tipo memory. Entonces indicamos el parámetro nombre y el resto vamos a darle un valor por defecto. Vamos a asociarle en este mapping, en nuestra propiedad de héroes, el adres de la dirección que está mandando la transacción a un nuevo héroe. Hay una serie de variables globales que se pueden acceder desde Solidity que nos permiten acceder a cierta información. Por ejemplo, nosotros podemos desde cualquier smart contract, desde cualquier punto, saber cuál es la dirección que está mandando la transacción a este smart contract. En este caso es message.sender. Esta variable siempre va a contener la dirección que está mandando la transacción. Y va a ser la clave de nuestro par que vamos a hacer aquí. Entonces vamos a hacer que heroes de message.sender... igual y entonces aquí tendremos que crear el objeto hero. Esto se puede hacer de múltiples maneras. Una manera de hacerlo es poner hero paréntesis y meter aquí directamente de manera ordenada los valores de todas las propiedades, en este caso sería name, el nivel va a ser uno por defecto y el ataque y la defensa vamos a poner que van a ser 100. Vale, esto es una manera de hacerlo. Hay otra manera de hacerlo que sería, en lugar de hacerlo así, se puede indicar mediante clave y valor cómo va a ser. Lo voy a poner... Comentamos esto... Por cierto, los comentarios en Solidity son con doble barra. Y también se puede hacer barra asterisco si queremos hacer un comentario de bloque. Otra opción que podríamos hacer aquí sería lo mismo, giro paréntesis y aquí introducimos el objeto, pero para eso introducimos unas llaves y entonces aquí sí que iríamos poniendo cada uno de los parámetros. Name, name, level1, etc. Pero bueno, como son poquitas cosas y es sencillito vamos a dejarlo de esta manera. Vale, con esto ya crearíamos el héroe. Podemos ir compilando y vemos que pasa. Compilamos game, nos vamos aquí al despliegue, tenemos aquí todo marcado como en los anteriores vídeos, desplegamos. El despliegue ha sido exitoso y aquí tenemos las dos funciones, la propiedad pública heroes y la función de createHero. Esto recibe como un parámetro un address y entonces, como decimos clave valor, si introducimos el address nos devolverá la propiedad hero. Por ejemplo, si ponemos el address de la cuenta con la que hemos hecho el despliegue, lo pegamos aquí, nos devuelve el objeto vacío con todos los valores por defecto. Entonces, como veis, el string está vacío y tanto el nivel como el ataque y la defensa están a cero. Ahora mismo podemos crear un héroe. Cuando lo llamemos, vamos a llamar al héroe Pedro. Esto nos dice que ya ha mandado una transacción, que ha ido correctamente, vemos el parámetro que hemos mandado y tal. Si volvemos a llamar a esta función... Aquí vemos que lo que nos ha devuelto es un objeto héroe con todas sus propiedades. Hombre Pedro, nivel 1, ataque 100, defensa 100. Entonces, ¿qué podemos hacer para ampliar esto? ¿Qué pasa si yo llamo a la función de createHero varias veces? Pues lo que va a hacer esto es que va a sobreescribirlo. Si yo ahora me creo otro héroe que se llame Antonio... y vuelvo a llamar a esto, me lo ha sobrescrito. Entonces con esto hay que tener cuidado, igual no queremos que este sea el comportamiento. Igual alguien llama a esta función sin querer y tenía ya un héroe nivel 200 y lo pierde. Así que aquí vamos a introducir un nuevo concepto que es muy importante, que es el require. RequiringSolidity lo que hace es que comprueba que se cumple una condición y si no se cumple, realiza un reverso a la transacción. Es decir, anula la transacción. Cualquier cosa que se hubiese hecho previamente no se va a guardar. Si hubiésemos hecho cambios en el SmartContact, da igual, esa transacción se ha cancelado y no se lleva a cabo. En este caso lo que vamos a comprobar es que no existe ya un héroe para este adres, para mesis.sender. Entonces, como el objeto héroe tenemos, vemos que tiene toda esta información, el nombre, el nivel, tal, tal, tal, tal, tal, lo que podemos hacer es, si accedemos a esto, nos devuelve, si no tenemos un héroe, nos devuelve el objeto vacío, pues lo que podemos hacer es comprobar el nivel. Si el nivel es cero, sabemos que no existe un héroe, porque si se hubiese creado un héroe sería por lo menos uno, porque se crea con uno, o puede que sea más y luego subiese el nivel si desarrollamos esa funcionalidad. Entonces, para eso vamos a hacer un require. Ponemos la condición booleana que en este caso va a ser que heroes de message.sender esto nos devuelve el objeto héroe de este address.level para acceder a cada una de sus propiedades podemos hacer.name,.level, etc. pero vamos a utilizar el nivel.level igual a 0 es decir, tenemos que asegurarnos que se cumple esta condición no puede haber un héroe asociado a esta dirección. Y el require nos permite además también poner un mensaje de error, de modo que si una transacción falla, la transacción puede fallar por múltiples motivos, algunos que escapen a nuestro control, pero si nosotros ponemos aquí un mensaje cuando veamos la traza de la transacción podemos saber por qué ha fallado. En este caso vamos a poner you already have a hero. Entonces guardamos, borramos el smart contract que teníamos desplegado. Como lo tenemos en autocompile no hay que volver a darle. Desplegamos de nuevo. Vamos a hacer lo mismo de antes. Creamos un héroe que se llama Pedro. Y ahora creamos otro héroe que se llame Antonio. Aquí ahora la transacción ha fallado, como podéis ver sale aquí una X y entonces nos dice revert, la transacción se ha revertido. Y aquí, Reason provided by the contract, esto es el mensaje que le hemos puesto, you already have a hero. Entonces ahora mismo hemos añadido esta restricción, no puedes crear otro héroe si ya tienes uno. ¿Vale? ¿Qué es lo siguiente que vamos a hacer? Pues yo creo que podemos hacer una función de lucha, para que se puedan luchar unos héroes contra otros. function fight. ¿Cómo vamos a hacer esto? Pues vamos a hacer que yo que esté mandando una transacción llamando a luchar, digo contra qué enemigo quiero enfrentarme. Entonces pues vamos a poner un address enemy. Esto también va a ser de tipo público. Y entonces aquí haríamos la lucha. Vamos a pensar qué se nos puede ocurrir, qué restricciones podemos poner a esta transacción. Pues lo primero, si yo quiero luchar contra alguien, necesito tener un héroe. Entonces aquí vamos a hacer lo mismo de antes. Vamos a hacer un require heroes message.sender.level Pero claro, aquí es lo contrario. Antes lo que queríamos era que estemos comprando que no tuviese un héroe. Ahora tenemos que comprobar que sí que tiene un héroe. Así que el nivel tiene que ser mayor que cero. Acordar siempre la condición booleana y luego el mensaje. y el mensaje pues aquí va a ser al contrario. You don't have a hero. Si no tienes un héroe, no puedes luchar. Muy bien. ¿Qué otra restricción podríamos poner? Pues que el enemigo al que nos estamos enfrentando también debe tener un héroe. Así que vamos a... Vamos a copiar y pegar. Entonces... La propiedad heroes del adres del enemigo que estamos indicando, punto level, tiene que ser mayor que cero. Si el nivel es 0 significa que el objeto está vacío. Si el nivel es mayor que 0 significa que ya hay un objeto ahí. Entonces queremos que el enemigo tenga un héroe, si no, no podemos luchar. El mensaje de error va a ser Enemy doesn't have a hero. Vale, pues ya tenemos dos restricciones que parecen bastante buenas. ¿Se nos ocurre alguna otra? Pues a mí se me ocurre que no puedas luchar contra ti mismo. Porque si yo aquí en el adres me pongo mi misma dirección, el héroe estaría luchando contra sí mismo y eso no es algo que queramos hacer. Así que hacemos requires message.sender, de nuevo, message.sender es la dirección del que está enviando la transacción. Tiene que ser distinto de enemy. Esta es la contrabandana y el mensaje que ponemos. You can't fight yourself. Muy bien, pues entonces ya hemos cubierto un poco todas las condiciones que podemos poner. ¿Cómo va a ganar un jugador? Pues si su nivel de ataque es mayor o igual que la defensa del enemigo, yo creo que parece que eso tendría sentido. Entonces, id heroes de message.sender Este es el objeto hero, entonces, como hemos dicho antes, para acceder a cualquiera de sus propiedades utilizamos el punto y la propiedad que queremos. En este caso, ataque. Si el ataque es mayor o igual que la defensa del enemigo, por eso, de nuevo, heroes de enemy, punto, defense, vale. Si el ataque es superior a la defensa, pues habremos ganado el combate. ¿Qué pasa si ganamos el combate? Si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, si, Podemos hacer que suba de nivel. Aquí ahora mismo no tenemos nada. Vamos a poner aquí un todo. Ahora vamos a crear una función que nos suba de nivel. Esta función tiene que tener ¿Qué visibilidad debería tener? Si ponemos que es una función pública, cualquiera puede coger y empezar a subir de héroe su nivel. No queremos hacer eso, porque entonces el usuario llamaría constantemente a esta función y estaría muy OP. Entonces lo que vamos a hacer es que sea una función privada. Como es privada, vamos a ponerle la barra baja. Como hemos dicho, esto no es que sea algo necesario, pero bueno. algo que ayuda. Yo considero que es una buena práctica. Al final luego el estilo de programación también depende un poco de cada uno. ¿Qué pasa cuando un jugador sube de nivel? Pues vamos a hacer que su héroe va a subir algunas de sus propiedades. girosmessage.sender.level, pues el nivel más o igual a 1. Vale, pues sube 1 en su nivel. ¿Qué más cosas vamos a subir? Pues el nombre no va a cambiar, pues vamos a subir el ataque y la defensa. El ataque vamos a subirlo en 15, por ejemplo, y la defensa la vamos a subir en 10. Entonces ahora tenemos que llamar la función simplemente, por debajo, levelUp. Como veis no hace falta pasarle a ningún parámetro. Podríamos hacer que el levelUp recibiese un parámetro con el address y entonces aquí en lugar de heroes.msc sería heroes.address. Ojo, aquí aunque estemos llamando una función distinta, el message.sender sigue siendo la dirección que ha llamado la transacción. Es decir, aunque la llamada a esta función venga de otra función, el message.sender no pasa a ser este contrato, porque quien ha iniciado la transacción es la dirección que manda la transacción. Ahora, si este contrato estuviese llamando a otro contrato, ahí sí que el message.sender cambiaría. Pero bueno, eso no es algo que aplique en este momento. Ahora mismo pues eso, estamos haciendo como 6 puntos en DER. Otra opción sería indicarle aquí el adres del héroe al que queremos subir. Son dos maneras distintas de hacerlo. Vale, pues con esto podemos ir probándolo. De nuevo, descartamos el contrato anterior. y lo desplegamos de nuevo. ¿Por qué lo estamos desplegando de nuevo? Porque cada vez que hacemos un cambio, el contrato anterior sigue adelante con el código compilado y la interfaz que tenía antes. Por eso hay que volver a desplegarlo. Y eso es un tema que tiene Solidity. Si tú descubres un bug en tu smart contract, no puedes simplemente parchearlo y que siga funcionando. Toda la información que tú tuvieses almacenada se pierde. Es decir, si yo ahora despliego este smart contract con esta nueva funcionalidad, y intento acceder a cuál es mi héroe, está vacío, así que el héroe Pedro que creé antes ya no existe. Bueno, existe, pero existe en el contrato anterior. En este ya no existe, son dos contratos distintos. No podemos actualizar un contrato como tal, al menos no de esta manera. Así que cada vez que se hace un cambio es un contrato nuevo. Por eso hay que tener cuidado cuando utilicemos Smart Contracts, cuando despleguemos Smart Contracts, tenemos que estar muy seguros de que todo funciona, porque si no hay que hacer todo de cero y los datos que tengamos ahí en el contrato anterior no se van a poder migrar de manera sencilla a este. Vamos a crear un héroe. Comprobamos el nombre. Vale. Pedro, ataque 100, defensa 100. Vale, entonces ahora necesitamos crear un enemigo. Así que aquí tenemos una serie de cuentas, como veis. La que estamos utilizando inicialmente es la de 5, B3, etc. Vamos a coger la segunda cuenta. La segunda cuenta esta que tenemos aquí no tiene un héroe. Comprobamos. No tiene un héroe. Así que lo vamos a crear. Este se va a llamar, pues como hemos dicho antes, Antonio. Creamos un héroe. Vale, entonces ahora tenemos Antonio es nivel 1, que es de la cuenta A, B, etc. Y luego la de 5B, lo que sea, tiene a Pedro. Vale, pues vamos a hacer que Pedro se enfrente a Antonio. Entonces, para eso, ahora mismo estamos con la de 5B, tal, tal, tal, tal, que es Antonio. Y vamos a copiar la dirección de Pedro. Entonces, estamos con 5B. y vamos a luchar contra la A, B, lo que sea. Fight. Vale, pues parece que ha ido todo correctamente. Ha funcionado la transacción. Así que ahora volvemos a ver las características de este héroe. Vale, pues Pedro ha subido al nivel 2. Ha subido al nivel 2 y ahora su ataque es 115 y su defensa es 110. Muy bien. ¿Qué pasa si intentamos...? Vamos a comprar que estos requirements que hemos puesto funcionen bien. Vamos a intentar utilizar a un héroe que aún no exista. Y le damos a luchar. Ha fallado. No tienes un héroe. Entonces esta primera condición ya funciona bien. Vamos a intentar luchar contra nosotros mismos. Así que nos vamos a poner el de... Entonces si estamos luchando contra AB8, vamos a ponernos el usuario AB8. Luchar. Vale, nos sale. You can't find yourself. No puedes luchar contra ti mismo. Vale, ¿y qué pasa si intentamos luchar contra un adres que no tiene un héroe? Pues copiamos esta, la pegamos y vamos a luchar. Ah, disculpad, no, tengo que... No había cambiado, me había puesto con otro héroe, perdón, con otra dirección que no tenía un héroe. Me he vuelto a coger la primera. Luchar. Enemidas en Javagirum. Vale, hemos comprobado ya todos los casos posibles. También hemos comprobado el caso exitoso, que es el que hemos hecho antes. ¿Qué más podemos hacer? Vale, pues... Se me ocurre que podemos hacer una función de entrenamiento. de modo que podamos subir de nivel a un héroe sin necesidad de luchar contra otro. Por eso creamos la función train. No le pasamos ningún parámetro. Va a ser una función pública. Vamos a pensar qué requires le podemos poner. Tiene sentido el de que tienes que tener un héroe. Si no tienes un héroe no puedes entrenar. Si tienes un héroe y por lo tanto puedes entrenar, vamos a hacer que subas de nivel. Y vosotros diréis, ¿qué diferencia hay entre poner el LevelUp como clase pública? Al final con llamar a Train ya estás subiendo de nivel. Es como puede ser, ¿verdad? ¿Cómo podríamos hacer esto más restrictivo para que no puedas estar entrenando constantemente? Podemos ponerle un límite de tiempo. En Solidity tú puedes acceder al momento actual. Igual que podemos acceder al message.sender, otra de las variables que existen es el timestamp del bloque en el que se ha minado esta transacción. Entonces podemos utilizar eso para ir comprobando el tiempo. Podemos decir que igual solo se puede entrenar una vez al día, por ejemplo. Entonces vamos a añadir una propiedad nueva al héroe. También va a ser un Win 256. Y lo vamos a llamar Last Training. Es decir, este contiene el timestamp de la última vez que se llamó a la función train. El timestamp al final es un entero porque es un número de segundos. Es un número muy largo de segundos. Y como no nos interesa tampoco exactamente qué significa ese número, sino sólo la variación de ese número. Si ha pasado suficientes segundos desde la última vez. Vale, pues entonces para eso en train tendremos que añadir otro require. Vale, pues entonces, ese require va a ser que pueda entrenar. Entonces, ¿cómo vamos a hacerlo? Pues que el timestamp, block.timestamp, Esta es la variable que he dicho que es con la que se puede acceder al momento actual, que es cuando tú estás mandando esa transacción. Esta va a tomar el valor del timestamp de ese momento. Entonces tenemos que comprobar que el timestamp sea mayor. Vamos a hacerlo de otra manera. Si le restamos el último momento en el que el héroe pudo entrenar, es decir, heroes.message.sender, las training, es decir, la diferencia entre el momento actual y la última vez que entrenó tiene que ser mayor que lo que digamos. Solidity nos permite utilizar, si pusiéramos un número de segundos, por ejemplo, si quisiéramos poner una hora, pues serían 60 segundos que tiene un minuto por 60. Entonces esto sería una hora. O podríamos, si luego quisiéramos que fuese un día, pues por 24. Pero Solidity nos permite ponerlo de alguna manera más sencilla. Un one days. Y esto también va a funcionar de la misma manera. Entonces, con esto estamos haciendo una comprobación de que ha tenido que pasar por lo menos un día desde la última vez que ha entrenado. Si no ha entrenado nunca el héroe, automáticamente esto va a estar a... las training va a estar a 0. Entonces, el timestamp va a ser un número bastante más alto, así que de primeras va a poder entrenar. ¿Qué pasa aquí también? Al haber puesto esta nueva propiedad, veis que aquí nos está saliendo un mensaje de error. Porque claro, nos está diciendo que esto espera 5 argumentos, pero solo hemos pasado 4. Aquí hemos pasado el nombre, el nivel, el ataque, la defensa, pero no nos hemos puesto el last training. Last training vamos a poner ahora que sea 0. Ponemos 0 para que de esta manera se pueda entrenar de primera. Si pusiésemos aquí el block timestamp... Es como que ya ha entrenado en el momento de crearlo, así que el primer día no podía entrenar. Pero bueno, lo vamos a dejar a cero para que se pueda entrenar desde el primer momento. Muy bien, pues entonces ya estaría... No, realmente no, porque tenemos que actualizar el valor de las training. Si no lo actualizamos, va a estar siempre a cero y siempre va a poder entrenar. Así que bueno. Vamos a coger esta propiedad del héroe y la vamos a igualar al momento actual. Block.timeStamp. También podríamos estar aquí poniendo eventos, pues por ejemplo cuando suba de nivel podemos poner un evento o cuando entrene, pero bueno, como eso ya lo hemos cubierto en vídeos anteriores tampoco vamos a repetirnos demasiado. Y ya tenemos listo nuestro video de hoy. Espero que les haya gustado. Si es así, no olviden de darle al botón de suscripción, de darle al botón de like y de compartir el video con sus amigos. Y ya saben, si quieren ver más vídeos así, pues síganme en Instagram, Facebook, Twitter y Twitter también. Y bueno, nos vemos en el próximo video. Como hemos dicho, lo tenemos en autocompilación. Descartamos los smart contracts anteriores. Desplegamos. Se ha desplegado correctamente. Vamos a crear nuestro héroe. Se ha creado bien. Copiamos la dirección para ver su información. Nivel 1, atracción, defensa 100, last training 0. Vale, pues ahora vamos a armar a Train. ¿Vale? La transacción se ejecuta correctamente. Entonces, según esto, ya deberíamos haber subido el nivel. Vamos a darle nuevo giro. Vale, se ha actualizado. Ha subido el nivel. Nivel 2. Aquí 115. Defensa 110. Last training. Pues esto es el timestamp del momento en que se ejecutó, que fue hace unos segundos. ¿Qué pasa si volvemos a darle a train? Ha fallado la transacción. Ah, claro, aquí nos dice que se ha revertido pero no nos está dando información. ¿Por qué? Pues porque se me ha olvidado poner aquí el mensaje. El mensaje, como digo, no es necesario pero es bastante recomendable. Si ponemos aquí, you can only train once a day. Solo puedes entrenar una vez al día. Bueno, pues venga, vamos a de nuevo a... destruimos el contrato, traemos uno nuevo, creamos la héroe. Observamos su información y entrenamos. Bien, volvemos a entrenar. Mal. You can only train once a day. Esto ya funciona correctamente. ¿Qué más cosas podemos hacer? Cuando quiero ver mi héroe que me esté devolviendo mi adres todo el rato, si hemos dicho que lo podemos sacar del message.sender Vamos a hacernos una función pública. que sea getMyHero que no reciba ningún parámetro. Y entonces esto lo que haga, como nos va a devolver el error, pues vamos a poner esto, returnsHero. Y entonces aquí vamos a poner returnHeroes de message.sender. Y ahora aquí nos dice, un momento, aquí pasa algo. ¿Qué es lo que pasa? Pues como he dicho antes, a veces hay que poner con algunos tipos de datos más complejos, con los tipos básicos, con booleano, int, tal, no hace falta. Pero con tipos más complejos, como es string o en este caso como es struct, pues entonces hay que especificarle si un modificador de memory o coldata o storage o tal, de... En este caso le vamos a poner memory. Entonces pues hero memory, guardamos. Esto es muy interesante, Remix nos va avisando cuando algo se nos pasa. Aquí lo que nos está diciendo es que esta función la podemos restringir a view y es cierto porque esta función como hemos dicho va a ser un call, no va a ser una transacción. y lo guardamos. ¿Por qué es view? Porque no estamos modificando nada, solo nos va a devolver, solo estamos leyendo información. Así que esta no requiere transacción, así que view. Vamos a probar. Desplegamos de nuevo. Seamos a GetMyHero. nos devuelve aquí... Esto ahora nos lo pone de una manera un poquito más fea.  Al final es lo mismo que si lo ponemos aquí. Lo que pasa es que aquí sí que nos devuelve como cada uno de los valores. Entonces, creamos un héroe. Entonces si le damos aquí nos va a salir Pedro y si le damos aquí a GetMyHero también nos viene Pedro 1 100 0. Con lo cual esto simplemente era un poco para facilitarlo. Al final si esta información... esto simplemente es la manera de representarlo. Cuando estéis vosotros haciendo un servidor o cuando estéis recogiendo esa información para hacer algo al final os da igual cómo aparezca porque lo vais a gestionar como vosotros queráis. ¿Qué más cosas podemos hacer? Ya parece que está bastante completo. Pero podemos hacer alguna otra cosa. Como he dicho en otros vídeos, no me gusta repetir código y si puedo evitarlo, pues lo evito. Así que, ¿qué código tenemos aquí repetido? Alguno que veáis. Pues yo veo uno claramente, que es el require de que no tengas un héroe. Esto cada vez que hacemos alguna acción que necesitamos un héroe, en este caso, es muy simple, solo tenemos luchar y entrenar, tenemos aquí este require. Entonces, esto lo podríamos sacar a una función que nos haga ese require. Pero hay una funcionalidad de Solidity que está muy bien y que nos sirve precisamente para esto, que son los modifiers. Los modifiers son como los decoradores que hay en otros lenguajes. Es algo que hace que se ejecute código antes o después de la ejecución de una función. Normalmente para lo que se utilizan es para hacer este tipo de comprobaciones. Son comprobaciones que se hacen a menudo. Ahora mismo solo tenemos luchar y entrenar, pero imaginad que tenemos 10 funcionalidades distintas que puede hacer un héroe y en todas tenemos que hacer ese rewire. Utilizando este modifier, este decorador, de una manera muy sencilla lo podríamos tener. Vamos a crearlo aquí, debajo del mapping, antes de las funciones. Hacemos un modifier. Lo vamos a llamar hashHero, es decir, que tiene un héroe. A los modifiers se le puede pasar un parámetro o se le puede omitir. En este caso lo vamos a omitir porque no lo necesitamos. ¿Qué le vamos a poner aquí? El require que hemos dicho de compruebe que tiene un héroe. Y luego lo que vamos a poner es barra baja, punto y coma. Y esto es un poco raro, ¿qué es esto de barra baja? Pues como esto es un decorador, barra baja significa la función que estamos decorando. Entonces, este es el código que se ejecuta antes la función y luego sigue haciendo lo que sea que haga la función. En este caso vamos a ponerle ese decorador a estas funciones, la de luchar y la de entrenar. Entonces, los modifiers los ponemos al final, después de public, antes de que se cuerpo la función. HashHero. Y aquí también, HashHero. Y entonces ya podemos quitar esto. JoinHavaHero. JoinHavaHero. Vale. Vamos a comprobar que esto funciona. Desplegamos. Intento llamar a entrenar. Ah, no funciona. Yudan haba hiru. Eso es porque, como está funcionando en el sistema de Defier, ha intentado ejecutar esto y no ha funcionado. Muy bien, pues yo creo que con esto tenemos ya un... un juego muy sencillito pero bastante completo por hacer un repaso de las cosas nuevas que hemos visto en este vídeo. Hemos visto los structs, hemos visto cómo se crean, cómo se accenan sus propiedades, hemos visto los mappings, que hemos dicho son asociaciones clave-valor, como si fuese un diccionario. Una cosa que no he comentado pero que se puede hacer, es que se pueden encadenar distintos mappings. Yo puedo hacer un mapping cuya clave sea un número, por ejemplo. y cuyo valor sea otro mapping. Y este mapping sí que sea address y bool, por ejemplo. Y esto es algo que está permitido, podéis asociar tantos como queráis. Y esto es muy útil. Los mappings son una de las estructuras de datos más importantes que hay en Solidity. Por ejemplo, para representar los balances de un token, es un mapping la dirección. que queremos saber el balance y uno en 256. Y entonces esto lo que es es el usuario tal tiene tantos tokens. Así es como se representan. Así que no dejéis de mirar el tema de los mappings que es importante. ¿Qué más hemos visto aquí? Bueno, hemos repasado el tema de las funciones, la visibilidad, por ejemplo esta función que es privada. Hemos repasado también el tema de de si es una función de tipo view o si es de transacción. Y cosas no más que hemos visto. Pues hemos visto también lo de modifiers, como hemos visto, que son los decoradores. También hemos visto el tema de los requires, que también es muy importante, sobre todo en cuestiones de seguridad, porque habrá funciones que no las puede ejecutar cualquiera. Por ejemplo, si yo quiero hacer una transferencia de tokens, tenemos que comprobar que el dueño de los tokens es el que está llamando la transacción. Si no, cualquiera podría transferir tokens ajenos. Bueno, eso es todo por hoy. Gracias por ver el video. Nos vemos en el próximo. Así que esta parte también es bastante importante. Y vale, pues por ahora ya está y ahora vamos a pasar a hacer más contratos y ver más funcionales de Solidity.