Primero vamos a entrar en doc.soliditylang.org que contiene información del lenguaje Solidity. Como veis, según entramos nos lleva a la última versión que es la 0.8.17 en el momento de grabar este vídeo. Esta documentación contiene todo lo que necesitáis para saber cómo funciona el lenguaje, qué tipos de datos hay, sus operadores, etc. Os recomiendo que, dado que en este curso solo vamos a hacer una pequeña introducción, si queréis profundizar en ello, exploréis la documentación que está muy bien redactada. La siguiente página que creo que es muy interesante también de cara a a ver las cosas de modo más práctico, no tan teórico, es Solidity by Example. En esta web lo que encontraremos serán un montón de ejemplos de Solidity utilizando aspectos concretos, como por ejemplo en este se centrará en variables, o en constantes, o en structs, o... Al principio son cosas muy básicas, pero si vais haciendo scroll, encontraréis cosas cada vez más avanzadas. Bueno, pues sin más, vamos a pasar a desarrollar nuestros propios smart contracts. Vamos a entrar en Remix. Remix, para quien no lo conozca, es un entorno de desarrollo de Solidity que nos permite directamente desarrollar, compilar, incluso desplegar tanto en redes virtuales como en redes de prueba o incluso en mainnet. Pero bueno, por ahora vamos a hacer cosas muy sencillitas simplemente dentro del navegador sin hacer ningún despliegue real. Esta es la home, como veis aquí tenemos distintos apartados. Este es el del file explorer, aquí es donde desarrollaremos nuestros contratos y demás. Si hacéis clic aquí en la carpeta de contracts, como veis tendremos ya una serie de contratos de ejemplo que nos ofrece Remix. Ahora los veremos en más detalle. Si nos vamos aquí a este símbolo, Solidity Compiler, desde aquí podremos compilar los distintos smart contracts que ya hayamos desarrollado aquí. En este caso podríamos, si le damos aquí, compilar automáticamente el smart contract storage que hemos abierto. Luego lo veremos también en más detalle y luego en este último panel es el de despliegue y realizar transacciones. Aquí podemos seleccionar cuál es el entorno en el que vamos a hacer el despliegue. Los que pone vm son en máquinas virtuales, esto sucederá solo a nivel de este navegador, pero podemos utilizar otros providers como por ejemplo aquí veis hardhat, ganache, una wallet, etc. para poder desplegar e interactuar con estos smart contracts en otras redes. Entonces... Este Smart Contract se llama Storage.sol SOL es la extensión del lenguaje Solidity, cada vez que hagáis un smart contract, mi recomendación es utilizar el mismo nombre que utilizáis para el contrato. Lo primero que vemos aquí es la licencia, realmente este no es un campo necesario pero es recomendable y si no lo utilizáis, si no lo indicáis en el contrato, el compilador de Solidity os va a lanzar un warning, en este caso está utilizando GPL3. Luego lo siguiente que se pone es la versión de Solidity a la que apunta este smart contract, es decir, con qué versión de Solidity se va a poder compilar este contrato. En este caso está utilizando una versión, es compatible con las versiones por lo menos la y menor que la Entonces se pone pragma Solidity y a continuación la versión. Luego veremos otras maneras de referirnos a una versión específica u otras maneras de hacerlo. uint256, 256 significa que es un entero, un ínteger, u es unsigned, es decir no tiene signos o todos serían números positivos y de 256 bits. Entonces esta es una propiedad del contrato. Luego aquí tenemos dos funciones, una función que es store, que lo que hace es que va a guardar un nuevo, va a actualizar digamos esta propiedad number pasándole un parámetro num. Aquí lo que haces es, function, nombre de la función, el parámetro que recibe, indicando primero el tipo y luego el nombre del parámetro, y luego un modificador de la función, indicando cuál es su visibilidad. En este caso es public, con lo cual esta función es accesible por cualquiera, incluso desde el propio contrato, desde contratos externos, etc. Y luego el cuerpo de la función, simplemente lo que está haciendo es una asignación. La variable number, que es esta propiedad que hemos dicho aquí. igual a num, que es el parámetro que está recibiendo. Esta es una función que está modificando el estado del smart contract, entonces esto requeriría una transacción que modifique el estado y por tanto requiere un coste de gas. Luego tenemos aquí esta otra función que se llama retrieve. Esta función como veis no recibe ningún parámetro, también es pública, pero es view. View significa que es una función que no modifica el estado de la blockchain, no modifica el estado del smart contract. Por lo tanto no es necesario realizar una transacción para ejecutarla. Esto desde consola, por ejemplo, se podría hacer, se podría acceder a esta función y se realizaría automáticamente sin necesidad de ninguna función. Esto lo que nos hace es nos devuelve... Aquí dice returns con lo cual nos devuelve, entre paréntesis nos dice el tipo que tiene que devolver y luego el cuerpo de la función. En este caso nos devuelve la propiedad number. Como veis este smart contract es muy sencillito, simplemente modifica y permite visualizar una propiedad. Vamos a crear una carpeta dentro de contracts, la llamaremos mba. Y dentro de esta carpeta vamos a crear un nuevo fichero que lo vamos a llamar simplecontract.sol Lo primero como hemos visto antes es establecer la licencia. Vamos a copiar esta de aquí por ejemplo. Y hay múltiples tipos de licencia, como podéis ver en la documentación de Solidity. Podéis poner unlicense si queréis, pero bueno, vamos a poner en este caso mid, que es una también muy conocida y muy recomendada por la documentación. El siguiente paso es establecer la versión. Para ello, como hemos visto antes, utilizamos la palabra en clave pragma, solidity que es el lenguaje. Entonces, en el smart contract de ejemplo de storage que hemos visto antes, decía que la versión tenía que ser superior a una e inferior a otra. Nosotros lo que vamos a hacer es ponerle acento de circunflejo 0.1. 0.8.17. Esto significa que el compilador que vamos a permitir que compile este smart contract tiene que ser 0.8.17 o superior pero inferior al 0.9. Ahora ya lo siguiente es crear el contrato. Utilizamos la palabra contract, utilizamos el nombre del contrato que hemos dicho que va a ser simplecontract, abrimos la llave, Y ya está. Con esto ya tendríamos la primera parte de nuestro contrato. De la misma manera que antes hemos visto, vamos a crear aquí una variable que va a ser una propiedad que va a ser un 256, la vamos a llamar number. Solo que si hacemos esto, la visibilidad de este parámetro no está indicada, así que lo que vamos a hacer es que sea pública. Además de números también podemos utilizar otros tipos de datos, por ejemplo vamos a utilizar adres, que esto es una dirección de ethereum, 0x, etc. También la vamos a declarar como pública y la vamos a llamar myadres. Luego vamos a utilizar un constructor. Los smart contracts pueden tener o no tener constructor, en este caso sí que lo vamos a crear. ¿Para qué sirve un constructor? Pues para inicializar una serie de datos o realizar una serie de operaciones en el momento de creación del smart contract. En este caso simplemente ponemos constructor, abrimos paréntesis, le pasamos una serie de parámetros, puede que reciba parámetros o puede que no. Por ejemplo, si no queremos que reciba parámetros podríamos decir así, number igual a 42. Entonces cuando creásemos el smart contract automáticamente la propiedad number ya tendría el valor 42. O podemos establecer nosotros el parámetro, lo ponemos aquí, win256. barra baja number y entonces aquí number igual a barra baja number. ¿Por qué lo pongo con barra baja? Esto es algo que se suele hacer que los parámetros vayan precedidos por una barra baja para poder diferenciarlos fácilmente en el cuerpo de una función del resto de cosas que sean propiedades o sean variables temporales. Además también nos permite, en casos como aquí que estamos utilizando, variables que representan lo mismo, este parámetro va a ser el valor de number, pues entonces ya sabemos que si tiene barra baja es el que le estamos estableciendo desde cero. Aquí vemos que nos ha salido una alerta. Esto nos está diciendo que el compilador al que estamos apuntando, el que estamos pidiendo aquí, que es por lo menos un 0817, no se corresponde con el compilador que está definido actualmente. Entonces nos podemos ir aquí a la pestaña de compilador. y aquí como veis está preseleccionado el 0.8.7. Sacamos el desplegable y nos vamos al que nosotros queramos, en este caso el 0.8.17 que como hemos comentado es el último. Muy bien, pues ya tenemos un Smart Contract muy simple ya creado. De manera que tenemos aquí estos botoncitos que nos permiten directamente copiar el ABI y copiar el bytecode. El bytecode es el código compilado del smart contract y el ABI es la interfaz, es decir, contiene todos los elementos del smart contract. El ABI nos dice que hay una propiedad pública que es un Win256 que es el number, que hay una propiedad pública que es de tipo address que es myAddress, que el constructor recibe tal parámetros y también contiene las signatures de todas las funciones. que haya pues nos dice que funciones hay, que reciben, que devuelven, etcétera, pero no contienen funcionalidad alguna, simplemente nos dice de qué manera se puede interactuar con este smart contract, mientras que el bytecode como digo es todo el código del smart contract compilado, necesitamos de ambas cosas para poder desplegar el smart contract, pero luego para poder interactuar con el smart contract necesitamos el ABI que es la interfaz y en qué dirección se ha desplegado. Una vez que ya lo tenemos compilado y funciona correctamente vamos a ir a hacer el despliegue. Tenemos aquí el smart contract y aquí lo podríamos desplegar, pero nos pide aquí todos los parámetros que tengamos en el constructor. Actualmente sólo tenemos el number. Si ponemos aquí a 36 por poner un ejemplo, esto realmente lo único que hace es despliegarlo y se ve un poco más en detalle. Así también nos serviría. y le daríamos a desplegar. De acuerdo, pues entonces aquí nos sale un tick de que ha ido todo bien, se ha desplegado, aquí vemos la información. En resumen, esto nos ha desplegado un nuevo smart contract que nos viene aquí, han deployed smart contracts, y entonces nos indica también en qué adres se ha desplegado este contrato. Y entonces aquí tenemos dos botoncitos que se corresponden con las funciones con las que podemos interactuar, que son estas dos que hemos dicho, number y myAddress. Entonces le damos a myAddress, nos dice que nos devuelve un 0x000000 porque no hemos establecido ningún valor para esta propiedad. entonces es el valor por defecto que es todo ceros. El number, ¿cuál será? Pues el que le hayamos indicado como parámetro en el constructor, que nos va a devolver 36. Aquí está. Como veis esto pone que son calls. Cuando pone call es que realmente no está realizando ninguna transacción, a diferencia de lo que hemos hecho antes, que al desplegar el contrato, que aquí sí que ha habido una transacción. Esto como solo es una consulta de información, porque esto al final son, como he dicho antes, unas funciones de tipo view. no requieren de ninguna transacción. Muy bien, pues con esto ya tenemos un contrato muy sencillito y vamos a pasar a ampliarlo un poco. ¿Qué podemos hacer? Podemos añadirle un setter a esta función, a estas propiedades, a ambas. Lo recomendable tal como indica la documentación o como veréis en la mayoría de contratos es seguir un poco un orden de qué cosas se ponen en qué orden. Por ejemplo primero se ponen las propiedades del contrato, el constructor iría después y luego las funciones. Luego hay otra serie de cosas que ya lo veremos como los structs, los eventos, los modifiers, todo eso ya se verá en qué orden van. La idea es eso. En este caso, que solo tenemos propiedades constructor y ahora funciones, se hace en este orden. Vale, pues entonces como hemos visto, utilizamos la palabra function. Vamos a poner el nombre de la función, setNumber en este caso. Los parámetros que va a recibir, que va a ser un win256 barra baja number, como hemos dicho es una buena práctica que los parámetros empiecen siempre con barra baja. Vamos a poner public porque esta función va a ser pública, porque vamos a querer que podamos interactuar con ella desde fuera. Abrimos las llaves. No he puesto un return de nada porque esto no devuelve nada, solo vamos a modificar la función. Y vamos a hacer exactamente lo mismo que estamos haciendo aquí. Podemos copiarlo y pegarlo, para facilitar un poco. Muy bien, entonces al final esto simplemente es un set, solo estamos modificando este valor y podemos hacer lo mismo para el address. Vamos a ponerlo setMyAddress, aquí el parámetro que recibe es de tipo address y lo vamos a llamar barra baja MyAddress. Realmente el nombre del parámetro, como digo, esto es simplemente una manera de hacerlo, pero aquí podríamos llamarlo ADDR si queremos. Como he dicho, aquí empiece con por barra baja mejor. Pero bueno, myAddress, también de tipo público. Y aquí lo mismo, pues myAddress pasa a ser... lo que haya almacenado en barra baja mayores. Punto y coma. Esta diferencia de otros lenguajes como Python, siempre todas las sentencias deben acabar en punto y comas, como Javascript, solo que Javascript es menos estricto. Vale, entonces hemos añadido estas nuevas funciones, así lo que vamos a hacer es nos vamos de nuevo al compilador de Solidity, compilamos de nuevo y ya nos vamos a la pestaña de despliegue. Entonces este smart contract que teníamos previamente lo vamos a desechar, y vamos a desplegar de nuevo. Esta vez vamos a ponerle un 12 por ejemplo para que sea distinto y deploy. Entonces ya se nos ha desplegado aquí el smart contract. Como veis antes teníamos sólo estos dos botoncitos de number y my address y ahora tenemos otros dos en naranja que son las funciones. Esta sí que implica transacciones y como veis esta recibe parámetros diferencias de las otras. Entonces si comprobamos el number va a ser 12, myAddress va a seguir siendo 0000 y vamos a establecer un nuevo número, por ejemplo 17. Y ahora como veis sí que ha enviado una transacción del mismo modo que cuando se desplegó el smart contract. Y aquí podréis de nuevo consultar la información de la transacción, el hash de la transacción, desde qué adresa ha ido, a qué dirección ha ido, que en este caso es a la dirección del smart contract, que es esta de aquí. y el gas que he consumido, etc. Entonces, una vez que hemos cambiado el número, esta transacción ha ido correctamente, si volvemos a consultar el número, ha cambiado y pone aquí 17. Muy bien, ahora también podemos cambiar el adres, pues vamos a coger... podríamos coger, por ejemplo, el propio adres del smart contract. Remix nos permite muchas veces, cada vez que hay un address o un hash, nos pone el botoncito de copiar para facilitarlo todo. Entonces ya lo hemos copiado y lo vamos a pegar aquí. Y entonces vamos a darle al botoncito y esto nos ha hecho una transacción. Entonces ya ha cambiado el address de la variable myAddress. Entonces cuando le damos aquí... ha cambiado,  ahora es esta nueva información. Esto está pidiendo un adres, entonces no podríamos poner otra cosa, no podemos poner aquí el string hola. Si lo hacemos... va a fallar, como veis aquí dice la transacción a esta función ha fallado y entonces nos dice que es un invalid address, se esperaba un argumento de tipo address pero el valor es hola, entonces no es válido, como no es válido pues no se ha podido realizar y si vamos a myAddress nos sigue devolviendo el valor que habíamos dicho inicialmente. vale pues vamos a seguir aumentando nuestro smart contract para ir metiéndole más funcionalidad Vamos a añadir una función que sea de tipo View. Como lo que hemos visto antes que era simplemente un getter, pues aquí vamos a ponerle un poco más de funcionalidad. Vamos a crear una función que se llama IsThisNumberLarger. Vamos a pasarle un parámetro que va a ser number. Va a ser una función de tipo público. Va a ser tipo View porque no va a modificar el estado del smart country. y además nos va a devolver una variable, un valor de tipo booleano. Entonces, ¿qué va a hacer esto? Nos va a decir que si nuestra propiedad number, esta de aquí, es mayor que... bueno, más bien la contracción, la hemos llamado IsThisNumberLarger, que el parámetro que le hemos pasado es mayor que la propiedad number. Entonces, ¿qué va a hacer? Nos va a decir que si nuestra propiedad number es menor que la propiedad number, entonces, ¿qué va a hacer? Nos va a decir que si nuestra propiedad number es mayor que la propiedad number, entonces, ¿qué va a hacer? Nos va a decir que si nuestra propiedad number es menor que la propiedad number, entonces, ¿qué va a hacer? Nos va a decir que si nuestra propiedad number es menor que la propiedad number, entonces, ¿qué va a hacer? Y además también vamos a explorar otro tipo de funciones. Hemos hablado de las funciones que son de tipo View y ahora vamos a hablar de las que son de tipo Pure. Vamos a crear una función zoom. Repasamos dos parámetros. Vamos a llamarlo number1. y otro que sea number2. También va a ser tipo público. El lugar de view va a ser view y lo que nos devuelve es un O en 200 segundos. Y entonces esto nos devuelve simplemente la suma de number1 más number2. ¿Por qué es de tipo pure y no view? Porque las funciones de tipo view no modifican el estado del smart contract pero sí que leen el estado del mismo, es decir, aquí nosotros estamos accediendo a la propiedad number entonces tenemos que leer ese smart contract mientras que aquí esta función de suma, le estamos pasando dos parámetros y nos está volviendo la suma de ellos no da igual lo que contenga el smart contract, da igual los datos que tenga porque no los vamos a consultar Entonces, esta función... ¡Uy! Perdón, esto no lo he puesto correctamente. Esta función... al no leer el estado del SmartControl se puede poner este tipo más restrictivo que además ahorrar a gas en el Solidity es muy importante hacer las cosas de la manera más barata posible porque luego esto supone realmente un ahorro de dinero de verdad cuando está desplegado en redes públicas especialmente si es Mainnet que es bastante caro entonces es muy importante intentar ahorrar el máximo posible Muy bien, pues vamos a ir de nuevo aquí a la compilación. Como tenemos en auto compile, esto no sería necesario, pero bueno, simplemente por comprobarlo. Y vamos a desechar el Smart Contract que teníamos desplegado, o la serie de Smart Contract que tuvimos desplegado, y entonces vamos a desplegar este nuevo. Vamos a poner aquí un parámetro que va a ser 10, por ejemplo. Desplegamos. Ya lo tenemos aquí desplegado. Aquí tenemos lo mismo de antes, el MyAddress es 0, el Number es 10 que solo hemos puesto, todo eso es lo mismo de antes. Vamos a probar las cosas nuevas que son IsThisNumberLarger y Sum. Como es 10, si yo le pongo aquí un valor 8, este me va a devolver false. Si le pongo un valor 13, nos va a devolver true. bull es otro tipo de dato igual que hemos visto ya los windows 156 los adres pues esto es un valor booleano que sólo puede tomar los valores true o false. Ahora vamos a probar el de suma aquí sí que tenemos como son varios parámetros los suyos que hagamos aquí el despliegue entonces aquí podemos poner los parámetros de cada uno de ellos, vamos a poner 5 más 3, hacemos el call y nos devuelve 8. De nuevo, los que tengan el cuadradito azul significa que no modifican el estado, son calls, entonces no hay que demandar transacciones, mientras que estos sí hay que mandar transacciones. Entonces ya hemos visto varias cosas, hemos visto las propiedades, hemos visto la visibilidad pública, pero todavía no hemos visto ninguna de privada, así que más adelante vamos a verlo. Hemos visto los modificadores de View, de Pure, así que ahora vamos a ver una cosa nueva que son los eventos. Los eventos es algo muy importante en Solidity, es bastante interesante. Los eventos son... son sucesos que nosotros marcamos o se emiten en el smart contract en algún momento de su funcionalidad para que puedan ser leídos off-chain, es decir, desde fuera de la blockchain, por ejemplo, aplicaciones o servicios que estén escuchando la blockchain y estén atentos de que suceda algo. Por ejemplo, cuando se hace una transferencia de un RC20 se emite un evento transfer. Entonces eso lo que se hace es para que se esté escuchando y cuando se detecte que se ha producido una transferencia pues se realice alguna acción en un backend, en un servidor, etc. Esos eventos son para hacerlo desde fuera, no es algo que desde un smart contract puedas detectar que se ha producido un evento en otro smart contract, es desde fuera. Los eventos los pondríamos debajo de las propiedades y antes que el constructor. este va a ser un evento que se va a disparar cuando se modifique la propiedad number entonces pues aquí se le va a pasar una serie de parámetros, ¿cuál vamos a pasar nosotros? pues el oldNumber y otro parámetro que es el newNumber acabando en punti y coma como siempre. Entonces, ¿de qué nos va a servir esto? Pues que cada vez que se cambie el número, nosotros vamos, si estamos escuchando los eventos de la smart contract, vamos a saber cuándo alguien ha cambiado ese número. Entonces podremos ver de qué número ha cambiado a qué número. Entonces eso lo podemos hacer, por ejemplo, aquí, cuando hacemos aquí el setNumber. Entonces aquí utilizamos la palabra emit, que es para emitir el evento, el nombre del evento que es newNumberSet y entonces los parámetros que recibe. ¿Cuál va a ser el viejo número? Pues aquí lo que actualmente es numbers. ¿Cuál va a ser el nuevo? El que estamos pasando por parámetro. Numbers con barra baja. Muy bien. desechamos el smart contract anterior, desplegamos de nuevo, lo tenemos aquí y entonces como vemos vale 5 y ahora vamos a ponerle valor de 8 por ejemplo. Set number, llevamos a la función y entonces aquí se ha enviado una transacción y la consola de Remix nos va a permitir comprobar el evento que se ha emitido. Aquí dentro de logs. observamos que aquí hay una propiedad que pone event y entonces nos dice el número del evento que es newNumberSet y aquí los argumentos. Aquí los argumentos del evento nos lo pone de dos maneras distintas o bien por el orden que es 0 y 1 o bien por el nombre de la propiedad que es oldNumber y newNumber que en este caso como vemos ha pasado de 5 a 8. Esto es una manera bastante útil de poder observar los cambios que se han producido en el smart contract desde fuera. Otra cosa interesante de Remix que no lo he comentado, además de desplegar aquí, podemos cargar un smart contract que ya se haya desplegado previamente. Entonces nosotros, por ejemplo, tenemos este smart contract aquí. Entonces si copiamos su dirección, lo descartamos y pegamos aquí la dirección y le damos aquí, nos va a sacar el smart contract que ya hemos desplegado previamente. Esto, igual en este entorno de una máquina virtual no tiene mucho sentido, pero si estamos utilizando un provider distinto, por ejemplo, estamos en una red de pruebas en Rinkeby, por ejemplo, entonces si queremos interactuar con un smart contract que ya existe, que ya hemos desplegado en otra sesión previamente, pues simplemente podemos copiar su adres y darle al botón. Entonces, como vemos aquí ya está, si le damos al number, está 8, que es el valor que le habíamos puesto anteriormente. Con esto ya hemos visto los eventos, pero podemos decir que también queremos emitir este evento en el constructor, porque en el constructor también estamos cambiando el número de 0, que es el valor inicial, al parámetro que le estamos pasando. Podríamos copiar esto aquí. y entonces estamos emitiendo el evento y cambiando el número tanto en el constructor como en esta función. Pero entonces aquí lo que estamos haciendo es una cosa que a mí personalmente no me gusta y es repetir código. Yo todo lo que se puede hacer para evitar repetir el código, mejor, porque eso facilita la elegibilidad, facilita el mantenimiento, porque si tienes el mismo código repetido en varias funciones y luego por lo que sea lo cambias en una, pero luego no lo cambias en otra te encuentras con que tienes unos comportamientos inconsistentes. Cada vez que se esté repitiendo código, en este caso es muy sencillito, son solo dos líneas de código, pero en otros casos nos vamos a encontrar que sea más complejo. Entonces, ¿qué vamos a hacer? Vamos a extraer esta funcionalidad de emitir el evento y cambiar el valor de esa propiedad a otra función externa. Entonces, vamos a crear una función. y esta función va a ser de tipo privado. ¿Qué implica eso? Que no vamos a poder interactuar con ella desde fuera. Es decir, ¿veis aquí todas las funciones a las que podemos acceder? Pues esta función que vamos a crear no va a estar aquí, porque esta función al ser de tipo privado sólo se va a poder acceder desde el propio Smart Contract. Entonces, ¿para qué se utiliza este tipo de funciones? Por ejemplo, para esto que hemos hecho, cuando internamente el smart contract tiene que realizar algunas acciones que solo van a ser llamadas desde el propio smart contract, que no queremos que se llamen desde fuera. Muchas veces también las funciones privadas se ponen con un underscore, con una barra baja delante del nombre de la función. Para lo mismo, de una manera rápida poder visualizar que esta función es una función privada, es algo interno del smart contract. Entonces vamos a hacer lo mismo. Barra baja es el number. Y esto va a hacer exactamente esto, va a recibir el parámetro number, solo que en lugar de public va a ser private. Y va a hacer exactamente lo mismo que hemos dicho aquí, pues va a emitir el evento. y va a cambiar la propiedad. Y entonces, donde estamos aquí haciendo estas acciones, pues vamos a llamar a esta función privada. SetNumber, Number, punto y coma. Entonces el smart contract se ha compilado correctamente, desechamos este, desplegamos de nuevo, poniéndole un 5, por ejemplo. Entonces cuando vengamos aquí y veamos la transacción, esta de nuevo es la transacción que ha desplegado el smart contract, vemos aquí que se ha llamado al evento pasando de 0 a 5. Y si lo cambiásemos a 12, por ejemplo, nos va a generar una nueva transacción que va a su vez a lanzar otro evento de 5 a 12. Con esto hemos aprovechado para ver cómo funcionan las funciones privadas y además cómo evitar repetir código y tener un código más reusable.