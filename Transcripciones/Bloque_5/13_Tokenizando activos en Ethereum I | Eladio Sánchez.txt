Speaker 0 | 00:13.622
En este vídeo vamos a crear un proyecto en el que vamos a desarrollar un smart contract de un NFT para posteriormente desplegarlo en una red de pruebas. Para ello vamos a empezar creándonos una carpeta, en este caso yo la he llamado mbAnft, y esta va a ser la base de nuestro proyecto. Como se han visto en otros vídeos, uno de los entornos de desarrollo posibles es Truffle, pero para cambiar y ver otras opciones, vamos a hacerlo en Hardhat. Si nos venimos a la web de Hardhat, buscamos Hardhat en Google, la primera opción que nos sale es la de este entorno de programación. Vamos a Get Started y aquí tenemos una documentación completa sobre cómo funciona y cómo utilizarlo. Es necesario tener instalado Node para poder utilizar esto. No vamos a entrar en detalles de cómo se instala Node, pero sí que vamos a ver desde que ya tenemos el entorno cómo instalar hardhat y cómo empezar a utilizarlo. Para ello primero tenemos que instalarlo con npm install savedev-hardhat. Así que copiamos esto, nos abrimos aquí un terminal, desde aquí terminal, new terminal se puede abrir o con el atajo de teclado como yo lo he hecho, y copiamos aquí estas entradas. mientras que instala, que puede tardar un ratillo, podemos ir viendo qué más podemos hacer. Lo que primero vamos a hacer va a ser crear el contrato, vamos a hacer el contrato del NFT. Para eso, como hemos visto en otros vídeos, vamos a utilizar lo que ya nos ofrece OpenZeppelin. Así que vamos aquí a la web de OpenZeppelin, Contratos, y aquí buscamos el 721, que es el del NFT. Entonces aquí nos da cierta información de cómo lo podemos hacer y demás. Entonces nosotros vamos a coger un NFT que sea de tipo URI Storage. ¿Qué significa esto? Que cada NFT que emitemos va a tener una URI, es decir, una URL, un enlace al contenido. Si no utilizásemos de tipo URI Storage, si utilizásemos simplemente un 721, tendríamos una base URI, que sería una URL base, más luego el número de cada uno de los NFTs, pues barra 1, barra 2, etc. Nosotros lo que vamos a hacer es que sea URI Storage para que podamos decidir cada NFT cuál es su URI completo. A ver si ya se ha terminado de instalar... Bien. Una vez que ya esté instalado, como hemos dicho, npx hardhat o hardhatini, cualquiera de las opciones vale, nos sale este wizard, vamos a crear un proyecto de javascript. El root es en la carpeta en la que estamos ahora mismo. Si queremos añadir un git ignore, pues si luego queremos subir esto a un repositorio. Si queremos instalar las dependencias que nos vienen por defecto, en general vamos a darle que sí a todas las opciones que nos proponga, porque va a ser el ejemplo más básico de un proyecto hardhat. Mientras que se están instalando las dependencias vemos que ya nos ha generado aquí una estructura de carpetas. La que nos vamos a centrar ahora mismo es la de Contracts, con la cual nos viene ya aquí un contrato de ejemplo que podemos fijarnos en él para crear lo nuestro. Aquí en esta misma carpeta vamos a crear nuestro contrato. Vamos a llamar MVANFT, por ejemplo. Copiamos... copiamos la licencia y la versión de Solidity y aquí lo podemos cambiar. Podemos usar Meet, como hemos hecho otras veces, y apuntar la versión que hemos utilizado otras veces, la 0817, que en el momento de grabar este vídeo es la más reciente. Entonces, pues, como hemos hecho otras veces, Contract, nombre de contrato, NiveNFT. Y entonces, si nos fijamos en lo que queríamos hacer aquí, tenemos que importar los contratos de Open Zeppelin que vamos a utilizar. La cuestión es, por defecto, no tenemos instaladas las dependencias de Open Zeppelin. Entonces, para eso hay que acceder a ellas. Entonces, si venimos aquí al principio, nos dice cómo instalarlo. npm install arroba openzeppelin barra contracts. Vale, pues copiamos esto. Y entonces con esto ya podremos acceder a los contratos de OpenCPL. Vale, entonces vamos a importar el RC721-URIStorage. Y entonces vamos a decir que este contrato MVINFT-IS, pues esto, RC721-URIStorage. Vale, pues una vez que tenemos esto tenemos que hacer el constructor. Aquí, como estamos viendo, utiliza un constructor en el que no recibe ningún parámetro y ya directamente le pone el nombre y el símbolo del token. Vamos a utilizar esto como base y luego lo modificamos como queramos. Por defecto sería así, pero igual nosotros queremos poder cambiarlo para cada contrato que despleguemos, establecerle el nombre y el símbolo.

Speaker 1 | 05:34.620
Para eso podemos hacer string memory name y string memory symbol.

Speaker 0 | 05:47.711
Entonces simplemente le pasamos estos parámetros.

Speaker 1 | 05:55.421
y el símbolo.

Speaker 0 | 06:01.748
En el constructor no es necesario poner nada más. Hay otras muchas modificaciones posibles, por ejemplo aquí está utilizando dice tema de access control, está utilizando counters, está haciendo una serie de cosas. Entonces... El tema del access control sí que nos interesa. Si recordáis otros vídeos había un smart contract de OpenCP Link, que era ownable, que ese sí que nos va a interesar para que seamos nosotros quienes... el owner del contrato sea el único que pueda mintear NFTs. Entonces, pues bueno, nos venimos aquí a access control y vemos aquí que se está importando el ownable, como hicimos en el otro vídeo. y entonces además de ser URI Storage lo vamos a poner como ownAugure. Así que en el momento de desplegar este smart contract, el adres que lo ha desplegado, pues ya sabemos que va a ser el loaner de este contrato. Muy bien, qué más cosas podemos hacer ahora mismo? Pues este contrato es muy básico, pero lo que queremos es que se pueda mintear NFT. Ahora mismo no se puede hacer, simplemente tenemos el NFT tal cual vacío. Vale, entonces, para ello vamos a hacer una función de minteo, que esto será muy similar a como hemos visto en... como se hacía con el RC20, que si os acordáis, porque estuvimos viendo el GitHub en los contratos, podemos ver realmente cómo está implementado. Vamos a Contratos, Token, 721. Entonces aquí tendrá una función.

Speaker 1 | 07:46.841
interna de Mint.

Speaker 0 | 07:50.223
Como esta función es interna, a no ser que pongamos una función pública, como hicimos con el RC20, no podremos tener acceso a ella, así que vamos a poner una función Mint que sea pública que llame a su vez a esta función interna. Vale, pues es lo que vamos a hacer. Creamos aquí una función Mint y los parámetros que recibe pues va a ser. el adres de a quien se le va a mintear este NFT. Y también, como hemos dicho, esto es un URI Storage, así que cada NFT va a tener un URI específico. Entonces ese URI también se lo vamos a especificar nosotros en esta función. Esta función va a ser external, porque esta sólo se va a llamar desde fuera del contrato. y va a tener el modificador only owner, es decir, solo el propietario de este contrato va a poder mintear. Si os habéis fijado, aquí en el mint lo que está recibiendo realmente es el address to y el token id. El token id lo que vamos a hacer es que va a ser autoincremental. Podríamos poner que cada vez que mintemos un NFT establezcamos nosotros un id, pero creo que tiene más sentido que el primer NFT sea el 1, el siguiente sea el 2, etc. Y el tema del token URI, aunque no aparece en esta función de minteo, es porque está en el smart contract de URI Storage, que a su vez sobreescribe la función mint del RCSID21. ¿Cómo vamos a hacer que los NFTs subsídios sean autoincrementales? Para eso podemos tener una propiedad que sea total supply. Entonces nos hacemos aquí un Win256.public. Total supply. De este modo también podemos consultar de una manera fácil y pública si está......cuántos NFT se han minteado ya. Entonces, lo primero que vamos a hacer en el mint es......vamos a incrementar el valor de total supply. Entonces, inicializamos el mint. inicialmente, como ya sabéis, se inicializa a 0, pues entonces nada más mintear ya decimos, vale, pues esto ya va a ser 1. Y entonces vamos a decir ahora, vamos a crear una variable que va a ser tokenId, y el tokenId va a valer lo mismo que lo que ahora vale totalSupply, es decir, el primero va a ser el 1, si ya hay 3, pues este nuevo va a ser el 4. Y ahora llamamos a la función de mint. que minteamos como hemos visto antes en el address to que le estamos aquí especificando, es decir, a quien se lo estamos minteando y cuál es el token id que vamos a establecer y el token id pues, bueno, es el que acabamos de crear. Y luego pues eso que hemos dicho, lo del URI storage, pues en el momento de mintear vamos a establecerle el URI de ese token. Pues esto tiene una función interna que es setTokenUri. Y entonces le decimos, este token id ahora va a tener este token ori. Lo mismo que hemos hecho con el Mint, que tiene una función interna, pero accedemos a ella a través de una función externa, pues también estamos haciendo esta otra. Si quisiéramos poder cambiar el URI de un token posteriormente, pues también podemos hacer una función pública, que sea setTokenUri, para cambiar el URI de cualquier token. Pero bueno, eso por ahora no lo vamos a hacer. Os recomiendo de todos modos echarle un ojo a los contratos de OpenCppLink, ver cómo funcionan internamente y ver qué cosas podéis modificar o cómo podéis un poco trastear con los contratos. Con esto ya tendríamos un contrato básico de NFT. Simplemente lo que estamos haciendo es desplegarlo y mintearlo. Como veis no he estado implementando ninguna función de transferencia ni nada porque eso como ya sabéis el propio smart contract lo hace, el propio smart contract de OpenCPL. Vale pues entonces ya se han instalado las dependencias, ya tenemos el contrato listo. Entonces ahora lo que vamos a hacer es compilar este contrato y comprobaremos si hay algún error con él. Para eso utilizamos npx hardhat compile. Nos ha dicho que se ha compilado con éxito. Entonces esto nos ha creado aquí una carpeta Artifacts, donde aquí vemos dentro de Contracts, pues vamos a tener cada uno de los contratos que tenemos. Está el log, que no le vamos a hacer caso, de hecho incluso lo podríamos borrar, y el que hemos creado nosotros, el mbanft.sol. Y entonces aquí esto nos genera un JSON que será similar a lo que vimos en Remix. Aquí tenemos por un lado el ABI y más abajo tendremos el bytecode, que esto es el código compilado, como veis esto es enorme. Y ya está. Bueno, esto tampoco es muy necesario saberlo, pero bueno, que sepáis que dentro de Artifacts tenéis la información de los contratos que se han compilado. Lo suyo aquí sería que ahora creásemos una serie de tests. Por ejemplo, aquí tenemos un test de ejemplo para el LOCKS, donde aquí se intenta acceder a las distintas funcionalidades, intenta comprobar que los smart contracts que has desplegado hacen exactamente lo que tú quieres, etc. Pues aquí, ¿qué tipo de test podríamos hacer? Podríamos comprobar que si una cuenta que no sea la owner del contrato, pues no puede mintear. o que no puedo transferir un NFT que no me corresponde. Pues todo ese tipo de test se harían aquí. Se crearía un fichero, en este caso mbnft.javascript. Y entonces ahí se testearía. Entonces eso sería lo que para lanzarlo sería npx hardhat test. y entonces aquí haría todos los tests que haya en la carpeta test. Entonces pues los tests que había del smart contract de log han pasado correctamente. Bueno, no nos vamos a poner a crear test que sino esto se puede alargar demasiado. Para desplegar los smart contracts, tenemos aquí un script, en la carpeta script es donde se van a poner todos los scripts que queremos realizar. Entonces en este caso como vemos hay un script que es deploy. Este script deploy es un script para el smart contract de ejemplo de log, cuando se lance este script va a desplegar automáticamente el smart contract de log y hará lo que sea que haga ese smart contract. Nosotros a continuación vamos a hacer un script de despliegue para el contrato de NFT, pero bueno vamos a lanzar por ejemplo el script de deploy que hay aquí, el de log, solo para ver cómo funciona antes de hacer el nuestro.

Speaker 1 | 14:29.549
apkisharhat.brand.scripts.barra.deploy

Speaker 0 | 14:39.898
Aquí nos dice que ha desplegado el smart contract de log, y lo ha desplegado en esta dirección. Y entonces os preguntaréis, ¿lo ha desplegado en qué red? Hardhat, como he dicho, es una herramienta que a mi me gusta mucho, es muy intuitiva y tiene un montón de funcionalidades. Cuando hacemos algún tipo de despliegue o similar, por defecto nos está creando una red temporal. solo en el proceso en el que dura el script, al lanzar el script crea la red con sus cuentas que ya tienen su ether y tal y luego al final de cuando finaliza el script separa esa red. También hay otras opciones para mantener la red abierta y entonces poder tener un poco de persistencia entre distintas ejecuciones y demás. Esto como primer acercamiento nos puede venir bien, simplemente estaríamos desplegando en la red y probando que funciona y luego ya posteriormente probaríamos a desplegar en otras redes, como puede ser GAN H, donde podemos ahí sí tener cierta persistencia, a ver qué es lo que está pasando, y posteriormente desplegar en TESLE.