Speaker 0 | 00:12.618
Una vez que hemos visto como se crean los scripts de despliegue en hardhat, vamos a crear nuestro propio script basándonos en este mismo. Para ello vamos a crear aquí un nuevo fichero, le vamos a llamar deployNFTContra.js Vamos a basarnos un poco en él, así que lo ponemos aquí a un ladito y nos vamos a ir fijando. Lo primero que hace aquí es que está importando hre desde hardhat. Hre dice que es el hardhat runtime environment. Y realmente lo único que lo está haciendo es para acceder a la propiedad ethers. Hay otra manera, en mi opinión, un poco más limpia de hacerlo, que es hacer const ethers igual a require hardhat. Esto no se supone una gran diferencia. Simplemente en lugar de traernos todo el objeto hre y acceder a ethers con esta nomenclatura, con las llaves, ya directamente obtenemos el objeto ethers. Luego aquí tenemos una función asíncrona main. Tiene que ser asíncrona porque casi todo lo que se hace relacionado con la blockchain se realiza de manera asíncrona. y luego aquí llama la función main, intenta hacer un cache si hubiese algún error, etc. Vamos a copiar esta misma fórmula y entonces ahora dentro del main tenemos que hacer lo que nosotros queramos. Aquí está inicializando una serie de variables, bueno, más inconstantes, de cara a hacer el despliegue, pero nosotros lo vamos a hacer de otra manera porque nosotros no necesitamos nada de esto. Si recordamos que tiene el constructor, pues el nombre y el símbolo. Vamos a instanciar esas constantes. Vamos a poner const name y lo vamos a llamar myNBANFT. Y el símbolo lo vamos a llamar MNFT. ¿Cómo hace aquí para desplegarle Smart Contract? Primero obtiene el Contract Factory, pasándole como parámetro el nombre del contrato que es log. Entonces una vez que tiene esto, simplemente con ese factory hace un deploy y ya le pasa los parámetros, etc. Si os fijáis aquí no está diciendo en ningún momento desde qué cuenta lo está haciendo. Si no especificas, va a coger por defecto la primera que esté disponible. Entonces hardhat como he dicho monta su propia red y pone una serie de cuentas disponibles con cierto ether y ya está. Nosotros vamos a ir un poco más allá. y vamos a especificar qué cuenta queremos. Para eso hay una función del objeto Ethers que es GetSigners. Entonces, vamos a crear una constante. GetSigners nos devuelve un array de las cuentas que pueden firmar transacciones, es decir, que están dentro de la red que tenemos su acceso a su clave privada y podríamos firmar con ellos. Entonces pues vamos a llamarle owner. Normalmente se les llama owner porque va a ser el dueño del contrato. Entonces hacemos await porque es una función asíncrona. ethers.getSigners. Vale, pues aquí podríamos tener varias, pero bueno, por el momento sólo estamos cogiendo owner. Como esto es un script y vamos a querer ir viendo qué es lo que está haciendo, vamos a ir poniendo consolelo. Y entonces aquí vamos a decir Deploying NFT with account y aquí vamos a poner el adres de la cuenta. Va a ser owner.addres Ahora vamos a coger el factory de la misma manera, const nft factory y entonces aquí vamos a hacer await de nuevo porque como ya he dicho casi todas las funciones son de tipo asíncrono así que hay que utilizar await. ethers.getContractFactory y el nombre del contrato que es NBA NFT. Entonces ahora vamos a inicializar el contrato. Vamos a desplegarlo. Entonces nft contract es await como siempre. Lo que vamos a hacer, si os fijáis aquí está haciendo el nombre del factory.deploy. En lugar de decir el deploy vamos a hacer.connect, que ahora mismo no es necesario porque si solo estamos utilizando una cuenta nos da igual, pero cuando estemos con varias el connect es para indicarle con que cuenta vamos a hacer la acción, en este caso la acción de despliegue. Hacemos conect a un ERG, como digo esto no es necesario pero creo que es una buena práctica para que se vea claramente quien está haciendo que. y aquí hay que pasarle los argumentos. ¿Qué argumentos tiene? Pues el nombre y el símbolo. name, symbol. Aquí se os fijáis está pasando un parámetro y luego entre llaves, estas son como las opciones de la transacción que estás enviando. En este caso tiene un value. Esto lo que significa es que está mandando Ether al smart contract. En nuestro caso nada de eso, simplemente los dos parámetros que queremos mandar, el nombre y el símbolo. Pues con esto ya se desplegaría. Pero además vamos a hacer un await. nftcontract.deploy() ¿Qué hace esto? Esto lo que dice, espérate hasta que este contrato se haya desplegado porque en estas redes que crea hardhat y tales se hace instantáneo pero por ejemplo en una red, una red mainnet o lo que sea puede tardar unos segundos 15, 30 segundos en desplegarse, depende de cómo de congestión esté la red entonces pues nosotros queremos esperar a que esté desplegada para estar seguros de que ya lo ha hecho todo Y entonces vamos a hacer aquí también unos cuantos console.log para decir... Vamos a decir nft deploy to... ¿A dónde se ha desplegado? Pues nftcontract.address. Como esto es un objeto contrato podemos hacer a su adres directamente. ¿Qué más? Pues podemos ver el hash de la transacción que lo ha desplegado. NFT... vale, bueno, ponemos aquí. Transaction hash NFT punto deployTransaction punto hash. Y entonces este nos viene el identificador de la transacción que lo ha hecho. ¿Qué más cosas podemos poner? Podemos consultar otra información del smart contract de NFT. Console.log, podemos poner el nombre y el símbolo. Vamos a llamar a NFTContract.name. Y esto es una función, así que lo ponemos con un solo paréntesis. Y podemos hacer lo mismo con el símbolo. Vale, pues yo creo que con esto tenemos ya suficiente. Y ahora podemos hacer un despliegue de este Smart Contract. Entonces... npx hardhat run igual que hemos hecho antes, solo que en lugar de scripts deploy.js que es el deploy de ejemplo pues vamos a hacerlo con el nuestro nftcontra.js Muy bien, pues entonces lo ha desplegado con esta cuenta, que es la cuenta por defecto, lo ha desplegado a este adres, este es el adres de nuestro NFT, este es el hash de la transacción y el nombre y el símbolo pues los ha puesto correctamente. Vale, pues ya tenemos, ya podemos desplegar. El problema es que, por lo que he dicho, la red solo se levanta en lo que dura el script, entonces, como es una red de desarrollo, pues no podemos interactuar con ella, no podemos ahora mismo... mintear nfts, es decir, podríamos mintearlos en este mismo script, pero creo que no es eso lo que queremos. Entonces vamos a ver cómo podemos hacer para desplegar en otras redes. Tenemos aquí un fichero que se llama hardhat-config.js, que esto contiene toda la configuración de hardhat. Ahora mismo no tiene prácticamente nada, como veis. Entonces lo único que dice es que la versión de Solidity es la 0.8.17, que es la que estamos usando. Si vais a la documentación vais a ver que aquí en el módulo de exports, además de la versión de Solidity, podéis poner un montón de cosas. Entre ellas, ¿qué es lo que nos interesa a nosotros ahora mismo? Networks. Aquí podemos decir las redes que vamos a poner. Así que vamos a crear una red que, por ejemplo, vamos a hacerlo con GANache. Entonces vamos a poner aquí GANache. y aquí tenemos que poner la URL del GAN H que vamos a hacer. Por hecho que habéis instalado ya GAN H, lo podéis hacer tanto en la versión de consola como en la versión con el GUI, con la interfaz visual. En este caso vamos a hacerlo con la interfaz visual para poder verlo de una manera más sencilla. Vamos a crear un nuevo workspace y aquí lo vamos a llamar... workspace mba.nft. Guardamos el workspace y ahora pues vamos a ver qué información hay aquí. ¿Qué es lo que necesitamos sí o sí para esto? Pues la url. Entonces la url de esto va a ser la que nos indique aquí, el rpc0. Lo copiamos y lo pegamos. El HTTP lo voy a poner en minúcula, pero eso ya es una cuestión de gustos. Entonces esto está accediendo al que es el local, al puerto 75.45, que es donde está ahora mismo esto. Y si veis aquí tenemos una serie de cuentas. con su ether y demás con la que vamos a poder directamente ya interactuar. Vemos aquí el líder de la red, etc. Y aquí vamos a poder ver las transacciones. Entonces hemos visto cómo se despliega aquí. Entonces si ahora fuésemos a desplegar no lo va a hacer directamente la red de ganache. Como vemos aquí no ha hecho nada. Si estamos haciendo una red que no sea la por defecto la desarrollo hay que especificarlo. Para eso se utiliza flag menos menos network. y el nombre de la red que le hayamos puesto en el hardhat.conf, en este caso ganache. Y entonces aquí como veis está utilizando una cuenta distinta y eso significa que algo diferente ha pasado. Entonces si ahora vamos a ganache, aquí vemos que hay una transacción. Aquí hay una transacción. comprobamos que su hash corresponde a e0ccc y e0ccc, es el mismo y esto ha creado un smart contract 0xe9df y aquí está 0xe9df vale pues ya tenemos nuestro smart contract de NFT en una red persistente de ganache entonces ahora mismo podríamos hacer nuestro otro script por ejemplo para mintear NFT vale pues Podemos hacerlo, vamos a crear aquí otro script, vamos a llamarle mint-nft.js, siempre estamos usando javascript. Vamos a copiar la estructura que hemos creado aquí, entonces aquí esto lo vamos a quitar y ahora vamos a decir, ¿qué queremos hacer? Pues lo primero que necesitamos, ¿qué información necesitamos? Pues primero, ¿cuál es la dirección del smart contract del NFT al que vamos a atacar? Así que vamos a hacer una constante NFT address. ¿Y cuál va a ser? Pues en este caso vamos a copiar la donde se ha desplegado. Entonces venimos aquí y lo pegamos. Cada vez que despleguemos un nuevo smart contract, tendremos que cambiar esta información. Si estamos utilizando una red distinta, en este smart contract no va a ser. Por ejemplo, si yo no le pusiera el "-network-ganache", cuando llame este script, no va a encontrar el smart contract en esta dirección. Porque esta dirección es el NFT de nuestro ganache que tenemos aquí. Este. No está en ninguna otra red. Entonces, como siempre, vamos a poner aquí un console log y vamos a decir, pues, venga, using NFT contract. Y entonces vamos a poner aquí en qué lugar está, NFT address. Ahora lo que queremos es... ya no queremos utilizar un factory porque ya no vamos a desplegar un contrato, vamos a coger uno que ya exista. Para eso, con el objeto Ethers también nos provee de funciones que nos permiten coger una instancia ya desplegada de un smart contract. Entonces vamos a coger aquí const NFTContract. es igual a await, de nuevo, como siempre, o casi siempre, fs.getContract, antes utilizamos esta, getContractFactory, aquí vamos a utilizar getContractAt, es decir, dame el contrato en un adres concreto. Entonces aquí nos dice el nombre, o el ABIC, vamos a usar el nombre, claro, que esto es, como lo habíamos llamado, mba.nft. Y el adres, pues el adres que hemos puesto. Y con esto ya tendríamos el... el objeto NFT. De hecho, si nos copiásemos esta información, el nombre, el símbolo, para comprobar que estamos haciendo justo lo que queremos, nos lo va a mostrar correctamente. ¿A qué función podemos llamar para mintear? Pues a la función de mint que hemos creado. ¿Qué parámetros recibe? Un adresTo y un tokenUri. Vale, pues entonces aquí vamos a... perdón, aquí en el Mint NFT. Vamos a hacer const mint tx, la transacción de minteo, va a ser await NFTContract.connect. Tenemos que conectarnos al quien va a realizar la transacción, que en este caso va a ser el owner, así que vamos a hacer lo mismo de antes. Cogemos el owner. owner es awaitEthers.getSigners. Entonces aquí tenemos el owner. Entonces nos conectamos al owner. De nuevo, esto no sería necesario si estamos utilizando el solo uno, pero esto sí que lo vamos a necesitar también para que, cuando hayamos la función de minteo, le tenemos que decir a quién lo vamos a mintear. Pues a nosotros mismos, a owner.address. Tened en cuenta que owner es un objeto de hardhat que es un signer, y es un signer que nos permite decirle a la persona que es el signer. Entonces, si no lo tenemos, nos vamos a decir que es el signer y nos vamos a decir que es el signer. Entonces, si no lo tenemos, nos vamos a decir que es el signer y nos vamos a decir que es el signer. Y si no lo tenemos, nos vamos a decir que es el signer. Entonces, si no lo tenemos, nos vamos a decir que es el signer. Y si no lo tenemos, nos vamos a decir que es el signer. Entonces, si no lo tenemos, nos vamos a decir que es el signer. Y si no lo tenemos, nos vamos a decir que es el signer. Entonces, si no lo tenemos, nos vamos a decir que es el signer. y no hay que confundirlo con su dirección. La dirección es una propiedad de ese objeto, es el address. Un slot objeto y address es el string que contiene, en este caso como habíamos visto, 0x378... Y entonces aquí habría que ponerle un URI. El URI puede ser lo que sea, podemos poner aquí testURI. Y luego vamos a entrar en await en int x. Esto es equivalente a que cuando estamos desplegando que hacemos un await deployed, pues aquí es await el objeto de la transacción.wait. Esto espera que la transacción se haya confirmado. Una vez que se ha confirmado podemos mostrar algunas cosas, por ejemplo, vamos a poner un consolero que nos diga aquí. Hemos minted NFT with ID y entonces aquí vamos a mostrar el ID de la transacción. Perdón, el ID de la transacción, no, el ID del NFT. Entonces, ¿cuál es el ID del NFT? Pues entonces será, si os acordáis, el total supply es el último... es cuántos NFTs hay. Entonces si el total supply es 1, el NFT de este que hemos minteado va a ser el 1. Entonces aquí hacemos await... bueno, de hecho vamos a guardarlo como una variable que parte. const NFTID es await, porque estamos interactuando con un contrato, NFTContract.totalSupply. Aquí no pongo el connect porque esto es un call, no estamos mandando una transacción, así que no lo hacemos desde ninguna cuenta, simplemente que nos dé ese valor. Entonces aquí decimos, vale, pues este es el NFT, el ID del NFT. ¿Qué más podemos sacar? Por ejemplo, podemos ver cuál es el URI. Entonces lo mismo, voy a copiar esta línea, consolelo, vamos a hacer aquí. Token URI. Y entonces aquí hacemos un await nftcontract.tokenURI. Esto lo podéis comprobar si queréis en OpenCPLIN. Pues tokenURI. Esto es una función pública que le indicas el token id y te devuelve el URI. En este caso el URI va a ser lo que le hemos puesto, que es testURI, que no sirve de nada. Normalmente esto tiene que ser una URL o un URI en un servidor o en IPFS o donde sea. En este caso es simplemente para comprobar que ha metido este campo de texto correctamente. Vale, pues entonces nftcontract.tokenURI especificándole el NFTID. ¿Qué más información podemos sacar? Podemos coger el owner. El owner de este NFT. Esto es una función que se llama ownerOf. Esto lo podéis ver, esto es parte del estándar. del RC721. Podéis comprobar todas sus funciones en la documentación oficial o como hemos visto antes aquí en los contratos de Open Zeppelin, OwnerOf. Voy a ampliar un poco el tamaño. Vale, ampliamos aquí un poquito para que se vea un poco mejor. Vale, pues entonces con esto estamos minteando un token, un NFT a esta cuenta con este URI. Vale, pues yo creo que con esto ya tenemos todo. ¿O necesitamos algo más? Bueno, yo creo que con esto ya podemos... Vale, también podemos ver, por ejemplo, el hash de la transacción. mintx.hash, como tenemos aquí el mintx, pues entonces esto va a ser... aquí no hace falta una wait porque es simplemente hacer una propiedad que ya está guardada dentro de esto. mintx.hash. Vale, pues entonces ahora vamos a llamar al script... scripts.mintnft.js en la red de ganache, porque como hemos dicho, este smart contract está en la red de ganache. Acabamos de mintear un NFT, tenemos aquí el hash de la transacción, el owner que es el que ha creado el contrato, el token URI, en efecto este es URI, el ID es 1. Y ahora si lo comprobamos mirando GANH, aquí tenemos la transacción nueva que se ha creado, el hash F710, coincide, F710. ¿Al contrato del NFT? Sí, coincide. Pues entonces ahora nuestro address ya tiene ese NFT. Con esto hemos conseguido despegar un FT y mantearlo en una red, que en este caso es la red de GAN H. A continuación vamos a ver cómo hacerlo en una red testnet, como por ejemplo en Mumbai, que es la red testnet de Polygon, de Matic.