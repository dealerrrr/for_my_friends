Speaker 0 | 00:13.398
En este vídeo vamos a hablar sobre la tokenización. La tokenización es el proceso por el cual convertimos activos físicos o digitales en tokens, que son activos digitales que se pueden transferir de forma segura y sin intermediarios en la red blockchain como en este caso es en Ethereum. Los tokens pueden seguir estándares como el ERC20 que ya hemos visto anteriormente, el ERC721 que es el token del estándar de los NFTs o pueden no seguir ningún estándar. En este caso vamos a hacer algunos ejemplos de distintos activos que se pueden tokenizar. Por ejemplo, vamos a hacer un caso en el que podamos tokenizar canciones. De este modo, las canciones que tokenicemos ya estarán en la blockchain, con lo cual podremos tener trazabilidad de que las han sido registradas, evitando así el posible plagio, incluso pudiendo transferir el token de esa canción para transferir los derechos que ello conlleva. Para ello vamos a crear un smart contract que llamaremos music token. Vamos a copiar la información de la licencia y vamos a modificar el número de versión del compilador de solidity como hemos hecho en otros vídeos. Este contrato lo vamos a llamar music token. ¿Cómo queremos que sea este contrato? Vale, pues lo que tiene sentido es que sea un token no fungible, un NFT, porque cada canción va a ser distinta de las demás y no pueden ser intercambiables, que eso es lo que diferencia los tokens de RC20 de los RC721. Vale, entonces, pues vamos a primero definir cómo es una canción. Vamos a crear un struct, le damos a MarkSong y aquí le podemos poner una serie de propiedades. Por ejemplo, le podemos poner un título. le podemos poner el artista, ambos los vamos a poner de tipo string, el año en el que se realizó la canción y luego un tipo bytes32 que esto es una ristra de 32 bytes, por ejemplo cuando se realiza un hash al final es lo que tenemos, un hash de una transacción o un hash de un fichero o lo que sea y entonces lo vamos a llamar simplemente hash. Este va a ser el hash del fichero de la canción. Los hashes tienen la propiedad de que con nada que cambie, aunque cambie un solo byte del contenido del fichero o del string que se esté haseando, el hash va a ser totalmente distinto. Con esto nos aseguramos que cada canción va a tener únicamente un hash y cada hash se va a corresponder únicamente a una canción. Vamos a hacer ahora un mapping en el que vamos a asociar el identificador de la canción, que va a ser un identificador numérico, con este struct de tipo canción. va a ser una variable pública, vamos a llamarla songs. Y además también queremos, como hemos dicho, los hashes no pueden repetirse y no puede haber dos canciones con el mismo hash, lo que vamos a hacer es una comprobación para ello utilizando un mapping que nos asocie el hash con el identificador de la canción. Y aquí lo vamos a llamar hashesToIbase. La clave de este emparejamiento será el hash y el valor será el identificador de la canción. Mientras que aquí la clave es el identificador y el valor es la canción en sí misma, el struct de canción. Queremos que este smart contract sea un NFT721. Entonces, igual que hicimos en vídeos anteriores con el RC20, vamos a importar desde OpenCPPLin el smart contract del RC721. Por ahí hacemos un import, arroba Open Zeppelin, barra contracts, barra token, barra rc721, barra rc721.sol. Esto os recomiendo que lo consultéis en la página web porque, como he dicho, hay un montón de contratos de Open Zeppelin. Entonces podéis ir mirando en el GitHub o mirando en la documentación dónde se encuentra cada uno y cuál es la ruta adecuada para importarlos. Entonces, este smart contract para que sea un Rc721, hacemos is Rc721. Vale, entonces con esto ya lo estaríamos transformando en un NFT. Entonces... ¿Qué es lo que nos dice? Vale, pues aquí nos salta un error porque en cuanto estamos implementando este smart contract, estamos haciendo un contrato que hereda del RC721, nos dice que necesitamos tener un constructor, un constructor que siga una estructura. constructor y aquí RC721 y aquí hay que pasarle cuál va a ser el nombre y el símbolo del smart contract del token, por ejemplo, lo podemos llamar music token. y el símbolo pues mvs por ejemplo. Y esto sería un constructor vacío, no necesitamos hacer nada más. Entonces aquí Remix ya no se queja, ya funciona todo correctamente. y entonces ya tendríamos una manera de tener un smart contract de tokens de música. ¿Qué sería lo siguiente? Pues sería la opción de mintear el NFT. Ahora mismo no podemos mintearlo, sólo tenemos el contrato pero no hay manera de mintearlo. Entonces vamos a crear una nueva función que se va a llamar createSong, en el que vamos a generar un nuevo struct y lo vamos a mintear el NFT asociado a esa canción. Podríamos hacer esto de múltiples maneras. Por ejemplo, podríamos hacer que el contrato sea A-1-Vol, es decir, que tenga un propietario y solo el propietario pueda crear las canciones. Pero esto vamos a visualizarlo como si fuese una plataforma abierta para que cada artista pudiese aquí registrar su música. Así que no vamos a añadir esa modificación y vamos a hacer que esta función va a ser pública y cualquiera puede utilizarla. Esta función requiere los parámetros para poblar la estructura de canción. Empezamos con un string memory. Si recordáis, cada vez que lo pasamos como parámetro le tenemos que poner memory. Aquí indicamos el título, el artista. Voy a copiar. String memory por facilitarlo. Artist, un 256 que va a ser year. Y por último el base32 que va a ser el hash. Esta función va a ser pública y no es una view porque esto sí que modifica el estado de la blockchain. Entonces, para que sea autoincremental, es decir, cada nuevo NFT que se genere, cada canción nueva tenga un identificador que vaya aumentando, tenemos que crear una propiedad que sea el total supply. No es necesario que se llame TotalSupply, podríamos llamarle Counter o SongNumber, etc. Normalmente TotalSupply creo que está claro para saber cuántos tokens hay, es un nombre bastante representativo. Así que vamos a aumentar inicialmente el TotalSupply cuando estamos creando una canción. La primera canción que creemos ya tendrá el identificador 1. Entonces, songs de total supply, que la primera será 1, igual a song. Y esto es igual que lo que hicimos en otros vídeos anteriores para crear un struct para meterle los datos. Simplemente los vamos metiendo de manera ordenada. Así. Entonces, pues aquí sería primero title, artist, year y el hash. Ya hemos creado la canción, la hemos metido dentro de Songs y ahora también lo que vamos a hacer es meterla dentro de HashesToIDs para que tengamos esta relación hecha. Ya hemos hecho esta pero nos faltaría esta de aquí. Así que hacemos HashesToIDs. Entonces tenemos que introducir como clave el hash. me estoy dando cuenta que me falta una barra baja. De el hash va a ser igual a el id de este token, que es total supply. Vale, entonces ya hemos creado una estructura song, la hemos metido dentro del mapping de songs, hemos guardado su... hemos linkeado su hash y su identificador aquí, y ahora nos quedaría mintear el NFT. Para mintearlo vamos a llamar a la función interna del rcsiteos1-mint y entonces aquí tenemos que indicar a qué usuario lo vamos a mintear, que lo vamos a hacer a message.sender, que esto ya lo hemos visto anteriormente, que es la dirección que está mandando esta transacción. Y vamos a indicar cuál es el identificador de este token, que como hemos dicho, pues ahora mismo es totalsupply. Con esto ya estaríamos creando la canción, minteando el token y dándoselo al que está enviando la transacción. Pero ahora lo que vamos a hacer además de esto es poner un require. Vamos a poner una restricción para que no se pueda registrar dos veces la misma canción y eso lo vamos a hacer teniendo en cuenta el hash. Para eso tenemos aquí nuestro mapping de hashes to IDs. Entonces, si el hash ya se hubiese registrado previamente, este hash se correspondía con un número que es mayor que 0 porque en la primera canción que se registre va a tener un identificador de 1. Entonces si se ha registrado sabemos que va a tener un identificador mayor que 1. Así que para ello vamos a hacer un require en el que vamos a comprobar que el id asociado a ese hash tiene que ser 0, lo que significa que la canción no se ha registrado. Así que hashIsToId de el hash que estamos enviando tiene que ser igual o igual a 0. De lo contrario, damos un mensaje de error que es song already exists. Muy bien, pues vamos a compilar. Tenemos un autocompiler, así que ya se habrá compilado. Así que ahora vamos a desplegar el token. Lo hemos desplegado, aquí vemos todas las funciones. Vamos a crear una canción. Para ello, el título lo vamos a llamar My Song, el artista va a ser Artist, el nombre del artista, el año 2022 y ahora el hash de la canción. Para eso, ¿cómo vamos a hacer? Pues tendremos que hashear el fichero en mp3 de la canción, mp3 o flag o el archivo que sea. Para esto lo podemos buscar simplemente online, hash file online. Y entonces aquí tendremos alguna web, por ejemplo esta de aquí, que nos permite hasear cualquier fichero que arrastremos con distintos algoritmos. Vamos a utilizar SHA-256, que es muy común. Entonces nos traemos aquí... vamos a coger mysha1.mp3, lo arrastramos y entonces este es el hash que nos genera. Así que lo vamos a poner aquí. Hay que poner 0x para indicar que es un BASE32, que es un string hexadecimal. Vale, entonces ahora realizaríamos la transacción. La transacción se ha realizado correctamente. Y entonces, pues podríamos ahora, si metemos este hash aquí en hashesToIDs, nos va a decir que este hash se corresponde al token 1. y entonces aquí si buscásemos la canción número 1 pues aquí nos dice el título, el artista, el año y el hash de modo que si por ejemplo alguien me robase la canción y fuese a comercializarla sin mi permiso yo podría demostrar, porque esto está en blockchain y lo que hay en blockchain es inmutable, que esta canción ya fue registrada incluso lo suyo sería que una vez que la registrasemos nos guardásemos el hash de la transacción y esto lo consultásemos a un explorador público y nos dijese, vale, esta transacción fue registrada en blockchain el día tal de tal de tal entonces sabemos que esto ya ha sido registrado, esta canción ya existía y ya fue registrada a mi nombre en blockchain tal día a tal hora evitando así que nos puedan plagiar o que nos puedan intentar comercializar cosas en nuestro nombre Con esto ya tendríamos una manera de demostrar que la canción es nuestra. Luego, si quisiéramos ceder los derechos de esa canción a otra persona, podríamos simplemente transferir este NFT a otra dirección. Simplemente haríamos un safe transfer from, etc., de qué dirección a qué dirección y cuál es el identificador. En este caso sería el número 1. ¿Qué más funcionalidad podríamos ponerle? Por ejemplo, podríamos poner un evento que cuando se cree la canción esto emite un evento, como hemos visto otras veces, y con esa información, de modo que sea más sencillo desde una aplicación externa poder ver cuando se están registrando canciones. Si yo tengo una canción y no sé a quién pertenece, ¿cómo lo podría hacer? Ahora mismo tendría que ir canción por canción comprobando cuál es el toker. En la canción número 1 vemos que el bytes es esto y le diríamos ¿quién es el owner de la canción 1? y aquí nos lo diría. Pero se me ocurre que podemos hacer otra funcionalidad muy sencilla para que directamente con el hash ya sepamos quién es el owner. Vamos a crear aquí una función que se llama getSongOwner que va a recibir un base32, que es el hash. Esta función va a ser public, va a ser view porque no modifica el estado, simplemente es para leer información y nos va a devolver un adres. Queremos que nos devuelva el ownerOf, que es una función pública que ya nos ofrece el Rc7OS1, de hecho la tenemos aquí. Y lo que vamos a hacer es transformar el hash en el ID y para eso utilizamos este mapping que tenemos. OwnerOf hashesToId de el hash que estamos pasando. Entonces... A ver qué error hay aquí... Ah, vale, sí. He escrito mal esto. Es returns, no era return. Vale, entonces, volvemos a hacer lo mismo. Nos cargamos el smart contract, lo desplegamos de nuevo, vamos a crear la canción, el hash vamos a coger este de aquí de nuevo, realizamos la transacción. Entonces, si yo quisiera aquí GetSongOwner, imaginemos que yo no he registrado nada, yo no sé nada, yo simplemente me han pasado un fichero con la canción. Porque digamos que yo soy un juez que voy a resolver la disputa de quién es el autor real de esta canción porque ha habido un plagio o lo que sea. Entonces yo tendría, pues como hemos hecho antes, yo tendría el fichero. Aquí, y lo vamos a actualizar para hacerlo de nuevo, tengo el fichero, saco el hash y digo vale, me vengo aquí a blockchain, 0x y el hash, ¿quién es el dueño de esta canción? Le doy, y entonces aquí me saldría el adres, y entonces el dueño de esta wallet diría está confirmado, yo soy el dueño, y con esto se resolverían las disputas. Vale, pues con esto hemos visto una manera bastante sencilla, con es más, bastante simple, de cómo tokenizar un activo digital, que en este caso son canciones, y la funcionalidad que puede tener y para todo lo que puede valer.