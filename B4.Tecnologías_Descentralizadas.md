---
title: Redes P2P | Alberto Martín
URL: https://app.web3mba.io/courses/take/bloque-4-tecnologias-descentralizadas/lessons/39251447-1-1-redes-p2p-alberto-martin
Tags/Keywords: null
lang: es-AR
---

###  194.B4_Redes_P2P-video

###  Redes P2P
![[194.B4_Redes_P2P.mp4]]
[Redes P2P](https://app.web3mba.io?wvideo=fzixx1kbn5)

Las redes P2P surgen de la necesidad de conectar ordenadores de forma punto a punto, es decir, de manera directa, sin un servidor intermediario que medie en la comunicación. Este concepto comenzó a desarrollarse en los años 80, cuando, dentro de los protocolos UNIX y GNU, se buscaba la posibilidad de transferir archivos sin depender de un servidor central que pudiera almacenar una copia de esos archivos. Actualmente, quienes utilizan distribuciones GNU, MacOS y similares, suelen emplear herramientas como SSH o SCP, que son métodos para conectarse a un servidor remoto. El origen de todo esto radica en la implementación de las primeras redes P2P, que fueron evolucionando con diferentes características y necesidades a lo largo del tiempo, dando lugar a lo que conocemos hoy. Ejemplos de redes P2P populares en la actualidad son BitTorrent y, a nivel técnico, el protocolo SCP mencionado anteriormente, que en esencia permite realizar una copia de datos de un punto A a un punto B.

Para entender cómo funcionan estas redes, es necesario analizar su funcionamiento desde un enfoque técnico. Si observamos cómo se transmite un mensaje a través de HTTP en Internet, notamos que existen diferentes niveles de jerarquía en los paquetes. En el protocolo TCP/IP, hay siete niveles. En las redes P2P, trabajamos en el nivel 7, que es el de aplicación, donde intentamos crear una red de nodos que tengan direcciones de sus vecinos, lo que nos permite construir una mini Internet donde todos pueden acceder a los datos de los demás. Las principales ventajas de una red P2P son varias. La primera es que no requiere un único punto de fallo, algo que siempre está presente en una red centralizada. Al eliminar el problema del "single point of failure", se abren nuevas posibilidades, como la descarga de archivos de manera distribuida. No es necesario tener una única representación del archivo, sino que puede estar distribuido y ser descargado desde múltiples fuentes simultáneamente. Además, podemos compartir información no solo con un servidor, sino de manera fragmentada y simultánea en muchos lugares.

En España, las primeras implementaciones de redes P2P fueron programas como Kazaa, eMule y Napster, que buscaban redistribuir contenido que tradicionalmente estaba protegido por derechos de autor, dándole una nueva vida a través de la comunicación entre pares. En esa época, se observaron no solo las ventajas, sino también algunas desventajas de estas redes. Al ser distribuidas, es fundamental cuidar la calidad del contenido que circula, ya que un archivo corrupto puede ser distribuido y es responsabilidad de los miembros de la red identificarlo y eliminarlo. Para que esto funcione, se necesita un software que cada cliente pueda descargar y un conjunto de nodos que ejecuten dicho software. Una vez que cada cliente participa, comienza el proceso de conocer a sus vecinos. En esencia, se necesita una red de vecinos, donde uno pueda pedir sal, otro pimienta, y a su vez, ofrecer leche y pan. Para lograr esto, es necesario tener tablas de paginación que contengan índices para descubrir qué tiene cada uno. Esto funciona bien a pequeña escala, pero se complica a mayor escala.

Una de las primeras redes basadas en texto fue el IRC, un caso curioso de redistribución P2P, ya que no comenzó como tal. Inicialmente, había un directorio central que almacenaba el índice de vecinos con sus direcciones, lo que permitía iniciar conversaciones. Sin embargo, llegó un momento en que los usuarios no querían que su comunicación pasara por ese índice central y deseaban un entorno donde los miembros de la comunidad tuvieran el control. Así, se pasó de tener una tabla de índices central a múltiples tablas de índices distribuidas. Ya hemos mencionado algunas ventajas de estos sistemas desde un punto de vista filosófico y de uso, pero también es importante considerar sus ventajas y desventajas a nivel técnico.

Entre las ventajas, destaca que una red P2P no puede ser censurada. En países donde los ISPs están controlados por el gobierno, como en China, hay restricciones para acceder a ciertas páginas web. Al distribuir el contenido de manera P2P, no hay un servidor DNS que pueda denegar el acceso a una ruta específica, ya que es una red de nodos la que proporciona ese contenido. Si hablamos de escalabilidad para compartir archivos de video o audio, como en los casos iniciales de BitTorrent, hemos visto una evolución significativa. Al principio, las descargas eran bloqueadas y se realizaban entre pares, pero ahora podemos tener particiones distribuidas que almacenan fragmentos de diferentes proveedores, lo que permite un acceso más rápido a nuestros archivos en comparación con la descarga desde un servidor centralizado.

Otra ventaja es que el sistema es agnóstico respecto al tipo de archivo que se desea compartir. En la misma red y ecosistema, se pueden enviar desde un tweet hasta descargar una canción o una base de datos de wallets comprometidos. La clave es que solo se necesita establecer una infraestructura y, a partir de ahí, cualquier tipo de información puede fluir libremente. Sin embargo, al considerar las desventajas del sistema, es importante analizar qué sucede con una red de gran escala. El rendimiento de esta red dependerá del tipo de algoritmo utilizado para la distribución de nodos. Según el tipo de archivo que se desee distribuir, algunos tendrán mayor calidad que otros, y la replicación de la información será más lenta en función del número de nodos que se mantengan. Por ello, ciertas redes distribuidas o P2P pueden no ser operativas para determinados casos de uso.

Aunque una red distribuida es prácticamente incensurable, no es un protocolo que, por defecto, garantice privacidad, a menos que esté diseñado específicamente para ello. Por ejemplo, en Alemania, el tráfico de BitTorrent es monitoreado por los ISPs, y se pueden imponer multas por compartir contenido protegido por derechos de autor. Este tipo de tráfico puede estar acompañado de medidas secundarias que aseguren la privacidad, como utilizar una red P2P sobre Tor o a través de una VPN con características específicas. Es fundamental tener en cuenta que la red distribuida ofrece libertad de distribución, pero no garantiza privacidad sobre lo que se comparte.

Por último, es importante mencionar los problemas estructurales que pueden surgir. Todo tipo de red y ecosistema tiene sus pros y sus contras, y en las redes distribuidas P2P, existen casos de uso que pueden ser vulnerables a ataques, como el ataque de eclipse. En un ataque de este tipo, se intenta aislar un nodo, creando un "eclipse" sobre él, lo que puede tener diversas finalidades, como reducir su capacidad de minería o inyectar transacciones fraudulentas. Esto se logra mediante la creación de nodos replicantes que apuntan a vecinos cercanos, y es crucial que las tecnologías en entornos cripto estén diseñadas para ser resilientes a este tipo de ataques.

¿Cómo se relaciona todo esto con las criptomonedas? Todo comenzó con la primera blockchain, Bitcoin. Cuando Satoshi diseñó el sistema, se inspiró en cómo funcionaba BitTorrent. En aquella época, BitTorrent ya utilizaba algoritmos para distribuir la carga entre diferentes nodos, y se adoptó un enfoque similar en Bitcoin. ¿Cómo se traduce esto en la minería? La minería es el proceso de encontrar la solución a un bloque y añadirlo a la cadena. El bloque que se añade se retransmite a todos los nodos. Si tenemos un número fijo de nodos y mineros, el sistema debe ser lo suficientemente robusto para evitar que ningún agente activo que valide transacciones pueda introducir una transacción maliciosa. Esto se relaciona con la regla del 51%, que establece que si más de la mitad de los nodos están de acuerdo en algo, ese algo se considera cierto. Para introducir una transacción maliciosa, sería necesario engañar a esa mayoría en un corto período de tiempo.

¿Qué sucede en un escenario específico? Si tenemos, por ejemplo, 20 mineros y 100 nodos, y 10 de esos mineros controlan el 80% de los nodos, lo que a escala actual es prácticamente imposible, esos mineros podrían intentar inyectar una transacción maliciosa. Si logran que la mayoría de los nodos acepten esa transacción, se generaría una situación en la que algunos nodos la aceptarían y otros no, lo que provocaría un hard fork. Un hard fork es la bifurcación de la blockchain, donde se crean dos redes P2P diferenciadas, cada una con sus propias reglas de consenso. Este tipo de algoritmos y prácticas no se limitan a Bitcoin. Todas las redes blockchain son distribuidas y cada una tiene su propia participación en ciertos algoritmos que han evolucionado con el tiempo.

Es importante mencionar la diferencia entre Bitcoin y Ethereum. Si observamos cómo se realiza la minería en la actualidad, tanto en Bitcoin como en Ethereum, notamos patrones distintos. Bitcoin permite que, con cierta potencia de cómputo, se logre un mejor rendimiento en la minería. En cambio, Ethereum premia la descentralización en la minería. ¿Qué implica tener una minería que prioriza la descentralización en lugar de la eficiencia? Que, evidentemente, es menos eficiente. Al buscar descentralización, se requiere una mayor duplicidad de datos y más mensajes intercambiados para sincronizar todo, lo que ralentiza el proceso y se traduce en tarifas de gas más altas.

El algoritmo utilizado en Ethereum se llama Cadembly, del cual hablaremos más adelante. Es importante destacar que no es el único en este tipo de implementación; otros protocolos como IPFS o Filecoin siguen características similares. Tanto IPFS como Filecoin buscan crear una red P2P donde se distribuyan archivos de manera libre, permitiendo que cada uno de nosotros actúe como un nodo activo con participaciones en esos archivos. Al tener participaciones, se asegura la confidencialidad del archivo completo y, gracias al algoritmo que se centra en la distribución, se garantiza su robustez, no solo para la privacidad, sino también para la imposibilidad de su distribución no autorizada.

Es relevante mencionar que Ethereum no está solo en este tipo de implementación; Cadembly también ha sido adoptado por proyectos como IPFS y Filecoin, que buscan crear redes distribuidas para intercambiar archivos P2P, permitiendo que cualquiera de nosotros sea un nodo activo. Aquí, nuevamente, se resalta la importancia de contar con un algoritmo que favorezca la descentralización masiva, aunque esto afecte un poco el rendimiento. Esto se debe a que, al subir un dato a esta nube distribuida, se busca que esté muy fragmentado para que nadie tenga acceso al archivo completo y, al mismo tiempo, que nadie tenga el poder suficiente para reconstruirlo.

Desde esta perspectiva, comenzaremos a ver poco a poco el uso característico de Cadembly. Este algoritmo ha sido elegido para su implementación en Ethereum, Filecoin y otros proyectos por su robustez a la hora de encontrar caminos entre nodos cuando uno de ellos desaparece, y su capacidad para soportar ataques de denegación de servicio. La característica principal de este algoritmo es que no organiza los nodos de manera aleatoria, sino que los estructura en forma de árbol. Se forma un árbol binario donde se distribuyen particiones de archivos, transacciones o cualquier tipo de información.

Cuando tenemos este árbol de nodos, que se puede imaginar como un sauce, es necesario contar con una posibilidad algorítmica para acceder a cada nodo en caso de que ocurra un fallo. Esta es la ventaja del algoritmo. Es eficaz para prevenir ataques de denegación de servicio, que buscan bombardear una familia de nodos y hacer que no puedan aceptar más transferencias. Con Cadembly, se garantiza que, como máximo, en 20 pasos se puede acceder a cualquier nodo, y si uno falla, se salta y se busca el siguiente. Si ese nodo también está inactivo, se continúa buscando hasta encontrar uno operativo. A menos que toda la red sea derribada, se puede encontrar un nodo sano en un máximo de 20 pasos.

Si profundizamos en la implementación técnica de este algoritmo, es necesario contar con una cantidad de nodos distribuidos que hayan descubierto a sus vecinos. Una vez que se identifican los vecinos, se deben almacenar en un índice, conocido como tabla de hash. Esta tabla de hash es como la primera hoja de un libro, donde se tiene una dirección parcial que permite llegar a un vecino. Si al llegar a un vecino este no puede proporcionar servicio, se salta al siguiente. Este proceso requiere que, a medida que los vecinos fallen, se pregunte a la red por nuevos vecinos. Por ello, hay varias operaciones específicas en cualquier red distribuida que utilice este tipo de algoritmo, que incluyen: "dame mi información", "toma información" y "hola, buenos días". El "hola, buenos días" es un ping; si se hace ping a una dirección, debe responder con un pong, lo que se añade a la hoja de índices. Esto ocurre en tiempo real y de manera distribuida.

Por eso, a pesar de que Ethereum tiene un alto nivel transaccional, gran parte de los mensajes se utilizan para mantener la integridad de la red. Esto se debe a que, en la actualidad, hay intentos constantes de introducir software malicioso, y es la robustez del algoritmo la que nos protege. Cuando se dice que cierta blockchain tiene un consumo eléctrico elevado o que otra tiene un consumo menor, a menudo se basa en las necesidades de esa blockchain, no solo para validar transacciones, sino para mantener la robustez mencionada. Por lo tanto, algoritmos como el que estamos discutiendo tendrán un tráfico mayor que aquellos que permiten la centralización, lo que puede llevar a la conclusión de que Ethereum tiene un consumo eléctrico más alto y un rendimiento inferior en comparación con Solana, por ejemplo. Además, es importante considerar que Bitcoin utiliza un sistema de prueba de trabajo (proof of work), mientras que Ethereum está en transición hacia un sistema de prueba de participación (proof of stake), lo que también influye en las diferencias en el consumo eléctrico y la eficiencia transaccional.


###  195.B4.U1.1_Redes_P2P

###  Redes P2P
Las redes P2P o redes _peer-to-pee_r, son un tipo de red de computadoras que permiten la comunicación directa entre las mismas, sin necesitar de intermediario alguno.

La creación de esta tecnología resultó vital no solo para mejorar nuestras comunicaciones, sino para ofrecer herramientas de privacidad, que sirvieron a miles de personas para comunicar su voz al mundo entero. 

Hoy, las redes P2P son un elemento clave de muchos protocolos digitales, siendo uno de ellos los protocolos que hacen posible el funcionamiento descentralizado de las criptomonedas.

####  ¿Qué es una red P2P?
Una red P2P o peer-to-peer, es un tipo de red digital donde un grupo de personas o máquinas participan de forma completamente descentralizada.

Es decir, **es una red donde no hay un punto central de conexión o control,** **por lo que cada una de ellas es totalmente autónoma,** estableciendo conexiones y compartiendo información de forma igualmente autónoma. Todo esto es posible, porque las redes P2P han sido programadas para responder a un protocolo de comunicaciones y consenso común, que les permite realizar este tipo de tareas sin que un tercero tenga intervención alguna en el proceso. 

Para lograr este funcionamiento, las redes P2P se construyen sobre protocolos que se ejecutan sobre los protocolos de Internet (TCP/IP, UDP o de cualquier otra índole que lo permita). De allí que, a los protocolos P2P se le reconozca como protocolos de aplicación o Layer 7, según el modelo _Open Systems Interconnection_ u OSI. Esto significa que los protocolos P2P necesitan para su funcionamiento el uso de otros protocolos más abstractos para poder funcionar, pero que al mismo tiempo, los hace más sencillos de construir y hacer funcionar.

Gracias a esto, los protocolos P2P, han sido ampliamente utilizados desde su creación para distintos usos. Algunos legales, otros un tanto grises, pero pese a ello hay una cosa muy clara: Los protocolos P2P son muy potentes y permiten la creación de estructuras descentralizadas, ==difícilmente censurables y de uso libre.== Por esa razón, criptomonedas como Bitcoin fueron construidas sobre la base de protocolos P2P.


###  196.B4.U1.2_P2P-Historia

###  Historia de las redes P2P
El origen de la primera red P2P, la podemos rastrear hasta la creación del protocolo UUCP o _Unix-to-Unix Copy Protocol_, en el año 1980. 

UUCP (_UNIX-to-UNIX Copy Protocol_) es un conjunto de programas UNIX que permite copiar y enviar archivos entre diferentes sistemas UNIX, o para enviar comandos que se ejecuten en otro sistema UNIX, todo ello mientras exista una comunicación directa entre ambos sistemas.  

![[198.B4_uucp.png]]

Si eres, usuario de GNU/Linux, BSD o MacOS, seguramente te vendrá a la mente un protocolo que hace esto en la actualidad: ssh. Pues bien, UUCP es por decirlo de una forma el origen del mismo, ya que su **objetivo es el mismo: comunicar dos sistemas de forma directa para enviar y recibir archivos.** 

**Por supuesto, UUCP es un protocolo que poco se usa hoy en día, sin embargo, su legado es inolvidable, porque dicho protocolo es lo que dio origen a USENET y los BBS, dos elementos que hoy en día se siguen usando.** Por ejemplo, el BBS de EfectoLinux o FideNet, son dos ==BBS== que se mantienen activos en nuestros días, y nos hacen recordar al “Internet antes del Internet”, a la vez que nos permiten acceder a archivos antiguos que de otra manera se hubieran perdido hace mucho. En ==USENET==, las opciones son mucho más amplias, ya que la red se ha mantenido activa gracias a un sistema de suscripciones de pago para acceder a dichos servicios, teniendo comunidades muy activas en este sentido. 

  ![[198.B4_fidonet.png]]

Dicho esto en su momento, USENET y el protocolo UUCP fueron la cumbre de las comunicaciones. De hecho, el movimiento cypherpunk inició con el uso de este protocolo. Personajes como Saint Jude, Eric Hughes, Timothy C. May, David Chaum, hacían uso de estos sistemas para compartir información en los tablones BBS de la comunidad Cypherpunks. 

> Eran los primeros años de la computación, y en ese momento, ya se vislumbraba mucho de las posibilidades futuras de este tipo de protocolos y de computadores mucho más potentes y capaces.

Más tarde, en 1983, llegó al mundo el protocolo TCP/IP. Básicamente, este nuevo protocolo buscaba flexibilizar la creación de grandes redes globales, de hecho, es la base de construcción de lo que hoy conocemos como Internet. Esto último, se hizo realmente posible cuando se estableció el sistema o modelo OSI (definiendo las siete capas de abstracción que contamos actualmente en Internet) en 1989 y, finalmente, con la llegada del protocolo WWW (World Wide Web) en 1990.

####  La era del IRC
En 1988, nacería ==Internet Relay Chat (IRC)== un sistema de mensajería basado en texto que fue desarrollado por Jarkko Oikarinen. Si bien IRC nació bajo un esquema centralizado (cliente-servidor) el sistema fue mejorado para convertirse en uno híbrido, en el cual la conexión principal se mantenía del modo cliente-servidor, pero se habilitaba también un modo de comunicación directa entre personas (Cliente-a-Cliente Directo o DCC) que para mayor seguridad podía usar un esquema Off-The-Record (OTR) usando criptografía de clave pública entre esos clientes. 

**IRC tuvo un tremendo éxito por varias razones: es fácil de usar, permite unir grandes comunidades, se da en tiempo real y es altamente personalizable. De hecho, muchas comunidades de criptografía y desarrollo de software libre aún usan IRC para sus comunicaciones, siendo software como Bitcoin o Ubuntu, dos de esas comunidades que aún usan IRC para comunicarse.** 

####  La era de la compartición de archivos y el nacimiento del P2P real
Con la masificación de Internet, comenzó una nueva era, una en la que era posible compartir archivos de forma rápida y sencilla. Proyectos de software libre y privativo trabajaron para hacer de este tiempo una “era dorada” en la que podías compartir tus fotos, vídeos y cualquier creación digital con comunidad, amigos y familia en todo el mundo, sin necesidad de intermediarios.

IRC fue al inicio de todo esto, el medio más usado para tal fin, ya que permitía este tipo de acciones. Sin embargo, no era eficiente y su dependencia de un servidor para lograr la comunicación de las partes era un problema. Pero en 1996 se publicó ==HotLine Connect,== una aplicación creada Adam Hinkley. **HotLine Connect era una red completamente P2P para compartir archivos que utiliza un sistema de trackers para permitir que dos usuarios pudieran intercambiar información.** Sin embargo, su desarrollo se detuvo debido a la dificultad de encontrar material y la inestabilidad de su protocolo, algo de lo que IRC-DCC no sufría. 

Para 1999, nacería otro contendiente conocido como Direct Connect (DC), el cual al igual que IRC-DCC necesitaba de un servidor central, para luego permitir que las partes conectadas al mismo, pudieran interconectarse entre ellas por medio de una conexión directa. No dejaba de ser un sistema híbrido, alejado de una implementación P2P pura. 

#####  La llegada de Gnutella, la primera red P2P real
En el año 2000, nacería Gnutella de Justin Frankel y Tom Pepper. Frankel y Pepper eran trabajadores de Nullsoft, la empresa creadora del reproductor Winamp y el servicio de streaming de audio Shoutcast. Su experiencia los llevó a la creación del que sería considerado el primer protocolo P2P realmente funcional y que incluso a día de hoy es usado de forma activa por al menos 12 millones de personas en todo el mundo. 

Gnutella funciona gracias a un modelo conocido como ==“boostrap network”== en el que cada cliente busca al menos un nodo al que conectarse, descargar la lista de nodos conocidos y así en lo sucesivo, ir descargando distintas listas para ir mapeando la red a la que se conecta. 

![[198.B4_gnutella.png]]

En dicha lista hay nodos con distintas funciones, como cachés y supernodos.  

- Los primeros tenían como función mantener un listado del archivo más solicitado y la dirección de un nodo que tuviera dicho archivo, facilitando y acelerando la búsqueda de los archivos deseados. 
- Los segundos tenían como función, hacer que las búsquedas realizadas pudieran propagarse más rápidamente por la red, con el fin de que los nodos con la información solicitada respondieran al llamado, algo vital para la escalabilidad de la red. 

**En todo caso, Gnutella pasó a convertirse en el protocolo más usado para el P2P ocupando el 40% del tráfico de Internet para este tipo de protocolos, y con ese desarrollo saldrían proyectos como FastTrack (MLDonkey) o eDonkey, siendo este último desarrollado por Jed McAleb, quien es más conocido por haber creado el exchange de criptomonedas Mt.Gox (que luego fue vendido a Mark Karpeles), y ser parte de los proyectos Ripple y Stellar, como CTO de ambos proyectos.** 

#####  BitTorrent y Kademlia, las tecnologías para la descentralización completa
Fue BitTorrent quien finalmente lograría alcanzar la cúspide del P2P. 

Diseñado por Bram Cohen en abril de 2001, **BitTorrent se ha transformado en uno de los proyectos P2P de mayor impacto en todo el mundo,** siendo que cerca del 28% del tráfico de todo el Internet a nivel mundial se debe a este protocolo, en el cual participan unos 200 millones de personas diariamente.

> El éxito de BitTorrent se debe al uso de dos tecnologías, Peer Exchange y DHT. El primero es una solución bastante parecida a la que se puede ver en Gnutella, donde los nodos se conectan a trackers con el fin de encontrar nodos con un determinado archivo y descargarlo.

El problema de esta solución es que, al bloquear a los trackers, se detiene el funcionamiento de la red, requiriendo de una intervención manual para su funcionamiento (agregando las direcciones IP de los nodos a mano). Pero DHT resuelve todo esto, gracias al uso del protocolo ==Kademlia.== 

**Kademlia es un protocolo que permite crear una tabla hash distribuida para redes informáticas descentralizadas peer-to-peer diseñada por Petar Maymounkov y David Mazières en 2002.** Este sistema permite crear una estructura de la red y habilitar el intercambio de información a través de las búsquedas de nodos. En una red Kademlia cada nodo se identifica con un número o ID de nodo. El ID de nodo no solo sirve como identificación, sino que el algoritmo Kademlia utiliza el ID de nodo para localizar valores (normalmente hashes de archivos o palabras clave). 

De hecho, el ID de nodo proporciona un mapa directo a los hashes de los archivos y ese nodo almacena información sobre dónde obtener el archivo o recurso. Con esa información, Kademlia permite que el BitTorrent DHT sea totalmente descentralizado. De allí, que los muchos intentos de gobiernos, ISP y distintas organizaciones de poder para parar el funcionamiento de BitTorrent no hayan surtido efecto. BitTorrent y todas las redes que adaptaron Kademlia, ahora son indetenibles. 

####  Relación de las redes P2P y las criptomonedas
Cuando Satoshi Nakamoto creó Bitcoin, él sabía que tratarían de detenerlo por cualquier medio. 

No era un “pensamiento conspiranoico”. En 2008 los intentos por detener las redes P2P estaban en su punto más álgido, y solo se compartían archivos. Imagina ¿Qué harían si en vez de compartir archivos compartieran dinero, algo incluso más valioso que el dinero que ellos creaban de la nada? Con eso en mente, Nakamoto miró a BitTorrent y el protocolo Kademlia que le hacía inmune a tales intentos y lo adaptó al protocolo de Bitcoin. 

**Como resultado, Bitcoin es hoy una red de más de 10 mil nodos públicos (y otro número no determinado de nodos privados) que hacen funcionar a su red de forma segura, descentralizada e indetenible.** 

¿Pero, solo Bitcoin lo usa? Pues no. La verdad es que proyectos como Ethereum (y sus derivados descentralizados) usan Kademlia. Proyectos como IPFS, Filecoin, Siacoin o Storj, también usan Kademlia para sus nodos. 

![[196.B4_kademilla.png]]

Con ello queda claro una cosa, Nakamoto aprendió de la historia y, como buen aprendiz decidió no cometer los errores del pasado. Una enseñanza que caló en el resto de proyecto y que ahora no permite ver que P2P es el camino no solo a la descentralización, sino también a la libertad financiera y tecnológica.


###  197.B4.U1.2.P2P-Funcionamiento

###  ¿Cómo funcionan las redes P2P?
El funcionamiento de una red P2P es relativamente sencillo. 

Básicamente, lo que se hace es construir un protocolo (lenguaje) de comunicaciones que permita a las personas que usan dicho software comunicarse de forma directa y sin intermediarios con otros computadores.

Sin embargo, el mayor problema frente a la construcción de estos sistemas es: ¿Cómo diseñar un sistema que no necesite un directorio centralizado para comunicarse con otros computadores que ejecuten el mismo software?

Este es un problema complejo, pero la situación se puede solventar de una forma bastante efectiva con dos medidas bien definidas:
1. **En primer lugar, hacer que el software sea capaz de compartir información de conexión sobre quienes ejecutan el mismo.** Así, cada computador que ejecuta el software es capaz de tener un directorio de computadores conectados y servirse de ellos para conectarse al nodo que desea.
2. **Incentivar la mayor descentralización posible de la red.** Es decir, hacer que muchas personas ejecuten el software creando sus propios nodos y, por tanto, aumentando el tamaño de la red. De esta manera, se mejora su alcance y las posibilidades de la misma.

**Es decir, mientras más pares o peers (computadores ejecutando el software P2P) tenga la red, más posibilidades hay de que la red no pueda ser censurada, su funcionamiento será más resistente y, mejor capacidad tendrá la misma.** En los primeros sistemas P2P, como USENET o IRC, los sistemas y sus conexiones se hacían conocer por medios escritos, llamadas, o el mismo sistema que tenía un tablero de pares a los cuales poder conectarse. Así, cada nuevo integrante en la red, tenía acceso a la lista de peers y se autoañadía para que otros pudieran establecer comunicación con ellos en caso de requerirlo. No solo eso, ese nuevo peer podía ser la puerta de entrada a la información de peers que pudieran bloquearse.

> Pero la creación de redes más grandes como el IRC, DCC, DC++, Napster, Gnutella, BitTorrent e incluso Bitcoin cambió drásticamente esto. Ahora cada nodo se conectaba a un punto, obtienen una lista de peer iniciales (o nodos semillas).

Y a partir de allí, cada nodo es capaz de recrear una lista propia de nodos que pertenecen a la red. Como resultado, se obtiene una mejor resistencia a la censura y la red puede crecer más rápidamente.

Por supuesto, el funcionamiento de cada protocolo es distinto. IRC, por ejemplo, es un sistema híbrido (parte centralizada, parte descentralizada) de servidores que pueden darte la capacidad de conectarte punto a punto con una persona. Pero DC+ (con el nuevo protocolo ADC) y Gnutella, son completamente descentralizados. Sus redes están pensadas para que, de forma automática, la red se ajuste con la entrada y salida de nuevos nodos a la red.

**Lo mismo pasa en Bitcoin, donde la red comenzó con una sola semilla, la iniciada por Satoshi Nakamoto, y desde entonces, la red ha ido creciendo paulatinamente para convertirse en una red con un tamaño superior a los 10 mil nodos en activos públicos que se conocen. Por supuesto, el objetivo de Bitcoin es distinto al de una red como Gnutella, pero los principios del protocolo se mantienen: comunicar a dos partes sin intermediarios.**

![[197.B4_p2p.png]]

####  Ventajas y Desventajas
#####  Ventajas
1. **Una red P2P es resistente a la censura.** Una red P2P altamente descentralizada es prácticamente imposible de censurar.
2. **Ofrecen una resiliencia inigualable**. Si un nodo cae, otro nodo puede ocupar su lugar. Por eso dicen que las redes P2P pueden sobrevivir a una catástrofe nuclear. Porque estas pueden destruir muchos nodos, pero si solo uno sobrevive, la red puede reconstruirse por completo.
3. **Las redes P2P pueden llevar a soluciones de escalabilidad** potentes para presentar servicios únicos con alcance global.
4. **Al no depender de entidades centrales,** las P2P generan más confianza en sus usuarios. 
5. **Ofrecen un alto nivel de ancho de banda.** Esto gracias a que aprovechan el ancho de banda de cada participante, para transformarlo en propio de la red.
6. **Sirven para transmitir información digital de cualquier tipo.** Desde tu canción favorita a cientos de millones de dólares en segundos.

#####  Desventajas
1. **Una red P2P es resistente a la censura, pero no te hace anónimo a menos que esté diseñada para ello,** incluso, si esa red usa cifrado. El mejor ejemplo es BitTorrent, donde los ISP pueden detectar el uso del protocolo, y con ello advertir a las autoridades de la descarga ilegal por parte de un usuario.
2. **El diseño de las redes P2P generan que a mayor tamaño aumente la ==latencia.==** Es decir, para que una información llegue a todas las partes que forma la red, se tomará más tiempo en una red P2P de gran tamaño que en una de menor tamaño. De allí que se busquen nuevos algoritmos y protocolos que ayuden a superar este problema.
3. **Los protocolos P2P tienen una serie de problemas estructurales conocidos.** Casos como los ataques MITM para tomar el control de nodos, debido a que estos deben estar conectados todo el tiempo de forma pública, son uno de estos fallos. También los protocolos **son susceptibles a ataques de enrutamiento o cosas tan sigilosas como un ataque Eclipse o un ataque Erebus.**

#####  Ejemplo de como funciona una red P2P en criptomonedas
Para ejemplificar el funcionamiento de una red P2P tomaremos el caso de Bitcoin. 

**Nakamoto puso en funcionamiento su nodo y un minero con el fin de comenzar a generar los bloques de la red.** Durante varios días Nakamoto hizo este trabajo él solo, era el único nodo de la red. En ese momento, Bitcoin por irónico que parezca, estaba totalmente centralizado porque el único nodo y minero estaban en manos de una sola persona.

Sin embargo, **a los pocos días se unió a la red el conocido Hal Finney**, creando el segundo nodo de la red. En ese momento, cuando Finney puso en funcionamiento su nodo, paso lo siguiente:
1. **El nodo de Finney** no tenía información alguna: no había Blockchain, no tenía historial, estaba vacío. 
2. **Comenzó a buscar algún nodo conocido** sin necesidad de un intermediario y se encontró con el nodo de Satoshi, quien ya llevaba varios días funcionando y con un historial creado. 
3. **El nodo de Finney se conectó y comenzó a sincronizarse con el nodo de Nakamoto,** teniendo cuidado de verificar toda la información que le fuera entregada. Una vez sincronizados, el nodo de Nakamoto y Finney tenían el mismo historial y un control 50/50 de la red (Finney también era un minero). 

![[197.B4_finney.png]]

En este punto, la red pasó de ser de una red centralizada a ser una red débilmente distribuida, pero era un primer paso. El protocolo de Bitcoin había sido creado para que a medida que más nodos se conectaran, estos nuevos nodos tuvieran la misma relevancia que el resto.

El proceso que se acaba de describir arriba, se mantiene hoy en día en Bitcoin. Cada vez que una persona instala un nodo completo de Bitcoin, este nodo hace exactamente el mismo proceso: buscar los nodos que están activos en la red, sincronizar y verificar la información, y al sincronizarse, se vuelve parte del sistema de consenso protegiendo a la red de cualquier manipulación. 

Un punto importante a tener en cuenta son los controles de la red. Por ejemplo, si Bitcoin pasaba a 100 nodos y 20 mineros, los nodos tendrían el 1% de peso en el consenso de la red (1% x 100 nodos = 100% del consenso) y los 20 mineros se dividirán la capacidad de generar bloques, de acuerdo a su poder minero. En este punto hay varios posibles escenarios:
1. **Si el 51% de los nodos está de acuerdo con lo que hacen los mineros,** entonces su bloque será aceptado y el resto de la red se le unirá en consenso. 
2. **Si el 51% de los nodos rechaza el trabajo de los mineros,** entonces el bloque será rechazado y ese será el consenso de la red.  
3. **Si hay cambios en las reglas de consenso de algunos nodos,** entonces se producirá un ==hard fork,== dividiendo a la red y su Blockchain en dos partes:
    - Los que aceptan las nuevas reglas de consenso.
    - Los que no reconocen las reglas de consenso.
4. **Si hay cambios en las reglas de consenso pero son opcionales o no vitales,** entonces estamos ante un ==soft fork.== Esto no romperá el consenso de la red, pero habrá una parte de ella que no será capaz de interpretar la información, pero si verificar que el resto es correcto.

Como se puede ver, el proceso de buscar los nodos es lo realmente vital para el funcionamiento de una red P2P y su descentralización. 

**En la actualidad, Bitcoin logra esto gracias al uso de un derivado de Kademlia y Gossip Protocol (dos protocolos centrados en ofrecer una red P2P totalmente descentralizada). Además, con el fin de acelerar la búsqueda de nodos, Bitcoin ha creado los llamados “Supernodos”, que nos son más que nodos especiales que se dedican a crear tablas de nodos completos de Bitcoin, a los cuales los nuevos nodos pueden conectarse para empezar la sincronización.** 

La idea es acelerar el proceso de unión a la red, ya que los “Supernodos” solo son una “guía”, ya no son capaces de proveer más información que direcciones de nodos. Esto es vital para evitar una búsqueda de mucho tiempo en una red como Internet donde hay cientos de millones de dispositivos conectados, y que resulta mucho más sencilla y segura que usar una lista escrita en un foro de Internet.


###  198.B4.U1.4_Kademlia

###  Kademlia
Se trata de un protocolo de comunicación _peer-to-peer_ que implementa tablas hash distribuidas. 

Diseñado por Petar Maymounkov y David Mazieres para descentralizar las redes informáticas P2P.

La estructura de la red en Kademlia está representada por un árbol binario, en el que cada nodo (la hoja del árbol) tiene su propio identificador único que define su posición en el árbol. Esta es una de las muchas versiones de los sistemas DHT.

La red Kademlia se caracteriza por tres elementos constantes que son: 
1. **Elemento Alfa:**  
    Un pequeño número que representa el grado de conexiones paralelas en la red, generalmente 3;
2. **Elemento B:**  
    Tamaño en bits (número de bits) de las claves que identifican los nodos y los datos almacenados y recibidos; en la versión básica de Kademlia es 160, la longitud del hash de la función SHA-1;
3. **Elemento K:**  
    Número máximo de contactos almacenados en un contenedor, generalmente 20.

El primer y tercer elemento son elementos estándar dentro del protocolo Kademlia, mientras que el segundo elemento es una mejora agregada por diversos protocolos derivados de Kademlia. Tienen como finalidad crear un medio de identificación por hash de los nodos, datos y funcionamiento de red, con el fin de evitar colisiones.

####  Nodos dentro de la red Kademlia
La red Kademlia consta de una serie de nodos cooperativos que se comunican entre sí y almacenan información entre ellos.

**Cada nodo tiene un ID de nodo, un número binario pseudo-único que identifica y especifica la ubicación del nodo en la red.**

Un nodo es simplemente un usuario de red, una estación de trabajo que ejecuta una aplicación que admite un protocolo de red determinado: en este caso Kademlia.

Además de la dirección IP, el nodo tiene una clave sobre la base de la cual puede ser reconocido y encontrado en la red. Dentro de la red, un bloque de datos (valor) también se puede asociar con una cadena binaria B de longitud fija (clave de valor). El nodo, cuando necesita valor, lo busca en los nodos más cercanos a la clave. Un nodo necesita almacenar un valor y lo almacena en los nodos más cercanos a la clave.

![[198.B4_kademilia.png]]

Para el correcto funcionamiento de los nodos dentro de una red Kademlia, es necesario que se respeten los siguientes puntos básicos para los mismos:

####  ID de nodo
Los equipos de la red se identifican por sus direcciones IP y claves que definen su ubicación en Kademlia. 

El ID de nodo es un número binario con una longitud de **B = 160 bits.**

En la versión básica de Kademlia, cada nodo selecciona su ID de acuerdo con un procedimiento pseudoaleatorio indefinido. Es importante que cada ID de nodo sea único e igualmente distribuido; de eso se trata el diseño de red.

####  Claves
Los datos almacenados en Kademlia se definen como un valor asignado a la clave correspondiente.

Esto se debe a las propiedades de las [tablas hash distribuidas](https://es.wikipedia.org/wiki/Tabla_de_hash_distribuida). Los datos almacenados o recibidos de la red deben tener una longitud de clave de B. Es así como los ID de nodo también deben distribuirse por igual. Hay varias formas de garantizar esto. **El más popular es crear un hash utilizando una función de hash segura SHA-1 (o cualquier otra función hash que agregue esta capa de seguridad).** Los pares se almacenan en los nodos cuyo ID está más cerca de la clave.

####  Distancia: Métrica XOR
La operación de Kademlia se basa en gran medida en el uso de operaciones XOR (OR eXclusivo) como métricas. La distancia entre claves o ID de nodo (por ejemplo, x e y) se define de la siguiente manera:

==**distancia (x, y) = x ^ y**==

Donde “^” representa el operador XOR. El resultado se obtiene de la operación XOR realizada en cada bit de los argumentos. **E****s la operación más importante del protocolo Kademlia, porque es la responsable de la correcta determinación de la proximidad entre nodos y, entre las claves y un nodo.**

Un ejemplo de esto lo podemos ver en la siguiente tabla:

|Tabla de Verdad de Xor|
|---|---|---|
|a|b|a XOR b|
|0|0|0|
|0|1|1|
|1|0|1|
|1|1|0|

- **Los nodos de Kademlia organizan sus contactos siguiendo este esquema,** con el fin de que otros nodos tengan un máximo de k contactos de todos sus conocidos. Estos son los denominados contenedores k. Los contenedores se organizan en función de la distancia entre el nodo y los contactos en el contenedor. 
- **Como resultado de esta función,** Kademlia garantiza que los distintos subconjuntos de la red P2P puedan interconectarse unos con los otros por distintos caminos, almacenando los nodos de mayor alcance (aquellos con mayor frecuencia de conexión) al final de la lista de nodos conocidos, y los nodos de menor alcance (aquellos con menor frecuencia de conexión) se colocan al principio de la lista de nodos conocidos. 
- **De esta manera, este sistema garantiza que toda la red esté conectada.** Asegura que los nodos tengan conexiones provenientes de distintos subconjuntos de la red y garantiza que la red pueda ser recorrida al completo sin importar si varios de los nodos caen, agregando resiliencia.

![[198.B4_xor.png]]

####  Tamaño de contenedor
En Kademlia, la constante "k" se establece en 20, lo que hace que sea muy poco probable que en redes grandes los contactos en cualquier contenedor puedan desaparecer en una hora.

Al intentar calcular esta probabilidad, se debe considerar la política que lleva a que los contactos de larga duración almacenados en la matriz sean preferidos como contactos más recientes. 

**"k" es el valor del sistema del protocolo de red Kademlia.** 

Este valor por supuesto puede cambiar a valores mucho mayores para agregar mayor seguridad, pero al mismo tiempo se incrementa un poco la latencia entre las distintas partes de la red. 

####  Contactos
Los contactos en Kademlia se almacenan en forma de tres de los siguientes elementos:
1. ID de nodo: ID de nodo
2. Dirección IP
3. Puerto UDP

- Los diseñadores de Kademlia no tuvieron en cuenta el uso de direcciones IPv6 o protocolo TCP / IP en lugar de UDP y la posibilidad de que un nodo tenga varias direcciones IP. 
- En Kademlia es importante enviar mensajes rápidamente entre nodos. Para ello, se utiliza un protocolo de comunicación sin conexión UDP. 
- ==UDP== es un protocolo sin conexión, por lo que no hay sobrecarga para el establecimiento de la conexión y el seguimiento de la sesión (a diferencia de TCP). Tampoco existen mecanismos para controlar el flujo y la retransmisión de datos. La ventaja de tal simplificación de la estructura es la mayor velocidad de transmisión de información y la falta de tareas adicionales que deben ser manejadas por el usuario que utiliza este protocolo.

Por supuesto, esto también tiene algunos problemas de seguridad y de integridad de datos que son tratados por diferentes mecanismos por las aplicaciones que usan Kademlia. En especial, los desarrolladores de sistemas P2P que usan Kademlia y UDP, deben crear protecciones contra el spoofing ( suplantación de identidad) , los ataques DDoS, entre otras amenazas. 

####  Protocolo
La documentación original de Kademlia dice que el protocolo tiene cuatro procedimientos de conexión remota.

1. PING
2. STORE
3. FIND_NODE
4. FIND_VALUE

También especifica otros procedimientos que deben ocurrir durante su llamada como algún otro protocolo. 

Es bueno agregar estos procedimientos y otros protocolos a lo que llamamos protocolo Kademlia. Al comunicarse en la red, cada nodo (enviando un RPC o cualquier otro mensaje) proporciona información sobre su destinatario en forma de dirección IP, puerto UDP e ID de nodo.

#####  1 | PING
Este procedimiento RPC implica que un nodo envía un mensaje PING a otro nodo que se supone que responde con un mensaje PONG si está activo.

El procedimiento tiene un efecto de dos factores: el destinatario del mensaje PING debe actualizar el contenedor que corresponde al remitente, y si hay respuesta, el remitente debe actualizar el contenedor correcto para el destinatario. Todos los paquetes de rutinas RPC requieren que contengan el ID de nodo asignado por el remitente. Es un número pseudoaleatorio de longitud B (160 bits). 

También debe ser posible responder al mensaje PING con el procedimiento RPC para forzar o permitir que el originador (el remitente del procedimiento RPC) proporcione información adicional a su destinatario. Puede ser una dirección IP diferente o un conjunto de direcciones IP, o el protocolo preferido para futuras comunicaciones. El mensaje se usa al agregar contactos al contenedor y durante la conexión de inicio.

#####  2 | STORE
El remitente del mensaje RPC STORE proporciona una clave y un bloque de datos y requiere que el destinatario almacene los datos y los ponga a disposición para búsquedas posteriores por clave. 

Esta es una operación básica para compartir datos en la red Kademlia, no iterativa.

#####  3 | FIND_NODE
El procedimiento FIND_NODE toma una clave de 160 bits como parámetro: El ID del nodo que se busca.

El destinatario del mensaje devuelve hasta k contactos en forma de tres, que sabe que están más cerca de la clave. El destinatario debe devolver triples si es posible. Puede devolver menos de k contactos siempre que devuelva todos los contactos que conoce. Esta es la operación básica de búsqueda de nodos y, por lo tanto, recursos en la red Kademlia no iterativa.

#####  4 | FIND_VALUE
El procedimiento FIND_VALUE toma una clave de 160 bits del valor buscado como parámetro. 

Si el valor de clave correspondiente está presente en el receptor, los datos asociados se devuelven al iniciador del procedimiento.

De lo contrario, el procedimiento es equivalente a FIND_NODE y se devuelve el conjunto de los k contactos más cercanos a la clave buscada. Esta es una operación básica de búsqueda de recursos de Kademlia no iterativa.


###  199.B4.Descentralización-video

###  Descentralización
![[199.B4.Descentralización.mp4]]
[Descentralizacion](https://app.web3mba.io?wvideo=yb3idnrmip)

Ya no solo por el white paper de Satoshi, sino por toda la comunidad que existía en aquella época a su alrededor. Estos eran los cypherpunks, y lo que buscaban entre ellos era tener un sistema que, por un lado, no estuviese controlado por el Estado, y por otro lado, tuviese una privacidad por diseño y por matemáticas que no dependiese de un organismo central que pretenda mantenerla, o en el que haya que confiar para que la mantenga. A su vez, buscaban distintos tipos de niveles de encriptación. Cuando un sistema falla, debe haber un sistema secundario. Si el secundario falla, debe haber un terciario. Esto se llama esteganografía. Dentro de esta comunidad inicial se encuentran los primeros empleados de Sound Microsystems, quienes fueron los creadores de la lista de correo de Cypherpunks. Podemos ver un poco cuáles son esas ideas originales. No lo sé, no se basaba tanto en un déficit financiero, como podríamos pensar hoy en día, sino que estaba muy centrado en separar la privacidad del Estado. Tal es el hecho que, a día de hoy, tiene millones en su cartera y se dedica, año sí, año no, a seguir denunciando al gobierno de Estados Unidos por violaciones de privacidad. Gente que, en un principio, tenía muy claro el núcleo de... Oye, queremos, por un lado, la privacidad, y queremos, por otro lado, la seguridad, así como la independencia de un tercero para poder actuar libremente. Para comentar brevemente las diferencias entre centralizado, descentralizado y distribuido, debemos empezar diciendo que no son conjuntos disjuntos. Centralizado y descentralizado son, evidentemente, tipos opuestos, pero ambos pueden ser distribuidos. Solo será no distribuido en sus etapas más tempranas. Si montas una startup pasado mañana, en esos primeros días lo más probable es que levantes un servidor web que represente tu negocio, una página web para ofrecer un servicio. Ojalá te vaya muy bien y tengas que escalarlo. Cuando necesites escalarlo, ya no será suficiente tener una única implementación de tu servidor. Tendrás que separar capas entre interfaces, middleware y capa de datos, y empezar a escalar horizontalmente la forma en que manejarás cada una de las peticiones que te llegan. Para lograr esto, lo que montarás es un sistema distribuido. Facebook, Twitter, B2Me, mi propia empresa, todos nosotros somos sistemas distribuidos en cuanto hemos alcanzado cierto tamaño. ¿Cuál es la diferencia entre un sistema centralizado y uno descentralizado? El punto único de fallo. En cualquier sistema centralizado, siempre hay una entidad que puede desconectar el servicio y acabar con la operación. Siempre puede haber una entidad centralizada, como un gobierno, que puede denegar a tu empresa o a tu organismo social el acceso a su servicio. ¿Qué sucede cuando se pasa de un sistema centralizado a uno descentralizado? Que tenemos dos obligatoriedades. Un organismo descentralizado siempre debe ser distribuido. ¿Por qué? Porque no hay un punto único de fallo, ya que no hay un máster que dirija todo, y por ello necesitamos que entre todos mantengamos la estructura. Si decimos que un sistema descentralizado debe ser distribuido, en el fondo estamos hablando de duplicaciones del mismo código que todos estamos ejecutando al mismo tiempo y compartiendo esa información. Con esto... ganamos y perdemos, es un poco lo que hemos comentado en unidades anteriores: robustez, rendimiento y la crítica posibilidad de ser censurados por un sistema externo. Para cada caso de uso, tendremos que elegir cuál es la mejor solución.


###  200.B4.U2.01_Descentralización

###  Descentralización
####  Su importancia para las redes Blockchain y las criptomonedas
¿Por qué necesitamos la descentralización?  
¿Es realmente necesaria?

La respuesta corta es:  
Sí, necesitamos de la descentralización hoy más que nunca. 

La descentralización se ha mostrado como el camino correcto para construir servicios de amplio acceso para todos, para evitar que pocos puedan controlar esos servicios y también para evitar que cualquiera con poder pueda simplemente decretar su extinción porque así lo desea.

####  Acceso para todos:  Libertad y privacidad 
El primer punto a favor de la descentralización es que nos permite crear estructuras en la que todos podemos participar de forma libre, plena y privada.

Un servicio basado en Blockchain pasa de las fronteras y de ideas anacrónicas sobre cómo acceder a un determinado servicio. 

**El mejor ejemplo de esto son las criptomonedas. Cualquier persona en el mundo puede acceder a ellas para tener libertad económica y financiera, a la vez que protege su privacidad.** 

> Te permite obtener, desde cualquier parte del mundo, una cantidad en ETH con el fin de interactuar con el enorme ecosistema de aplicaciones descentralizadas de Ethereum.

Este simple hecho te brindaría acceso a un conjunto de aplicaciones financieras que de otra forma sería imposible de alcanzar y podrías usar la mayor parte de ellas sin necesidad de pasar por procesos de KYC que violen tu privacidad. 

Por supuesto, esto no solo aplica a esa criptomoneda. La práctica totalidad de las criptomonedas te permiten acceder a funciones muy parecidas. Bien sea porque quieres usarlas como medio de ahorro, inversión, etc. o como sistema de pago internacional, remesas o cualquier otro uso que desees. Después de todo, la descentralización de Blockchain y las criptomonedas apunta a dos cosas: total libertad y respeto a tu privacidad. 

Esos principios no solo aplican al dinero, sino también a otros servicios. Por ejemplo, puedes usar una identidad digital basada en Blockchain para usar tus datos para acceder a una red social descentralizada. Sin embargo, con esa misma identidad digital basada en Blockchain, puedes proteger tu nombre, edad y otros datos sensibles al acceso de terceros no deseados. Todo eso mientras las personas de la red pueden verificar que cualquier cosa escrita por ti realmente lo es, haciendo más difícil con ello los bulos y las fake news. 

####  Descentralizando el control

![[200.B4_descentralizacion.png]]

Permite crear estructuras de control que no están en manos de un reducido grupo de personas, sino que nos coloca a todos a un mismo nivel.

La descentralización nos ayuda a igualar las reglas de juego entre los poderosos y los que no tienen tanto poder, a la vez que nos permite a todos participar en un sistema bajo un conjunto de reglas bien definidos.

Esto podemos ejemplificarlo de forma muy sencilla:
- **Un minero de Bitcoin puede tener un enorme poder de minería, pero si hace mal su trabajo, la red trabajará en conjunto para rechazar ese trabajo, evitando que manipule a su favor el sistema.** 
- Incluso en caso de que ese poder de minería alcance o supere el 51%, los integrantes de la red detectarán el caso y actuarán en consecuencia para evitar que tal poder siga actuando en su contra.

> Suena idealista, pero esta es una realidad que se ha visto en la práctica dentro del mundo Blockchain.

En Bitcoin, por ejemplo, hubo un grupo minero que alcanzó el 51% de todo el poder minero y, al darse cuenta de esto, la comunidad advirtió sobre el hecho. Al poco tiempo, ese grupo minero comenzó a perder poder minero y dejó de funcionar. Este es un ejemplo de la comunidad actuando en contra de la centralización, protegiendo lo más preciado para ellos: La descentralización de la red. 

Vimos otro ejemplo de descentralización cuando Gavin Andresen trató de imponer su visión sobre el tamaño de los bloques de Bitcoin, intentando impulsar una propuesta de mejora de Bitcoin (BIP) pasando de los canales regulares. 

**La comunidad rápidamente actuó en su contra y por ello fue expulsado del desarrollo de Bitcoin. Desde entonces, Andresen ha pasado de ser una gran figura respetada en la comunidad, a simplemente, ser parte de su historia, una que terminó de la peor manera posible.**

 Una historia que tiene un mismo reflejo en Bitcoin SV, un proyecto que languidece lentamente mientras sus creadores intentan sostener un castillo de naipes formado de mentiras y un control centralizado absurdo en su desarrollo. 

####  Generación de valor con reglas claras
En consonancia con el control tenemos la generación o acuñación de monedas.

¿Qué detiene a un banco central de imprimir dinero sin control?  
La respuesta es clara: Absolutamente nada. 

**Si así lo desean, pueden imprimir tanto dinero como deseen. No tienen límite y ellos mismos lo reconocen. Ese poder es un verdadero peligro, uno que ya nos ha tocado vivir en muchas ocasiones.** 

La descentralización de Blockchain y las criptomonedas nos ayuda a controlar esto, por medio de reglas muy claras que indican la forma y cantidad de dinero que se puede imprimir. **Una idea que usualmente se suele usar en contra de los pro-cryptos es que el** [**modelo deflacionario**](https://economipedia.com/definiciones/deflacion.html)**, que muchas monedas usan, es insostenible y que llevaría a una espiral deflacionaria sin control que haría que la economía de los países se contraiga a mínimos históricos.**

Apuntan a ese supuesto y lo atacan con la necesidad de crear [sistemas inflacionarios](https://economipedia.com/definiciones/inflacion.html), para resolver el problema. La realidad es que los desarrolladores de muchas criptomonedas no son insensatos. Conocen bien las debilidades y fortalezas de cada sistema (deflacionario e inflacionario) y, por ello, en el ecosistema puedes ver criptomonedas que usan un sistema u otro dependiendo de su objetivo. 

> Bitcoin es deflacionario, está diseñado para que solo existan unos 21 millones de monedas y nada más, y toda esa emisión no terminará hasta el año 2144.

Todo su sistema económico o ==tokenomics,== se sostiene sobre la base de un sistema en el que los mineros crean una cantidad de monedas en cada bloque (6,25 BTC en la actualidad), y esa cantidad se reduce a la mitad cada 4 años aproximadamente. 

**Cuando ya se hayan emitido todos los BTC, los mineros seguirán su trabajo bajo una premisa muy clara:** R**ecibirán comisiones por los usuarios de la red y esas comisiones tendrán tal valor, que por si solo cualquier minero querrá mantenerse trabajando en la red.** Hasta el momento la premisa se mantiene, porque BTC paso de ser una moneda de valor 0 a tener un valor superior a los 69 mil $ USD. ¿Qué precio tendrá BTC para 2144? Nadie lo sabe, pero de seguir el desarrollo hasta el momento, es posible que sea muy superior a esa cifra. 

**En comparación, Ethereum sigue un modelo inflacionario, uno pensado para producir unos 18 millones de monedas al año, y que se ha mantenido prácticamente inamovible desde su creación.** Sus mineros y usuarios saben el nivel de inflación que tendrá ETH, y con base en eso, pueden crear modelos predictivos sobre distintos elementos económicos y financieros para su ecosistema, especialmente para sus aplicaciones DeFi. En ambos casos, las reglas que rigen la generación de monedas son claras. Siempre se han cumplido y se rigen por medio de software ejecutada de forma descentralizada. Nadie puede con un simple botón agregar más monedas o hacerse con el control de todas ellas. 

**Pero, para un banco central, controlar la emisión o hacerse con el control de las monedas es tan sencillo como presionar un botón para agregar los 0 que quiere en su base de datos, o emitir un boletín para subir al 100% el encaje legal del país. Con ambas acciones, no solo te hacen más pobre (por la devaluación de la moneda) sino que frenan la capacidad para acceder a créditos, pagar deudas y en definitiva, terminan empobreciendo a toda la población de forma general.** 

####  Evitando la censura
Otro gran beneficio de la descentralización es que evita la censura. 

Por ejemplo:  
Un país ha decidido envenenar sus servidores DNS y filtra toda conexión en Internet para evitar que puedas navegar por ciertos sitios que ellos consideran “ofensivos y peligrosos”. 

**Una red descentralizada como la presente en la Blockchain ayudaría a evitar que este tipo de acciones realmente censuren todo tipo de disidencia, a la vez que protege su privacidad.** 

Tres proyectos descentralizados que buscan evitar esto son: 
1. IPFS
2. Orchid
3. Ethereum Name Services

#####  1 | IPFS
No es Blockchain, pero es descentralizado y está íntimamente relacionado con proyectos Blockchain como Ethereum o Filecoin (el cual es un derivado de IPFS). 

IPFS permite que puedas acceder a documentos e información de forma totalmente descentralizada, de manera que puedas evitar la censura que un tercero pueda imponerte.

#####  2 | Orchid
Es un sistema de VPNs que permite enmascarar y cifrar tu conexión entre varios puntos a los fines de evitar la censura. 

Los túneles VPNs de Orchid, son una forma sencilla de evitar estas prácticas manteniendo la seguridad de tu conexión, y el sistema funciona gracias a la tecnología Blockchain y una red descentralizada de nodos desperdigados por todo el mundo. 

#####  3 | Ethereum Name Services 
Permite acceder a servicios DNS y de identidad digital seguros y no manipulables, para que puedas navegar o contactar con personas en todo el mundo, teniendo la seguridad de que no podrán ser suplantados por un tercero. 

Tal como se puede observar en todos los casos mencionados, la descentralización resulta fundamental y de allí que todos debamos proteger este espacio con el fin de seguir teniendo servicios seguros, privados y confiables para todos.


###  201.B4.U2.2_Modelos_de_funcionamiento

###  Modelos de funcionamiento de las redes Blockchain
Las redes Blockchain pueden organizarse en distintos modelos de funcionamiento. 

1. Centralizada 
2. Descentralizada 
3. Distribuida

Cada una de estas configuraciones tiene sus ventajas, inconvenientes, diferencias y cosas en común.

![[201.B4_modelos.png]]

####  1 | Redes centralizadas
Una red de ordenadores centralizada es aquella en la que cada ordenador que la conforma es periférico y está conectado a una unidad central.

Son conocidas generalmente como redes cliente-servidor, porque cada computador (cliente) debe conectarse a un servidor para solicitar y recibir la información deseada.

Así, esta unidad central ejerce todo el control y gestión de la red. Es decir: toda la responsabilidad y poder de decisión recae sobre un solo elemento, en este caso una máquina o una entidad.

![[201.B4_centralizada.png]]
_Imagen 1: Ejemplo de una red centralizada_

**Esta configuración de red es la más utilizada debido a su simplicidad y escalabilidad.** 

Las redes centrales son capaces de manejar grandes cantidades de información rápidamente, lo que las hace perfectas para servicios de alta demanda. Esto se debe a que un servidor maneja el consenso total de la red, sus datos son en toda extensión: la realidad de la red. 

Por supuesto, esto significa que este tipo de redes son las más inseguras y menos resilientes a los ataques. Veamos algunos casos para entender esto:
1. **Si un cliente pide un dato al servidor, la respuesta del mismo resultará 100% confiable para el cliente, incluso aunque esa información sea errónea.** El cliente no tiene forma de saber si la data ha sido manipulada de alguna manera y, por tanto, este tipo de situaciones pueden suceder perfectamente. 
2. **Otro ejemplo de su debilidad lo vemos en su resistencia a los ataques.** Supongamos que un hacker ataca al servidor y logra acceder al mismo. Ese hacker no solo puede robar toda la información de la red, sino que puede directamente dañarla y dejar a la red completamente fuera de servicio.

**Generalmente, puedes ver este tipo de arreglos dentro de las empresas.** Esa es la razón por la cual un fallo es capaz de afectar a todos dentro de la empresa. Por supuesto, para evitar esto se tienen copias de seguridad y servidores paralelos. Pero como el funcionamiento de la red sigue completamente centralizada, solo se mitigan los peligros, no se solucionan. 

**Un buen ejemplo lo podemos ver en Blockchains como Ripple. Si bien la red cuenta con varios nodos repartidos en todo el mundo, las decisiones para su desarrollo y control están centralizadas en la empresa Ripple.** Otro ejemplo en Blockchain es la plataforma Hyperledger: un proyecto de software libre cuya finalidad es crear redes Blockchain para uso empresarial y con un control centralizado ajustado a las necesidades de dichas empresas. Este desarrollo fue pensado para ser controlado por empresas, limitando o incluso negando el acceso a la red por parte de elementos fuera de la empresa.

**Ambos casos (Ripple y Hyperledger) son redes muy rápidas, capaces de hacer frente a gran cantidad de usuarios de forma concurrente. Pero el hecho de que sean redes centralizadas limita su confiabilidad, seguridad, privacidad y resiliencia.** 

####  2 | Redes descentralizadas
Las redes descentralizadas son aquellas en las que no existe una sola unidad central.
En su lugar existe una serie de ordenadores que funcionan en conjunto para controlar y manejar la red.

De esta forma se agrega un cierto nivel de tolerancia a fallos gracias a que este conjunto de ordenadores asume determinadas tareas de la red.

**Sin embargo, en este tipo de redes aún existe riesgo de un fallo catastrófico total. Esto es posible porque las redes descentralizadas aún pueden fallar si queda fuera de servicio el coordinador de la red.** Con la caída de un ordenador coordinador, el resto de los ordenadores de esa sub-red quedan sin servicio y desconectados de la red principal. Si por ejemplo, el ordenador coordinador de red principal cae, el resto de las subredes quedan desperdigadas. En cualquiera de los casos, la pérdida de un coordinador llevaría a una desconexión de menor o mayor magnitud.

Una concepción errónea sobre este tipo de redes es que la actuación de los coordinadores es completamente autónoma. La verdad es que estos actúan como una unidad central dentro de una red más grande. Un vestigio de las redes centralizadas que aún sobrevive dentro de este modelo.

Un buen ejemplo de este tipo de redes son:
-  Facebook
- Twitter
- Google

Todos estos servicios cuentan con subredes dentro de una gran red y en su conjunto son capaces de manejar todos los servicios que prestan. 

**En el mundo de las criptomonedas, dos ejemplos de este tipo de redes son:**
- Polkadot
- Solana

#####  Polkadot
Acceder a la red Polkadot implica tener un conjunto de nodos (nodos, collators, nominadores y validadores). Cada nodo tiene su función específica y para acceder a su trabajo requiere de hardware, software y staking distintos.

 Sin embargo, los números de nodos que puede alcanzar Polkadot son pequeños en comparación con Bitcoin u otras redes. Y la razón de ello es que, a mayor tamaño y velocidad, la red requiere de una cantidad de recursos que difícilmente pueden ser alcanzados (a menos que se agrupen dichos nodos en servicios en la nube). Como resultado, la red Polkadot no supera los 1700 nodos, distribuidos en menos de 120 localidades.

![[201.B4_polkadot.png]]
_Imagen 2: Mapa de nodos dentro de Polkadot_

#####  Solana
Solana se encuentra en una situación parecida. 
Con sus 1749 nodos validadores en activo, 22 nodos Superminority y 1678 nodos RPC (los encargados de dar acceso a app como MetaMask), la red está bien descentralizada. Pero en el mapa podemos ver que su distribución geográfica está sobre todo centrada en América del Norte y Europa. 

Esta condición, junto a la existencia de los 22 Superminority, hace de Solana una red que sufre de problemas de inestabilidad, hasta el punto de haber sido reiniciada en varias ocasiones por este problema. Esto deja claro que su descentralización es débil, y eso explica por qué la comunidad indica que la descentralización de Solana es incompleta. 

![[201.B4_solana.png]]
_Imagen 3: Dashboard mostrando los datos de la red Solana y la distribución de nodos._

####  3 | Redes distribuidas
Finalmente, tenemos a las redes distribuidas en las que no existe ningún centro de control individual o colectivo.

Significa que cada una de las partes en una red distribuida son iguales y no tienen la capacidad de filtrar o alterar la información dentro de la red, porque de hacerlo, el resto de la red detectaría el cambio y se podrían tomar medidas para remediar dicha manipulación. 

Así, gracias a esta estructura, si algún ordenador falla o es atacado este no desconectará al resto o afectaría el funcionamiento del resto. 

> El ejemplo más claro de este tipo de redes es Internet. Desde su nacimiento, Internet fue pensado para ser una red completamente distribuida.

En principio, fue una red muy centralizada debido a los pocos ordenadores que estaban conectados en ese momento. Pero a medida que aumentaron los ordenadores interconectados, Internet pasó a convertirse en una red distribuida.

#####  BitTorrent
Otro buen ejemplo de redes distribuidas son las redes de compartición de archivos P2P como BitTorrent. 

Esta red está formada por más de mil millones de usuarios y cerca de 250 millones de ellos se mantienen en activo de forma diaria. La red es tan grande que poco más del 27% del tráfico de Internet en todo el mundo tiene su origen en esta red. 

**Con esos datos está claro que BitTorrent es la mayor red distribuida después de Internet** y no debería sorprendernos, puesto que su tecnología ha demostrado no solo adaptarse a los tiempos, sino también proveer de un medio rápido para compartir información sin limitaciones. 

#####  Bitcoin
El mejor ejemplo de red distribuida en el mundo Blockchain lo podemos ver en Bitcoin. 

**Actualmente, la red de Bitcoin cuenta con más de 15 mil nodos públicos activos y hay potencialmente la misma cantidad en nodos privados (un total de 30 mil nodos desperdigados por todo el mundo).**

Esto convierte a Bitcoin en la red de criptomonedas más grande de la actualidad, y sus desarrolladores abogan para que siga creciendo, para de esa forma seguir fortaleciendo la red.


###  202.B4._Qué_son_los_Smart_Contracts-video

###  titulo
![[202.B4._Qué_son_los_Smart_Contracts.mp4]]
[Que son los Smart Contracts](https://app.web3mba.io?wvideo=53mfvgpjg3)

Antes de indagar en lo que es un smart contract, primero debemos recordar qué significa un contrato. Un contrato no es más que un acuerdo entre dos o más partes, un entorno donde se define lo que se puede hacer, cómo se puede hacer y qué sucede si algo no se cumple. Es decir, son unas reglas del juego que permiten a todas las partes que lo aceptan entender en qué consistirá la interacción que van a realizar. Hasta ahora, los contratos han sido medios verbales o documentos escritos. Estos documentos están sujetos a las leyes y jurisdicciones territoriales y, en ocasiones, requieren de notarios, lo que implica más costos, tiempo y la intervención de terceros en el proceso. Debido a esto, no son accesibles para cualquier persona. Y esto no es lo peor; los contenidos de los contratos pueden estar sujetos a interpretación.

En cambio, un smart contract o contrato inteligente es capaz de ejecutarse y hacerse cumplir por sí mismo de manera autónoma y automática, sin intermediarios ni mediadores, y sin interpretaciones distintas a las que se especifican en la propia programación del mismo. Así, básicamente, un smart contract se trata de un script, un código informático, escrito en un lenguaje de programación definido y aceptado por la red blockchain sobre la que se ejecuta. Por otro lado, un smart contract puede ser creado y llamado por personas físicas y jurídicas, pero también por máquinas u otros programas que funcionan de manera autónoma. Un smart contract tiene validez sin depender de autoridades. Esto se debe a su naturaleza. Es un código visible para todos y que no se puede modificar al existir sobre la tecnología blockchain. Esto le confiere un carácter descentralizado, inmutable y transparente.

La primera vez que se tiene constancia pública de los smart contracts es a través del jurista y criptógrafo Nick Szabo, quien mencionó públicamente el término en un documento en internet en el año 1995. Dos años después, en 1997, desarrolló un documento mucho más detallado explicando los smart contracts y un glosario básico aplicable a los mismos. Por ello, se considera a Nick Szabo como el padre de los smart contracts, incluso en momentos en que la tecnología era inaplicable. La razón de esto es que no había un sistema lo suficientemente autónomo y seguro para hacer realidad esta visión.

La tecnología para hacer realidad los smart contracts llegó con la creación de Bitcoin. Satoshi Nakamoto se dio cuenta de la necesidad de un lenguaje de programación capaz de permitir realizar operaciones dentro de Bitcoin de forma descentralizada, y que dicho lenguaje fuera fundamental para la protección de los activos en la red. La idea se desarrolló hasta crear el conocido como Bitcoin Script, el primer lenguaje de programación para smart contracts del mundo. Si bien Bitcoin Script es un lenguaje limitado en su alcance, cumple perfectamente con las características básicas de los smart contracts racionalizados por Nick Szabo. De hecho, Bitcoin Script ha sido utilizado para crear protocolos más complejos dentro de Bitcoin, como OmniLayer, ColorCoins, Counterparty, RGB, Lightning Network y otros que pueden existir.

Adicionalmente, Bitcoin también cuenta con algunos smart contracts ya creados que se ejecutan por defecto y de manera transparente para el usuario. Por ejemplo, cada vez que realizas una operación de Bitcoin usando el modelo de transacción, en realidad estás creando un smart contract dentro de la red Bitcoin, en la que transfieres una determinada cantidad de Bitcoin a otra persona, usando tu clave privada y la pública de esa persona, asegurándote de pagar la comisión correspondiente al minero y obteniendo tu cambio, si queda, por la operación que realizas. Ejemplificando, podrían desarrollarse nuevos productos o aplicaciones como, por ejemplo, mercados distribuidos que permitieran implementar contratos P2P y trading en los mercados con Bitcoin, postulándose como un competidor completo al sistema financiero actual.

Un buen ejemplo de esto es BISC, considerado por la comunidad como el primer DEX de criptomonedas. El funcionamiento del sistema hace uso de Bitcoin Scripts y otros lenguajes para garantizar la seguridad de los intercambios que se realizan en esta aplicación. ¡Gracias por ver el video! El funcionamiento de los NFTs como Rare PPS o Spell of Genesis es una muestra del potencial de los smart contracts sobre Bitcoin, utilizando Bitcoin Script. Otro ejemplo es Lightning Network, que es la Layer 2 de Bitcoin. Depende de potentes smart contracts para hacer un puente que lleve tus satoshis de la red mainnet de Bitcoin a la red de Lightning Network, permitiéndote usarlos dentro de la misma.

Otros usos posibles pueden ser para manejar propiedades como automóviles, teléfonos, casas o elementos no físicos. Controlados a través de la cadena de bloques, conforman las llamadas Smart Property. Mediante el uso de contratos y propiedades inteligentes, se permite que el nivel de confianza sea mucho mayor, reduciendo el fraude, los honorarios de mediación para terceros y llevando las operaciones a un nuevo nivel. Y es que los smart contracts se sirven de la tecnología y Bitcoin para existir, algo que beneficia a Bitcoin, pues está atrayendo mucha más atención y cientos de miles de nuevos usuarios a su ecosistema.

Esta lógica que puede aplicarse a las transacciones de Bitcoin se realiza a través del uso de un lenguaje propio, permitiendo que sea la misma blockchain quien determine qué hacer, basándose en las indicaciones programadas. Esto significa que tenemos una transacción con instrucciones que nos permiten realizar una operación con una blockchain. Y es que, además de ser una transacción, también es una transacción de un sistema de datos, que nos permite operar con un sistema de datos. Y es que, además de ser una transacción, también es una transacción de un sistema distribuido e inmutable, brindando una seguridad completa y sin interpretaciones.

Por supuesto, los smart contracts no son exclusivos de Bitcoin y tampoco son el espacio donde más desarrollados se encuentran. Por ejemplo, en Ethereum, los smart contracts de esta red son mucho más sencillos de implementar y las posibilidades de creación son incluso mayores. Debido a esto, Ethereum es considerada la red perfecta para el uso e implementación de smart contracts, aunque existen varios competidores como Polygon, Solana, Algorand o Cardano, entre otros.


###  203.B4.U3.1_Smart_Contracts-¿Qué_son?

###  ¿Qué son los Smarts Contracts?
Un contrato es un acuerdo entre dos o más partes, donde se define lo que se puede, cómo se puede hacer y qué pasa si no se hace. 

Es decir, unas reglas de juego que permiten a todas las partes que lo aceptan entender en qué va a consistir la interacción que van a realizar.

**Hasta ahora los contratos han sido medios verbales o documentos escritos. Estos documentos están sujetos a las leyes y jurisdicciones territoriales, y en ocasiones requieren de notarios. Es decir, más costes, tiempo y terceros que intervienen en el proceso.** Debido a ello, no son accesibles para cualquier persona. Y esto no es lo peor: los contenidos de los contratos pueden estar sujetos a la interpretación.

**En cambio, un Smart Contract o contrato inteligente, es capaz de ejecutarse y hacerse cumplir por sí mismo, de manera autónoma y automática, sin intermediarios, ni mediadores y sin interpretaciones distintas más allá de la que se especifican en la programación del mismo.** Así, básicamente un Smart Contract se trata de un “script” (código informático) escrito con un lenguaje de programación definido y aceptado por la red Blockchain sobre la que se ejecuta. 

Por otro lado, un Smart Contract puede ser creado y llamado por personas físicas y/o jurídicas. Pero también por máquinas u otros programas que funcionan de manera autónoma. Un Smart Contract tiene validez sin depender de autoridades. Esto se debe a su naturaleza: es un código visible por todos y que no se puede cambiar al existir sobre la tecnología Blockchain. Esto le confiere un carácter descentralizado, inmutable y transparente.

####  El nacimiento
La primera vez que se tiene constancia de forma pública sobre los Smart Contracts es a través del jurista y criptógrafo Nick Szabo, quien mencionó públicamente el término en un documento por Internet en el año de 1995.

Dos años después, en 1997, desarrolló un documento mucho más detallado explicando los Smart Contracts y un glosario básico aplicable a los mismos. 

De allí, que se considere a Nick Szabo como el padre de los Smart Contract, incluso en momento en los que su tecnología era inaplicable. La razón de ello, es que no había un sistema lo suficientemente autónomo y seguro para hacer realidad esta visión. 

- **La tecnología para hacer realidad a los Smart Contracts llegó con la creación de Bitcoin.** 
- Satoshi Nakamoto se dio cuenta de la necesidad de un lenguaje de programación capaz de permitirle realizar operaciones dentro de Bitcoin de forma descentralizada y que dicho lenguaje fuera fundamental para la protección de los activos en la red. 
- **La idea la desarrolló hasta crear el conocido Bitcoin Script, el primer lenguaje de programación para Smart Contracts del mundo.** 
- Si bien, Bitcoin Script es un lenguaje limitado en su alcance, este perfectamente cumple con las características básicas de los Smart contracts racionalizados por Nick Szabo. Y de hecho, Bitcoin Script ha sido perfectamente usado para crear protocolos más complejos dentro de Bitcoin (como OmniLayer, Colored Coins, Counterparty, RGB, Lightning Network, entre otros)

**Bitcoin también cuenta con algunos Smart Contract ya creados que se ejecutan por defecto y de manera transparente al usuario. Por ejemplo, cada vez que realizas una operación de Bitcoin usando el modelo de transacción tradicional, en realidad, estas creando un Smart Contract dentro de la red Bitcoin.** En esta operación traspasas una determinada cantidad BTC a otra persona usando tu clave privada y la pública de esa persona, asegurándote de pagar la comisión correspondiente al minero y obteniendo tu cambio (si queda) por la operación que realizas. 

![[203.B4_smart.png]]
  
####  Smarts contracts en Bitcoin
Podrían desarrollarse nuevos productos o aplicaciones como, por ejemplo:
1. **Mercados distribuidos que permitieran implementar contratos P2P y trading en los mercados con Bitcoin, postulándose como un competidor completo al sistema financiero actual.** Un buen ejemplo de esto es Bisq, considerado por la comunidad como el primer DEX de criptomonedas (exchange descentralizado). El funcionamiento del sistema hace uso de Bitcoin Scripts y otras formas de lenguaje para garantizar la seguridad de los intercambios que se dan en esta aplicación.
2. El funcionamiento de los NFTs como [Rare Pepes](https://rarepepes.com/) o [Spell of Genesis](https://spellsofgenesis.com/), son una muestra del potencial de los Smart Contracts sobre Bitcoin usando Bitcoin Script. 
3. Otro ejemplo es la red [Lightning Network](https://lightning.network/), la Layer2 de Bitcoin. Depende de potentes Smart Contracts para hacer un puente que lleve tus satoshis de la red mainnet de Bitcoin la red LN, y que puedas usarlas dentro de la misma de forma libre. 
4. **Otros usos posibles pueden ser para manejar propiedades como automóviles, teléfonos, casas o elementos no físicos controlados a través de la cadena de bloques conforman las nombradas Smart Property.** Mediante el uso de los contratos y con propiedades inteligentes se permite que el nivel de confianza sea muy superior, reduciendo el fraude, los honorarios de mediación para terceras partes y permite que las operaciones se lleven a un nuevo nivel.

  ![[203.B4_smart-btc.png]])

  Los Smart Contracts se sirven de la tecnología de Bitcoin para existir, algo que le viene genial a Bitcoin, pues está haciendo que reciba mucha más atención trayendo cientos de miles de nuevos usuarios a su ecosistema. 

**Esta lógica que puede aplicarse a las transacciones Bitcoin se realiza a través del uso de todo un lenguaje propio, permitiendo que sea la propia Blockchain la que determine qué hacer basándose en las indicaciones programadas. Esto quiere decir que tenemos una transacción con unas instrucciones de forma distribuida e inmutable, dando una seguridad completa y sin interpretaciones.**

Por supuesto, **los Smart Contracts no son exclusivos de Bitcoin** **y tampoco son el espacio donde más desarrollados se encuentran.** En Ethereum los Smart Contracts de esta red son mucho más sencillos de implementar y las posibilidades de creación son incluso mayores. Debido a esto, **Ethereum es considerada la red perfecta para el uso e implementación de los Smart Contracts,** y junto a ella, existen varios contrincantes: Polygon, Solana, Algorand y Cardano.


###  204.B4_Funcionamiento_de_los_Smart_Contracts-video

###  Funcionamiento de los Smart Contracts
![[204.B4_Funcionamiento_de_los_Smart_Contracts.mp4]]
[Como funcionan los Smart Contracts](https://app.web3mba.io?wvideo=hlkf46d962)

La forma más sencilla de entender cómo funciona un Smart Contract es a través de un ejemplo. Imagina por un momento que estás en una línea de producción de puertas de seguridad, donde el punto más crítico es el brazo robótico, encargado de colocar en su sitio y realizar la soldadura de cada una de las partes de las puertas. Este brazo robótico está programado para llevar a cabo toda su tarea de forma autónoma. Nadie le ayuda; lo único que necesita es que le lleven los materiales necesarios a su ubicación. Hasta ese punto, nada difiere de la realidad industrial que tenemos actualmente. Sin embargo, este brazo robótico es capaz de hacer cosas que, con los medios actuales, un brazo robótico no podría. Una de esas cosas es, por ejemplo, solicitar mantenimiento a las empresas que lo han creado cada cierta cantidad de horas, siguiendo parámetros de mantenimiento recomendados que fueron aceptados por la empresa al momento de adquirirlo.

No solo eso, el brazo puede gestionar el pago de estos mantenimientos por su propia cuenta. Esto es posible gracias a que puede verificar que dicha operación se ha realizado. Es capaz de revisar el hardware, comprobar que se han hecho los ajustes de mantenimiento y verificar que las reparaciones se han efectuado. Entonces, genera un registro completo de toda la operación e informa del mismo a los encargados de la zona de producción. Al mismo tiempo, antes, durante y después del mantenimiento, el brazo robótico mantiene comunicación con el resto de la línea de producción para avisar, por ejemplo, cuándo va a interrumpir su trabajo, el tiempo estimado de la interrupción y, al final, el tiempo real de la parada. También informa que ya está listo para volver a entrar en acción, porque su mantenimiento ha sido exitoso y su capacidad operativa está dentro de los rangos esperados.

Básicamente, el brazo robótico se ha transformado en un ente de trabajo totalmente autónomo, capaz de gestionar su propio mantenimiento y comunicarse con el resto de la línea de producción y la empresa para realizar un seguimiento verificable de su producción y de su estatus en tiempo real. El ejemplo podría parecer una historia de ciencia ficción, pero es tan real que actualmente empresas de todo el mundo se dedican a lograr esto con un solo fin: mejorar la productividad de las empresas, la seguridad dentro de las mismas y entrar en la era de la automatización y descentralización operativa. De hecho, se le conoce con un nombre bastante particular: la industria 4.0, que abarca la inclusión de tecnologías como IoT, inteligencia artificial, robótica y blockchain dentro de nuestras industrias para hacer más eficientes sus capacidades productivas.

Al fin y al cabo, el mantenimiento adecuado del brazo robótico de nuestro ejemplo es lo que asegura una buena operatividad de la empresa. Que él mismo gestione toda esa operativa deja espacio para que las personas dentro de la empresa puedan centrarse en mejorar sus productos u ofrecer nuevos productos adaptados a las necesidades del mercado, así como reducir los gastos y mejorar la producción. Todo lo anterior es posible gracias a los Smart Contracts, ya que estos elementos definen una serie de reglas, acciones y eventos que son aceptadas por todas las partes y que se ejecutan de forma totalmente autónoma. Una vez que se ponen en ejecución, solo pueden alterarse bajo el consenso de las mismas partes, evitando que un contrato pueda ser reescrito de forma unilateral. Esto último es bastante común y generalmente lleva a malos resultados.

La gestión de recursos en este contexto depende de la compra de servidores, discos duros, ancho de banda, equipos de soporte, UPS, generadores eléctricos, etcétera, así como de software para gestionar toda la granja de servidores. Todo ello conlleva un completo reto de administración y gestión de recursos, que muchas veces son limitados frente a una demanda cada vez mayor. Esta realidad lleva a las empresas a usar sus recursos de forma muy poco eficiente y, en el proceso, se producen errores que pueden ser especialmente costosos para la empresa, pero aún más para sus propios clientes. ¿Cómo de costoso? Pues una pérdida total de una granja de servidores, y todo simplemente por un mantenimiento realizado de forma incorrecta y por unos recursos mal gestionados en el tiempo.

¿Ha pasado algo así? La respuesta es que sí. El caso más sonado, aunque no reciente, ha sido el de VH, que perdió prácticamente dos granjas de servidores por errores administrativos de construcción y de mantenimiento acumulados. Errores que pudieron evitarse haciendo un uso eficiente de sus recursos para evitar el triste desenlace que al final ocurrió: la pérdida de millones de sitios web, miles de terabytes de datos y varios negocios afectados por lo sucedido, incluyendo varios servicios de exchanges de criptomonedas. En el ámbito de las criptomonedas, hay una frase bien conocida por todos: "El código es la ley". Esta frase hace referencia a que lo escrito en el software de los nodos es lo que realmente se hace cumplir en todo momento, siendo que la única manera de cambiarlo es mediante el consenso de la misma comunidad para aceptar dicho cambio.

Básicamente, no debe haber nada fuera del código, sino todo dentro del código. Esta máxima se cumple con los Smart Contracts. Un Smart Contract es simplemente un conjunto de instrucciones informáticas que se ejecutan dentro de una blockchain. Ese conjunto de instrucciones es inamovible; no se pueden cambiar. Si decides interactuar con un Smart Contract, lo haces cumpliendo con tu deseo de hacerlo y por tu libre albedrío, ya que el Smart Contract y las instrucciones que contiene son transparentes; puedes verlas y verificarlas en cualquier momento usando, por ejemplo, un explorador de bloques. Así, lo que ocurre al interactuar con el Smart Contract es algo que aceptas y que está en consonancia con lo que sus creadores han programado. Básicamente, es un contrato tradicional, solo que este no tiene forma de cambiar sus condiciones. Las que están escritas son las condiciones que siempre se habrán de cumplir.

Veamos, por ejemplo, el siguiente Smart Contract de Bitcoin. Este Smart Contract está escrito en Bitcoin Script y básicamente le dice a los nodos de la red Bitcoin lo siguiente: toma los datos de la clave pública y la firma, y copia ambos a la pila de ejecución. Duplica la clave pública dentro del stack. Realiza una operación que se llama RIPEMD-160 sobre la clave pública duplicada y verifica si el resultado de la operación anterior es igual al hash que empieza por 12 y acaba en 8C. Finalmente, se chequea la firma y se verifica que es correcta. ¿De qué sirve todo esto? Este sencillo Smart Contract se conoce como P2PKH y, aunque no diga nada, es la forma más común de transferir valor dentro de la red de Bitcoin. Este script garantiza que solo la persona que recibe una transacción pueda movilizarlo, porque es quien tiene todos los elementos para demostrar y completar las condiciones de uso de Bitcoin que están contenidas en el Smart Contract.

Todo este proceso se da on-chain, es decir, el Smart Contract está en la blockchain y cuando un usuario interactúa con él, dicha interacción se realiza en forma de una transacción que luego es almacenada en un bloque, gracias al trabajo de un minero o nodo validador. Sin embargo, en este punto, el Smart Contract aún no está del todo ejecutado; luego, los nodos ven la operación, verifican la misma y, si todo es correcto, entonces esta es definitivamente ejecutada y aceptada. Este principio básico se mantiene en todas las blockchains, con algunos cambios ajustados a la estructura de funcionamiento de cada una de ellas o a las capacidades de programación de las mismas. Esto deja claro una cosa: Bitcoin sí tiene Smart Contracts. Son complejos y tal vez no tan potentes como en otras plataformas, pero los tiene.


###  205.B4.U3.2_Smart_Contracts-Funcionamiento

###  Funcionamiento de los Smart Contracts
Imagina por un momento que estás en una línea de producción de puertas de seguridad.

- El punto más crítico es el del brazo robótico encargado de colocar en su sitio y hacer la soldadura de cada una de las partes de las puertas. 
- Este brazo robótico está programado para hacer toda su tarea de forma autónoma, nadie le ayuda, lo único que necesita es que se lleven los materiales necesarios a su sitio. 

Hasta este punto, nada difiere de la realidad industrial que tenemos actualmente. Sin embargo, este brazo robótico es capaz de hacer cosas que con los medios actuales un brazo robótico no podría: 
- **Solicitar mantenimiento a la empresa que lo ha creado cada determinada cantidad de horas,** siguiendo los parámetros de mantenimiento recomendados que fueron aceptados por la empresa al momento de adquirirlo. 
- **El brazo puede gestionar el pago de dichos mantenimientos por su propia cuenta. Esto gracias a que puede verificar que dicha operación se ha realizado** (es capaz de revisar el hardware y saber si se ha hecho los ajustes de mantenimiento y reparaciones), genera un registro completo de toda la operación e informa del mismo a los encargados de la zona de producción.
- **Durante y después del mantenimiento, el brazo robótico mantiene comunicación con el resto de la línea de producción** para avisar cuando interrumpirá su trabajo. También indicar el tiempo estimado y real de su parada, e informar que ya está listo para volver en acción porque su mantenimiento es óptimo y su capacidad operativa está en los rangos esperados.

**El brazo robótico se ha transformado en un ente de trabajo totalmente autónomo,** en el que incluso es capaz de gestionar su propio mantenimiento y comunicarse con el resto de la línea de producción y empresa, para realizar un seguimiento verificable de su producción y de su estatus en tiempo real.

####  Smart Contracts , la era de la automatización y la descentralización

Empresas de todo el mundo se abocan a lograr esto con un solo fin: Mejorar la productividad de las empresas, la seguridad dentro de las mismas y entrar en la era de la automatización y descentralización operativa.

Se le conoce con un nombre bastante particular: Industria 4.0. 

**Abarca la inclusión de tecnologías como el** [**IoT**](https://es.wikipedia.org/wiki/Internet_de_las_cosas)**, IA, robótica y Blockchain, dentro de nuestras industrias para mejorar y hacer más eficientes sus capacidades productivas.** 

Al fin y al cabo, el mantenimiento correcto del brazo robótico de nuestro ejemplo es lo que mantiene la buena operatividad de la empresa, y que el mismo gestione toda esa operativa deja espacio para que las personas dentro de la empresa puedan centrarse en mejorar sus productos u ofrecer nuevos adaptados a las necesidades del mercado, así como se reducen los gastos y se mejora la producción. 

![[205.B4_3.0_4.0.png]]

**Todo lo anterior es posible gracias a los Smart Contracts, ya que estos elementos definen una serie de reglas, acciones y eventos que son aceptados por todas las partes y que se ejecutan de forma totalmente autónoma.** Es más, una vez se ponen en ejecución, solo pueden alterarse bajo el consenso de esas mismas partes, evitando que un contrato pueda ser reescrito de forma unilateral. 

Esto último es bastante común y generalmente lleva a malos resultados. Por ejemplo, una empresa de almacenamiento y hosting depende de comprar servidores, discos duros, ancho de banda dedicado, equipos de soporte (UPS, unidades generadoras eléctricas, edificios climatizados, equipos de seguridad, entre otros) y software para gestionar su granja de servidores. Todo ello conlleva a un completo reto de administración y gestión de recursos, recursos que muchas veces son limitados frente a una demanda cada vez mayor. 

> Esa realidad lleva a las empresas a usar sus recursos de forma poco eficiente, y en el proceso se producen errores, errores que pueden ser especialmente costosos para la empresa, pero aún más costosos para sus clientes. ¿Qué tan costosos? Una perdida total de una granja de servidores y todo simplemente por un mantenimiento realizado de forma incorrecta y recursos mal gestionados en el tiempo. 

**¿Ha pasado algo así? La respuesta es sí, y el más sonado (que no reciente) ha sido el caso de OVH, que perdió prácticamente dos granjas de servidores por errores administrativos, de construcción y de mantenimiento acumulados**. Errores que pudieron evitarse haciendo uso eficiente de sus recursos para evitar el triste desenlace: la perdida de millones de sitios web, miles de terabytes de datos y varios negocios afectados por lo sucedido (incluyendo varios servicios de Exchanges de criptomonedas). 

####  El código es la Ley
En criptomonedas hay una oración que es bien conocida por todos:
==El código es la Ley==

La misma hace referencia a que lo escrito en el software de los nodos, es lo que realmente se hace cumplir en todo momento, siendo que la única manera de cambiarlo, es por medio del consenso de la misma comunidad para aceptar dicho cambio. Fuera de esto, nada fuera del código, todo dentro del código. 

Pues bien, esta máxima se cumple con los Smart Contracts. Un Smart Contract es simplemente un conjunto de instrucciones informáticas que se ejecutan dentro de una Blockchain. Ese conjunto de instrucciones es inamovible, no se pueden cambiar. Si decides interactuar con un Smart Contract, lo haces cumpliendo con tu deseo de hacerlo y por libren elección, ya que **el Smart Contract y sus instrucciones son transparentes: puedes verlas y verificarlas en cualquier momento** usando un explorador de bloques. Así, lo que pase al interactuar con el Smart Contract es algo que aceptas y que está en consonancia con lo que sus creadores han programado. 

**Básicamente, es un contrato tradicional, solo que en este no tiene forma de cambiar sus condiciones: las que están escritas, son las condiciones que siempre se habrán de cumplir.**

#####  Veamos, por ejemplo, el siguiente Smart Contract de Bitcoin:
pubKey: 304502203f004eeed0cef2715643e2f25a27a28f3c578e94c7f0f6a4df104e7d163f7f8f022100b8b248c1cfd8f77a0365107a9511d759b7544d979dd152a955c867afac0ef78601
signature: 044d05240cfbd8a2786eda9dadd520c1609b8593ff8641018d57703d02ba687cf2f187f0cee2221c3afb1b5ff7888caced2423916b61444666ca1216f26181398c
OP_DUP OP_HASH160 
12ab8dc588ca9d5787dde7eb29569da63c3a238c 
OP_EQUALVERIFY OP_CHECKSIG

**Este Smart Contract está escrito en Bitcoin Script** y básicamente les dice a los nodos de la red Bitcoin, lo siguiente:
1. Toma los datos de la pubKey y signature, copia ambos a la pila o stack de ejecución.
2. Duplica la pubKey dentro del stack. 
3. Realiza una operación RIPEMD-160 sobre la pubKey duplicada.
4. Verifica si el resultado de la operación anterior es igual a 12ab8dc588ca9d5787dde7eb29569da63c3a238c.
5. Finalmente, chequea la firma y verifica que sea correcta.

¿Para qué sirve todo esto?. 

**Este sencillo Smart Contract se conoce como P2PKH y es la forma más común de transferir valor dentro de la red Bitcoin.** Este scirpt garantiza que solo la persona que recibe una transacción pueda movilizarlo, porque es quien tiene todos los elementos para demostrar y completar las condiciones de uso para el BTC que está contenido por el Smart Contract o Bitcoin Script. 

![[205.B4_script.png]]
_Imagen 1: Demostración gráfica de que el script anterior se cumple totalmente._

Todo este proceso se da On-Chain. Es decir, el Smart Contract está en la Blockchain y cuando un usuario interactúa con el mismo, dicha interacción va en forma de una transacción que luego es almacenada en un bloque gracias al trabajo de un minero o validador. Sin embargo, en este punto, el Smart Contract aún no está del todo ejecutado sino que luego los nodos ven la operación, verifican la misma y si todo es correcto es definitivamente ejecutada y aceptada. Este principio básico se mantiene en todas las Blockchain, con algunos cambios ajustados a la estructura de funcionamiento de la Blockchain o las capacidades de programación de la misma. 

**Bitcoin SÍ tiene Smart Contracts.**
Que son complejos y no tan potentes como en otras plataformas es una cosa muy distinta a no tenerlos en absoluto, como muchas personas suelen decir en redes sociales, en una forma de ataque a esta criptomoneda.


###  206.B4_Smart_Contracts_en_Ethereum-video

###  Smart Contracts en Ethereum
![[206.B4_Smart_Contracts_en_Ethereum.mp4]]
[Smart Contracts en Ethereum](https://app.web3mba.io?wvideo=ah4ak77jnf)

Hasta la llegada de Ethereum, los smart contracts siguieron el esquema establecido por Bitcoin. En primer lugar, porque era muy sencillo de implementar y, en segundo lugar, porque su seguridad es insuperable. Bitcoin Script es un lenguaje limitado. Las acciones también son limitadas, y la revisión y auditoría de sus instrucciones es tal que romper el lenguaje es muy complejo. Por esa razón, muchos desarrolladores ven a Bitcoin Script como una especie de jardín amurallado. Las posibilidades que ofrece son fenomenales, pero esto nos lleva a una pregunta: ¿qué hay más allá de esas murallas? Los innovadores siempre buscan nuevos océanos, y la primera creación exitosa en salir del estándar de Bitcoin fue Ethereum.

Ethereum lo cambió todo con la llegada de la Ethereum Virtual Machine (EVM) y el lenguaje de programación Solidity. La EVM fue creada para ser una máquina virtual con enormes capacidades, siendo la principal la de ejecutar el lenguaje de programación Solidity. Solidity es un derivado de JavaScript que tiene el poder de ser un lenguaje Turing completo. En comparación, Bitcoin Script es un lenguaje de tipo Turing incompleto. Esto quiere decir que tiene un conjunto de instrucciones y capacidades mucho más limitadas. Más allá de las diferencias entre las blockchains de Ethereum y Bitcoin, los smart contracts siguen el mismo principio: el código es la ley. Este código está grabado en la blockchain, donde permanece protegido por la red, siendo ejecutado y verificado por los nodos que la conforman.

Dicho esto, tal vez recuerdes el Bitcoin Script que mencionamos antes. Ahora observa un smart contract en Ethereum creado con el lenguaje Solidity. Es mucho más legible, ¿verdad? Este es un ejemplo muy básico de smart contract en Ethereum. De hecho, es el código base de un token ERC20. Un ERC20 es un smart contract que te permite crear una nueva criptomoneda que funcione sobre Ethereum. Esta moneda tendrá su propia contabilidad y disfrutará de la seguridad de esta red. Esto solo es el principio del poder de los smart contracts, una tecnología que aún tiene mucho que ofrecernos dentro del universo descentralizado y de Web3, un universo donde las empresas pueden ganar y ofrecer mucho a sus usuarios.

Ahora bien, seguramente te preguntarás: ¿qué podemos hacer con los smart contracts en Ethereum? ¿Cuáles son sus límites? La verdad es que sus límites son prácticamente infinitos. Tomemos un sencillo ejemplo. Cuando pensamos en préstamos, generalmente imaginamos ir a un banco y solicitar uno, como una hipoteca, en la que la garantía de nuestro préstamo es, por ejemplo, nuestra casa o cualquier otro inmueble de valor. En consonancia con el valor del inmueble, recibiremos el préstamo del banco con determinadas condiciones que muchas veces pueden cambiarse, ya sea por leyes o porque el banco, en su letra pequeña, se reserva el derecho de hacer dichos cambios. Puede que consideres esto injusto, pero al firmar el contrato con el banco, estás aceptando esas condiciones y ya no hay vuelta atrás.

Sin embargo, en Ethereum, gracias a sus smart contracts, podemos crear un contrapeso. Las finanzas descentralizadas, o DeFi por sus siglas en inglés, se han convertido en un producto destacado de la economía actual. Estos no son más que programas descentralizados cuyo funcionamiento está controlado por un smart contract. Las instrucciones del smart contract son claras y no se pueden alterar; no hay letras pequeñas. Básicamente, lo escrito es lo que se cumple en todo momento: el código es ley, como hemos mencionado. Pero su función no se limita a eso, porque podemos usar los smart contracts para crear nuestro propio banco descentralizado, ofrecer créditos y tomar como garantía de esos créditos otras criptomonedas de gran valor en el mercado.


###  207.B4.U3.3_Smart_Contracts-Ethereum

###  Smart Contracts en Ethereum
Hasta la llegada de Ethereum, los Smart Contracts seguían el esquema mostrado por Bitcoin. 

- Era muy sencillo de implementar
- Su seguridad era insuperable. 

Bitcoin Script es un lenguaje limitado, las acciones son igualmente limitadas y la revisión/auditoría de sus instrucciones es tal que romper el lenguaje es extremamente complejo. 

Por esa razón, muchos desarrolladores ven a Bitcoin Script como un "_walled garden_" (jardín amurallado). 

Las posibilidades que ofrece son fenomenales, pero eso nos lleva a la pregunta: ¿Qué hay más allá de esas murallas? Los innovadores, siempre en búsqueda de nuevos océanos por navegar, pensaron en ello y **la primera creación exitosa en salir del “Bitcoin Standard” fue Ethereum.** 

**Ethereum lo cambió todo con la llegada de la Ethereum Virtual Machine (EVM) y el lenguaje de programación Solidity.** La EVM fue creada para ser una máquina virtual con enormes capacidades, siendo la principal ejecutar el lenguaje de programación Solidity: Un derivado de JavaScript que tiene el poder de ser un [lenguaje Turing Complete](https://es.wikipedia.org/wiki/Turing_completo) y mucho más sencillo de aprender y programar. Básicamente, esto quiere decir que, si puedes pensar o soñar alguna herramienta digital, Solidity tiene la capacidad de hacerla realidad. En comparación, Bitcoin Script es un lenguaje del tipo Turing Incomplete, con un set de instrucciones y capacidades limitadas. 

Pero más allá de las diferencias entre la Blockchain de Ethereum y Bitcoin, los Smart Contracts siguen el mismo principio: El código es la Ley. Y ese código está grabado en la Blockchain, donde permanece protegido por la red, siendo ejecutado y verificado por los nodos que forman la misma. 

![[207.B4_evm.png]]

####  Smart Contract en Ethereum creado en lenguaje Solidity
\ pragma solidity ^0.8.0;


\ interface IERC20 {


\	function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);


\	function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);


\	event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}


\ contract ERC20Basic is IERC20 {


\	string public constant name = "ERC20Basic";
    string public constant symbol = "ERC";
    uint8 public constant decimals = 18;


\	mapping(address => uint256) balances;


\	mapping(address => mapping (address => uint256)) allowed;


\	uint256 totalSupply_ = 10 ether;


\	constructor() {
    balances[msg.sender] = totalSupply_;
    }


\	function totalSupply() public override view returns (uint256) {
    return totalSupply_;
    }


\	function balanceOf(address tokenOwner) public override view returns (uint256) {
        return balances[tokenOwner];
    }


\ function transfer(address receiver, uint256 numTokens) public override returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender]-numTokens;
        balances[receiver] = balances[receiver]+numTokens;
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }


\	function approve(address delegate, uint256 numTokens) public override returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }


\	function allowance(address owner, address delegate) public override view returns (uint) {
        return allowed[owner][delegate];
    }


\	function transferFrom(address owner, address buyer, uint256 numTokens) public override returns (bool) {
        require(numTokens <= balances[owner]);
        require(numTokens <= allowed[owner][msg.sender]);


\		balances[owner] = balances[owner]-numTokens;
        allowed[owner][msg.sender] = allowed[owner][msg.sender]-numTokens;
        balances[buyer] = balances[buyer]+numTokens;
        emit Transfer(owner, buyer, numTokens);
        return true;
    }
}

Mucho más legible, ¿no es así? Pues bien, este es un ejemplo muy básico de Smart Contract en Ethereum, de hecho, **es el código base de un token ERC-20, un Smart Contract que te permite crear una nueva moneda que funciona sobre Ethereum, teniendo su propia contabilidad y disfrutando de la seguridad de esta red.** 

Y esto es solo el principio del poder de los Smart Contracts, una tecnología que aún tiene mucho que ofrecernos dentro del universo descentralizado y Web 3.0. Un universo donde las empresas pueden ganar y ofrecer mucho a sus usuarios. 

####  Posibilidades infinitas
¿Qué podemos hacer con los Smart Contracts en Ethereum? ¿Cuáles son sus límites? La verdad es que sus límites son prácticamente infinitos.

Ejemplo:
- Pensamos en ir a un banco y solicitar un préstamo. Generalmente, una hipoteca, en la que la garantía es nuestra casa o cualquier otro inmueble de valor. 
- En consonancia con el valor del inmueble, recibiremos el préstamo del banco con determinadas condiciones, que muchas veces pueden cambiarse, bien sea por leyes o porque el banco, en su “letra pequeña” se reserva el derecho de hacer dichos cambios. Puede que lo veas como algo injusto, pero al firmar el contrato con el banco, aceptas esas condiciones, no hay vuelta atrás.
- **En Ethereum gracias a sus Smart Contracts podemos crear un contrapeso.** Las Finanzas Descentralizadas (DeFi) no son más que programas descentralizados cuyo funcionamiento está controlado por un Smart Contract. 
- **Las instrucciones del Smart Contract son claras:** No se pueden alterar y no hay “letras pequeñas”, lo escrito es lo que se cumple en todo momento. 

Pero su función no se limita a eso, podemos usar los Smart Contracts para:

1. Crear nuestro banco descentralizado
2. Ofrecer créditos
3. Tomar como garantía de esos créditos criptomonedas de gran valor en el mercado. 

**Uno de los mayores ejemplos en este sentido es** [**AAVE**](https://aave.com/)**, una plataforma DeFi que desde sus inicios redefinió la forma en la que podemos acceder a préstamos en Blockchain.** Simplemente basta con tener cierta cantidad de criptomonedas, ponerlas en el protocolo y con ello puedes solicitar un préstamo en la plataforma, usando esas criptomonedas como garantía. Es un banco, solo que no hay gerente, ni secretaría, ni asesor. Solo eres tú y el Smart Contract, no hay nada más.

#####  Pero ¿Cómo se sostiene y desarrolla una aplicación si no hay nadie que la gobierne y controle? 
- **Esto recae en la comunidad**, ya que, así como los Smart Contracts habilitan las funciones de préstamos, también es posible habilitar acciones de gobernanza. 
- **Cada persona que desea participar en la gobernanza de AAVE, debe hacer una pequeña inversión** con el fin de obtener poder de voto. 
- **La inversión garantiza que la persona actúe en pro de la plataforma**, ya que su buen funcionamiento, significa que su inversión será próspera.  
- **Los Smart Contracts habilitan a determinado número de personas que pueden decidir**, en conjunto, cuáles serán las tasas de interés, los pagos de comisiones y otros aspectos de AAVE para su buen funcionamiento y sostenibilidad. 
- No hay una sola voz gobernando el protocolo, sino que todos los que forman parte del mismo y pueden hacer valer su voz, dentro de lo que se conoce como **Organización Autónoma Descentralizada (DAO)**, otra creación posible gracias a los Smart Contracts.

**Estas dos funciones (DeFi y DAO), son solo algunas de las posibilidades que pueden construirse gracias a los Smart Contracts en Ethereum,** son parte de la creatividad de un colectivo que busca hacer de la descentralización algo común y al alcance de todos, una descentralización donde los Smart Contracts son parte fundamental para lograrla.


###  208.B4_Ethereum_Virtual_Machine-video

###  Ethereum Virtual Machine
![[208.B4_Ethereum_Virtual_Machine.mp4]]
[Ethereum Virtual Machine](https://app.web3mba.io?wvideo=ie9iw82v20)

La Ethereum Virtual Machine (EVM) es una máquina virtual que forma parte del ecosistema blockchain de Ethereum. Esta máquina virtual es capaz de ejecutar una amplia gama de instrucciones, lo que le permite una gran flexibilidad a la hora de realizar diferentes operaciones. Sin embargo, para simplificar la programación en esta máquina virtual, se creó un lenguaje especializado de alto nivel llamado Solidity. A través de este lenguaje de programación, se facilita la creación de los smart contracts. En primer lugar, Solidity se transforma en los códigos de operación de Ethereum, conocidos como Opcodes, y luego en un Bytecode. Este bytecode es finalmente ejecutado por la Ethereum Virtual Machine para realizar las operaciones especificadas en el smart contract que se escribió inicialmente.

Todo esto hace que la Ethereum Virtual Machine funcione como un verdadero computador, ejecutando desde las operaciones más sencillas hasta las más complejas. Como buen proyecto de software libre, toda esta información sobre los bytecodes y opcodes está bien documentada, así que no hay que preocuparse. En pocas palabras, dada la característica descentralizada de Ethereum y su capacidad de almacenar smart contracts en los nodos de la red, la EVM puede ejecutar las órdenes programadas en dichos smart contracts. Así, Ethereum se convierte en un gran ordenador mundial descentralizado, capaz de realizar instrucciones que resuelvan casi cualquier tarea específica. Todo esto ocurre dentro de la misma red de Ethereum.

Todas estas instrucciones se encuentran escritas en los llamados contratos inteligentes de Ethereum. Estos contratos son un tipo de cuenta que posee su propio código y se habilitan desde el momento en que llegan a la blockchain. Lo mejor de todo es que, para poder usar el potencial de la EVM, solo necesitamos tener algo de Ether e interactuar con alguna aplicación descentralizada, contrato inteligente o crear nuestro propio contrato. No existe ninguna limitación; cualquiera puede aprovechar el poder que la EVM pone a su disposición. Suena increíble, y lo es. La EVM es un trabajo de desarrollo enorme que requirió grandes esfuerzos por parte de personas muy talentosas, como Gavin Wood y Greg Colvin.

Gavin Wood fue quien creó el conocido como "Yellow Paper" de Ethereum. Este documento técnico especifica las ideas y capacidades iniciales de la EVM. Por otro lado, Greg Colvin es conocido como el principal desarrollador de la EVM. Estas dos personas, junto con el equipo que las acompañó, permitieron la creación de la Ethereum Virtual Machine, una tecnología que transformó a Ethereum en un ecosistema único dentro de las demás tecnologías que utilizan blockchain. Todo esto gracias a que la EVM es una parte integral del funcionamiento interno de Ethereum y representa una verdadera innovación en el desarrollo de estas tecnologías.

Con el fin de evitar que algún programador pueda atentar contra la seguridad de la red, la Ethereum Virtual Machine realiza una completa abstracción del sistema, manejando el acceso a los recursos de los computadores y limitando sus acciones en un ambiente controlado o de máquina virtual. A su vez, la EVM permite simplificar el desarrollo y la actualización de aplicaciones y características disponibles. La Ethereum Virtual Machine permite el diseño y la ejecución de smart contracts. Además, gracias a Solidity y otros lenguajes soportados, podemos crear estos smart contracts de forma sencilla y manejable. Aunque la EVM por sí misma no es capaz de ejecutar directamente el lenguaje, sí lo hace mediante una técnica conocida como compilación de instrucciones. Con esta técnica, podemos obtener los opcodes necesarios.

Por su parte, Solidity es un lenguaje de programación de alto nivel, muy similar a JavaScript o C++. Este lenguaje está orientado a la creación de contratos inteligentes. De esta forma, la mayor parte del código fuente de los contratos está escrito en este lenguaje y, después, se compila a esos códigos de operación comprensibles para la Ethereum Virtual Machine. La EVM utiliza estos códigos de operación, o opcodes, para crear los contratos inteligentes y realizar tareas específicas. Estas limitaciones llevan a la EVM a crear métodos de trabajo que le permitan realizar sus operaciones. Entre ellas, una de las más importantes es la memoria de contratos. Dicha memoria sirve para almacenar información a la que la EVM podrá acceder rápidamente en el futuro.

Por otro lado, para almacenar datos de manera indefinida y hacerlos accesibles para futuras ejecuciones de contratos, se puede usar el almacenamiento por contratos. Este actúa, esencialmente, como una base de datos pública desde la cual los valores se pueden leer externamente sin tener que enviar una transacción al contrato, es decir, sin comisiones. Los opcodes son una parte muy importante y esencial de la Ethereum Virtual Machine. Estos códigos de operación definen las operaciones válidas que la EVM puede realizar. En la Ethereum Virtual Machine existe la capacidad de ejecutar hasta 256 opcodes distintos, aunque en la actualidad no se han definido tantos códigos. La razón es que el desarrollo de la EVM no ha requerido la creación de tales códigos, y los desarrolladores son cuidadosos al incluir nuevos códigos debido a estas limitaciones en los números mencionados.

Un aspecto importante de los opcodes es que son un nivel intermedio de programación para la Ethereum Virtual Machine. El primer nivel está dado por Solidity y otros lenguajes de programación de alto nivel similares. Un segundo nivel serían estos opcodes, y por último tendríamos el bytecode, que es el resultado de compilar los opcodes. Básicamente, el bytecode es el equivalente al lenguaje máquina de la Ethereum Virtual Machine, algo prácticamente imposible de entender y describir para un ser humano. Sin embargo, al ser Ethereum una blockchain pública y un proyecto que aboga por la apertura y transparencia, el lenguaje bytecode de la EVM se puede descompilar. Es decir, podemos transformar el bytecode en opcodes y de allí volver a llevarlo a un lenguaje cercano a Solidity. Esto es importante, ya que brinda a la Ethereum Virtual Machine la capacidad de mantener de forma abierta y clara el contenido de un smart contract, además de permitir reconocer la ABI de la que dispone.

Un dato relevante es que la ABI se refiere a cómo se pueden codificar las llamadas de un contrato para la EVM y, al revés, cómo leer los datos de las transacciones que genera dicho contrato. La red de Ethereum ha sido nombrada como la computadora global, debido a que cada uno de los nodos conectados a la red ejecuta una instancia de la EVM, al mismo tiempo que todos realizan las instrucciones de forma idéntica con el fin de mantener un consenso sobre el estado del sistema. Esta particularidad de Ethereum hace que su cálculo sea un poco más lento y costoso en comparación con un ordenador común, pero le brinda mayores ventajas, como una alta defensa contra fallas bizantinas, una mayor protección e integridad de los datos y una mayor resistencia a la censura. Así, Ethereum funciona como una computadora mundial descentralizada de uso general, en una red entre pares, una red peer-to-peer.

Los smart contracts y las aplicaciones descentralizadas desarrolladas en la Ethereum Virtual Machine podrían incluso asumir funciones de internet, tal como la conocemos hoy en día. Además, podrían permitirnos la creación de economías más estables, ya que su funcionamiento puede ser garantizado y no está sujeto a interpretaciones humanas. Con la aplicación de elementos como la distribución de archivos, la ejecución de contratos inteligentes, las aplicaciones descentralizadas y muchos otros, se elimina la necesidad de confiar en terceros, ya que, si no se cumplen estos términos programados, simplemente el contrato no se ejecutará. Sin embargo, podemos comparar su nacimiento y desarrollo con la Internet de los años 90. Nadie tiene idea de lo que traerá el futuro. Pero, sin duda alguna, la Ethereum Virtual Machine evolucionará con el tiempo y le permitirá convertirse en una red mucho más sólida.

Un ejemplo de esa evolución lo podemos ver en las distintas actualizaciones que se han ido dando a la misma. Por ejemplo, las actualizaciones de Byzantium, Constantinople, Estambul y London. En estos casos, la Ethereum Virtual Machine sufrió varios cambios, agregándose nuevos opcodes y mejorando ciertas prestaciones de la misma. En un futuro, con la llegada de la Ethereum Virtual Machine 2.0, la EVM evolucionará hasta ser finalmente reemplazada por lo que se llama eWASM, Ethereum Web Assembly, el cual mejorará enormemente las capacidades de generación de aplicaciones descentralizadas dentro de Ethereum 2.0. La EVM permite el desarrollo de una mayor cantidad de aplicaciones y que estas puedan ejecutarse sobre una misma red blockchain sin afectar a otras operaciones que estén dentro de la misma red.

Los contratos inteligentes diseñados en la Ethereum Virtual Machine son invariables y pueden ejecutarse y hacerse cumplir de manera autónoma y automática, eliminando la burocracia, los altos costos y el tiempo de espera típicos de los contratos tradicionales. Sin embargo, la Ethereum Virtual Machine es sustancialmente menos eficiente que muchas otras máquinas virtuales convencionales. Esto se debe, básicamente, a que su diseño se basó en la utilidad del momento y no en un alto rendimiento. Los cambios y mejoras experimentados por la Ethereum Virtual Machine han sido pocos hasta ahora, por lo que no está optimizada en cuanto a la velocidad para las distintas plataformas de hardware que existen. El diseño de la Ethereum Virtual Machine no está dirigido a la portabilidad, lo que limita los espacios en los que dicha máquina virtual puede implementarse y ejecutarse.

Como has podido ver, estas son algunas de las características y el funcionamiento de la Ethereum Virtual Machine, que al final es, de alguna manera, el corazón de Ethereum y lo que permite que se puedan ejecutar estos smart contracts.


###  209.B4.U3.4_Smart_Contracts-Ethereum_Virtual_Machine

###  ¿Qué es la EVM?
Ethereum Virtual Machine o EVM, es una máquina virtual que forma parte del ecosistema Blockchain de Ethereum. 

Es capaz de ejecutar una amplia gama de instrucciones que le permiten una gran flexibilidad a la hora de realizar distintas operaciones.

Sin embargo, para hacer más sencilla la programación para esta máquina virtual se creó un lenguaje especializado de alto nivel llamado Solidity. A través de este lenguaje de programación se facilita la creación de los Smart Contracts. 

**En primer lugar, se transforma Solidity a los códigos de operación de Ethereum (OP_CODES) y luego a un bytecode. Este bytecode es finalmente ejecutado por la EVM para realizar las operaciones especificadas en un Smart Contract.** Todo ello hace que la EVM puede funcionar como un computador de verdad, ejecutando desde las más sencillas hasta las más complejas operaciones. 

Como buen proyecto de software libre, toda esta información sobre los bytecodes y OP_CODES está bien documentada y un espacio excelente para leer sobre esto, es [Ethereum Virtual Machine Opcodes (ethervm.io)](https://www.ethervm.io/)

  ![[209.B4_opcodes.png]]
_Imagen 1: Muestra de algunos OP_CODES dentro de la EVM_

Así, en pocas palabras, dada la característica descentralizada de Ethereum y su capacidad de almacenar Smart Contracts en los nodos de la red, y que con EVM pueden ejecutarse las órdenes programadas en dichos Smart Contracts, **Ethereum se convierte en un gran ordenador mundial descentralizado.** Uno que es capaz de realizar instrucciones que lleven a la resolución de cualquier tarea específica. De hecho, puede resolver casi cualquier problema computacional y todo esto ocurre dentro de la misma red Ethereum.

Todas estas instrucciones se encuentran escritas en los llamados contratos inteligentes de Ethereum.  

- Estos contratos son un tipo de cuenta que posee su propio código, y se habilita desde el mismo momento en el que llegan a la Blockchain. 
- Lo mejor de todo es que para poder usar el potencial de EVM tan solo debemos tener algo de Ether e interactuar con alguna DApp, contrato inteligente o hacer nuestro propio contrato. 
- No existe ninguna limitación, cualquiera puede aprovechar el poder que EVM tiene a su disposición.

**Suena increíble y lo es, EVM es un trabajo de desarrollo enorme que requirió de enormes esfuerzos por parte de gente muy talentosa, y que conocerás a continuación.**

####  ¿Quién la creó?
Las mentes maestras detrás del desarrollo de la EVM son Gavin Woods y Greg Colvin.

Gavin Woods fue quien creó el conocido Yellow Paper de Ethereum. 

En dicho documento técnico, se especifican las ideas y capacidades iniciales de la EVM. Por otro lado, Greg Colvin es conocido como el principal desarrollador de la EVM.

Estas dos personas y el equipo que las acompañó, permitieron la creación de la EVM. Una tecnología que transformó a Ethereum en un ecosistema único dentro de las demás tecnologías que usan Blockchain. Todo gracias a que EVM es una parte integral del funcionamiento interno de Ethereum y representa una verdadera innovación en el desarrollo de estas tecnologías.

![[209.B4_yellow_paper.png]]
_Imagen 2: Introducción del Yellow Paper de la EVM_

####  ¿Cómo funciona la Ethereum Virtual Machine (EVM)?
Con la finalidad de evitar que algún programador pueda atentar contra la seguridad de la red, la EVM realiza una completa abstracción del sistema.

Manejando el acceso a los recursos de los computadores y limitando sus acciones en un ambiente controlado o de máquina virtual.

A su vez, la EVM permite simplificar el desarrollo y actualización de aplicaciones y características disponibles para las aplicaciones descentralizadas.

La EVM permite el diseño y la ejecución de Smart Contract. Además, gracias a Solidity (u otros lenguajes soportados) podemos crear estos Smart Contracts de forma sencilla y manejable. **Aunque la EVM por sí misma no es capaz de ejecutar directamente este lenguaje, si lo hace por medio de una técnica conocida como ==compilación de instrucciones,== con el cual obtenemos los OP_CODES necesarios.** 

Por su parte, Solidity es un lenguaje de programación de alto nivel muy similar al JavaScript y a C++. Este lenguaje está orientado a la creación de contratos inteligentes. De esta forma, la mayor parte del código fuente de los contratos está escrito en este lenguaje y luego se compilan en códigos de operación comprensible para la EVM.

![[209.B4_virtual_machine.png]]
_Imagen 3: Estructura básica de cómo funciona la EVM_

**La EVM utiliza estos códigos de operación (OP_CODES) para realizar tareas específicas.** Estas limitaciones llevan a la EVM a crear métodos de trabajo que le permitan realizar sus operaciones, entre ellas la más importante es la **memoria de contratos.** Dicha memoria sirve para almacenar información a la que la EVM puede acceder rápidamente. Por otra parte, para almacenar datos de manera indefinida y hacerlos accesibles para futuras ejecuciones de contratos, se puede usar el almacenamiento por contratos. Esta actúa esencialmente como una base de datos pública, desde la cual los valores se pueden leer externamente sin tener que enviar una transacción al contrato, es decir, sin comisiones.

**Los OP_CODES son una parte muy importante y esencial de la EVM.** Estos códigos de operación son los que definen las operaciones válidas que la EVM puede realizar. En EVM existe la capacidad de ejecutar hasta 256 OP_CODES distintos, aunque en la actualidad no existen esta cantidad de códigos definidos. La razón es que **el desarrollo de EVM no ha requerido de la creación de tales códigos y los desarrolladores son cuidadosos con incluir nuevos códigos debido a las limitaciones en sus números.**

**Un aspecto importante de los OP_CODES, es que este es un nivel intermedio de programación para la EVM.** El primer nivel vendría dado por Solidity y los lenguajes de programación de alto nivel similares a este. Un segundo nivel de profundidad serían los OP_CODES. Por último, tendríamos el bytecode resultado de compilar los OP_CODES en el equivalente a lenguaje máquina de la EVM, algo prácticamente imposible de entender y escribir por un ser humano.

Sin embargo, al ser Ethereum una Blockchain pública y ser un proyecto que aboga por la apertura y transparencia, el lenguaje bytecode de la EVM se puede descompilar. Es decir, podemos transformar el bytecode a OP_CODES y de allí llevarlo a un lenguaje cercano a Solidity. **Esto es importante, puesto que brinda a EVM la capacidad de mantener de forma abierta y clara el contenido de un Smart Contract.** Además de permitir reconocer la ABI de la que dispone. Un dato importante, puesto que se trata básicamente de cómo puede codificar llamadas de un contrato para el EVM y, al revés, cómo leer los datos de las transacciones que genera dicho contrato.

####  Evolución futura de la EVM
La red de Ethereum ha sido nombrada como la computadora global debido a que cada uno de los nodos conectados a la red ejecuta una instancia de la EVM.

Al mismo tiempo que todos realizan las instrucciones de forma idéntica con el fin de lograr y mantener un consenso sobre el estado del sistema.

**Esta particularidad de Ethereum hace que su cálculo sea más lento y costoso en comparación con un ordenador común.** **Pero le brinda mayores ventajas, como por ejemplo una alta defensa a las** [**fallas bizantinas,**](https://ciberseguridad.com/guias/nuevas-tecnologias/criptomoneda/tolerancia-fallas-bizantinas/) **una mayor protección e integridad de los datos y una mayor resistencia a la censura.**

Así, Ethereum funciona como una computadora mundial descentralizada de uso general en una red entre pares. **Los Smart Contract y las DApps desarrolladas en la EVM podría incluso asumir las funciones de Internet tal y como las conocemos.** **Además, podría permitirnos la creación de economías más estables,** ya que su funcionamiento puede ser garantizado y no está sujeto a interpretaciones humanas.

> Con la aplicación de elementos como la distribución de archivos, la ejecución de contratos inteligentes, las aplicaciones descentralizadas y muchos otros, se elimina la confianza en terceros, ya que, si no se cumplen los términos programados, simplemente el contrato no se ejecutará.

**Sin embargo, podemos comparar su nacimiento y desarrollo con la Internet de los años 90. Nadie tiene idea lo que traerá en el futuro. Pero sin duda alguna, la EVM evoluciona con el tiempo y le permitirá a la red convertirse en una mucho más sólida.** Un ejemplo de esa evolución la podemos ver en las distintas actualizaciones que se han dado a la misma. Por ejemplo: en los Hard Fork Byzantium y Constantinople, Istambul, London y Homestead, la EVM sufrió de varios cambios agregándose nuevos OP_CODES y mejorando ciertas prestaciones de la misma. En un futuro, con la llegada de EVM 2.0, la EVM evolucionará hasta que sea finalmente reemplazada por **eWASM (Ethereum Web Assembly)** el cual mejorará enormemente las capacidades de generación de dApps dentro de Ethereum 2.0.

####  Característica de las EVM
La Ethereum Virtual Machine es un software que posee muchas características o cualidades tanto positivas como negativas. Entre ellas podemos mencionar:
1. **La EVM está enfocada en proporcionar seguridad y ejecutar códigos no confiables** en computadoras de todo el mundo.
2. **Las aplicaciones descentralizadas y los contratos inteligentes desarrollados en la EVM son completamente descentralizados y distribuidos.** Por lo que no requiere de la participación de terceros. Ni pueden ser modificadas ni alteradas.
3. **La EVM permite el desarrollo de una mayor cantidad de aplicaciones,** y que estas puedan ejecutarse sobre una misma red Blockchain, sin afectar otras operaciones.
4. **Los contratos inteligentes diseñados en la EVM son invariables y pueden ejecutarse y hacerse cumplir por sí mismo, de una manera autónoma y automática.** Con lo que se elimina la burocracia, los altos costos y el tiempo de espera típicos en los contratos tradicionales.
5. **La EVM es sustancialmente menos eficiente que muchas otras máquinas virtuales convencionales.** Esto se debe a que principalmente su diseño se basó en la utilidad del momento y no en el alto rendimiento.
6. **Los cambios y mejoras experimentados por la EVM han sido pocos hasta ahora.** Por lo que no está optimizada en cuanto a la velocidad para distintas plataformas de hardware.
7. **El diseño de la EVM no está dirigido a la portabilidad,** lo que limita los espacios en los que dicha máquina virtual puede implementarse.


###  210.B4_Solidity-video

###  Solidity
![[210.B4_Solidity.mp4]]
[Solidity.mp4](https://app.web3mba.io?wvideo=o1yv9r7686)

El nombre de Solidity hace referencia a un lenguaje de alto nivel de tipo estático que permite programar smart contracts para la red Ethereum. Su sintaxis es muy similar a la de lenguajes conocidos como C++ o JavaScript. Solidity fue creado con el propósito de facilitar la escritura de smart contracts de forma sencilla para la red Ethereum. Se trata de un lenguaje diseñado para aprovechar al máximo la EVM, permitiendo la creación y desarrollo de smart contracts que puedan ser ejecutados de manera óptima en ella.

El programador puede desarrollar sus aplicaciones en un lenguaje fácil de utilizar, leer y mantener, para que, al finalizar, el motor de Solidity convierta ese código sencillo en el código máquina que la EVM puede entender. Este código máquina es prácticamente imposible de interpretar por una persona. En esencia, Solidity facilita el desarrollo de smart contracts sobre Ethereum. Aunque no es el único lenguaje, sí fue el primero y el más versátil, además de ser el que más contratos inteligentes tiene desarrollados en la actualidad.

La principal característica de Solidity es que es un lenguaje Turing completo. Un lenguaje Turing completo permite una gran diversidad de operaciones y, por lo tanto, la generación de aplicaciones para prácticamente cualquier tipo de problema. El hecho de que sea Turing completo también implica que se debe contar con un mecanismo de protección para evitar el mal uso. Este mecanismo es conocido como "gas" y sirve para prevenir que el sistema, que es la Ethereum Virtual Machine, pueda colapsar debido a la creación de bucles infinitos u otras acciones maliciosas.

El gas funciona como el gasto computacional que conlleva procesar una transacción o un smart contract dentro de la red. Podríamos hacer una pequeña analogía y compararlo con los kilovatios hora de la electricidad. Al final, nos permitirá tener una compensación de precio entre la fluctuación del precio de Ethereum y el costo que debemos pagar por realizar una transacción dentro de la Ethereum Virtual Machine.

Ethereum nació como una alternativa a la red de Bitcoin. Su creador, Vitalik Buterin, propuso en su momento incorporar un lenguaje de tipo Turing completo a la red de Bitcoin, ya que consideraba que el lenguaje con el que fue desarrollado Bitcoin era insuficiente para la evolución de la red. Sin embargo, al no recibir respuesta por parte de los desarrolladores, Buterin decidió crear y desarrollar su propio proyecto: Ethereum. Hoy en día, Bitcoin y Ethereum son las dos redes más valiosas y conocidas, ocupando el primer y segundo lugar, respectivamente.

No obstante, Bitcoin y Ethereum poseen grandes diferencias. Por ejemplo, Bitcoin, la moneda de la red Bitcoin, fue creada como medio de pago y como resguardo de valor, mientras que Ethereum fue desarrollada con la finalidad de ser mucho más flexible y programable, permitiendo evolucionar con nuevas capacidades a lo largo del tiempo. Esto es gracias a la EVM y a Solidity, las dos herramientas que permiten a los desarrolladores aprovechar al máximo Ethereum, facilitando la tarea de desarrollar aplicaciones distribuidas y otras funciones que hacen uso de los smart contracts.

El desarrollo de Ethereum comenzó como una idea en la mente de Gavin Wood. Esta idea fue materializada por Christian Rittwisner junto a un equipo de trabajo, y el resultado de este esfuerzo llegó a ser Solidity. Desde entonces, el desarrollo de Solidity ha mantenido su evolución y, en la actualidad, se encuentra en la versión 0.8.13, a fecha de 16 de marzo de 2022. Solidity es un lenguaje orientado a objetos, similar a C++ o C#. Fue diseñado específicamente para desarrollar aplicaciones para la red de Ethereum, por lo que solo corre en la blockchain de Ethereum o en otras derivadas compatibles, como Polygon.

Una ventaja de este lenguaje es que el código fuente de los programas realizados con él puede ser accedido públicamente desde la red blockchain. Incluso estando en bytecode, es posible compilarlo y obtener una muestra bastante clara de cómo era el código fuente original. Solidity soporta la herencia y la herencia múltiple, lo que le otorga una gran flexibilidad a la hora de programar elementos complejos. Este lenguaje también proporciona una serie de bibliotecas muy útiles que facilitan la programación de los smart contracts, haciendo que el código sea reutilizable y mucho más sencillo de mantener.

Como casi todo lenguaje de programación, Solidity puede aprovechar las ventajas de un entorno integrado de desarrollo (IDE). En Ethereum, el IDE oficial es conocido como Remix. Este facilita a los desarrolladores la creación de smart contracts, al mismo tiempo que permite acceder al estado y propiedades de estos contratos ya creados. Además, cuenta con poderosas herramientas de corrección y análisis de código para ayudar a los desarrolladores a depurar sus programas. Remix también puede ser ejecutado y utilizado de forma online a través de navegadores como Firefox o Chrome, o directamente en nuestro ordenador. Aunque este es el IDE oficial de Ethereum, también existen otros entornos compatibles con el lenguaje de Solidity.


###  211.U3.5_Smart_Contracts-Solidity

###  ¿Qué es Solidity?
El nombre de Solidity hace referencia a un lenguaje de alto nivel de tipado estático con el que se pueden programar Smart Contracts para la red de Ethereum.

De sintaxis es muy similar a C++ o Javascript, Solidity fue creado con el propósito de permitir la escritura de Smart Contracts de forma sencilla para la red Ethereum.

Se trata de un lenguaje diseñado para sacar el máximo provecho a la Ethereum Virtual Machine, permitiendo la creación y desarrollo de Smart Contracts que puedan ser ejecutados de forma óptima en la EVM.

Para ello, el programador puede desarrollar sus aplicaciones en un lenguaje sencillo de utilizar, leer y mantener para que, al terminar, el motor de Solidity convierta ese código sencillo en el código máquina que la EVM entenderá. Un código máquina prácticamente imposible de entender por una persona.

En esencia, Solidity facilita el desarrollo de Smart Contracts sobre Ethereum y, aunque no es el único lenguaje, sí fue el primero, el más versátil y sobre el que más contratos inteligentes hay desarrollado.

  ![[211.B4_solidity.png]]

####  Un lenguaje Turing Complete
Gracias a Solidity y a su relación con la EVM, los desarrolladores pueden realizar programas que sean Turing Complete.

Esto se debe a que EVM posee la capacidad de ejecutar cualquier código que sea definido por un desarrollador dentro del marco de sus capacidades.

Esto representa una gran ventaja para la red Ethereum. Gracias a EVM y Solidity los desarrolladores pueden programar acciones que luego serán ejecutadas por la EVM de forma descentralizada en la red Ethereum. Pero esto también **implica que se debe disponer de un mecanismo de protección para evitar su mal uso. Este mecanismo es conocido como ==Gas== y sirve para evitar que el sistema pueda ser colapsado por la creación de bucles infinitos u otras acciones maliciosas. Este Gas funciona como el gasto computacional que conlleva procesar una transacción o un Smart Contract en la red.**

####  Importancia y desarrollo de Solidity
Su creador, Vitalik Buterin, propuso incorporar un lenguaje tipo Turing Complete a la red Bitcoin.

Consideraba que el lenguaje con el que fue desarrollado Bitcoin era insuficiente para la evolución de la red. 

Pero al no recibir ninguna respuesta por parte de los desarrolladores, Buterin decidió crear y desarrollar su propio proyecto: **Ethereum.**

> Hoy en día, Bitcoin y Ethereum son las redes más valiosas, conocidas y empleadas por la comunidad de las criptomonedas. 

Ocupando el primer y segundo lugar respectivamente. No obstante, Bitcoin y Ethereum poseen grandes diferencias. Por ejemplo, Bitcoin, la moneda de la red Bitcoin, fue creada como medio de pago y de resguardo de valor.  Mientras que **Ethereum, fue desarrollada con la finalidad de ser mucho más flexible y programable permitiéndole evolucionar con nuevas capacidades en el tiempo.**

Esto gracias a EVM y Solidity, las dos herramientas que permiten a los desarrolladores sacar el máximo provecho de Ethereum. Con Solidity, se facilita la tarea de desarrollar aplicaciones distribuidas (DApps) u otras funciones que hagan uso de los Smart Contracts.

El desarrollo de Ethereum comenzó como una idea en la mente de Gavin Wood en 2014. La idea fue materializada por Christian Reitwiessner junto a un equipo de trabajo. El resultado de este trabajo llevó a Solidity. Desde entonces, el desarrollo de Solidity ha mantenido su evolución y en la actualidad se encuentra en la versión 0.8.13 del lenguaje (16 de marzo de 2022).

####  Características de Solidity
1. Es un tipo de lenguaje orientado a objetos (OO) como C++ y C#.
2. **Fue diseñado específicamente para desarrollar aplicaciones para la red Ethereum.** Por lo que solo corre en la blockchain Ethereum o derivadas compatibles.
3. **Una ventaja que posee este lenguaje es que el código fuente de los programas que son realizados con él puede ser accedido públicamente desde la blockchain.** Incluso estando en bytecode, es posible descompilarlo y obtener una muestra bastante clara del código fuente original.
4. **Solidity soporta la herencia y la herencia múltiple,** dotándolo de una gran flexibilidad a la hora de programar elementos complejos.
5. **Este lenguaje también proporciona una serie de bibliotecas muy útiles** que facilitan la programación de los Smart Contracts, haciendo que el código sea reutilizable y más sencillo de mantener.

####  Entornos de desarrollos disponibles
Como casi todo lenguaje de programación, Solidity puede explotar las ventajas de un entorno integrado de desarrollo o IDE.

En Ethereum, el IDE oficial es conocido como Remix. 

Este facilita a los desarrolladores la creación de Smart Contract, a la vez que permite tener acceso al estado y propiedades de los Smart Contract ya creados. Además, cuenta con poderosas herramientas de corrección y análisis de código para ayudar a los desarrolladores a depurar sus programas.

Remix también puede ser ejecutado y usado de forma online a través de Firefox o Chrome o directamente en nuestro ordenador. Y aunque este es el IDE oficial de Ethereum, también existen otros entornos compatibles con el lenguaje Solidity. 

**Atom es una herramienta editable que se puede emplear para personalizar cualquier cosa. Podemos encontrar un paquete conocido como Etheratom que emplea la biblioteca web3.js para interactuar con un nodo de Ethereum.**

Otro IDE que podemos encontrar es el plugin Visual Studio Code, creado por Microsoft. Este permite la creación y desarrollo de Smart Contract a través de un compilador de Solidity. También permite la creación de aplicaciones para Microsoft y aplicaciones webs modernas y servicios en la nube que usen su servicio Azure.


###  212.U3.6_Smart_Contracts-Otros_lenguajes

###  Otros lenguajes de programación para Smart Contracts
Los Smart Contracts pueden ser escritos en distintos lenguajes de programación.

Siempre y cuando exista el compilador y librerías capaces de traducir y servir de interfaz con las distintas capacidades Smart Contracts de la Blockchain que usemos.

Esto significa que es posible usar cualquier lenguaje de programación para crearlos, pero los desarrolladores de la Blockchain deben crear el set de herramientas básico para tal fin.

En tal sentido, algunos de los lenguajes de programación que podemos usar para crear Smart Contracts son los siguientes.

1. Bitcoin Script
2. Miniscript
3. Vyper
4. Cairo
5. Haskell
6. C++

####  1 | Bitcoin Script
El lenguaje de programación por defecto es Bitcoin Script. Este es un lenguaje de programación diseñado para Bitcoin y es el responsable de permitir la programación de transacciones dentro de la red, para hacer que Bitcoin cumpla con la premisa de “dinero digital programable”.

Si bien, Bitcoin Script es un lenguaje de programación bastante limitado debido a que no es Turing Completo y que funciona mediante un esquema de tipo pila. 

> Esto hace que Bitcoin Script no solo sea complejo de programar, sino también limitado en las características y funciones que presenta. 

**De hecho, Bitcoin Script está limitado a solo 256 tipos de instrucciones distintas, conocidas como OP_CODES,** muchas de las cuales aún no han sido definidas porque Satoshi Nakamoto las dejó en blanco. El fin de esto era mejorar sus capacidades en el futuro, pensando en las necesidades que pudiera tener la red en los años por venir. 

![[212.B4_bitcoin_script.png]]

El lenguaje Script de Bitcoin posee varias características y cualidades, entre las que podemos mencionar:
1. **Es simple** y requiere de un procesamiento mínimo.
2. **Su funcionalidad es limitada,** lo que aporta mayor seguridad al sistema.
3. **Al ser un lenguaje Turing Incomplete no posee bucles, por lo que se asegura que el programa deja de repetirse y termina.** Así, se evita la posibilidad de que ocurran errores y códigos maliciosos a la red Bitcoin.
4. Su simplicidad le permite ser **implementado en una amplia gama de dispositivos.**
5. No hay un estado anterior o posterior a la ejecución del script. **Toda la información necesaria para ejecutar el script debe estar contenida en él.**
6. **Está basado en una pila y puede usar dos tipos: Una principal y otra alternativa.** Donde esta última se emplea para el almacenamiento de datos de cálculos de pasos intermedios de una forma muy parecida a la tecla memoria en las calculadoras.
7. **El lenguaje de script de Bitcoin es bastante pequeño.** Solo puede contener 256 instrucciones, ya que cada instrucción está expresada en un byte.

> El propósito de la creación de un lenguaje script en Bitcoin, es el de proporcionar una serie de parámetros fáciles y flexibles para poder posibilitar una transacción.

**Cuando Satoshi Nakamoto desarrolló Bitcoin deshabilitó varias funciones, entre ellas la multiplicación.** Por lo que el script se mantiene simple en términos de programación. Entonces, este lenguaje de programación es lo que determina si una operación puede realizarse o no. Es decir, si dicha operación está autorizada para la transferencia de fondos.

En pocas palabras, **la creación del Bitcoin Script es lo que otorga la naturaleza programable de Bitcoin.** Es lo que nos permite, por ejemplo, enviar una transacción que la misma se valide solo si determinadas condiciones se cumplen. E**sta propiedad es algo único de Bitcoin y las criptomonedas, algo que el dinero digital actual no puede alcanzar**, y mucho menos el arcaico dinero físico. **Es la evolución del dinero** llegado a un punto en que incluso este puede actuar de forma independiente y descentralizada, atendiendo simplemente a la programación incrustada en él.

Por otra parte, el script de Bitcoin también evita la creación de errores en el sistema y el uso innecesario de transacciones muy complejas. De hecho, el script hace que las transacciones sean relativamente fáciles de calcular. Además, los bucles infinitos requieren muchísima más potencia de cálculo y ralentizan las redes, como se mencionó al principio.

Un ejemplo de Bitcoin Script sería el siguiente:

######  OP_DUP
OP_HASH160
OP_PUSHBYTES_20 0706a504a6b9af3bc99a6554f4d5e167a107b40d
OP_EQUALVERIFY
OP_CHECKSIG

ScriptPubKey (HEX)76a9140706a504a6b9af3bc99a6554f4d5e167a107b40d88ac

Este sencillo script conocido como P2PKH, sencillamente hace una verificación de la PubKey (en hexadecimal) para saber si es correcto el parámetro OP_PUSHBYTE_20. Para ello hace una duplicación pubKey, aplica un OP_HASH160 (corresponde a un hash SHA-256 y luego un RIPEMD-160), realiza un PUSH de los primeros 20 bytes del parámetro (0706a504a6b9af3bc99a6554f4d5e167a107b40d) y verifica si son correctos. Si es cierto, entonces chequea la firma digital y permite el uso de Bitcoin. 

En este caso falta la sección ScriptSig, pero ello no impide la verificación que la transacción está usando el estándar SegWit de Bitcoin. En todo caso, puedes verificar esta operación en la siguiente imagen:

![[212.B4_verifiicacion.png]]   

####  2 | Miniscript
Miniscript es un lenguaje de programación que facilita la generación de Smart Contracts para Bitcoin.

**Permite que el software analice automáticamente un script, incluyendo la determinación de los datos de los testigos que deben generarse para gastar los Bitcoin protegidos por ese Script.**

La representación estructurada de los scripts de Bitcoin proporcionada por Miniscript permite a los monederos ser mucho más dinámicos con los scripts que utilizan. Para apoyar ese dinamismo, los Miniscripts pueden ser creados usando un lenguaje de políticas de fácil escritura. Las políticas son componibles, permitiendo que cualquier sub-expresión válida sea reemplazada por otra sub-expresión válida (dentro de ciertos límites impuestos por el sistema Bitcoin).

Inicialmente, el lenguaje fue diseñado para ser parecido a JavaScript, sin embargo, el desarrollo del proyecto dejo ese desarrollo y lo traslado a Rust, el cual sigue en desarrollo y ya se encuentra en proceso de ser integrado a Bitcoin Core, con varias propuestas para agregar soporte oficial a este lenguaje. 

![[212.B4_miniscript.png]]

De esa forma, Miniscript se transformaría en un crate de Rust, que permitiría usar Rust para realizar Smart Contracts para Bitcoin, todo un adelanto que permitirá a Bitcoin disfrutar de potentes Smart Contracts Turing Completo dentro de su estructura. 

####  3 | Vyper
Vyper es un lenguaje de programación basado en Python dirigido a crear Smart Contracts para la máquina virtual de Ethereum (EVM). 

**Al estar basado en Python, este lenguaje disfruta de una enorme facilidad para desarrollar dApps para quienes están acostumbrados a este lenguaje, y al mismo tiempo, se alimenta de las potentes herramientas de depuración que están creadas para él.**

Entre sus principales objetivos tenemos: 
1. **Ofrecer una mejor seguridad,** ya que debería ser posible y natural construir contratos inteligentes seguros en Vyper.
2. **Simplicidad del lenguaje y del compilador:** El lenguaje y la implementación del compilador deben esforzarse por ser simples.
3. **Mejorar la auditoría del código.** El código de Vyper debe ser lo más legible posible. Además, debe ser lo más difícil posible escribir código engañoso. La simplicidad para el lector es más importante que la simplicidad para el escritor, y la simplicidad para los lectores con poca experiencia previa con Vyper (y poca experiencia previa con la programación en general) es particularmente importante.
4. **Permite una mejor comprobación de límites y desbordamiento,** especialmente en los accesos a arrays y en la aritmética.
5. **Soporte para enteros con signo y números decimales de punto fijo.** 
6. **Decidibilidad:** Es posible calcular un límite superior preciso para el consumo de gas de cualquier llamada a una función de Vyper.
7. **Tipificación fuerte,** para evitar los problemas de seguridad que el tipado dinámico puede traer. 
8. **Código del compilador pequeño y comprensible.** 
9. **Soporte limitado para funciones puras:** Cualquier cosa marcada como constante no puede cambiar el estado, lo que ayuda a mejorar la seguridad.

Vyper puede ser usado en Ethereum o en cualquier red EVM compatible como Polygon, BNB Chain, u otras redes derivadas de la EVM y sus primitivas criptográficas.

####  4 | Cairo
Es un lenguaje para escribir programas demostrables.La ejecución de un programa Cairo produce una traza que puede ser enviada a un prover sin confianza, que genera una prueba STARK para la validez de la declaración o el cálculo representado por el programa Cairo. 

La prueba puede entonces ser verificada utilizando un verificador (que puede o no estar en la cadena).

Cairo no es un lenguaje de Blockchain y, por tanto, no puede utilizarse para escribir contratos inteligentes (aunque puede llegar a serlo, más adelante). Sin embargo, Cairo es especialmente útil para crear funciones donde el uso de criptografía ZKP es esencial para mantener la seguridad y privacidad, de allí que se haya ganado un espacio en el desarrollo de dApps pensadas en proteger la privacidad, especialmente en plataformas de identidad soberana, DEX sobre zk-Rollups o cualquier aplicativo que use criptografía ZKP. 

####  5 | Haskell
Haskell en un lenguaje de programación muy usada en el mundo científico, y es el lenguaje elegido por Cardano.

**Haskell destaca por ser un lenguaje de programación funcional, que es muy adecuado para código de alta seguridad y programas que requieren un alto grado de verificación formal.**

Esto permite a los programadores puedan tener un mayor grado de certeza de que el código que han implementado es correcto, lo que sin duda ayuda a mantener la seguridad de los Smart Contracts y de las plataformas que dependen de ellos. 

**En Cardano, Haskell permite que los contratos inteligentes de Plutus y Marlowe pueden ser cuidadosamente implementados en un código preciso y formalmente verificado que ofrece un alto nivel de seguridad desde el principio.** Plutus y Marlowe se ofrecen como un conjunto de bibliotecas para Haskell, aprovechando la documentación existente de Haskell, los juegos de herramientas y una comunidad altamente profesional para proporcionar una base a partir de la cual construir contratos inteligentes seguros y de calidad empresarial.

Tanto el código off-chain como on-chain de Cardano está escrito en Haskell, lo que permite a Cardano heredar el rico cuerpo de investigación que ya existe dentro del ecosistema de Haskell, en lugar de reinventar la rueda con un lenguaje de contratos inteligentes totalmente nuevo y no probado. Básicamente, Haskell es un lenguaje que ha sido probado, que es seguro y que puede ser perfectamente utilizado para crear Smart Contracts Turing Completo que pueden ser verificados formalmente en todo momento. 

####  6 | C++
El lenguaje de programación C++ es un viejo conocido en el mundo de la programación. Es usado como lenguaje de programación para Smart Contracts en EOS. 

De esta manera, los desarrolladores pueden crear contratos inteligentes en EOSIO utilizando el lenguaje de programación C++. 

El kit de herramientas de desarrollo de contratos de EOSIO o EOSIO.CDT proporciona las bibliotecas y herramientas necesarias para construir un contrato inteligente. Consulte el manual de EOSIO.CDT para obtener más detalles sobre cómo empezar con EOSIO.CDT.

Para desplegar el contrato inteligente en la cadena de bloques, primero hay que utilizar la herramienta eosio-cpp para compilar el contrato inteligente. La compilación crea un archivo Web Assembly (WASM) y un archivo de interfaz binaria de aplicación (ABI) correspondiente.

El archivo Web Assembly o .wasm es el código binario que el motor WASM de la Blockchain ejecuta. El motor de ensamblaje web o motor WASM está alojado en el demonio de nodeos y ejecuta el código del contrato inteligente. La interfaz binaria de la aplicación o archivo .abi define cómo los datos son transferidos hacia y desde el motor WASM.

De esta manera, se puede usar el lenguaje de programación C++ y su capacidad Turing Completa, para crear Smart Contracts en EOS.


###  213.B4_Programación_de_Smart_Contracts_en_Solidity_I-video

###  Programación de Smart Contracts en Solidity I
![[213.B4_Programación_de_Smart_Contracts_en_Solidity_I.mp4]]
[Programacion de Smart Contracts en Solidity I](https://app.web3mba.io?wvideo=6l3v25oa8m)

Primero, vamos a entrar en doc.soliditylang.org, que contiene información sobre el lenguaje Solidity. Como veréis, al ingresar, nos lleva a la última versión, que es la 0.8.17 en el momento de grabar este vídeo. Esta documentación contiene todo lo que necesitáis saber sobre cómo funciona el lenguaje, qué tipos de datos hay, sus operadores, etc. Os recomiendo que, dado que en este curso solo vamos a hacer una pequeña introducción, si queréis profundizar en el tema, exploréis la documentación, que está muy bien redactada.

La siguiente página que creo que es muy interesante, de cara a ver las cosas de un modo más práctico y no tan teórico, es "Solidity by Example". En esta web encontraremos un montón de ejemplos de Solidity utilizando aspectos concretos, como, por ejemplo, variables, constantes, structs, etc. Al principio son cosas muy básicas, pero si hacéis scroll, encontraréis ejemplos cada vez más avanzados. Sin más, vamos a pasar a desarrollar nuestros propios smart contracts. Vamos a entrar en Remix.

Remix, para quien no lo conozca, es un entorno de desarrollo de Solidity que nos permite desarrollar, compilar e incluso desplegar tanto en redes virtuales como en redes de prueba o en mainnet. Por ahora, vamos a hacer cosas muy sencillas simplemente dentro del navegador, sin realizar ningún despliegue real. Esta es la página de inicio; como veis, aquí tenemos distintos apartados. Este es el del "file explorer", donde desarrollaremos nuestros contratos y demás. Si hacéis clic en la carpeta de "contracts", veréis que ya hay una serie de contratos de ejemplo que nos ofrece Remix. Ahora los veremos en más detalle.

Si nos dirigimos al símbolo de "Solidity Compiler", desde aquí podremos compilar los distintos smart contracts que hayamos desarrollado. En este caso, podríamos compilar automáticamente el smart contract "storage" que hemos abierto. Luego lo veremos también en más detalle. En este último panel, tenemos el de despliegue y realización de transacciones. Aquí podemos seleccionar el entorno en el que vamos a hacer el despliegue. Los que indican "vm" son en máquinas virtuales; esto sucederá solo a nivel de este navegador, pero podemos utilizar otros proveedores, como Hardhat, Ganache, una wallet, etc., para desplegar e interactuar con estos smart contracts en otras redes.

Este smart contract se llama "Storage.sol". La extensión "sol" es del lenguaje Solidity. Cada vez que hagáis un smart contract, mi recomendación es utilizar el mismo nombre que el contrato. Lo primero que vemos aquí es la licencia; realmente este no es un campo necesario, pero es recomendable. Si no lo indicáis en el contrato, el compilador de Solidity os lanzará un warning; en este caso, se está utilizando GPL3. Luego, lo siguiente que se indica es la versión de Solidity a la que apunta este smart contract, es decir, con qué versión de Solidity se va a poder compilar este contrato. En este caso, está utilizando una versión compatible con las versiones menores que la 0.9.

Entonces se pone "pragma solidity" y a continuación la versión. "uint256" significa que es un entero, un "integer"; "u" es "unsigned", es decir, no tiene signo, por lo que todos serían números positivos y de 256 bits. Esta es una propiedad del contrato. Luego aquí tenemos dos funciones: una función que es "store", que lo que hace es guardar un nuevo valor, actualizando la propiedad "number" pasándole un parámetro "num". Aquí lo que hacemos es definir la función, el nombre de la función, el parámetro que recibe, indicando primero el tipo y luego el nombre del parámetro, y luego un modificador de la función, indicando cuál es su visibilidad. En este caso es "public", por lo que esta función es accesible por cualquiera, incluso desde el propio contrato o desde contratos externos.

El cuerpo de la función simplemente realiza una asignación. La variable "number", que es esta propiedad que hemos mencionado, se iguala a "num", que es el parámetro que está recibiendo. Esta es una función que modifica el estado del smart contract, por lo que requeriría una transacción que modifique el estado y, por tanto, requiere un coste de gas. Luego tenemos esta otra función que se llama "retrieve". Esta función, como veis, no recibe ningún parámetro, también es pública, pero es "view". "View" significa que es una función que no modifica el estado de la blockchain ni del smart contract. Por lo tanto, no es necesario realizar una transacción para ejecutarla.

Esto se podría hacer desde la consola, por ejemplo, accediendo a esta función, que se ejecutaría automáticamente sin necesidad de ninguna transacción. Esta función nos devuelve... Aquí dice "returns", lo que significa que nos devuelve, y entre paréntesis nos indica el tipo que tiene que devolver. En este caso, nos devuelve la propiedad "number". Como veis, este smart contract es muy sencillo; simplemente modifica y permite visualizar una propiedad. Vamos a crear una carpeta dentro de "contracts", la llamaremos "mba". Dentro de esta carpeta, vamos a crear un nuevo archivo que llamaremos "simplecontract.sol".

Lo primero, como hemos visto antes, es establecer la licencia. Vamos a copiar esta de aquí, por ejemplo. Hay múltiples tipos de licencia, como podéis ver en la documentación de Solidity. Podéis poner "unlicense" si queréis, pero en este caso vamos a utilizar "MIT", que es una licencia muy conocida y recomendada por la documentación. El siguiente paso es establecer la versión. Para ello, como hemos visto antes, utilizamos la palabra clave "pragma", seguida de "solidity", que es el lenguaje. En el smart contract de ejemplo "storage" que hemos visto antes, se indicaba que la versión tenía que ser superior a una e inferior a otra. Nosotros lo que vamos a hacer es ponerle "0.8.17", lo que significa que el compilador que vamos a permitir que compile este smart contract tiene que ser 0.8.17 o superior, pero inferior a 0.9.

Ahora, lo siguiente es crear el contrato. Utilizamos la palabra "contract", seguido del nombre del contrato, que será "simplecontract", abrimos la llave y ya está. Con esto ya tendríamos la primera parte de nuestro contrato. De la misma manera que antes, vamos a crear aquí una variable que será de tipo "uint256", la llamaremos "number". Solo que si hacemos esto, la visibilidad de este parámetro no está indicada, así que lo que vamos a hacer es que sea pública. Además de números, también podemos utilizar otros tipos de datos; por ejemplo, vamos a utilizar "address", que es una dirección de Ethereum, como "0x...". También la vamos a declarar como pública y la llamaremos "myAddress".

Luego, vamos a utilizar un constructor. Los smart contracts pueden tener o no tener constructor; en este caso, sí que lo vamos a crear. ¿Para qué sirve un constructor? Para inicializar una serie de datos o realizar una serie de operaciones en el momento de creación del smart contract. En este caso, simplemente ponemos "constructor", abrimos paréntesis y le pasamos una serie de parámetros; puede que reciba parámetros o puede que no. Por ejemplo, si no queremos que reciba parámetros, podríamos decir "number = 42". Entonces, cuando creásemos el smart contract, automáticamente la propiedad "number" tendría el valor 42. O podemos establecer nosotros el parámetro, lo ponemos aquí, "uint256 _number", y entonces aquí "number = _number".

¿Por qué lo pongo con barra baja? Esto es algo que se suele hacer para que los parámetros vayan precedidos por una barra baja, lo que permite diferenciarlos fácilmente en el cuerpo de una función del resto de propiedades o variables temporales. Además, también nos permite, en casos como este, utilizar variables que representan lo mismo; este parámetro será el valor de "number", así que sabemos que si tiene barra baja, es el que le estamos estableciendo desde cero. Aquí vemos que nos ha salido una alerta. Esto nos indica que el compilador al que estamos apuntando, que es al menos 0.8.17, no se corresponde con el compilador que está definido actualmente.

Entonces, podemos ir a la pestaña de "compilador" y, como veis, está preseleccionado el 0.8.7. Abrimos el desplegable y seleccionamos el que queramos, en este caso el 0.8.17, que como hemos comentado, es el último. Muy bien, pues ya tenemos un smart contract muy simple creado. De manera que tenemos aquí estos botones que nos permiten copiar el ABI y el bytecode. El bytecode es el código compilado del smart contract y el ABI es la interfaz, es decir, contiene todos los elementos del smart contract. El ABI nos indica que hay una propiedad pública que es un "uint256", que es "number", y que hay una propiedad pública de tipo "address", que es "myAddress". También nos dice que el constructor recibe ciertos parámetros y contiene las firmas de todas las funciones.

Esto nos indica qué funciones hay, qué reciben, qué devuelven, etcétera, pero no contienen funcionalidad alguna; simplemente nos dice de qué manera se puede interactuar con este smart contract, mientras que el bytecode, como digo, es todo el código del smart contract compilado. Necesitamos ambas cosas para poder desplegar el smart contract, pero luego, para interactuar con él, necesitamos el ABI, que es la interfaz, y la dirección en la que se ha desplegado. Una vez que ya lo tenemos compilado y funciona correctamente, vamos a proceder a hacer el despliegue.

Tenemos aquí el smart contract y aquí lo podríamos desplegar, pero nos pide todos los parámetros que tengamos en el constructor. Actualmente, solo tenemos "number". Si ponemos aquí 36, por ejemplo, esto realmente lo único que hace es desplegarlo y se verá un poco más en detalle. Así también nos serviría. Le daríamos a "desplegar". De acuerdo, pues entonces aquí nos sale un tick que indica que ha ido todo bien; se ha desplegado. Aquí vemos la información. En resumen, esto nos ha desplegado un nuevo smart contract que aparece en "deployed smart contracts", y nos indica también en qué dirección se ha desplegado este contrato.

Aquí tenemos dos botones que se corresponden con las funciones con las que podemos interactuar, que son "number" y "myAddress". Entonces, le damos a "myAddress", que nos dice que nos devuelve "0x000000" porque no hemos establecido ningún valor para esta propiedad, así que es el valor por defecto, que son ceros. El "number", ¿cuál será? Pues el que le hayamos indicado como parámetro en el constructor, que nos devolverá 36. Aquí está. Como veis, esto pone que son "calls". Cuando pone "call", significa que realmente no está realizando ninguna transacción, a diferencia de lo que hicimos antes al desplegar el contrato, que aquí sí que hubo una transacción. Esto, como solo es una consulta de información, porque al final son funciones de tipo "view", no requieren de ninguna transacción.

Muy bien, pues con esto ya tenemos un contrato muy sencillo y vamos a pasar a ampliarlo un poco. ¿Qué podemos hacer? Podemos añadir un setter a estas propiedades, a ambas. Lo recomendable, tal como indica la documentación o como veréis en la mayoría de contratos, es seguir un orden de qué cosas se ponen en qué orden. Por ejemplo, primero se ponen las propiedades del contrato, el constructor iría después y luego las funciones. Hay otra serie de elementos que ya veremos, como los structs, los eventos, los modifiers, etc. La idea es esa. En este caso, que solo tenemos propiedades, constructor y ahora funciones, se hace en este orden.

Vale, pues entonces, como hemos visto, utilizamos la palabra "function". Vamos a poner el nombre de la función, "setNumber" en este caso. Los parámetros que va a recibir serán "uint256 _number", como hemos dicho, es una buena práctica que los parámetros empiecen siempre con barra baja. Vamos a poner "public" porque esta función va a ser pública, ya que queremos que podamos interactuar con ella desde fuera. Abrimos las llaves. No he puesto un "return" porque esto no devuelve nada; solo vamos a modificar la función. Haremos exactamente lo mismo que estamos haciendo aquí. Podemos copiarlo y pegarlo para facilitar un poco.

Muy bien, entonces al final esto simplemente es un "set"; solo estamos modificando este valor y podemos hacer lo mismo para el "address". Vamos a poner "setMyAddress"; aquí el parámetro que recibe es de tipo "address" y lo vamos a llamar "_myAddress". Realmente, el nombre del parámetro, como digo, es simplemente una manera de hacerlo, pero aquí podríamos llamarlo "ADDR" si queremos. Como he dicho, es mejor que empiece con barra baja. Pero bueno, "myAddress", también de tipo público. Y aquí lo mismo, "myAddress" pasa a ser lo que haya almacenado en "_myAddress". Punto y coma.

Esta diferencia con otros lenguajes como Python es que siempre todas las sentencias deben acabar en punto y coma, como en JavaScript, aunque JavaScript es menos estricto. Vale, entonces hemos añadido estas nuevas funciones. Así que lo que vamos a hacer es ir de nuevo al compilador de Solidity, compilar de nuevo y luego ir a la pestaña de despliegue. Entonces, este smart contract que teníamos previamente lo vamos a desechar y vamos a desplegar de nuevo. Esta vez vamos a ponerle un 12, por ejemplo, para que sea distinto y le damos a "deploy". Entonces ya se nos ha desplegado aquí el smart contract. Como veis, antes teníamos solo estos dos botones de "number" y "myAddress", y ahora tenemos otros dos en naranja que son las funciones.

Estas sí que implican transacciones y, como veis, estas reciben parámetros, a diferencia de las otras. Entonces, si comprobamos, el "number" va a ser 12, "myAddress" seguirá siendo "0x0000" y vamos a establecer un nuevo número, por ejemplo, 17. Ahora, como veis, sí que ha enviado una transacción, del mismo modo que cuando se desplegó el smart contract. Aquí podréis consultar la información de la transacción, el hash de la transacción, desde qué dirección ha ido, a qué dirección ha ido, que en este caso es a la dirección del smart contract, que es esta de aquí, y el gas que ha consumido, etcétera.

Entonces, una vez que hemos cambiado el número, esta transacción ha ido correctamente. Si volvemos a consultar el número, ha cambiado y ahora pone 17. Muy bien, ahora también podemos cambiar el "address". Vamos a coger, por ejemplo, el propio "address" del smart contract. Remix nos permite muchas veces, cada vez que hay un "address" o un hash, poner el botón de copiar para facilitarlo todo. Entonces ya lo hemos copiado y lo vamos a pegar aquí. Le damos al botón y esto nos ha hecho una transacción. Entonces ya ha cambiado el "address" de la variable "myAddress". Cuando le damos aquí, ha cambiado; ahora es esta nueva información.

Esto está pidiendo un "address", así que no podríamos poner otra cosa; no podemos poner aquí el string "hola". Si lo hacemos, va a fallar. Como veis, aquí dice que la transacción a esta función ha fallado y nos indica que es un "invalid address"; se esperaba un argumento de tipo "address", pero el valor es "hola", así que no es válido. Como no es válido, no se ha podido realizar y si vamos a "myAddress", nos sigue devolviendo el valor que habíamos indicado inicialmente. Vale, pues vamos a seguir ampliando nuestro smart contract para añadirle más funcionalidad.

Vamos a añadir una función que sea de tipo "view". Como lo que hemos visto antes era simplemente un getter, aquí vamos a ponerle un poco más de funcionalidad. Vamos a crear una función que se llame "isThisNumberLarger". Vamos a pasarle un parámetro que será "number". Va a ser una función de tipo público y de tipo "view" porque no va a modificar el estado del smart contract. Además, nos va a devolver un valor de tipo booleano. Entonces, ¿qué va a hacer esto? Nos va a decir si nuestra propiedad "number" es mayor que el parámetro que le hemos pasado.

Además, también vamos a explorar otro tipo de funciones. Hemos hablado de las funciones que son de tipo "view" y ahora vamos a hablar de las que son de tipo "pure". Vamos a crear una función "sum". Recibirá dos parámetros, que llamaremos "number1" y "number2". También será de tipo público. En lugar de "view", será "pure" y lo que nos devuelve es un "uint256". Esta función simplemente devolverá la suma de "number1" más "number2". ¿Por qué es de tipo "pure" y no "view"? Porque las funciones de tipo "view" no modifican el estado del smart contract, pero sí leen el estado del mismo.

Es decir, aquí estamos accediendo a la propiedad "number", mientras que en esta función de suma, le estamos pasando dos parámetros y nos está devolviendo la suma de ellos. No importa lo que contenga el smart contract, ya que no lo vamos a consultar. Entonces, esta función... ¡Uy! Perdón, esto no lo he puesto correctamente. Esta función, al no leer el estado del smart contract, se puede clasificar con este tipo más restrictivo, lo que además ahorra gas. En Solidity, es muy importante hacer las cosas de la manera más económica posible, ya que esto supone un ahorro de dinero real cuando está desplegado en redes públicas, especialmente en mainnet, que es bastante caro.

Entonces, es muy importante intentar ahorrar el máximo posible. Muy bien, pues vamos a ir de nuevo aquí a la compilación. Como tenemos "auto compile", esto no sería necesario, pero simplemente lo hacemos para comprobarlo. Vamos a desechar el smart contract que teníamos desplegado y vamos a desplegar este nuevo. Vamos a poner aquí un parámetro que será 10, por ejemplo. Desplegamos y ya lo tenemos aquí desplegado. Aquí tenemos lo mismo de antes; "myAddress" es "0x0000", el "number" es 10, que es lo que hemos puesto, todo eso es lo mismo de antes.

Vamos a probar las cosas nuevas que son "isThisNumberLarger" y "sum". Como es 10, si le pongo aquí un valor de 8, este me devolverá "false". Si le pongo un valor de 13, nos devolverá "true". "bool" es otro tipo de dato, igual que hemos visto ya con "uint256" y "address"; esto es un valor booleano que solo puede tomar los valores "true" o "false". Ahora vamos a probar la función de suma. Aquí sí que tenemos, como son varios parámetros, los suyos que hagamos aquí el despliegue. Entonces aquí podemos poner los parámetros de cada uno de ellos; vamos a poner 5 y 3, hacemos el "call" y nos devuelve 8.

De nuevo, los que tienen el cuadradito azul significan que no modifican el estado; son "calls", así que no hay que realizar transacciones, mientras que estos sí requieren transacciones. Entonces ya hemos visto varias cosas: hemos visto las propiedades, la visibilidad pública, pero todavía no hemos visto ninguna de tipo privada, así que más adelante lo veremos. Hemos visto los modificadores de "view" y "pure", así que ahora vamos a ver algo nuevo: los eventos. Los eventos son algo muy importante en Solidity y son bastante interesantes.

Los eventos son sucesos que nosotros marcamos o se emiten en el smart contract en algún momento de su funcionalidad para que puedan ser leídos off-chain, es decir, desde fuera de la blockchain, por ejemplo, aplicaciones o servicios que estén escuchando la blockchain y estén atentos a que suceda algo. Por ejemplo, cuando se realiza una transferencia de un token ERC20, se emite un evento "Transfer". Esto se hace para que se esté escuchando y, cuando se detecte que se ha producido una transferencia, se realice alguna acción en un backend, en un servidor, etc. Estos eventos son para ser detectados desde fuera; no es algo que desde un smart contract puedas detectar que se ha producido un evento en otro smart contract.

Los eventos los pondríamos debajo de las propiedades y antes del constructor. Este será un evento que se disparará cuando se modifique la propiedad "number". Aquí se le pasarán una serie de parámetros; ¿cuáles vamos a pasar? Pues "oldNumber" y otro parámetro que será "newNumber", acabando en punto y coma, como siempre. Entonces, ¿de qué nos servirá esto? Cada vez que se cambie el número, si estamos escuchando los eventos del smart contract, sabremos cuándo alguien ha cambiado ese número. Podremos ver de qué número ha cambiado a qué número. Esto lo podemos hacer, por ejemplo, aquí, cuando hacemos el "setNumber".

Entonces aquí utilizamos la palabra "emit", que es para emitir el evento, seguido del nombre del evento, que será "newNumberSet", y los parámetros que recibe. ¿Cuál será el viejo número? Pues aquí lo que actualmente es "number". ¿Cuál será el nuevo? El que estamos pasando por parámetro, "number" con barra baja. Muy bien, desechamos el smart contract anterior, desplegamos de nuevo y, como vemos, vale 5. Ahora vamos a ponerle un valor de 8, por ejemplo. "SetNumber" llamamos a la función y aquí se ha enviado una transacción. La consola de Remix nos permitirá comprobar el evento que se ha emitido.

Aquí dentro de "logs", observamos que hay una propiedad que dice "event" y nos indica el número del evento, que es "newNumberSet", y aquí los argumentos. Los argumentos del evento nos los muestra de dos maneras distintas: o bien por el orden, que es 0 y 1, o bien por el nombre de la propiedad, que son "oldNumber" y "newNumber", que en este caso ha pasado de 5 a 8. Esto es una manera bastante útil de poder observar los cambios que se han producido en el smart contract desde fuera.

Otra cosa interesante de Remix, que no he comentado, es que además de desplegar aquí, podemos cargar un smart contract que ya se haya desplegado previamente. Por ejemplo, si copiamos su dirección, lo descartamos y pegamos aquí la dirección, al darle, nos mostrará el smart contract que ya hemos desplegado anteriormente. Esto, en el entorno de una máquina virtual, no tiene mucho sentido, pero si estamos utilizando un proveedor distinto, por ejemplo, en una red de pruebas como Rinkeby, si queremos interactuar con un smart contract que ya existe y que hemos desplegado en otra sesión, simplemente podemos copiar su dirección y darle al botón.

Como vemos, aquí ya está; si le damos al "number", está en 8, que es el valor que le habíamos puesto anteriormente. Con esto ya hemos visto los eventos, pero también podemos decir que queremos emitir este evento en el constructor, porque en el constructor también estamos cambiando el número de 0, que es el valor inicial, al parámetro que le estamos pasando. Podríamos copiar esto aquí y entonces estaríamos emitiendo el evento y cambiando el número tanto en el constructor como en esta función. Sin embargo, lo que estamos haciendo es algo que a mí personalmente no me gusta: repetir código.

Todo lo que se puede hacer para evitar repetir código es mejor, porque facilita la legibilidad y el mantenimiento. Si tienes el mismo código repetido en varias funciones y luego, por alguna razón, lo cambias en una, pero no en otra, te encuentras con comportamientos inconsistentes. Cada vez que se repite código, en este caso son solo dos líneas, pero en otros casos puede ser más complejo. Entonces, ¿qué vamos a hacer? Vamos a extraer esta funcionalidad de emitir el evento y cambiar el valor de esa propiedad a otra función externa.

Vamos a crear una función y esta función será de tipo privado. ¿Qué implica eso? Que no podremos interactuar con ella desde fuera. Es decir, ¿veis aquí todas las funciones a las que podemos acceder? Esta función que vamos a crear no estará aquí, porque al ser de tipo privado, solo se podrá acceder desde el propio smart contract. Entonces, ¿para qué se utilizan este tipo de funciones? Por ejemplo, para lo que hemos hecho, cuando internamente el smart contract tiene que realizar algunas acciones que solo serán llamadas desde el propio smart contract, que no queremos que se llamen desde fuera.

Muchas veces, las funciones privadas se nombran con un guion bajo delante del nombre de la función. Esto permite visualizar rápidamente que esta función es privada, es algo interno del smart contract. Entonces, vamos a hacer lo mismo. "_setNumber". Esta función hará exactamente lo mismo; recibirá el parámetro "number", solo que en lugar de ser "public", será "private". Hará exactamente lo mismo que hemos mencionado aquí: emitirá el evento y cambiará la propiedad. Entonces, donde estamos haciendo estas acciones, llamaremos a esta función privada: "_setNumber(number);".

El smart contract se ha compilado correctamente. Desechamos este, desplegamos de nuevo, poniéndole un 5, por ejemplo. Cuando vengamos aquí y veamos la transacción, esta es la transacción que ha desplegado el smart contract; vemos que se ha llamado al evento, pasando de 0 a 5. Si lo cambiásemos a 12, por ejemplo, generará una nueva transacción que lanzará otro evento de 5 a 12. Con esto hemos aprovechado para ver cómo funcionan las funciones privadas y cómo evitar repetir código, logrando un código más reutilizable.


###  214.B4_Programación_de_Smart_Contracts_en_Solidity_II-video

###  Programación de Smart Contracts en Solidity II
![[214.B4_Programación_de_Smart_Contracts_en_Solidity_II.mp4]]
[Programacion de Smart Contracts en Solidity II](https://app.web3mba.io?wvideo=fa8on4840i)

En este nuevo vídeo, vamos a crear otro contrato para seguir explorando las posibilidades que nos ofrece el lenguaje Solidity. Vamos a desarrollar una especie de juego y comenzaremos creando un archivo que llamaremos "game.sol". Primero, estableceremos la licencia, que será MIT, y luego definiremos la versión de Solidity. Como dijimos en el vídeo anterior, utilizaremos "pragma" y la versión será la 0.8.17, es decir, desde la 0.8.17 hasta la 0.9.

El contrato se llamará "Game" y en este pequeño juego, cada usuario podrá crear un héroe, y los héroes podrán luchar entre ellos. Para ello, introduciremos un nuevo concepto llamado "struct". Un struct es como un tipo de dato, y lo llamaremos "Hero". Aquí detallaremos las propiedades que este tipo de dato tendrá. El héroe tendrá un nombre, un nivel, un nivel de ataque y un nivel de defensa. Como mencioné en otros vídeos, es una buena idea mantener un orden sobre qué va antes y qué va después. Los tipos de datos, en este caso los structs, deben ir antes de las propiedades. Esto definirá el tipo de dato "Hero" con todas sus propiedades, y ahora veremos cómo asociar a cada usuario con uno de estos héroes.

Para ello, introduciremos un nuevo tipo de dato que es el "mapping". El mapping es como un hashmap o un diccionario en otros lenguajes, que asocia una clave con un valor. En este caso, la clave será un "address", que será la dirección del usuario. Luego, el valor será un objeto de tipo "Hero". La variable será pública y la llamaremos "heroes". Ya tenemos el tipo de dato y esta propiedad que indica la asociación entre los usuarios y los héroes. Podríamos crear un constructor, pero en este caso lo omitiremos, ya que no es necesario que existan constructores en el contrato.

Lo que sí haremos es crear una función para poder crear el héroe. Entonces, ¿qué parámetros le pasaremos? Vamos a pasarle el nombre. En cuanto a los strings, cuando se pasan como parámetro, hay que usar la palabra clave "memory", porque es un string que está en memoria. Hay otros tipos de modificadores, pero para este caso, siempre será de tipo "memory". Así que indicamos el parámetro "name" y el resto les daremos un valor por defecto. Vamos a asociar en este mapping, en nuestra propiedad de "heroes", el address de la dirección que está enviando la transacción a un nuevo héroe.

Hay una serie de variables globales que se pueden acceder desde Solidity y que nos permiten obtener cierta información. Por ejemplo, desde cualquier smart contract, podemos saber cuál es la dirección que está enviando la transacción a este smart contract. En este caso, es "msg.sender". Esta variable siempre contendrá la dirección que está enviando la transacción y será la clave de nuestro par que vamos a crear aquí. Entonces, haremos que "heroes[msg.sender]" sea igual a un nuevo objeto "Hero". Esto se puede hacer de múltiples maneras. Una forma es poner "Hero()" y pasar directamente los valores de todas las propiedades, en este caso sería "name", el nivel será uno por defecto, y el ataque y la defensa serán 100.

Esta es una manera de hacerlo. Otra forma sería, en lugar de hacerlo así, indicar mediante clave y valor cómo será. Lo voy a poner... Comentamos esto. Por cierto, los comentarios en Solidity se hacen con doble barra "//". También se puede hacer con barra y asterisco "/* ... */" si queremos hacer un comentario de bloque. Otra opción que podríamos utilizar aquí sería lo mismo, "Hero()" y aquí introducimos el objeto, pero para eso introducimos unas llaves y aquí sí que iríamos poniendo cada uno de los parámetros: "name", "name", "level", 1, etc. Pero como son pocas cosas y es sencillo, lo dejaremos de esta manera.

Con esto ya crearíamos el héroe. Podemos ir compilando y ver qué pasa. Compilamos "game", nos vamos a la pestaña de despliegue, tenemos todo marcado como en los vídeos anteriores, y desplegamos. El despliegue ha sido exitoso y aquí tenemos las dos funciones: la propiedad pública "heroes" y la función "createHero". Esta recibe como parámetro un address y, como decimos clave-valor, si introducimos el address, nos devolverá la propiedad "Hero". Por ejemplo, si ponemos el address de la cuenta con la que hemos hecho el despliegue, lo pegamos aquí y nos devuelve el objeto vacío con todos los valores por defecto. Como veis, el string está vacío y tanto el nivel como el ataque y la defensa están a cero.

Ahora mismo podemos crear un héroe. Cuando lo llamemos, vamos a llamarlo "Pedro". Esto nos dice que ya ha enviado una transacción, que ha ido correctamente, y vemos el parámetro que hemos mandado. Si volvemos a llamar a esta función, aquí vemos que lo que nos ha devuelto es un objeto "Hero" con todas sus propiedades: "Héroe Pedro", nivel 1, ataque 100, defensa 100. Entonces, ¿qué podemos hacer para ampliar esto? ¿Qué pasa si llamo a la función "createHero" varias veces? Lo que sucederá es que se sobrescribirá. Si ahora me creo otro héroe que se llame "Antonio" y vuelvo a llamar a esto, me lo ha sobrescrito.

Con esto hay que tener cuidado; igual no queremos que este sea el comportamiento. Quizás alguien llama a esta función sin querer y tenía ya un héroe de nivel 200 y lo pierde. Así que aquí vamos a introducir un nuevo concepto que es muy importante: el "require". En Solidity, "require" comprueba que se cumple una condición y, si no se cumple, revierte la transacción. Es decir, anula la transacción. Cualquier cosa que se hubiese hecho previamente no se guardará. Si hubiésemos hecho cambios en el smart contract, da igual; esa transacción se cancela y no se lleva a cabo.

En este caso, lo que vamos a comprobar es que no existe ya un héroe para este address, para "msg.sender". Como el objeto "Hero" tiene toda esta información, el nombre, el nivel, etc., lo que podemos hacer es comprobar el nivel. Si el nivel es cero, sabemos que no existe un héroe, porque si se hubiese creado un héroe, sería por lo menos uno, ya que se crea con uno, o puede que sea más y luego suba el nivel si desarrollamos esa funcionalidad. Entonces, para eso vamos a hacer un "require".

Ponemos la condición booleana que en este caso será que "heroes[msg.sender].level" sea igual a 0. Es decir, tenemos que asegurarnos de que se cumple esta condición: no puede haber un héroe asociado a esta dirección. El "require" nos permite además poner un mensaje de error, de modo que si una transacción falla, podemos saber por qué ha fallado. En este caso, vamos a poner "You already have a hero". Entonces guardamos, borramos el smart contract que teníamos desplegado. Como lo tenemos en "autocompile", no hay que volver a darle. Desplegamos de nuevo.

Vamos a hacer lo mismo de antes. Creamos un héroe que se llama "Pedro". Y ahora creamos otro héroe que se llame "Antonio". Aquí, la transacción ha fallado, como podéis ver, sale una "X" y nos dice "revert", la transacción se ha revertido. Y aquí, "Reason provided by the contract", esto es el mensaje que le hemos puesto: "You already have a hero". Ahora hemos añadido esta restricción: no puedes crear otro héroe si ya tienes uno.

¿Qué es lo siguiente que vamos a hacer? Creo que podemos implementar una función de lucha, para que los héroes puedan enfrentarse entre sí. La función se llamará "fight". ¿Cómo vamos a hacer esto? Haremos que, al enviar una transacción llamando a "fight", se indique contra qué enemigo queremos enfrentarnos. Así que pondremos un "address enemy". Esto también será de tipo público. Aquí realizaremos la lucha. Vamos a pensar qué restricciones podemos poner a esta transacción.

Lo primero es que, si quiero luchar contra alguien, necesito tener un héroe. Así que aquí haremos lo mismo de antes. Vamos a hacer un "require" que verifique que "heroes[msg.sender].level" sea mayor que cero. Acordémonos de siempre poner la condición booleana y luego el mensaje. El mensaje será "You don't have a hero". Si no tienes un héroe, no puedes luchar. Muy bien.

¿Qué otra restricción podríamos poner? Que el enemigo al que nos estamos enfrentando también debe tener un héroe. Así que vamos a copiar y pegar. La propiedad "heroes[enemy].level" tiene que ser mayor que cero. Si el nivel es 0, significa que el objeto está vacío. Si el nivel es mayor que 0, significa que ya hay un objeto ahí. Entonces queremos que el enemigo tenga un héroe; si no, no podemos luchar. El mensaje de error será "Enemy doesn't have a hero".

Vale, ya tenemos dos restricciones que parecen bastante buenas. ¿Se nos ocurre alguna otra? A mí se me ocurre que no puedas luchar contra ti mismo. Si yo aquí en el address me pongo mi misma dirección, el héroe estaría luchando contra sí mismo y eso no es algo que queramos hacer. Así que hacemos "require(msg.sender != enemy)". Esta es la condición y el mensaje que pondremos será "You can't fight yourself".

Muy bien, pues ya hemos cubierto todas las condiciones que podemos poner. ¿Cómo va a ganar un jugador? Si su nivel de ataque es mayor o igual que la defensa del enemigo, eso tendría sentido. Entonces, "heroes[msg.sender]" es el objeto "Hero". Para acceder a cualquiera de sus propiedades, utilizamos el punto y la propiedad que queremos. En este caso, "attack". Si el ataque es mayor o igual que la defensa del enemigo, entonces habremos ganado el combate.

¿Qué pasa si ganamos el combate? Si ganamos, podemos hacer que suba de nivel. Aquí ahora mismo no tenemos nada. Vamos a poner aquí un "TODO". Ahora vamos a crear una función que nos suba de nivel. Esta función debe tener visibilidad. Si la hacemos pública, cualquiera podría subir el nivel de su héroe. No queremos eso, porque entonces el usuario llamaría constantemente a esta función y estaría muy OP. Así que lo que vamos a hacer es que sea una función privada. Como es privada, le pondremos la barra baja al inicio. Esto no es necesario, pero es una buena práctica. Al final, el estilo de programación depende de cada uno.

¿Qué pasa cuando un jugador sube de nivel? Vamos a hacer que su héroe suba algunas de sus propiedades. "heroes[msg.sender].level" será el nivel más uno. Así que sube uno en su nivel. ¿Qué más cosas vamos a subir? El nombre no va a cambiar, pero vamos a subir el ataque y la defensa. El ataque lo subiremos en 15, por ejemplo, y la defensa la subiremos en 10. Entonces ahora tenemos que llamar a la función simplemente, "levelUp". Como veis, no hace falta pasarle ningún parámetro.

Podríamos hacer que "levelUp" recibiese un parámetro con el address y entonces aquí, en lugar de "heroes[msg.sender]", sería "heroes[address]". Ojo, aquí, aunque estemos llamando a una función distinta, "msg.sender" sigue siendo la dirección que ha llamado la transacción. Es decir, aunque la llamada a esta función venga de otra función, "msg.sender" no cambia, porque quien ha iniciado la transacción es la dirección que manda la transacción. Ahora, si este contrato estuviese llamando a otro contrato, ahí sí que "msg.sender" cambiaría. Pero eso no aplica en este momento.

Ahora mismo, estamos haciendo como 6 puntos en DER. Otra opción sería indicarle aquí el address del héroe al que queremos subir. Son dos maneras distintas de hacerlo. Vale, pues con esto podemos ir probándolo. De nuevo, descartamos el contrato anterior y lo desplegamos de nuevo. ¿Por qué lo estamos desplegando de nuevo? Porque cada vez que hacemos un cambio, el contrato anterior sigue adelante con el código compilado y la interfaz que tenía antes. Por eso hay que volver a desplegarlo.

Esto es un tema que tiene Solidity. Si descubres un bug en tu smart contract, no puedes simplemente parchearlo y que siga funcionando. Toda la información que tuvieras almacenada se pierde. Es decir, si despliego este smart contract con esta nueva funcionalidad e intento acceder a cuál es mi héroe, estará vacío. Así que el héroe "Pedro" que creé antes ya no existe. Bueno, existe, pero en el contrato anterior. En este ya no existe; son dos contratos distintos. No podemos actualizar un contrato como tal, al menos no de esta manera. Así que cada vez que se hace un cambio, es un contrato nuevo.

Por eso hay que tener cuidado al utilizar smart contracts. Cuando despleguemos smart contracts, debemos estar muy seguros de que todo funciona, porque si no, hay que hacer todo desde cero y los datos que tengamos en el contrato anterior no se podrán migrar de manera sencilla a este. Vamos a crear un héroe. Comprobamos el nombre. Vale, "Pedro", ataque 100, defensa 100. Ahora necesitamos crear un enemigo. Aquí tenemos una serie de cuentas. La que estamos utilizando inicialmente es la de 5, B3, etc. Vamos a coger la segunda cuenta. Esta segunda cuenta no tiene un héroe. Comprobamos. No tiene un héroe, así que lo vamos a crear. Este se llamará "Antonio". Creamos un héroe.

Vale, ahora tenemos a "Antonio", que es nivel 1, de la cuenta A, B, etc. Y luego la de 5B tiene a "Pedro". Vamos a hacer que "Pedro" se enfrente a "Antonio". Para eso, ahora mismo estamos con la de 5B, que es "Antonio". Vamos a copiar la dirección de "Pedro". Entonces, estamos con 5B y vamos a luchar contra la A, B, lo que sea. "Fight". Vale, parece que ha ido todo correctamente. La transacción ha funcionado. Ahora volvemos a ver las características de este héroe.

Vale, "Pedro" ha subido al nivel 2. Ha subido al nivel 2 y ahora su ataque es 115 y su defensa es 110. Muy bien. ¿Qué pasa si intentamos...? Vamos a comprobar que los requisitos que hemos puesto funcionen bien. Intentemos utilizar a un héroe que aún no exista. Le damos a luchar. Ha fallado. No tienes un héroe. Entonces esta primera condición ya funciona bien. Vamos a intentar luchar contra nosotros mismos. Así que nos vamos a poner el de... Entonces, si estamos luchando contra AB8, vamos a ponernos el usuario AB8. "Luchar". Vale, nos sale "You can't fight yourself".

¿Qué pasa si intentamos luchar contra un address que no tiene un héroe? Copiamos esta dirección, la pegamos y vamos a luchar. Ah, disculpad, no, tengo que... No había cambiado, me había puesto con otro héroe, perdón, con otra dirección que no tenía un héroe. Me he vuelto a coger la primera. "Luchar". Enemigos en Javagirum. Vale, hemos comprobado ya todos los casos posibles. También hemos comprobado el caso exitoso, que es el que hemos hecho antes.

¿Qué más podemos hacer? Se me ocurre que podemos hacer una función de entrenamiento, de modo que podamos subir de nivel a un héroe sin necesidad de luchar contra otro. Por eso creamos la función "train". No le pasamos ningún parámetro. Será una función pública. Vamos a pensar qué "require" le podemos poner. Tiene sentido que tengas que tener un héroe. Si no tienes un héroe, no puedes entrenar. Si tienes un héroe, podrás entrenar, así que vamos a hacer que subas de nivel.

Y vosotros diréis, ¿qué diferencia hay entre poner "levelUp" como función pública? Al final, con llamar a "train" ya estás subiendo de nivel. Es como puede ser, ¿verdad? ¿Cómo podríamos hacer esto más restrictivo para que no puedas estar entrenando constantemente? Podemos ponerle un límite de tiempo. En Solidity, puedes acceder al momento actual. Igual que podemos acceder a "msg.sender", otra de las variables que existen es el timestamp del bloque en el que se ha minado esta transacción. Entonces, podemos utilizar eso para comprobar el tiempo. Podemos decir que solo se puede entrenar una vez al día, por ejemplo.

Así que vamos a añadir una propiedad nueva al héroe. También será un "uint256" y lo llamaremos "lastTraining". Este contendrá el timestamp de la última vez que se llamó a la función "train". El timestamp es un entero porque es un número de segundos. Es un número largo de segundos y, como no nos interesa exactamente qué significa ese número, sino solo la variación de ese número, si ha pasado suficiente tiempo desde la última vez.

Para eso, en "train" tendremos que añadir otro "require". Este "require" será que se pueda entrenar. Entonces, ¿cómo lo haremos? El timestamp, "block.timestamp", es la variable que hemos mencionado que se puede utilizar para acceder al momento actual, que es cuando estás enviando esa transacción. Esta tomará el valor del timestamp de ese momento. Entonces, tenemos que comprobar que el timestamp sea mayor.

Vamos a hacerlo de otra manera. Si le restamos el último momento en el que el héroe pudo entrenar, es decir, "heroes[msg.sender].lastTraining", la diferencia entre el momento actual y la última vez que entrenó tiene que ser mayor que lo que digamos. Solidity nos permite utilizar, si pusiéramos un número de segundos, por ejemplo, si quisiéramos poner una hora, serían 60 segundos por 60. Entonces esto sería una hora. O podríamos, si quisiéramos que fuese un día, multiplicar por 24. Pero Solidity nos permite ponerlo de una manera más sencilla: "1 days". Esto también funcionará de la misma manera.

Con esto estamos haciendo una comprobación de que ha pasado al menos un día desde la última vez que entrenó. Si no ha entrenado nunca el héroe, automáticamente "lastTraining" estará a 0. Entonces, el timestamp será un número bastante más alto, así que de primeras podrá entrenar. ¿Qué pasa aquí también? Al haber puesto esta nueva propiedad, nos está saliendo un mensaje de error. Porque claro, nos está diciendo que esto espera 5 argumentos, pero solo hemos pasado 4. Aquí hemos pasado el nombre, el nivel, el ataque, la defensa, pero no hemos puesto "lastTraining".

Vamos a poner ahora que sea 0. Así, de esta manera, podrá entrenar desde el primer momento. Muy bien, pues entonces ya estaría... No, realmente no, porque tenemos que actualizar el valor de "lastTraining". Si no lo actualizamos, estará siempre a cero y siempre podrá entrenar. Así que vamos a coger esta propiedad del héroe y la igualaremos al momento actual: "block.timestamp". También podríamos estar aquí poniendo eventos, por ejemplo, cuando suba de nivel podríamos poner un evento o cuando entrene, pero como eso ya lo hemos cubierto en vídeos anteriores, tampoco vamos a repetirnos demasiado.

Y ya tenemos listo nuestro vídeo de hoy. Espero que os haya gustado. Si es así, no olvidéis darle al botón de suscripción, al botón de "like" y compartir el vídeo con vuestros amigos. Y ya sabéis, si queréis ver más vídeos así, seguidme en Instagram, Facebook, Twitter, y también en Twitter. Nos vemos en el próximo vídeo. Como hemos dicho, lo tenemos en autocompilación. Descartamos los smart contracts anteriores y desplegamos. Se ha desplegado correctamente. Vamos a crear nuestro héroe. Se ha creado bien. Copiamos la dirección para ver su información. Nivel 1, ataque 100, defensa 100, "lastTraining" 0.

Vale, ahora vamos a entrenar. La transacción se ejecuta correctamente. Entonces, según esto, ya deberíamos haber subido de nivel. Vamos a comprobarlo. Se ha actualizado. Ha subido al nivel 2. Aquí, ataque 115, defensa 110. "LastTraining" es el timestamp del momento en que se ejecutó, que fue hace unos segundos. ¿Qué pasa si volvemos a darle a "train"? Ha fallado la transacción. Ah, claro, aquí nos dice que se ha revertido, pero no nos está dando información. ¿Por qué? Porque se me ha olvidado poner aquí el mensaje.

El mensaje, como digo, no es necesario, pero es bastante recomendable. Si ponemos aquí "You can only train once a day", solo puedes entrenar una vez al día. Bueno, pues vamos a destruir el contrato, desplegamos uno nuevo, creamos el héroe, observamos su información y entrenamos. Bien, volvemos a entrenar. Mal. "You can only train once a day". Esto ya funciona correctamente.

¿Qué más cosas podemos hacer? Cuando quiero ver mi héroe, que me esté devolviendo mi address todo el rato, si hemos dicho que lo podemos sacar de "msg.sender". Vamos a crear una función pública que se llame "getMyHero" que no reciba ningún parámetro. Entonces, esto lo que hará, como nos va a devolver el héroe, pondremos "returns (Hero)". Y aquí vamos a poner "return heroes[msg.sender]".

Ahora aquí nos dice, un momento, aquí pasa algo. ¿Qué es lo que pasa? Como he dicho antes, a veces hay que poner con algunos tipos de datos más complejos, con los tipos básicos, como booleano, int, etc., no hace falta. Pero con tipos más complejos, como es string o en este caso como es struct, hay que especificar un modificador de "memory", "calldata" o "storage". En este caso, le vamos a poner "memory". Entonces, "Hero memory". Guardamos. Esto es muy interesante; Remix nos avisa cuando algo se nos pasa.

Aquí lo que nos está diciendo es que esta función la podemos restringir a "view" y es cierto, porque esta función, como hemos dicho, será un "call", no será una transacción. Así que no requiere transacción, así que será "view". Vamos a probar. Desplegamos de nuevo. Vamos a "getMyHero". Nos devuelve aquí... Esto ahora nos lo pone de una manera un poquito más fea. Al final es lo mismo que si lo ponemos aquí. Lo que pasa es que aquí sí que nos devuelve cada uno de los valores.

Entonces, creamos un héroe. Si le damos aquí, nos saldrá "Pedro" y si le damos a "getMyHero", también nos vendrá "Pedro", nivel 1, ataque 100, "lastTraining" 0. Con lo cual, esto simplemente era un poco para facilitarlo. Al final, si esta información... esto simplemente es la manera de representarlo. Cuando estéis vosotros haciendo un servidor o recogiendo esa información para hacer algo, al final os da igual cómo aparezca, porque lo vais a gestionar como queráis.

¿Qué más cosas podemos hacer? Ya parece que está bastante completo, pero podemos hacer alguna otra cosa. Como he dicho en otros vídeos, no me gusta repetir código y si puedo evitarlo, lo evito. Así que, ¿qué código tenemos aquí repetido? Alguno que veáis. Yo veo uno claramente, que es el "require" de que no tengas un héroe. Esto lo tenemos que hacer cada vez que realizamos alguna acción que necesita un héroe. En este caso, es muy simple; solo tenemos "luchar" y "entrenar", así que tenemos este "require".

Podríamos extraerlo a una función que realice ese "require". Pero hay una funcionalidad de Solidity que está muy bien y que nos sirve precisamente para esto: los "modifiers". Los "modifiers" son como los decoradores que hay en otros lenguajes. Es algo que hace que se ejecute código antes o después de la ejecución de una función. Normalmente, se utilizan para hacer este tipo de comprobaciones. Ahora mismo solo tenemos "luchar" y "entrenar", pero imaginad que tenemos 10 funcionalidades distintas que puede hacer un héroe y en todas tenemos que hacer ese "require".

Utilizando este "modifier", de una manera muy sencilla, lo podríamos tener. Vamos a crearlo aquí, debajo del mapping, antes de las funciones. Hacemos un "modifier". Lo llamaremos "hasHero", es decir, que tiene un héroe. A los "modifiers" se les puede pasar un parámetro o se les puede omitir. En este caso, lo omitiremos porque no lo necesitamos. ¿Qué le vamos a poner aquí? El "require" que hemos mencionado para comprobar que tiene un héroe. Luego, lo que vamos a poner es "_;".

Esto es un poco raro, ¿qué es esto de " _ "? Pues como esto es un decorador, el guion bajo significa la función que estamos decorando. Este es el código que se ejecuta antes de la función y luego sigue haciendo lo que sea que haga la función. En este caso, vamos a ponerle ese decorador a estas funciones: la de "luchar" y la de "entrenar". Entonces, los "modifiers" los ponemos al final, después de "public", antes del cuerpo de la función. "hasHero". Y aquí también, "hasHero".

Entonces ya podemos quitar este "require". "requireHero". Vale. Vamos a comprobar que esto funciona. Desplegamos. Intento llamar a "entrenar". Ah, no funciona. "You don't have a hero". Eso es porque, como está funcionando en el sistema de "require", ha intentado ejecutar esto y no ha funcionado. Muy bien, pues yo creo que con esto tenemos ya un juego muy sencillo pero bastante completo.

Para hacer un repaso de las cosas nuevas que hemos visto en este vídeo, hemos visto los structs, cómo se crean, cómo se accede a sus propiedades, y hemos visto los mappings, que son asociaciones clave-valor, como si fuese un diccionario. Una cosa que no he comentado, pero que se puede hacer, es que se pueden encadenar distintos mappings. Puedo hacer un mapping cuya clave sea un número, por ejemplo, y cuyo valor sea otro mapping. Este mapping puede ser "address" y "bool", por ejemplo. Esto es algo que está permitido; podéis asociar tantos como queráis.

Los mappings son una de las estructuras de datos más importantes que hay en Solidity. Por ejemplo, para representar los balances de un token, se utiliza un mapping donde la clave es la dirección y el valor es un "uint256". Así es como se representan. Así que no dejéis de mirar el tema de los mappings, que es importante. ¿Qué más hemos visto aquí? Hemos repasado el tema de las funciones, la visibilidad, por ejemplo, esta función que es privada. También hemos revisado el tema de si es una función de tipo "view" o si es de transacción.

Hemos visto también los "modifiers", que son los decoradores. También hemos visto el tema de los "requires", que es muy importante, sobre todo en cuestiones de seguridad, porque habrá funciones que no pueden ser ejecutadas por cualquiera. Por ejemplo, si quiero hacer una transferencia de tokens, tenemos que comprobar que el dueño de los tokens es quien está llamando la transacción. Si no, cualquiera podría transferir tokens ajenos. Bueno, eso es todo por hoy. Gracias por ver el vídeo. Nos vemos en el próximo. Esta parte también es bastante importante. Así que, por ahora, ya está y ahora vamos a pasar a hacer más contratos y ver más funcionalidades de Solidity.


###  215.B4_Programación_de_Smart_Contracts_en_Solidity_III-video

###  Programación de Smart Contracts en Solidity III
![[215.B4_Programación_de_Smart_Contracts_en_Solidity_III.mp4]]
[Programacion de Smart Contracts en Solidity III](https://app.web3mba.io?wvideo=wswph1psja)

En este nuevo vídeo, vamos a explorar otro concepto de Solidity: las interfaces. Las interfaces, básicamente, proporcionan una lista de funciones que los smart contracts que las implementen deben tener y deben implementar todas sus funciones. Las interfaces contienen simplemente el nombre de la función, los parámetros, lo que devuelven, etc., pero no contienen la funcionalidad, es decir, la implementación de esa función. No contienen un código ejecutable; son simplemente una guía de lo que deben tener los smart contracts que implementen esa interfaz.

Para ello, vamos a crear una interfaz de oráculo y una serie de oráculos que nos proporcionarán el precio de algunos tokens. Por ejemplo, vamos a hacer que nos den el precio de USDT y el precio de MATIC en la red mainnet de Ethereum. De acuerdo, primero vamos a crear una carpeta llamada "oracles" y dentro de esta carpeta, comenzaremos creando la interfaz "IOracle". Es recomendable que el nombre de la interfaz empiece por "I" para que sea fácil identificar que es una interfaz en lugar de un contrato normal. Para acelerar el proceso, vamos a copiar la licencia y la versión.

Normalmente, cuando hemos creado otros contratos, hemos puesto "contract" y el nombre del contrato, pero al ser esto una interfaz, hay que poner "interface" y el nombre de la interfaz, que es "IOracle". ¿Qué queremos que contenga? Queremos que incluya las funciones que tendrá la interfaz. En este caso, solo nos interesa una: obtener el precio. Así que la llamaremos "function getPrice". No recibe parámetros y lo que nos devolverá es el precio.

Hemos visto antes otros tipos de visibilidad, como "public" y "private". Aquí vamos a poner "external", porque las funciones de las interfaces deben ser externas. "External" significa que solo se puede llamar a la función desde fuera del contrato, es decir, desde otro contrato o desde una dirección, como una wallet, pero no desde el propio contrato. Todas las funciones de las interfaces son externas. En este caso, será una función "view" porque no modificará el estado de la blockchain; simplemente leerá y devolverá un tipo "uint256".

De acuerdo, esta sería nuestra interfaz. Como veis, es muy sencilla; únicamente contiene esta función. Ahora vamos a crear un oráculo que implemente esta interfaz. Creamos un nuevo archivo que llamaremos "StableOracle.sol". ¿Por qué "Stable"? Porque este será un oráculo que nos dará el precio de monedas estables, como USDT, USDC, DAI u otras similares. Para simplificar, lo que haremos es un contrato que nos devolverá siempre un valor fijo, que será 1. Normalmente, cuando se obtienen los precios de tokens, se suelen hacer relativos al dólar estadounidense (USD).

Entonces, aquí hacemos "contract StableOracle". Este será el contrato, pero queremos que implemente la interfaz. Para eso, tenemos que importarla en este contrato. Así que utilizamos la palabra "import". Debemos poner la ruta relativa donde está el contrato; al estar en la misma carpeta, será "./IOracle.sol". Ahora tenemos que decirle que este contrato es un "IOracle". ¿Qué implica eso? Estamos diciendo que este contrato debe implementar todas las funciones de esta interfaz. Si no lo hace, nos mostrará un error.

Vamos a hacerlo. La función debe llamarse igual, por supuesto. Tiene que recibir los mismos parámetros; en este caso, ninguno. Esto será una función "external view". Vamos a poner lo mismo. Aquí vamos a poner "override" porque estamos indicando que estamos sobrescribiendo la función de la interfaz. De esta manera, vemos que esta es una función de interfaz y devolverá lo mismo. Como esto será en stablecoin y lo haremos de manera sencilla, devolveremos 1, ya que representa 1 USD o 1 USDT.

Lo que sucede es que en Solidity no existen los decimales; lo que se hace es escalar, es decir, se multiplica y se añaden ceros en lugar de usar decimales. Normalmente, depende de la moneda, pero muchas veces es un estándar utilizar 18 decimales, que es lo que utiliza Solidity para el Ether, que son 10 elevado a 18 wei. Entonces, multiplicaremos esto por 10 elevado a 18, es decir, será un 1 seguido de 18 ceros. De manera simplificada, se puede poner como "1e18", que es 1 por 10 elevado a 18.

Aquí nos sale un warning que nos dice que esto no está leyendo nada de este smart contract, así que en lugar de "view", se puede poner "pure". Sin problema, lo ponemos como "pure". Con esto ya tenemos un oráculo que implementa esta interfaz. Ahora podemos crear otro oráculo que también implemente esta interfaz. Vamos a hacer uno para MATIC. Lo llamaremos "MaticOracle.sol". Para acelerar, vamos a copiar esto y pegarlo aquí. En lugar de "Stable", ahora será "Matic".

Como MATIC no es una stablecoin y tiene un valor que varía, vamos a poner una propiedad que será el precio, que es la que devolveremos cada vez. Entonces, creamos la propiedad "uint256 price", pero la pondremos como privada porque queremos que no se interactúe con este contrato directamente, sino que se haga a través de la interfaz "IOracle". Así que ya tenemos la función "getPrice".

Ahora aquí lo que podremos hacer es, en lugar de devolver 1e18, devolver la propiedad "price". Esto ya no será "view", ahora será "view" porque estamos leyendo algo del smart contract. Sin embargo, ahora mismo no le estamos asignando valor. Vamos a cambiar esto. Cuando despleguemos el smart contract, le pondremos en el constructor un parámetro "price" que será el que asignaremos a la propiedad "price". Esto es lo mismo que hemos hecho en otras ocasiones.

Cuando desplegamos el smart contract, le decimos que el MATIC vale tanto y se almacena esa variable. Cuando llamemos a "getPrice", será ese valor. Pero claro, MATIC es un token que cambia de precio, así que deberíamos tener aquí una función que nos permita cambiar ese valor. Vamos a hacer un "setPrice". Esto es muy parecido a lo que hemos hecho en vídeos anteriores. Establecemos el "price", esto será "public". No es "view" porque estamos cambiando el precio, así que esto será una transacción que modifica el estado.

Vale, pues ya tenemos dos contratos distintos, dos oráculos distintos, pero ambos implementan la misma interfaz "IOracle". Así que, como hemos dicho, nos da igual cómo esté implementado cada uno de estos smart contracts, porque nosotros solo utilizaremos esta interfaz. Vamos a llamar a "getPrice". Nos da igual cómo esté implementado, qué tiene por dentro, si llama a otros contratos; eso nos es indiferente.

Ahora vamos a crear otro smart contract que nos permita interactuar con estos. Vamos a crear uno que se llame "PriceChecker". Copiamos esto, el contrato se llamará "PriceChecker". Este contrato no le pondremos "is IOracle" porque no implementará "IOracle"; lo que hará es llamar a esos otros oráculos. En lugar de importar cada uno de ellos, podríamos hacer un "import MaticOracle.sol" e interactuar con "MaticOracle". Pero la gracia de esto es que basta con tener esta interfaz; podemos comunicarnos con cualquiera de ellos simplemente usando la interfaz y haciendo referencia al address de cada uno de esos contratos.

Vamos a hacerlo bastante genérico. Haremos un mapping, que es algo que ya hemos visto en el vídeo anterior, cuya clave será un address, que será el address del token cuyo precio queremos comprobar, y cuyo valor será un "IOracle", es decir, un objeto, un contrato que implementa la interfaz "IOracle". Lo pondremos como público y lo llamaremos "oracles". Básicamente, es un mapping que nos dice para cada token cuál es su oráculo.

¿Qué tenemos que hacer ahora? Haremos un setter para poder rellenar eso. Este recibirá el token al que queremos consultar el precio y el address del oráculo que nos dará esa información. Será público. Entonces, lo que hacemos, como hemos hecho en otros vídeos, es "oracles[token] = IOracle(oracle)". Con esto estamos instanciando un contrato que sigue esta interfaz con esta dirección. Entonces, esto es un objeto al que podremos llamar a todas sus funciones. Bueno, a todas, en este caso, es únicamente "getPrice".

Con esto ya no necesitamos nada más. Con acceder a "oracles[token]" ya tendremos acceso a esa función. Pero también queremos que nos diga el precio, así que vamos a crear una función que llamaremos "checkPrice". Aquí le diremos que reciba la dirección del token. Es decir, cuando le diga aquí la dirección del token USDT, por ejemplo, me devolverá 1, porque llamará internamente a través de la interfaz de "IOracle", llamará al "StableOracle" y me devolverá lo que sea que implemente esa función.

Vale, pues esto será "public view" y nos devolverá un "uint256". Entonces, esto nos devolverá lo que haya en "oracles[token]", que nos devolverá el objeto "IOracle", y de este llamaremos a su función "getPrice". Y ya está. Con esto ya tendríamos un contrato que podemos surtir de todos los oráculos que creemos, asociados a cada uno de los tokens, y podemos consultar los precios de cada uno de esos tokens.

Ahora vamos a desplegarlos, a compilarlos y a ver que todo funciona bien. Como está en "autocompile", aquí no habrá ningún problema. Vamos a empezar desplegando, por ejemplo, el "StableOracle", que es el primero que hemos hecho. La interfaz no se despliega; lo que desplegamos son cada uno de estos oráculos que implementan esa interfaz. Desplegamos el "StableOracle". Ha ido todo bien y aquí lo tenemos. De hecho, si le diésemos aquí a "getPrice", nos devolvería un 1 seguido de 18 ceros. Perfecto, lo mismo que esperábamos.

Ahora vamos a desplegar el de MATIC. Aquí nos pide un parámetro. Nos venimos aquí y decimos: "¿Cuánto vale ahora mismo un MATIC en USD?". Esto lo tenemos que transformar a... lo tenemos que escalar, es decir, multiplicar por 10 elevado a 18, para que tenga el mismo número de decimales que todos los demás oráculos. Así que lo que hacemos es pegar aquí el número, cambiamos la coma por un punto y decimos "por 10^18". Y entonces esto nos tiene que devolver el valor. Aquí está.

Vale, pues cogemos este número, que es 0.84 x 10^18, lo pegamos aquí y desplegamos el smart contract. Vale, ya tenemos aquí desplegados el "StableOracle" y el "MaticOracle". Lo mismo aquí, si le damos a "getPrice", nos devuelve ese valor. Podríamos actualizar el valor si luego cambiásemos, pero ahora no lo vamos a hacer. Por último, vamos a desplegar el "PriceChecker". Lo desplegamos y aquí lo tenemos.

Ahora mismo no tenemos ningún oráculo dentro de este mapping, así que lo que vamos a hacer es rellenarlo. Vamos a poner un oráculo para el USDT y otro oráculo para MATIC. ¿Cuál es el address del token? Yo lo tengo aquí ya abierto. En Etherscan, puedes buscar cualquier token. Aquí están los USDT, que son los más famosos. Aquí nos viene su dirección, que es la dirección del contrato. Al final, todos los tokens... Esto es un ERC20, es un smart contract que está desplegado. Copiamos su address y lo ponemos aquí en "setOracle". El token será este y el oráculo será el stable, así que como lo tenemos aquí desplegado, le damos al botón de copiar y lo pegamos.

Entonces estamos asociando la dirección de este token con la dirección de este oráculo. Llamamos a la transacción y se ha hecho correctamente. Ahora vamos a añadir, vamos a borrarlo para que no haya confusión. Ahora vamos a añadir el de MATIC. Vale, pues aquí lo mismo, tenemos aquí el token MATIC en la mainnet de Ethereum. Copiamos el address del token y ahora copiamos la dirección del oráculo de MATIC, que es este de aquí. Lo copiamos, lo pegamos y hacemos "Transact".

Muy bien, pues ya tenemos ambos oráculos. Si quisiésemos hacer una comprobación, copiamos aquí el address de MATIC y si le doy, me va a devolver 0.84, que es el oráculo de MATIC. Vale, pues entonces ya podemos consultar directamente los precios de cada uno de ellos. Vamos a consultar el de MATIC, que lo tenemos aquí a mano. Meto el address, estamos llamando a esta función de aquí, "checkPrice". Le vamos a meter el address del token de MATIC y a ver qué nos devuelve.

Vale, pues esto es lo que hemos puesto antes: 0.84 por 10^18. ¡Gracias por ver el vídeo! Y si queremos comprobar el precio del USDT, lo mismo. Vamos aquí a "checkPrice": 1 seguido de 18 ceros. Funciona perfectamente. Como veis, aquí estamos utilizando simplemente "IOracle" para interactuar con distintos smart contracts que están implementados de distinta manera. Cada uno tiene sus particularidades, pero la interfaz nos permite ser agnósticos a la implementación de ese smart contract. Lo único que nos interesa es la interfaz que presenta y la función "getPrice".

También podemos hacer ahora una modificación. Supongamos que el MATIC ha cambiado de precio. Vamos a simular que ha cambiado. Aquí tenemos este número, vamos a decir que en lugar de 0.84, sube a 0.87. Hacemos la transacción y copiamos de nuevo el número, la dirección de MATIC, "checkPrice", 0.87. Hemos cambiado el valor dentro del contrato del oráculo de MATIC y eso nos ha permitido que, cuando lo volvemos a consultar desde el contrato de "PriceChecker", obtenemos un valor distinto.

Y bueno, esto sería todo. Con esto hemos repasado un poco. Hemos visto cómo funcionan las interfaces. Hemos visto que son simplemente funciones sin cuerpo. Hemos visto cómo se importan contratos o interfaces de uno a otro. Hemos visto cómo hacer que un smart contract implemente una interfaz, poniéndole "is IOracle" y el nombre de la interfaz que hemos importado, y poniendo el cuerpo de la función, indicando que estamos haciendo un "override" de esa función. Luego, desde aquí, hemos visto cómo interactuar con distintos contratos a través de una interfaz unificada. ¡Gracias por ver el vídeo!


###  216.B4_Programación_de_Smart_Contracts_en_Solidity_IV-video

###  Programación de Smart Contracts en Solidity IV
![[216.B4_Programación_de_Smart_Contracts_en_Solidity_IV.mp4]]
[Programacion de Smart Contracts en Solidity IV](https://app.web3mba.io?wvideo=u1x4589guk)

En este vídeo vamos a hablar de OpenZeppelin. OpenZeppelin es una compañía que implementa una serie de contratos en Solidity, es decir, smart contracts. Muchas veces, implementa los estándares de una manera que está muy probada, auditada y es muy segura. Por lo tanto, en lugar de tener que implementar nosotros mismos smart contracts muy extendidos, como pueden ser el ERC20 o el ERC721, OpenZeppelin ya nos proporciona contratos que son muy seguros y fiables. Así que, en lugar de reinventar la rueda, es muy recomendable utilizar estos contratos que ya existen y que son tan confiables. Vamos a ver algunos ejemplos, los integraremos en Remix y observaremos cómo funcionan.

Nos unimos aquí a los contratos. Esta es la documentación de OpenZeppelin. Como podemos ver, tiene multitud de recursos, incluyendo temas de control de acceso, tokens, gobernanza y otras utilidades. Comenzaremos, por ejemplo, con el tema del control de accesos. También podemos revisar directamente el código fuente en GitHub, lo cual es bastante útil. Aquí accedemos a su repositorio de contratos. Esta es la última versión, pero se pueden seleccionar versiones anteriores si deseamos utilizar otros compiladores. Aquí podemos ver todas las versiones disponibles.

Vamos a ir a Remix y crearemos un contrato que utilice el control de acceso. Si habéis echado un vistazo a los smart contracts que vienen por defecto en Remix, notaréis que hay uno que se llama Owner. Este contrato permite utilizar un modificador que restringe quién puede acceder a ciertas funciones. Esto es similar a lo que hemos visto en un vídeo anterior, donde solo algunas direcciones pueden realizar ciertas acciones. En este caso, las funciones que tengan ese modificador OnlyOwner solo pueden ser utilizadas si la cuenta que lo envía es la que se ha establecido como owner.

OpenZeppelin ya nos proporciona una funcionalidad muy similar a esta, de modo que podemos simplemente utilizar su modificador en lugar de tener que implementarlo nosotros mismos. Así que, vamos a crear una carpeta que llamaremos OpenZeppelin y crearemos un contrato que llamaremos ContractWithOwner, por ejemplo. Vamos a copiar, como hacemos siempre, la licencia y la versión, y ahora importaremos el smart contract. Hay varias maneras de hacerlo. Si nos fijamos en la documentación, aquí nos explican cómo instalarlo, pero desde Remix no es necesario hacer ninguna instalación, ya que automáticamente detecta si estás utilizándolo y te instala el paquete directamente.

Entonces, se puede hacer de esta manera, con `@openzeppelin/contracts` y la ruta hacia el contrato que queramos, o incluso se puede hacer referencia directamente al smart contract desde GitHub. Si copiásemos esta URL de OpenZeppelin contracts, nos llevaría hasta allí. Pero, por ahora, nos quedaremos simplemente con el AccessControl. Vamos a copiar aquí lo que nos viene de ejemplo. En este caso, queremos el de Ownable. Aquí podéis comprobar que lo que viene es muy similar al ejemplo que se encuentra en Remix. Tenemos una propiedad privada que se llama Owner, y también tenemos una serie de eventos, etc. Lo importante es el modificador OnlyOwner, que comprueba que el owner del contrato es el mismo que el messageSender y, si no, nos lanza un error: "OwnableCaller is not the owner".

Así que, tenemos importado el smart contract de Ownable, y vamos a crear nuestro contrato, que hemos llamado ContractWithOwner. De una manera muy similar a como hicimos antes con las interfaces, para que un contrato implemente el nombre de la interfaz, este contrato lo que hará es heredar del contrato Ownable. Así que utilizamos `is` y el nombre del contrato que estamos heredando, `is Ownable`. Con esto, nuestro contrato es como si estuviese embebido dentro del contrato Ownable, lo que nos da acceso a todas las funciones y modificadores que esto permite.

Ahora que tenemos esto, vamos a probar a crear una propiedad uint256 que será pública y la llamaremos number, como hemos hecho en otras ocasiones. No creo que haga falta ni hacer un constructor, así que simplemente haremos la función de set. Esta función recibirá un parámetro llamado _number, será pública y aquí asignaremos `number = _number`. Así que, esto es como lo hicimos inicialmente, de modo que cualquier dirección puede hacer esta modificación. Pero si ahora añadimos aquí el modificador OnlyOwner, que de nuevo es el que nos viene en el contrato Ownable que estamos heredando, ya no permitirá que cualquiera lo modifique, solo el owner.

¿Y quién es el owner por defecto? El address que despliega el contrato. Muy bien, vamos a hacer una prueba. Vamos a desplegar este contrato. Además de las funciones que hemos definido, que son el number, que es la propiedad pública, y el setNumber, que es la función para establecer esa propiedad, vemos que aparecen aquí algunas otras funciones o propiedades. Por ejemplo, esta owner, que también será una función pública que nos ofrece el contrato Ownable y que nos devuelve el address del owner. Como vemos, coincide con el address de la cuenta que ha desplegado el smart contract, y el number inicialmente es cero.

Podemos establecerlo, por ejemplo, en 15, y si le damos a number, nos aparecerá porque hemos podido cambiar ese número. Si ahora utilizásemos otra cuenta distinta, por ejemplo, la segunda de la lista que nos aparece aquí, e intentásemos cambiar ese número, por ejemplo, a 7, mandaríamos una transacción y nos daría un fallo. La transacción ha revertido, y el motivo que nos da es "OwnableCaller is not the owner", que es el mensaje que se muestra cuando el require falla, al comprobar que el owner no coincide con quien está enviando la transacción.

Entonces, ¿qué más opciones nos proporciona este contrato Ownable? Una opción es renunciar a la propiedad del contrato. Pero hay que tener cuidado con esto, porque una vez que renuncias a la propiedad, ya no puedes recuperarla, de modo que todas las funciones clave que están protegidas bajo el OnlyOwner ya no serían accesibles. Así que recomiendo tener mucho cuidado al hacer esto. Lo que sí se permite, y que en muchas ocasiones es bastante útil, es transferir la propiedad del contrato a otra cuenta. Por ejemplo, ahora estamos con esta cuenta, y no nos ha dejado cambiar el número, pero si cambiásemos la propiedad del contrato a otra cuenta, si lo hacemos desde la propia cuenta, no nos dejará, solo el owner puede hacerlo.

Entonces, si volvemos a enviar esa transacción con el owner, nos permitirá cambiarla, y ahora el que antes era owner ya no podrá hacer estos cambios porque ya no es el owner. Tendría que ser esta nueva cuenta quien realice ese cambio. Una vez que lo hace, ya sí que nos ha permitido cambiarlo y comprobamos que efectivamente ha cambiado este número. Este es uno de los ejemplos de smart contracts que facilita bastante el desarrollo con OpenZeppelin.

Ahora vamos a hacer otro ejemplo, vamos a crear un token ERC20. Si quisiéramos hacer un token ERC20 desde cero, deberíamos crear la propiedad de los balances, que sería un mapping, como hemos mencionado en otro vídeo, de cuánto balance tiene cada usuario. Tendríamos que implementar la función de minteo, de transferencia, y todas las que vienen definidas en el estándar. Pero como eso es algo muy habitual y ya está hecho mil veces, en lugar de hacerlo desde cero, vamos a importar el smart contract ERC20 que nos ofrece OpenZeppelin.

En la sección de contratos, tenemos un apartado que es tokens, donde encontramos distintos estándares. En este caso, nos centraremos en el ERC20. Vemos que está el ERC20 y también está el IERC20, que es la interfaz de utilización del ERC20. El que vamos a utilizar es el ERC20. Lo dejo aquí abierto para que luego consultemos alguna cosa, pero como veis, es básicamente la implementación del estándar de una manera muy segura y totalmente probada.

Así que vamos a crear un nuevo contrato y lo llamaremos MyToken.sol. Copiamos esto y la importación ya no será en AccessControl, sino que será en ERC20.sol. Entonces, aquí, igual que antes, declaramos el contrato, en este caso MyToken, que hereda de ERC20. Ahora, ¿qué tenemos que hacer aquí? Debemos definir el constructor, porque el contrato de OpenZeppelin requiere que se le indique el nombre y el símbolo del token. Por lo tanto, es necesario tener un constructor, ya que el contrato padre, que en este caso es el ERC20 de OpenZeppelin, requiere estos parámetros.

La manera de realizar el constructor es un poco diferente. Haremos el constructor, le pasaremos los parámetros que necesitamos, y luego debemos llamar a ERC20, que es el nombre del contrato padre, y entre paréntesis, pasaremos los parámetros que nos pide, que son el nombre del token, que será "MyToken", y el símbolo del token, que será "TKN". Este sería el constructor, así que, haciendo únicamente esto, ya tendríamos un smart contract de un token ERC20.

El problema es que ahora mismo no se ha minteado ningún token, es decir, sería un token con un total supply de 0. Así que hay que mintear algo, es decir, debemos generar una cantidad de tokens para alguien. Lo común aquí es dárselo al que ha desplegado el smart contract. Entonces, accederíamos a la función mint y diríamos para quién estamos minteando, que será el message.sender. ¿Y cuánto estamos minteando? Vamos a poner aquí un 1 seguido de un montón de ceros.

¿Por qué llamamos a mint? Estamos invocando una función que no estamos viendo, pero esta función es interna y nos ofrece el ERC20. Antes hemos hablado de las funciones públicas, privadas y externas, y ahora nos queda hablar de las funciones internas. Si buscamos mint, vemos que esta es una función interna. ¿Qué implica eso? Las funciones privadas solo se pueden acceder desde el mismo contrato, mientras que las funciones internas también se pueden acceder desde subcontratos, es decir, desde un smart contract que herede de este.

Y eso es justo lo que estamos haciendo. Desde el constructor del smart contract, llamamos a mint, indicando a qué cuenta y la cantidad, y esto, después de hacer ciertas comprobaciones, realizará la acción. Como vemos, está aumentando el total supply, emitiendo un evento, cambiando el balance y realizando una serie de acciones. Si hacemos esto, nuestro smart contract, nuestro token ERC20, tendrá esta cantidad de tokens, y nunca se podrá modificar la cantidad total porque no hay manera desde fuera de llamar a esta función. Al ser una función interna, no tendremos acceso a ella.

Vamos a hacer la demostración. Desplegamos el contrato anterior y desplegamos MyToken. Aquí ya vemos que hay un montón de información. Cuando no hemos dado ninguna función, todas estas son propias internas del ERC20 de OpenZeppelin. Entonces, ¿qué vemos aquí? El name, que es MyToken, el símbolo, que es TKN, y el totalSupply, que es la cantidad que hemos definido. TotalSupply indica cuántos tokens hay de este ERC20. ¿Hemos minteado todos estos? Eso es lo que hay. Los decimales, por defecto, son 18, que es muy común.

Podemos hacer una prueba de sobrescribir alguno de esos valores. También podemos comprobar el balance. Si vemos el balance del usuario que ha desplegado el smart contract, veremos lo que hemos minteado. Tiene sentido. Si cogiésemos otro, por ejemplo, este de aquí, nos dirá que es cero, por supuesto, porque no ha recibido ningún token. Aquí tenemos también las funciones de approve, transfer, etc. El allowance permite que otra cuenta use tus tokens de alguna manera, que pueda transferirlos o hacer lo que quiera con ellos.

Entonces, si estamos así, lo único que podemos hacer para que estos tokens cambien de mano es que el usuario los transfiera. Es la única manera. Vamos a probar a hacer la transferencia. Transferimos a esta otra cuenta que hemos puesto la mitad de los tokens. Si aquí hay esto que empieza por 1, 0, borramos 2, ponemos un 5, y hacemos la transacción. Se ha realizado la transferencia. De hecho, ahora, si lo vemos, vamos a notar que se ha generado un evento de transferencia. Aquí está: evento transfer desde esta cuenta hasta esta cuenta por el valor correspondiente.

Ahora, el balance que antes era 0, ahora será un 5 seguido de todos esos ceros. Como hemos mencionado, no hay manera de que se puedan mintear nuevos tokens. Es decir, nunca habrá más de estos tokens, ni menos, porque no se permite mintear ni quemar ninguno de esos tokens. Para modificar eso, deberíamos implementar una función de minteo. Aquí le pondríamos, digamos, que la forma de la función será muy similar a esto, que queremos mandárselo a una cuenta y una cantidad. Hacemos addressToMintAmount y lo pondremos de manera pública.

Aquí llamaremos a la función interna, que es esta de aquí. Entonces, lo que hacemos es mintear con la función que nos provee OpenZeppelin, mint, para la dirección y la cantidad. Como es una función interna, aquí no nos aparece, pero en cuanto damos una puerta de salida al exterior, que es una función pública, al desplegar el token de nuevo, veremos que ahora sí tenemos esta función de mint. El total supply sigue siendo el mismo, y si minteamos otra cantidad para quien sea, para la misma cuenta que lo ha desplegado, el total supply se duplicará.

Con esto, sí podemos aumentar la cantidad. ¿Qué más podríamos hacer? Antes de continuar, no es muy seguro tener una función de mint que sea pública, porque cualquiera podría venir y mintear tokens gratis para sí mismo. Entonces, ¿qué tenemos que hacer? Limitar quién puede mintear. Una manera clara de hacerlo es importar también el contrato Ownable de OpenZeppelin. Así, haremos que este smart contract, además de ser un ERC20, también sea Ownable. Solo el propietario de este smart contract podrá mintear.

Si volvemos, eliminamos este smart contract, lo desplegamos de nuevo y lo hacemos con la cuenta de arriba del todo, ahora solo el propietario, que aquí vemos de nuevo owner, será el único que podrá mintear. Si yo ahora quiero mintear con esta cuenta, puedo hacerlo. Pero si llega otra cuenta, por ejemplo, la última que hemos seleccionado antes, e intenta mintear para sí misma, se encontrará con que no puede. Esto combina lo que hemos visto del ERC20 con lo que hemos visto previamente del Ownable.

Estas son pequeñas piezas del rompecabezas que vamos uniendo, y sin apenas haber desarrollado nosotros prácticamente nada, ya estamos dando una funcionalidad más compleja. ¿Qué más podríamos hacer? De la misma manera que estamos minteando con el OnlyOwner, podríamos implementar una función para quemar tokens. La función de quemar tokens hace justo lo contrario, como podéis imaginar. También tenemos aquí una función interna dentro del ERC20 que permite quemar tokens de una cuenta específica.

Entonces, de manera sencilla, hacemos una copia y donde ponemos burn, ya está. Ahora, vamos a quemar un 10%. Le he quitado un 0 y de esta misma cuenta, porque hay que quitárselo a alguien que tenga los tokens, sino no podremos. La transacción ha ido correctamente y esto nos ha generado un evento. Como vemos, no hay un evento específico de quemar. Cuando se están quemando tokens, internamente se está haciendo una transferencia a un address que, al final, es lo mismo, porque nadie posee el wallet y, por lo tanto, nadie puede hacer nada con ello.

Así que, básicamente, esto es lo que hemos hecho. Si comprobamos el total supply, en lugar de 1,0 ahora hay un 9. Y aquí lo mismo, no podríamos quemar tokens desde otra cuenta que no tenga tokens. Por ejemplo, si intentamos quemar desde aquí, nos fallará. Primero, nos fallará porque estamos haciéndolo desde una cuenta que no es la 1, y si cambiamos al owner y lo intentamos de nuevo, nos fallará porque la cantidad que estamos intentando quemar excede el balance de esa cuenta. Lo mismo ocurre si intentamos hacer una transferencia; no puedes transferir más de lo que tienes, etc.

Este es un ejemplo sencillo de cómo modificar un ERC20. Os recomiendo que le echéis un vistazo a la implementación para ver cómo lo hace y demás. Otras opciones que se podrían cambiar, como he mencionado, son los decimales. En este caso, se podría sobrescribir esta función que es pública. Utilizando el override, igual que hemos hecho antes con las interfaces, en lugar de que los decimales sean 18, podríamos cambiarlos a 6, 12 o cualquier otro número que nos sea más manejable. Si no lo veis claro, de todos modos, id a la documentación. En la documentación se explica bastante bien los contratos y cómo hacer este tipo de modificaciones, por ejemplo, cómo modificar el tema de los decimales.


###  217.B4_Herramientas_no-code_para_Smart_Contracts-video

###  Herramientas no-code para Smart Contracts
![[217.B4_Herramientas_no-code_para_Smart_Contracts.mp4]]
[Herramientas no-code para Smart Contracts](https://app.web3mba.io?wvideo=0loo3xj76e)

Una parte importante de toda la etapa de programación o desarrollo de una aplicación tiene que ver con las plataformas que nos permiten interactuar con la blockchain. En este caso, estudiaremos dos plataformas muy conocidas dentro de la comunidad: Infura y Alchemy. Presentemos cada una de ellas.

Infura es una plataforma dedicada a ofrecer a los desarrolladores de aplicaciones descentralizadas servicios que les permitan interconectar sus aplicaciones con los diferentes ecosistemas blockchain a los que esta plataforma tiene acceso. La idea es bastante sencilla: Infura se encarga de gestionar la conexión a la blockchain, es decir, a todos los nodos y las funciones que estos pueden realizar dentro de la red. Ofrecen una API sencilla a los desarrolladores para que puedan conectar sus aplicaciones a través de esta API y, de esta manera, acceder a las blockchains que Infura soporta.

Como pueden ver, es una web bastante conocida en el mundo del desarrollo web y de aplicaciones descentralizadas, ya que grandes figuras del ecosistema, como Metamask, Uniswap o Brave, dependen de las infraestructuras de Infura para su funcionamiento. Entonces, ¿cómo podemos acceder a todos estos recursos de manera sencilla? La mejor manera es simplemente ir a su web, que es la que estamos viendo en pantalla. Podemos realizar un login, ya que los servicios básicos de esta web son completamente gratuitos. Existen servicios de pago, pero estos están destinados a grandes aplicaciones que requieren un uso más amplio de recursos, por lo que tendrían que aportar una cierta cantidad de dinero o pagar una suscripción a los servicios de Infura.

Sin embargo, si eres un desarrollador que está empezando o que quiere desarrollar una aplicación sencilla, no te preocupes, porque Infura ofrece un plan gratuito que es el que empezaremos a ver aquí para que sepas cómo utilizarlo y desplegar todo el potencial de esta plataforma. En este caso, ya tenemos aquí un login y simplemente procederemos a iniciar sesión. Si es tu primera vez en la plataforma, lo primero que debes hacer es registrarte. Aquí puedes crear una cuenta ingresando tu correo electrónico, contraseña y aceptando los términos de uso. Luego, cuando tengas creada la cuenta, simplemente regresas a Login y aquí sí podrás acceder a la plataforma.

En este punto, ya podemos ver el dashboard de Infura. Se nos presenta información relevante, siendo la más importante el merge, ya que Infura tiene acceso a la red Ethereum. De hecho, fue creada con esa red en mente. Aquí podemos ver todos los productos que podemos desplegar. En este caso, tenemos la Web3 API, que es la API de Ethereum, la API de ETH2, IPFS y Filecoin. Estas son las cuatro redes que Infura soporta de forma oficial y completa. También podemos ver los roles que puedes crear dentro de cada uno de tus proyectos: dueño, administrador o colaborador.

Ahora bien, ya tenemos desplegada toda la parte del dashboard. Quiero crear una API que me permita interconectar mi aplicación en desarrollo con las capacidades que Infura me ofrece. Para ello, simplemente iremos a crear una nueva API o una nueva clave y seleccionaremos la red que queremos utilizar. En este caso, seleccionaremos la Web3 API. Podemos dar un nombre, por ejemplo, "Testing de Pruebas", y creamos. Automáticamente, ya tenemos aquí nuestra primera API key, que es el dato que aparece aquí. También tenemos los endpoints de la red, que son las redes que podemos utilizar. En el lado de Ethereum, podemos utilizar la red mainnet o las redes de pruebas Ropsten, Kovan, Rinkeby, Goerli y Sepolia.

Es decir, si queremos crear una aplicación descentralizada que funcione en la mainnet, debemos copiar este endpoint que está aquí. Esta API Key es la misma que se repite aquí, para que nuestra aplicación descentralizada se conecte automáticamente a Infura y los datos que comparte tu aplicación con Infura se dirijan a la red main. Si queremos utilizar alguna otra red, simplemente seleccionamos y automáticamente la dirección cambia, en este caso, a rekenv-info.io. Esto significa que todo lo que hagamos con nuestra DApp se dirigirá a la red de pruebas.

Por supuesto, esto es solo para el caso de Ethereum. También podemos trabajar con otras redes, como Polygon, Optimism, Arbitrum o Avalanche. Si seleccionamos Polygon, podemos agregar la red Mainnet, pero también podemos agregar la red Mumbai, que es la red de testnet. ¿Qué sucede en este punto? Infura nos pide un complemento, un addon sobre la plataforma. Si vamos allí, nos solicita que seleccionemos un plan de pago, que puede ser el más sencillo, el de Developer, para poder activar esta función.

Sin embargo, en este caso, simplemente nos manejaremos con Ethereum y volveremos atrás. Podemos ver aquí que tenemos estas cuatro opciones, pero son pagas. Debemos cancelar una pequeña suscripción para poder utilizarlas. También tenemos acceso a otras redes del tipo Web3, como Near, Aurora y la red Starknet. Sin embargo, redes como Avalanche, Near, Staken y Aurora están en lo que se llama pruebas beta privadas. Es decir, se nos presta el servicio para este tipo de redes, pero debemos ser conscientes de que pueden haber fallos debido a que están en desarrollo dentro de la infraestructura de Infura.

Si pasamos a Settings, podemos cambiar el nombre de nuestro proyecto o borrarlo. También podemos gestionar la parte de seguridad, donde se nos recuerda que debemos mantener nuestra API Key en secreto. Esto nunca debe ser legible para humanos en tu aplicación. ¿Por qué estas advertencias sobre la API Key? La API Key es muy importante porque es la interfaz que te permite conectar tu aplicación con los servicios de Infura. Si alguien tiene tu API Key, esa persona tiene acceso a tu aplicación y a todo lo que esta realiza. Por lo tanto, la API Key siempre debe estar bien protegida o, en este caso, ofuscada de alguna manera para que cualquier persona que tenga acceso a tu código no pueda leerla directamente. Debes cuidarla como si fuera tu clave privada de criptomonedas, porque esta API Key es la llave secreta para acceder a todo tu sistema de interacción con Infura y tu aplicación.

Aquí también tenemos otros requerimientos, como un secret, en caso de que quieras agregar una clave adicional, o un sistema de JWT, que utiliza un sistema de claves públicas y privadas para agregar una seguridad extra a tu API Key. Finalmente, también tenemos la parte de Project Sharing, que nos permite compartir nuestro proyecto con otras personas. Simplemente debemos agregar un correo electrónico y seleccionar el rol: administrador o colaborador. ¿Por qué solo dos roles si mencioné tres? La persona que crea el proyecto es el dueño, y este permiso no cambia en ningún momento. La persona que abrió el proyecto será siempre el dueño. Luego, simplemente nos quedaría asignar los roles de administrador y colaborador. Agregamos el correo, seleccionamos el rol y compartimos el proyecto para que esta persona pueda colaborar contigo sin mayores dificultades en el desarrollo de tu aplicación descentralizada.

Como puedes ver, la parte administrativa que nos permite Infura es bastante sencilla. Aquí también tenemos un apartado de estadísticas, que nos indica cuántas veces estamos haciendo solicitudes a Infura. Cada vez que realicemos una acción dentro de nuestra aplicación descentralizada, se nos informará cuántas veces hemos hecho una acción. También tenemos un reporte que nos dice cuántas veces hemos realizado acciones dentro de nuestra aplicación descentralizada. Esta actividad se reflejará en el total de solicitudes en las últimas 24 horas, y también nos indicará qué método se ha utilizado y cuántas de esas solicitudes han ido a la red.

Finalmente, tenemos la sección de explorador, que nos permite crear proyectos y almacenar datos dentro de la red IPFS. Por ejemplo, si seleccionamos "Testing", ya tenemos nuestro proyecto. Nos indica que tenemos un total de 5GB de almacenamiento gratuito, sin restricciones de tamaño de archivos, y podemos subir o bajar 5GB de datos al mes. Este es nuestro plan básico. Si queremos aumentar nuestro plan, podemos comprar más espacio para seguir aumentando la capacidad de este sistema.

¿Para qué se utiliza el sistema de IPFS? Si nuestra aplicación descentralizada necesita almacenar información de las interacciones o de los usuarios, IPFS es una opción potente para almacenar toda esa información de forma descentralizada. Cada usuario tendrá su propio espacio de almacenamiento dentro de esta red descentralizada, y todos los datos estarán vinculados a la interacción de ese usuario. Es decir, todos los usuarios pueden leer la información que ha subido al IPFS a través de tu aplicación descentralizada, pero ninguno de los otros usuarios puede leerla sin las claves privadas que se almacenan en el monedero de cada persona. Es la mejor forma de almacenar datos en la nube, ya que mantiene privados los datos de cada uno de sus usuarios.

Como pueden ver, todas las opciones que Infura nos ofrece son bastante potentes y flexibles para generar aplicaciones descentralizadas. Haciendo una acotación, vamos a la parte de aplicación. Aquí está nuestra aplicación, "Crear 18", y vamos a manejar la API Key, que es la que está en la parte inferior. Esta es nuestra API Key y es el dato que debemos tomar para llevarlo a nuestra aplicación descentralizada. Esto lo veremos más adelante para que vean cómo utilizar este dato en nuestras aplicaciones y así interactuar con la blockchain de una forma más sencilla, utilizando códigos en Python o JavaScript, que son los dos lenguajes de programación más utilizados para generar aplicaciones descentralizadas.

Ahora, en sus pantallas tenemos a Alchemy. Alchemy, al igual que Infura, es un servicio de desarrollo para aplicaciones web 3 descentralizadas que nos permite crear APIs que facilitan la integración de nuestras aplicaciones con el universo blockchain de la web 3. ¿Qué diferencia hay entre Infura y Alchemy? El mercado de las aplicaciones descentralizadas es el mismo, pero la principal diferencia radica en la capacidad y las opciones de redes que tenemos activas dentro de Alchemy. Alchemy soporta bloques como Ethereum, Solana, Optimism, Polygon, Arbitrum, Crypto.org, Starknet y Astar, lo que nos brinda un mayor abanico de aplicaciones blockchain para crear nuestras propias aplicaciones.

Al igual que Infura, podemos utilizar todo este poder a través de Web3 APIs, que podemos crear fácilmente al acceder a la plataforma. ¿Cómo podemos acceder a la plataforma? Simplemente vamos a la parte de Login y aquí tenemos la opción de suscribirnos utilizando una cuenta de Google o registrándonos con un correo electrónico y contraseña. En este caso, utilizaremos la suscripción por Google. La interfaz es bastante sencilla y distinta a la de Infura, pero ya tenemos el dashboard y una aplicación de prueba creada. Como no hemos tenido ninguna interacción, simplemente nos aparece que no hay información que mostrar en el dashboard.

Si queremos crear una aplicación, es decir, si queremos crear nuestra propia API para utilizarla en nuestra aplicación descentralizada, es bastante sencillo. Simplemente debemos ir a "Create App" y ofrecer un nombre para la misma. En este caso, pondremos "Testing" y haremos una descripción: "Aplicación de prueba para el desarrollo". Luego, elegimos la cadena, donde tenemos opciones como Polygon, Solana, Astar, y seleccionamos Ethereum y la red Goerli. Creamos la aplicación y ya estamos dentro del dashboard de nuestra aplicación recién creada utilizando la red Goerli.

Ahora bien, ¿dónde está nuestra API Key? Simplemente vamos a "View Key" y allí está nuestra API Key para interactuar con los servicios de Alchemy y todo el poder de esta red dentro de Ethereum. Fíjense que aquí está nuestra API Key, utilizando el protocolo HTTPS y WebSockets. Aquí están las capacidades de cómo podemos utilizar el SDK o las herramientas de desarrollo de Alchemy, utilizando lenguajes de programación como JavaScript, una consola o Python. También podemos utilizar Go, un lenguaje bastante potente. Como pueden ver, hay varias opciones de lenguaje que podemos utilizar para realizar todas estas acciones.

Es importante copiar esta API Key y colocarla en nuestros programas de prueba o en nuestra aplicación para utilizar todo este potencial. En la parte de seguridad, podemos permitir direcciones de uso que estén permitidas para la aplicación, dominios o direcciones IP. Esto funciona como un muro de fuego, controlando qué direcciones pueden interactuar con tu aplicación. También podemos agregar un monedero que nos dirige a recargar la parte de Metamask y agregar ETH de prueba.

Fíjense que aquí ya estamos en la red Goerli. Vamos a hacer la conexión al faucet para probar. Ya estamos conectados y vamos a enviar la dirección de nuestro monedero, que ya está configurado para Goerli. Automáticamente nos enviará 0.25 ETH a nuestro monedero. También podemos solicitar tokens de prueba en la red Mumbai. Vamos a esperar un momento a que la operación se haga efectiva.

Las interacciones que se realizan en redes como Mumbai y Goerli, que son redes testnet, no necesitan dinero real, pero sí requieren tokens de esas redes para funcionar. Recordemos que estas redes operan como la red Mainnet de Ethereum, por lo que necesitamos pagar las comisiones de esas redes. Esto del faucet nos ayuda a tener fondos en nuestros monederos, aunque sean de la red testnet, para realizar diferentes interacciones con estas redes.

Finalmente, cerremos aquí un momento y volvamos a Alchemy. Ya podemos ver el dashboard de Alchemy y las cuatro opciones que nos ofrece: seguridad, cómo agregar un monedero, cómo agregar tokens de prueba y cómo realizar interacciones con nuestras aplicaciones. En el explorador, tenemos toda la actividad que se ha realizado dentro de nuestra aplicación descentralizada. También tenemos el compositor, que nos permite crear solicitudes especializadas utilizando las diferentes cadenas que Alchemy soporta.

Podemos solicitar el bloque o la chain ID de una cadena, en este caso, la red Ethereum en la red Goerli. Al enviar nuestra solicitud, podemos recibir un mensaje de error si el origen no está permitido. Simplemente debemos permitir el origen y ya podremos empezar a hacer solicitudes. También tenemos acceso a la main pool, un observador de la main pool, y notificaciones sobre las diferentes actividades que podemos estar realizando con nuestra aplicación descentralizada.

Finalmente, Alchemy nos ofrece APIs avanzadas para transferencias, generación de metadata para tokens, balance de tokens, allowance, HMV Web 3, Smart Web Sockets, Trace API, Debug API y NFT API. Estas APIs de desarrollo son bastante potentes y nos permiten mejorar el debugging de nuestras aplicaciones descentralizadas. Es fundamental que ningún desarrollador deje de lado el debugging y el reconocimiento de errores para mantener las aplicaciones seguras y evitar que hackers o actores maliciosos puedan comprometer la seguridad de nuestras aplicaciones.

Como pueden ver, Alchemy es bastante sencillo de utilizar. Crear una cuenta aquí y empezar a utilizar su potencial es muy fácil.

---

Una parte importante de toda la etapa de programación o desarrollo de una aplicación de app tiene que ver con las plataformas que nos permiten interactuar con la blockchain. En este caso, estudiaremos dos plataformas que son muy conocidas dentro de la comunidad que son Infura y Alchemy. Presentemos cada una de ellas. Infura es una plataforma dedicada a ofrecer a los desarrolladores de aplicaciones descentralizadas servicios que les permitan interconectar sus aplicaciones con los diferentes ecosistemas blockchain a los que esta plataforma tiene servicio. La idea es bastante sencilla, simplemente, Infura se encarga de gestionar la conexión a todo lo que es la blockchain, es decir, todo lo que son los nodos, todo lo que estos pueden realizar dentro de la blockchain, y ofrecen una API sencilla a los desarrolladores para que estos puedan llegar y conectar sus aplicaciones por medio de esta API y, de esta manera, poder tener acceso a las blockchains que Infura tiene en su capacidad de utilizar. Como pueden ver, Es una web bastante conocida en el mundo del desarrollo web, del desarrollo de aplicaciones centralizadas, porque, de hecho, parte de lo que son las grandes figuras del ecosistema, como son Metamask, Uniswap o Brave, dependen de las infraestructuras de Ifura o utilizan las infraestructuras de Ifura para su funcionamiento. Entonces, ¿Cómo podemos llegar y acceder a todos estos recursos de manera bastante sencilla? Pues bien, la mejor manera es simplemente ir a su web, que es la que estamos viendo ahorita en pantalla Y tranquilamente podemos llegar y realizar un login porque los servicios básicos de esta web son completamente gratis. Hay servicios de pago, pero estos servicios de pago son para grandes aplicaciones que requieren de un nivel de uso de recursos mucho más amplio y que entonces, por lo tanto, tendrían que aportar una cierta cantidad de dinero o pagar una determinada suscripción a los servicios de Fura. Sin embargo, si tú eres un desarrollador que estás empezando o que quieres desarrollar una aplicación bastante sencilla, algo personal, no te preocupes, porque si tú eres un desarrollador que está empezando o que quieres desarrollar una aplicación bastante sencilla, no te preocupes, porque si tú eres un desarrollador que está empezando o que quieres desarrollar una aplicación bastante sencilla, no te preocupes, porque si tú eres un desarrollador que está empezando o que quieres desarrollar una aplicación bastante sencilla, no te preocupes, porque si tú eres un desarrollador que está empezando o que quieres desarrollar una aplicación bastante sencilla, no te preocupes, porque si tú eres un desarrollador que está empezando o que quieres desarrollar una aplicación bastante sencilla, no te preocupes, porque si tú eres un desarrollador que está empezando o que quieres desarrollar una aplicación Infura ofrece un plan gratuito que es el que empezaremos a ver aquí para que tú sepas cómo utilizarlo y cómo poder llegar y desplegar todo el poder de esta plataforma. En este caso ya tenemos aquí un login y simplemente vamos a proceder a loggearnos. Pero si esta es tu primera vez entrando a la plataforma, lo primero que debes hacer entonces es hacer la suscripción. y aquí está para que puedas crear una cuenta. Simplemente debes poner tu correo electrónico, tu contraseña y aceptar los términos de uso. Luego, cuando tengas creada ya la cuenta, simplemente vas nuevamente a Login y aquí sí podemos llegar y acceder a la plataforma. En este punto, ya podemos ver el dashboard de Infura. Podemos ver que se nos pone una información relevante. En este caso, la información más relevante es el merge. Porque Infura tiene acceso a lo que es la red Ethereum. De hecho, fue creado con esa red en mente. Y aquí podemos ver todos los productos que podemos despegar. En este caso, tenemos la Web3 API, que es la API de Ethereum. La API de ETH2. IPFS y Filecon. Estas son las cuatro redes que soporta Infura de momento de forma oficial y de forma completa. Y también podemos ver los roles que son en este caso los roles que tú puedes ir creando dentro de cada uno de tus proyectos. Puede ser el dueño, administrador o contribuidor al proyecto. Ahora bien. Ya tenemos aquí desplegado todo lo que es la parte del dashboard. Yo quiero crear una API que me permita interconectar mi aplicación que estoy desarrollando con las capacidades que KFuno me ofrece. Para eso, simplemente iremos a crear nueva API o crear nueva key y seleccionamos la red que queremos utilizar. En este caso, vamos a seleccionar la web3 API. y podemos dar un nombre, en este caso vamos a poner testing de pruebas y creamos. Automáticamente ya tenemos aquí nuestra primera API key, que es lo primero que nos aparece aquí, este dato que está aquí. Y tenemos también los endpoints de la red, que en este caso los endpoints de la red son las redes que podemos utilizar. En este caso, en el lado de Ethereum, podemos utilizar la red mainnet, o podemos utilizar las redes de pruebas Robstan, Coban, Rigby, Godly y Sepolia. Es decir, simplemente si queremos utilizar una... O crear una aplicación descentralizada que funcione en la mainnet, nosotros debemos copiar este endpoint que está aquí, que si nos damos cuenta, esta API Key es la misma que se repite aquí, para que nuestra aplicación descentralizada se conecte automáticamente a lo que es Infura y esos datos que comparte tu aplicación con Infura se vayan o vayan dirigidos a la red main. En el caso de que queramos utilizar alguna otra red, simplemente seleccionamos. y automáticamente fíjense que la dirección cambia, en este caso, rekenv-info.io. Eso significa que todo lo que hagamos con nuestra Dapp va a ir dirigido a la red rekenv. Por supuesto, esto es simplemente para el caso de Ethereum. También podemos funcionar con otras redes. Por ejemplo, en este caso podemos llegar a utilizar las redes Polygon, Optimum, Arbitrum o Parp. En este caso si seleccionamos Polygon, podemos agregar y agregar la red Mainnet, pero fíjense que también podemos agregar la red Moonbyte, que es la red de testnet. ¿Qué sucede en este punto? Que para ello, Infra nos pide un agregado, un addon sobre la plataforma. Si vamos allí, nos está pidiendo entonces que seleccionamos un plan de pago, en este caso puede ser el plan más sencillo, que en este caso es el de Developer, para llegar allí. poder agregar esta situación con el correspectivo pago que nos están solicitando para poder activar esta función. Sin embargo, en este caso simplemente nos vamos a manejar con Ethereum y vamos a volver atrás. Podemos ver aquí cómo entonces tenemos estas cuatro opciones, pero estas cuatro opciones son pagas. Debemos llegar y cancelar una pequeña suscripción para poder utilizarlas. Y también tenemos acceso a otras redes del tipo Web3, como sería en este caso Near, Aurora y la red Starnet. Sin embargo, tanto lo que es Avalanche.js, Nier, Stagne y Aurora, que son redes que están disponibles como podemos ver aquí Todas estas redes están en lo que se llama pruebas, eh... Betas privadas Es decir se nos presta el servicio para este tipo de redes, pero debemos estar conscientes de que hay cosas que pueden ir bastante bien o otras que pueden ir bastante mal debido a que están en desarrollo dentro de lo que sería la infraestructura de Infura. Si pasamos a Settings, podemos ver aquí que podemos llegar y cambiar el nombre de nuestro proyecto o borrarlo. Y también podemos elegir la parte de seguridad, viendo que en el principio tenemos aquí nuestra API. y nos dice aquí muy claramente, mantenga su APK en secreto. Esto nunca debe ser legible para humanos en tu aplicación. ¿Por qué estas vertencias dentro de la APK? Bueno, la APK es muy importante porque es la interfaz o el medio que te permite llegar y conectar tu aplicación con lo que son los servicios de Infura. ¿Qué sucede aquí? Que si alguien tiene tu APK, Esta persona tiene acceso a tu aplicación y todo lo que ello hace. Por lo tanto, la APK siempre debe ser bien protegida. o en este caso, ofuscada de alguna manera para que cualquier persona que pueda tener acceso a tu código o de repente esté incluida dentro de tu aplicación, no pueda leerla directamente. Es decir, debes cuidarla como si fuese tu clave privada de criptomonedas, como si fuera la clave privada de tu monedero, porque esta APK es la llave secreta para acceder a todo tu sistema de interacción con lo que sería Infura y tu aplicación. Aquí también tenemos otros requerimientos, como sería un secret, en el caso de que quieras agregar una clave adicional, o un sistema de JWT, que en este caso utiliza un sistema de claves públicas y privadas para poder llegar y agregar una seguridad extra a lo que sería tu APK. Finalmente también tenemos la parte de Project Sharing, que en este caso nos permite llegar y decir, mira, yo quiero compartir mi proyecto, quiero que estas personas puedan colaborar con mi desarrollo y simplemente nos pide aquí en la parte de fuera, es que agregamos un correo electrónico y seleccionamos el rol. administrador o contribuidor. ¿Por qué solamente dos roles si yo había mencionado en un principio tres? O sea, dueño, administrador y contribuidor. Bueno, la persona que crea el proyecto es el dueño. Este permiso no cambia en ningún momento. O sea, la persona que abrió el proyecto es la persona que va a ser el dueño de ese proyecto todo el tiempo. Luego, simplemente nos quedaría entonces los roles de administración y contribuidor. Simplemente agrega el correo, seleccionas el rol y compartes el proyecto para que esta persona pueda colaborar contigo sin mayores dificultades dentro de lo que sería el desarrollo de tu aplicación descentralizada. Como puedes ver, es bastante sencilla. la parte administrativa que nos permite infurar, lo que sería la APK, y de todo lo que sería la parte que nos permita conectarnos a sus servicios y todo lo demás. Aquí también tenemos un stats, que en este caso, los stats lo que nos dice es cuántas veces estamos haciendo los requests a lo que sería la parte de infura. Es decir, cada vez que hagamos una acción dentro de nuestra aplicación descentralizada, nos va a decir cuántas veces hemos hecho una acción. Y aquí también tenemos un reporte de la parte de infura, que nos dice cuántas veces hemos hecho una acción dentro de nuestra aplicación descentralizada. Y aquí también tenemos un reporte de la parte de infura, que nos dice cuántas veces hemos hecho una acción dentro de nuestra aplicación descentralizada. Y aquí también tenemos un reporte de la parte de infura, que nos dice cuántas veces hemos hecho una acción dentro de nuestra aplicación descentralizada. Y aquí también tenemos un reporte de la parte de infura, Esa acción o request se va a ver reflejada dentro de este total, que en este caso es el volumen total de request en las últimas 24 horas, y también nos va a decir qué método se ha utilizado y cuántas de esos requests han ido a la red. Toda esa actividad se puede ver aquí, dentro de lo que sería la parte de stats. También podemos ver las transacciones que se realizan. En este caso, está todo el proceso de cómo se realizan las transacciones, pero en este punto, este es un servicio que se requiere directamente a Infura. Infura manejaría toda esta parte directamente, evitando que, en caso de que estés haciendo una transacción o una operación, esto simplemente se pierda. Y Infura, con esta función, lo que hace es que simplemente agarra todas esas transacciones y maneja las mismas de una forma más inteligente para evitar que la interacción de tu DApp no sea la correspondiente o no sea la mejor en este caso. Finalmente, tenemos la sección de explorador, que en este caso es un explorador para la red IPF, que nos permite crear proyectos y hacer almacenamientos de datos dentro de la misma. Por ejemplo, en este caso, IPFS. Vamos a seleccionar aquí Testing. Y en este caso ya tenemos nuestro proyecto. Fíjense que nos está diciendo que tenemos un total de 5GB de almacenamiento gratuito. No hay tamaño de archivos restringido. Y podemos bajar 5GB de datos al mes o subir 5GB de datos al mes. Este es nuestro plan básico. Si queremos aumentar nuestro plan, podemos llegar y comprar más espacio para que entonces podamos llegar y seguir aumentando la capacidad de este sistema. ¿Para qué se utiliza en este punto el sistema de IPFS? Bueno, si queremos llegar y nuestra aplicación descentralizada necesita almacenar información de las interacciones o de los usuarios, IPFS es una opción bastante potente para llegar y almacenar toda esa información de forma descentralizada. De manera que cada usuario tenga su propio espacio de almacenamiento dentro de lo que sería esta red descentralizada de almacenamiento todos esos datos van a ir unidos a lo que sería la interacción de ese usuario, es decir... todos los usuarios pueden leer la información que ha subido al IPFS por medio de tu aplicación descentralizada. Ninguno de los otros usuarios puede leerla porque para poder realizar esta acción, necesitas de lo que serían las claves privadas que se almacenan dentro del monedero de cada persona. Es decir, es la mejor forma, en este caso, de almacenar datos dentro de lo que sería una nube porque mantiene privados los datos de cada uno de sus usuarios. Así, como pueden ver, todas las opciones que Infura nos ofrece son bastante potentes, bastante flexibles para llegar y generar aplicaciones descentralizadas en este caso. Simplemente hacer una acotación y un hincapié en este punto. Y vamos a la parte de aplicación. Fíjense que aquí está nuestra aplicación, crear 18. Y vamos a manejar la key. Esta, como se puede ver, es la que está en la parte de abajo. es nuestra APK y ese es el dato que debemos llegar y tomar para llevarlo a lo que sería nuestra aplicación descentralizada. Esto lo veremos un poco más adelante para que vean cómo podemos utilizar este dato dentro de lo que serían nuestras aplicaciones y así pueden interactuar con la blockchain de una forma bastante más sencilla, utilizando códigos con Python o con JavaScript, que en este caso serían los dos lenguajes de programación más utilizados en este sentido para generar aplicaciones descentralizadas. ¡Gracias! o aplicaciones centralizadas que requieran de cierta utilidad o funcionamiento con lo que serían las aplicaciones blockchain. En sus pantallas tenemos a Alchemy. Alchemy, al igual que Infura, es un servicio de desarrollo para aplicaciones web 3 descentralizadas que nos permite crear APIs que nos faciliten la integración de nuestras aplicaciones centralizadas con lo que sería el universo blockchain de la web 3. ¿Qué diferencia hay Infura de Alchemy? El mercado de las aplicaciones centralizadas es el mismo mercado que el mercado de las aplicaciones blockchain. Pues bien, principalmente la diferencia entre Alchemy y Infura es la capacidad o las opciones de redes que tenemos activas dentro de Alchemy. Alchemy en este caso, soporta bloques como Ethereum, Solana, Optimis, Polygon, Arbitrum, Crypto.org, Starnet y Astar. Es decir, tenemos un mayor abanico de aplicaciones de blockchain dentro de lo que sería Alchemist, que podemos utilizarla para llegar y crear nuestras propias aplicaciones. Ahora bien, al igual que Infura, podemos llegar y utilizar todo este poder a través de Web3 APIs, que fácilmente podemos ir creando cuando accedemos a la plataforma. ¿Cómo podemos acceder a la plataforma? Pues bien, simplemente vamos a la parte de Login In, y aquí tenemos la capacidad para llegar y suscribirnos. utilizando la cuenta de Google o simplemente suscribirnos con una parte de email y password. En este caso vamos a utilizar la suscripción por Google. Como pueden ver, la interfaz es bastante sencilla, bastante distinta también a lo que sería, a lo que vimos anteriormente en Infura. Pero podemos ver que ya tenemos el dashboard, tenemos aquí ya una aplicación de prueba creada. En este caso, como no hemos tenido ninguna interacción, simplemente nos aparece que no hay ninguna información que mostrar dentro que sería el dashboard. Ahora bien, si queremos crear una aplicación, es decir, si queremos crear nuestra propia API para llegar y utilizarla dentro de lo que sería nuestra aplicación descentralizada, eso es bastante sencillo. Simplemente debemos ir aquí a Create App y ofrecemos un nombre para la misma. En este caso vamos a poner Testing también y vamos a hacer una descripción. Testing de API. En este caso la descripción es una aplicación de prueba para el desarrollo y vamos a elegir la cadena. En este caso nos da opciones para elegir las cadenas Polygon, Solana, Astar, en este caso Astar Mainnet o podemos elegir Polygon, Polygon Mumbai o podemos seleccionar Solana y Solana con las dos redes que tiene. Empezamos a seleccionar Ethereum y vamos a seleccionar la red Governing. Creamos la aplicación. y ya estamos dentro de lo que sería el dashboard de nuestra aplicación recién creada utilizando la red Governly tal como podemos ver aquí desplegado dentro de lo que sería el dashboard. Ahora bien, ¿dónde está nuestra APK? ¿Cuál es nuestra APK en este caso? Simplemente vamos aquí, vemos detalles y... empezamos a ver todo lo que es la información. En este caso, tenemos las unidades de computación, en este caso ha sido 0 porque el proyecto ha sido recién creado. También tenemos la respuesta media, el success, la capacidad, luego el uso de las redes en este caso, la cantidad de requests que se han realizado, el éxito de esas requests, el total de requests en las últimas 24 horas y las requests que han sido marcadas como inválidas. En este caso, simplemente, si queremos ver la key, vamos aquí a View Key, y allí está nuestra API Key para interactuar con lo que serían los servicios de archiving y todo lo que sería el poder de esta red dentro de lo que sería Ethereum, Ethereum Guaranty, en este caso. Fíjense que aquí está nuestra API Key, nuestro employee, en este caso, utilizando el protocolo HTTPS, y el employee utilizando WebSockets. Aquí están las capacidades de cómo podemos llegar y utilizar el SDK o las herramientas de desarrollo de Archemix, utilizando lenguaje de programación como JavaScript, una consola o simplemente podemos utilizar Python. En este caso, podemos utilizar Python con V3 para llegar y hacer la conexión y podemos ver que hay diferentes partes de uso, o sea, códigos de uso para llegar y utilizar todo el poder de esta aplicación. También podemos utilizar en Go, que es el lenguaje de Google, un lenguaje bastante potente en este caso. Pero como pueden ver, hay varias opciones de lenguaje que podemos utilizar para llegar y realizar todas estas opciones. Simplemente llegamos y tenemos que tener cuidado de copiar esta aplicación, esta APK, y colocarla en los programas de prueba o en nuestra aplicación para llegar a utilizar todo este potencial. Y cerramos aquí. Podemos ir entonces a tener lo siguiente. Podemos tener. el TH de prueba, podemos agregar un molde de aero y la parte de seguridad. En este caso, la parte de seguridad es prácticamente la misma situación que hemos visto anteriormente con la parte de fuera. Podemos llegar y permitir direcciones de uso que están permitidas para la aplicación, dominios que estén permitidos o direcciones IP. En este caso, podríamos verlo como una especie de muro de fuego. nos permite controlar, mira, estas son las direcciones que pueden interactuar con tu aplicación o estos son los dominios o estas son las direcciones IP. También podemos agregar un monedero que en este caso nos dirige a recargar la parte de Metamask y también podemos llegar a agregar lo que serían ETH de pruebas. Fíjense que aquí ya estamos en el govern de Faunet. Fawcett, digo, que en este caso el Werly Fawcett simplemente nos permite, vamos a hacer aquí la conexión al Chemi para probar, en este caso fíjense que ya estamos conectados, conectados como José, y tenemos que es un Fawcett para Werly, simplemente copiamos la dirección de nuestro monedero, que ya está configurado para Werly, vamos a enviarlo, denme, y automáticamente nos enviará la totalidad de 0.25 gobernos a nuestro monedero. En este caso podemos llegar a mandarlo a la red Mumbai. Vamos a hacer aquí, para requerir lo que serían toques de prueba, copiamos la dirección, hermetic. En este caso ya tengo aquí la red Mumbai activa. Vamos a esperar un momentico a que se haga la operación. a que la operación se haga efectiva. Y aquí está. Ya se hizo efectiva la operación. Ya tenemos 1.5 Matic en la red Moonbyte, que es la red de prueba de Póligo. ¿Y de qué nos sirve esto? O sea, ¿para qué hemos realizado esta operación dentro de lo que sería un Faucet? Bueno, las interacciones que se realizan en redes como Mumbai, Goerli, que son redes testnet, si bien no necesitan dinero real, si necesitan de tokens de esas redes para que puedan funcionar. Recordemos que estas redes funcionan tal cual como funcionaría la red Mainnet de cada una de estas redes, por lo menos en este caso Ethereum Mainnet, Goerli funciona tal cual. Es decir, necesitamos pagar las comisiones de esas redes que si bien... Lo hacemos con ETH Go Early o ETH Go como se llama. Este token no tiene ningún valor económico como tal, pero necesitamos pagarlas para que las acciones se puedan realizar. En este caso es tratar de mantener lo mayor, lo mejor posible, lo que sería la actividad o cómo funciona todo lo que sería la red como tal. Esto del Fawcett nos ayuda a tener dinero en nuestros monederos que aunque sea de la red testnet, podemos utilizarlo para llegar y hacer las diferentes aplicaciones o las diferentes interacciones con estas redes. Ahora bien, cerremos aquí un momento y volvamos aquí a Archemi. Ya podemos ver aquí entonces todo lo que es el dashboard de Archemi. Y ya podemos saber qué estas cuatro opciones nos ofrecen, que en este caso, seguridad, cómo agregar un monedero, cómo agregar toques de pruebas para nuestro monedero y la que, en este caso, es para llegar a hacer las interacciones con nuestras aplicaciones. Aquí en las aplicaciones, exploradores. Aquí en el explorador tenemos todo lo que sería la actividad que se ha realizado dentro de nuestra aplicación descentralizada. Aquí tenemos el compositor. El compositor es simplemente... una utilidad que nos permite crear requests especializados. En este caso podemos utilizar las diferentes cadenas que Alchemy nos ofrece de soporte, podemos utilizar las diferentes redes y los diferentes métodos que nos permiten acceder a la información que está dentro de lo que serían las capacidades de respuesta del request de Alchemy. En este caso podemos llegar y podemos, por ejemplo, pedir el bloque o la chain ID. de una cadena, en este caso la cadena sería la red ethereum en la red de product worldly y mandamos nuestros requests. En este caso, mandamos un request. aquí está el request enviado, pero la respuesta que recibimos es una respuesta de error porque nos da aquí el mensaje, en este caso el mensaje es que el origen dashboard.archive.com no es un origen que esté permitido. Esto tiene que ver mucho con la parte de seguridad que acabamos de ver hace un momento. Simplemente permitimos el origen, en este caso la dashboard.archive.com, y ya con ello podemos llegar y empezar a hacer los requests en este caso. También tenemos acceso a lo que sería la main pool, un observador de la main pool, y notificaciones por las diferentes actividades que podemos estar realizando con nuestra aplicación descentralizada. En este caso, podemos revisar la actividad de NFT, la actividad de direcciones, las notificaciones de transacciones que hayan sido dropeadas o las que hayan sido minadas. Finalmente, también tenemos otras opciones que HMV nos ofrece, que en este caso son APIs avanzadas para transferencias, generación de metadata para los tokens, balance de tokens, allowance, lo que es HMV Web 3, Smart Web Sockets, Trace API, Debug API y NFT API. Importante estas dos. que son APIs de desarrollo bastante potentes, que nos permiten llegar y mejorar, o debugging, en este caso, las aplicaciones esterilizadas que estemos haciendo. Esto es muy importante porque un papel o un punto que ningún desarrollador debe dejar de lado es el debugging y el reconocer cuáles son los errores y cómo solucionarlos dentro de lo que serían las capacidades de desarrollo de la aplicación. Esto con el fin de mantener las aplicaciones bastante seguras evitar este triste episodio que puedan llevar a hackers o a doctores maliciosos a llegar y traspasar la seguridad de nuestras aplicaciones y poder obtener así una ganancia bastante de una forma bastante maliciosa en este caso. Entonces como pueden ver esto es Archemy Es bastante sencillo crear una cuenta aquí y empezar a utilizar su potencial.


###  218.B4_Smart_Contracts_en_Bitcoin_Script-video

###  Smart Contracts en Bitcoin Script
![[218.B4_Smart_Contracts_en_Bitcoin_Script.mp4]]
[Smart Contracts sobre Bitcoin](https://app.web3mba.io?wvideo=4umxj53x1u)

Los contratos inteligentes, o smart contracts, pueden ser escritos en diferentes lenguajes de programación, siempre y cuando existan compiladores y bibliotecas capaces de traducir y servir de interfaz con las distintas capacidades de los contratos inteligentes en la blockchain que utilicemos. Esto significa que es posible usar cualquier lenguaje de programación para crearlos, pero los desarrolladores de la blockchain deben crear el conjunto de herramientas básico para tal fin. En este sentido, algunos de los lenguajes de programación que podemos utilizar para crear contratos inteligentes son los siguientes.

En Bitcoin, el lenguaje de programación por defecto es Bitcoin Script. Este lenguaje está diseñado específicamente para Bitcoin y es responsable de permitir la programación de transacciones dentro de la propia red, haciendo que Bitcoin cumpla con la premisa de ser un dinero digital programable. Sin embargo, Bitcoin Script es un lenguaje bastante limitado, ya que no es Turing completo y funciona mediante un esquema de tipo pila. Esto hace que Bitcoin Script no solo sea complejo de programar, sino también limitado en las características y funciones que presenta. De hecho, Bitcoin Script está restringido a solo 256 tipos de instrucciones distintas, conocidas como opcodes, muchas de las cuales aún no han sido definidas porque Satoshi Nakamoto las dejó en blanco con el fin de mejorar sus capacidades en el futuro, pensando en las necesidades que pudiera tener la red en los años venideros.

El lenguaje Script de Bitcoin posee varias características y cualidades. Entre ellas, podemos mencionar que es simple y requiere un procesamiento mínimo, que su funcionamiento es limitado, lo cual aporta mayor seguridad al sistema, y que al no ser un lenguaje Turing completo, no posee bucles, lo que asegura que el programa deje de repetirse y termine. De esta manera, evitamos la posibilidad de que ocurran errores y códigos maliciosos en la red de Bitcoin. Otra característica es que su simplicidad le permite ser implementado en una amplia gama de dispositivos. Además, no hay un estado anterior o posterior a la ejecución del script; toda la información necesaria para ejecutar el script debe estar contenida en el propio script.

El lenguaje está basado en una pila y puede usar dos tipos: una pila principal y otra pila alternativa, donde esta última se emplea para el almacenamiento de datos, cálculos y pasos intermedios, de una forma muy parecida a la tecla de memoria en las calculadoras. El lenguaje de script de Bitcoin es bastante pequeño, ya que solo puede contener 256 instrucciones, y cada instrucción está expresada en un byte. El propósito de crear un lenguaje script en Bitcoin es proporcionar una serie de parámetros fáciles y flexibles para posibilitar una transacción. Así, cuando Satoshi Nakamoto desarrolló Bitcoin, deshabilitó varias funciones, entre ellas la multiplicación, lo que mantiene el script simple en términos de programación.

Este lenguaje de programación determina si una operación puede realizarse o no, es decir, si dicha operación está autorizada para la transferencia de fondos. En pocas palabras, la creación de Bitcoin Script es lo que otorga la naturaleza programable de Bitcoin. Esto nos permite, por ejemplo, enviar una transacción que se valide automáticamente si se cumplen determinadas condiciones. Esta propiedad es única de Bitcoin y las criptomonedas, algo que el dinero actual no puede alcanzar, y mucho menos el arcaico dinero físico. Es la evolución del dinero, llegando a un punto en que incluso puede actuar de forma independiente y descentralizada, atendiendo simplemente a la programación incrustada en él.

Por otra parte, el script de Bitcoin también evita la creación de errores en el sistema y el uso innecesario de transacciones muy complejas. De hecho, el script hace que las transacciones sean relativamente fáciles de calcular. Además, los bucles infinitos requieren mucha más potencia de cálculo y pueden sobrecargar las redes, como se mencionó al principio. Miniscript es un lenguaje de programación que facilita la generación de contratos inteligentes para Bitcoin. Permite que el software analice automáticamente un script, incluyendo la determinación de los datos de los testigos que deben generarse para gastar los bitcoins protegidos por ese script. La representación estructurada de los scripts de Bitcoin proporcionada por Miniscript permite a los monederos ser mucho más dinámicos con los scripts que utilizan.

Para apoyar este dinamismo, los Miniscripts pueden ser creados usando un lenguaje de políticas de fácil escritura. Las políticas son componibles, permitiendo que cualquier subexpresión válida sea reemplazada por otra subexpresión válida, dentro de ciertos límites impuestos por el sistema de Bitcoin. Inicialmente, el lenguaje fue diseñado para ser parecido a JavaScript; sin embargo, el desarrollo del proyecto se trasladó a Rust, el cual sigue en desarrollo y ya se encuentra en proceso de ser integrado en Bitcoin Core.

Vyper es un lenguaje de programación basado en Python, dirigido a crear contratos inteligentes para la máquina virtual de Ethereum. Al estar basado en Python, este lenguaje ofrece una enorme facilidad para desarrollar aplicaciones distribuidas para quienes están acostumbrados a este lenguaje, y al mismo tiempo, se beneficia de las potentes herramientas de depuración que ya existen para él. Entre los principales objetivos de Vyper se encuentran ofrecer una mejor seguridad, ya que debe ser posible y natural tener contratos inteligentes seguros en este lenguaje. También se busca la simplicidad del lenguaje y del compilador, así como mejorar la auditoría del código. El código de Vyper debe ser lo más legible posible y, además, debe ser difícil escribir código engañoso en él. La simplicidad para el lector es más importante que la simplicidad para el escritor, y es particularmente relevante para aquellos con poca experiencia previa en Vyper y en programación en general.

Además, Vyper permite una mejor comprobación de límites y desbordamientos, especialmente en los accesos a arrays y en la aritmética. Vyper puede ser utilizado en Ethereum o en cualquier red compatible con la Ethereum Virtual Machine, como Polygon, BNB Chain u otras redes derivadas de la EVM y sus primitivas criptográficas. Haskell es un lenguaje de programación muy utilizado en el mundo científico y es el lenguaje elegido por Cardano. Haskell destaca por ser un lenguaje de programación funcional, muy adecuado para código de alta seguridad y programas que requieren un alto grado de verificación formal. Esto permite a los programadores tener un mayor grado de certeza de que el código que han implementado es correcto, lo que, sin duda, ayuda a mantener la seguridad de los contratos inteligentes y de las plataformas que dependen de ellos.

En Cardano, Haskell permite que los contratos inteligentes de Plutus y Marlowe sean implementados cuidadosamente en un código preciso y formalmente verificado, que ofrece un alto nivel de seguridad desde el principio. Plutus y Marlowe se ofrecen como un conjunto de bibliotecas, aprovechando la documentación existente de Haskell, los juegos de herramientas y una comunidad altamente profesional para proporcionar una base a partir de la cual construir contratos inteligentes seguros y de calidad empresarial. Tanto el código off-chain como on-chain de Cardano está escrito en Haskell, lo que permite a Cardano heredar el rico cuerpo de investigación ya existente dentro del ecosistema de Haskell, en lugar de reinventar la rueda con un lenguaje de contratos inteligentes totalmente nuevo y no probado.

Básicamente, Haskell es un lenguaje que ha sido probado, que es seguro y que puede ser utilizado para crear contratos inteligentes Turing completos, que pueden ser verificados formalmente en cualquier momento. Como hemos podido ver a lo largo del tema, los contratos inteligentes pueden desarrollarse de diferentes maneras. Podemos desarrollarlos en Solidity, en Vyper, o incluso en lenguajes que no hemos visto en este curso, como el LLL. Estos lenguajes, al final, nos permitirán desarrollar nuestros contratos inteligentes basados en toda la potencia que nos ofrece la blockchain de Ethereum y, gracias a ellos, crear ese bytecode, subirlo a la blockchain y ejecutarlo de forma descentralizada en nuestras aplicaciones. A partir de aquí, lo que nos queda es seguir investigando y profundizando en todo el mundo de los contratos inteligentes y sus lenguajes de programación.


###  219.U4.1_Bitcoin_Script

###  Bitcoin Script:  El primer lenguaje de Smart Contracts del mundo
Es un lenguaje de programación simple empleado en Bitcoin para el procesamiento de las transacciones.

Este lenguaje está basado en una serie de estructuras lineales, conocidas como pila (_stack_), que contienen datos existentes que son procesados usando el esquema LIFO (_Last In – Firt Ou_t).

Así, cada instrucción en este lenguaje se ejecuta consecutivamente una después de la otra.

Como ya hemos mencionado, este lenguaje no es Turing Completo debido a que su funcionalidad es limitada y no puede realizar bucles. No obstante, esta limitación es intencional porque así se evita la entrada en un bucle infinito y se comentan errores irrecuperables dentro de los mismos. Esto evita que las partes maliciosas del programa pueden tener la libertad de crear operaciones complicadas para consumir los recursos de la red y servir de base para la generación de ataques de denegación de servicios (DoS). 

La intención y objetivo tras la creación de Bitcoin Script, es la de permitir escribir programas y que los ordenadores ejecuten los mismos de forma descentralizada. Así, Bitcoin puede comunicar nuestros deseos por medio de códigos de programación u operacionales que son conocidas como OP CODES. Entre esas funciones están la manipulación de memoria, matemáticas, bucles, llamadas a funciones, entre muchas otras.

> Por ello, Bitcoin Script es en esencia un conjunto de instrucciones programadas que se registran con cada transacción realizada. Estas instrucciones describen cómo los usuarios pueden obtener accesos a los bitcoins disponibles en la red y hacer uso de ellos.

####  ScriptSig & scriptPubKey:  Las dos secciones de los Bitcoin Scripts
En la red Bitcoin, cada Bitcoin Script se divide en dos tipos de scripts, los scriptSig y scriptPubKey.

- **ScriptSig es el script de desbloqueo,** que requiere de una clave pública y una firma digital. De hecho, luego de detectar varios problemas en las primeras versiones del software de Bitcoin, se incluyeron las verificaciones de las firmas. Por lo que el sistema solo acepta realizar transacciones si las firmas y su verificación cumplen con una serie de reglas establecidas que garantizan un comportamiento adecuado en la red.
- **ScriptPubKey, es el script de bloqueo,** que contiene un hash de clave pública, también denominada dirección de Bitcoin. Algunos scripts de Bitcoin requieren de multifirmas, es decir, de la autorización de varios usuarios para realizar la transacción. En este caso, el script es más complicado debido a que se trata de una operación mucho más grande que la estándar entre iguales. De hecho, la programación como tal de las transacciones de Bitcoin es almacenada en esta parte del script.

![[219.B4_scripts.png]]

#####  Objetivo de su creación
El propósito de la creación de un lenguaje script en Bitcoin, es el de proporcionar una serie de parámetros fáciles y flexibles para poder posibilitar una transacción. 

**Cuando Satoshi Nakamoto desarrolló Bitcoin, deshabilitó varias funciones, entre ellas la multiplicación. Por lo que el script se mantiene simple en términos de programación.** 

Entonces, este lenguaje de programación es lo que determina es si una operación puede realizarse o no. Es decir, si dicha operación está autorizada para la transferencia de fondos.

En pocas palabras, la creación del Bitcoin Script es lo que otorga la naturaleza programable de Bitcoin. Es lo que nos permite, por ejemplo, enviar una transacción que la misma se valide solo si determinadas condiciones se cumplen. Esta propiedad es algo único de Bitcoin y las criptomonedas, algo que el dinero digital actual no puede alcanzar, y mucho menos el arcaico dinero físico. Es la evolución del dinero llegado a un punto en que incluso este puede actuar de forma independiente y descentralizada atendiendo simplemente a la programación incrustada en él.

Por otra parte, el script de Bitcoin también evita la creación de errores en el sistema y el uso innecesario de transacciones muy complejas. De hecho, el script hace que las transacciones sean relativamente fáciles de calcular. Además, los bucles infinitos requieren muchísima más potencia de cálculo y ralentizan las redes, como se mencionó al principio.

####  Ejemplo de Bitcoin Script.
Vamos a ver un pequeño Bitcoin Script muy usado en la actualidad para las transacciones en Bitcoin.

Explicaremos su comportamiento y funcionamiento, así como las distintas partes del mismo, para luego ir profundizando en sus propiedades.

#####  Bitcoin Script: Transacciones en Bitcoin usando el script P2PKH
**Los Bitcoin Script están presentes en todas las acciones de Bitcoin. La verdad es que cada operación en Bitcoin es llevada a cabo por un script específico que delimita lo que se va a realizar. Fuera de lo que dice dicho script nada puede pasar.**

Por ejemplo, si queremos hacer una transacción un script para ello sería el siguiente:

|Secciones|Contenido del Bitcoin Script|
|---|---|
|scriptPubKey|OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG|   |
|scriptSig|Signature|   |
|scirptSig|Pubkey|   |

**Todo el contenido anterior es una simple transacción en Bitcoin del tipo P2PKH (_Pay to Public Key Hash_).** Este tipo de script es un script estándar y de hecho es la forma más usada para enviar bitcoins. A primera vista se muestra como algo muy críptico y difícil de entender. La verdad es que detrás de tal complejidad, se esconde un sencillo sistema que explicaremos ahora.

######  Explicando a fondo la transacción
El anterior Bitcoin Script está delimitado en dos partes: 
1. scriptPubKey
2. scriptSig.

En el primero, están las acciones a realizarse, mientras que el segundo contiene la firma y clave pública para verificar la autenticidad de tales acciones. De tal forma se asegura que solo quien tiene acceso a los fondos pueda realizar alguna operación con los mismos. Por otro lado, están los OP_CODES que en la operación son los siguientes:
1. **OP_DUP:** Duplica el elemento de la pila superior.
2. **OP_HASH160:** La entrada se codifica dos veces: primero con SHA-256 y luego con RIPEMD-160.
3. **OP_EQUALVERIFY:** Verifica que los datos introducidos sean correctos y válidos.
4. **OP_CHECKSIG:** Las salidas, entradas y el script de toda la transacción se resumen en un hash. La firma utilizada debe ser una firma válida para este hash y debe estar junto a la clave pública.

Ahora bien, lo que pasa durante la ejecución del script es lo siguiente:
1. **En primer lugar,** la clave pública original del dueño (que está en el scriptSig) de los fondos se duplica.
2. **La clave pública duplicada pasa luego a un proceso de hashing.** En este proceso se le aplica primero un hash SHA-256 y al resultado luego se le aplica un hash RIPEMD-160.
3. **El resultado se compara con el hash de la clave pública que está en el scriptPubKey** para asegurarse de que sea EQUALVERIFY (es decir, sea la misma clave y sea verificada como válida).
4. **Si coincide, el script continúa ejecutándose y se realiza el CHECKSIG** para verificar la firma con la clave pública.
5. **De esta forma se lleva a cabo todo lo indicado en el script de forma segura y programada.** Si deseas conocer más a fondo cómo funciona Bitcoin Script, puedes visitar nuestro servicio Bit2Me TV, donde podrás ver algunos vídeos explicando mucho más sobre este interesante lenguaje.

#####  Bitcoin Script Escrow
El ejemplo de P2PKH es bastante sencillo y es básico, pero Bitcoin Script nos permite crear cosas mucho más avanzadas, como un Escrow. 

**Un ==escrow== es un elemento básico en un Exchange descentralizado, básicamente es un baúl de seguridad, donde las partes colocan sus criptomonedas y secretos para realizar un intercambio seguro y descentralizado.** Plataformas como LocalBitcoin o Bisq usan este tipo de scripts para su funcionamiento y en Bitcoin Script es posible crearlas de la siguiente forma: 

OP_DUP OP_1 OP_EQUAL
OP_IF
  OP_DROP
  <AnaHashedPublicKey>
  <JuanHashedSecret>
OP_ELSE
  OP_DUP OP_2 OP_EQUAL
  OP_IF
    OP_DROP
    <AnaHashedPublicKey>
    <HashedDisputeReleaseSecret>
  OP_ELSE
    OP_DUP OP_3 OP_EQUAL
    OP_IF
      OP_DROP
      <JuanHashedPublicKey>
      <AnaHashedSecret>
    OP_ELSE
      OP_4 OP_EQUALVERIFY
      <JuanHashedPublicKey>
      <HashedDisputeRevertSecret>
    OP_ENDIF
  OP_ENDIF
OP_ENDIF
OP_ROT
OP_HASH160
OP_EQUALVERIFY
OP_OVER
OP_HASH160
OP_EQUALVERIFY
OP_CHECKSIG

**El script tiene un funcionamiento bastante sencillo:**
Ana y Juan deciden realizar un intercambio, y para ello preparan los siguientes elementos:
1. **Ana prepara su Hash PubKey** (su dirección de criptomoneda) y la pública (comprador)
    
2. **Juan prepara su Hash PubKey** (su dirección de criptomoneda) y la pública (vendedor)

El segundo paso es generar los secretos que permitirán a cada una de las partes saber que efectivamente se han realizado las operaciones correspondientes para el intercambio. Tanto Ana como Juan crean estos secretos y realizan un Hash de los mismos, sin embargo, estos solo se harán públicos bajo ciertas condiciones:
1. **Si Juan realiza la operación y libera el pago, este ya no podrá tomar para sí los fondos.** En este punto, Juan hace público el secreto que le permitirá a Ana confirmar la operación (generalmente la TXID de una operación enlazada con la operación de escrow que se mantiene en la mempool de Bitcoin). Si Ana confirma la operación, ella está obligada a realizar su operación con el fin de obtener las criptomonedas. En caso contrario, se aplica la función de reintegro, porque Ana no ha cumplido su parte y se le amonesta. 
2. **Si Ana decide que no quiere completar la operación, simplemente cancela la operación, y la esta se reintegra a Juan devolviéndole sus fondos.** En este punto, Ana no recibe amonestación, ya que solo ha cancelado la operación y los fondos nunca estuvieron en peligro.
3. **Si el resultado de la operación no ha sido satisfactorio ni para Ana ni para Juan. Pueden pedir a un tercero neutral que intervenga y decida sobre el mejor curso para los fondos, sin embargo, el tercero solo es un mediador y no puede tomar los fondos para sí mismo en ningún momento.** Esto es posible gracias a un segundo Bitcoin script que paga las comisiones y es capaz de finalizar la operación, solo si OP_4 es activada (la opción que Juan como vendedor puede activar para generar la intervención de un tercero para la mediación).  

El segundo Bitcoin Script que habilita el pago de las comisiones es:
OP_DUP OP_3 OP_EQUAL
OP_IF
  OP_DROP
  OP_HASH160
  <AnaHashedSecret>
  OP_EQUALVERIFY
  OP_DUP
  OP_HASH160
  <JuanHashedPublicKey>
  OP_EQUALVERIFY
  OP_CHECKSIG
OP_ELSE
  OP_DUP OP_4 OP_EQUAL
  OP_IF
    OP_DROP
    OP_HASH160
    <HashedDisputeRevertSecret>
    OP_EQUALVERIFY
    OP_DUP
    OP_HASH160
    <JuanHashedPublicKey>
    OP_EQUALVERIFY
    OP_CHECKSIG
  OP_ELSE
    OP_DUP
    OP_HASH160
    <MediatorSwapHashedPublicKey>
    OP_EQUALVERIFY
    OP_CHECKSIG
  OP_ENDIF
OP_ENDIF

Así tenemos que:
OP_IF
  OP_DROP
  OP_HASH160
  <AnaHashedSecret>
  OP_EQUALVERIFY
  OP_DUP
  OP_HASH160
  <JuanHashedPublicKey>
  OP_EQUALVERIFY
  OP_CHECKSIG

Esta primera parte, aplica cuando ambas partes están de acuerdo con la operación y ambas firman la operación para que sea transmitida a la red y se complete el intercambio deseado. 

OP_ELSE
  OP_DUP OP_4 OP_EQUAL
  OP_IF
    OP_DROP
    OP_HASH160
    <HashedDisputeRevertSecret>
    OP_EQUALVERIFY
    OP_DUP
    OP_HASH160
    <JuanHashedPublicKey>
    OP_EQUALVERIFY
    OP_CHECKSIG
  OP_ELSE
    OP_DUP
    OP_HASH160
    <MediatorSwapHashedPublicKey>
    OP_EQUALVERIFY
    OP_CHECKSIG
  OP_ENDIF
OP_ENDIF

**En caso contrario, se aplica la reversión de la operación que le devuelve los fondos a Juan, o se aplica la mediación para que esta revise el caso y decide completar la operación si todo es correcto, o bien una parte intenta hacerle trampa a la otra.** 

Tal como se puede ver, el proceso de creación de Smart Contracts usando Bitcoin Script es procedimental, algo complejo pero posible de realizar sin mayores complicaciones, y esto es solo una parte de su potencial, porque el lenguaje va mejorando a medida que la red Bitcoin evoluciona y se desarrolla.


###  220.U4.2_Bitcoin_Script_-_Funcionamiento

###  Funcionamiento de Bitcoin Script
Imagina que apilas 3 libros: 
1. Libro A (arriba), 
2. Libro B (en medio) 
3. Libro C (abajo). 

Con Bitcoin Script: 
- El Libro A tendría que ser el primero en salir de la pila (_popped_). 
- El Libro B, sería el siguiente. 
- El Libro C sería el último, para poner cualquier cosa en la parte inferior de la pila (_pushed_). 

El mismo concepto se aplica virtualmente a las operaciones en una secuencia con Script.

![[220.B4_pila.png]]

####  Capacidades de Bitcoin Script
Uno de los puntos más relevantes del funcionamiento de Bitcoin Script es su notación y sus capacidades de complejidad programática.

El primer punto es fácil de ver, porque Bitcoin Script usa la conocida Notación Polaca Inversa (RPN) o notación postfija. La RPN es un método para colocar la función de la operación al final de una frase. 

**Por ejemplo, la suma de 5 y 6 en Bitcoin Script debe escribirse como "5 6 +" en lugar de "5 + 6".** **En el caso de que queramos multiplicar tendríamos que escribirla “5 6 *”. Este tipo de notación facilita la creación de stacks manipulables para realizar las distintas operaciones a la que Bitcoin Script debe darnos acceso.** 

El otro punto, la complejidad algorítmica, tiene que ver con un concepto muy conocido en los lenguajes de programación, la conocida capacidad Turing. En este punto existen dos capacidades Turing que son:
1. Turing Completo.
2. Turing Incompleto.

**Un lenguaje del tipo Turing Completo, nos dice que el lenguaje es capaz de generar bucles infinitos y nos ofrece las capacidades para generar algoritmos tan complejos como para recrear cualquier sistema informático, sin importar que tan complejo puedan ser.** Básicamente, un lenguaje Turing Completo te permite crear cualquier cosa que puedas imaginar y escribir en un algoritmo completo dentro de ese lenguaje de programación. 

**Por su parte, un lenguaje Turing Incompleto significa que el lenguaje no permite bucles infinitos. Esto tiene tanto ventajas como desventajas. Una de las ventajas de utilizar un lenguaje Turing incompleto es la imposibilidad de ejecutar algoritmos malformados, independientemente de si son ataques maliciosos intencionados o errores de programación no intencionados.** De esta manera, se evita el problema de la detención, permitiendo leer el script y ejecutar sus acciones. Si las instrucciones son correctas, el script se ejecuta de forma correcta, y si las instrucciones son incorrectas, el script solo emite un error y se continúa con el sistema, evitando caer en bucles infinitos que detengan al sistema.

Otros blockchains desarrollados desde Bitcoin han optado principalmente por ser Turing Completo, o al menos tener un alto grado de Turing Completo. Aunque esto potencialmente pone en juego el problema de la interrupción, también proporciona un mejor soporte para la compleja lógica requerida para el desarrollo de contratos inteligentes. Un caso en este sentido es Ethereum, cuyo lenguaje Solidity y su EVM son del tipo Turing Completo, lo que permite desarrollar Smart contracts extremadamente potentes. 

####  Ejemplo de una transacción de Bitcoin
Los Bitcoin Script están presentes en todas las acciones de Bitcoin. Cada operación en Bitcoin es llevada a cabo por un script específico que delimita lo que se va a realizar. Fuera de lo que dice dicho script, nada puede pasar.

Por ejemplo, si queremos hacer una transacción un script para ello sería el siguiente:
- scriptPubKey | OP_DUP OP_HASH160
- scriptSig (Signature)
- scriptSig (Pub Key)

Lo que hemos visto hasta ahora es una transacción en Bitcoin del tipo P2PKH (Pay to Public Key Hash). Este tipo de script es un script estándar y de hecho es la forma más usada para enviar bitcoins. A primera vista se muestra como algo muy críptico y difícil de entender. La verdad es que detrás de tal complejidad, se esconde un sencillo sistema que explicaremos ahora.

#####  Explicando a fondo la transacción
**El anterior Bitcoin Script está delimitado en dos partes: ScriptPubKey y scriptSig. En el primero, están las acciones a realizarse, mientras que el segundo contiene la firma y clave pública para verificar la autenticidad de tales acciones.** De tal forma se asegura que solo quien tiene acceso a los fondos pueda realizar alguna operación con los mismos. Por otro lado, están los OP_CODES que en la operación son los siguientes:
1. OP_DUP: Duplica el elemento de la pila superior.
2. OP_HASH160: La entrada se codifica dos veces: Primero con SHA-256 y luego con RIPEMD-160.
3. OP_EQUALVERIFY: Verifica que los datos introducidos sean correctos y válidos.
4. OP_CHECKSIG: Las salidas, entradas y el script de toda la transacción se resumen en un hash. La firma utilizada debe ser una firma válida para este hash y debe estar junto a la clave pública.

Ahora bien, lo que pasa durante la ejecución del script es lo siguiente:
1. En primer lugar, la clave pública original del dueño (que está en el scriptSig) de los fondos se duplica.
2. La clave pública duplicada pasa luego a un proceso de hashing. En este proceso se le aplica primer un hash SHA-256 y al resultado luego se le aplica un hash RIPEMD-160.
3. El resultado se compara con el hash de la clave pública que está en el scriptPubKey para asegurarse de que sea EQUALVERIFY (es decir, sea la misma clave y sea verificada como válida).
4. Si coincide, el script continúa ejecutándose y se realiza el CHECKSIG para verificar la firma con la clave pública.
5. De esta forma se lleva a cabo todo lo indicado en el script de forma segura y programada. Si deseas conocer más a fondo cómo funciona Bitcoin Script, puedes visitar nuestro servicio Bit2Me TV, donde podrás ver algunos vídeos explicando mucho más sobre este interesante lenguaje.


###  221.U4.3_Bitcoin_Script_-_OP_CODES

###  OP_CODES
También conocidos como "Códigos de Operación"

Son las instrucciones e indicaciones que se utilizan en informática para la programación de equipos de computación y máquinas virtuales.

**Estos códigos indican las operaciones o funciones que deben ser realizadas y ejecutadas por el hardware o software.**

En el caso de los hardware, la forma de los OP_CODE estará definida según el tipo de arquitectura del conjunto de operaciones (ISA) del ordenador. Es decir, según las instrucciones que posea el dispositivo para la interpretación y ejecución de los códigos de operación. En caso del software, los OP_CODE están creados con un tipo de ISA, o arquitectura de operaciones, diseñada especialmente para ser interpretada por la máquina virtual o el interpretador de bytes.

**Los códigos de operación permiten que un programa de computación pueda emitir una orden al computador y que este la intérprete y la ejecute.**

####  ¿Cómo funciona un OP_CODE?
Para que las máquinas, equipos y ordenadores puedan recibir y ejecutar una orden específica, es necesario emitir instrucciones en un lenguaje que puedan entender.

Por ello, estas instrucciones son escritas en un lenguaje de programación que contiene códigos de operación o es traducido en última instancia a una serie de códigos de operación.

**Estos códigos están escritos en un idioma que generalmente conocemos, como el inglés, y luego son traducidos por un programa compilador o traductor para que las máquinas lo entiendan en su lenguaje binario.** Es decir, las instrucciones mnemónicas escritas en nuestro lenguaje para la interpretación de nosotros los humanos, tienen su equivalente en lenguaje binario para que las máquinas puedan interpretarlas fácilmente. Y así poder actuar sobre la instrucción recibida y ejecutarla de forma correcta.

#####  Ejemplo de un OP_CODE
Un buen ejemplo de OP_CODE lo podemos ver en la siguiente imagen:

![[221.B4_op_code.png]]

En ella podemos ver algunos OP_CODES pertenecientes a las instrucciones capaces de ejecutar un procesador o CPU de computadora (específicamente los x86 de Intel). Como podrás ver es algo críptico de leer y difícilmente se puede programar usando el mismo (aunque algunos desarrollos se hacen en este tipo de lenguaje debido a su velocidad).

La situación en el mundo cripto no es muy distinta y en Bitcoin, por ejemplo, podemos ver algo como esto:

![[221.B4_op_codes.png]]

1. **Signature:** Firma digital del dueño de la dirección Bitcoin
2. **Public Key:** Clave pública, suministrada por el dueño de la dirección, donde están los fondos BTC.
3. **OP_DUP:** Duplica la clave pública donde están los fondos Bitcoin.
4. **OP_HASH160:** Realiza un Hash SHA-256 y RIPEMD-160 a la clave pública suministrada por el dueño de la dirección
5. **Hash160 (Public Key):** Hash RIPEMD-160 a la clave pública donde están los fondos BTC.
6. **OP_EQUALVERIFY:** Se verifica la clave suministrada y la almacenada en el script son iguales.
7. **OP_CHECKSIG:** Se verifica la firma digital, si es VERDAD, se liberan los fondos.

Ciertamente, es igual de críptico, pero esta sencilla sentencia es equivalente a una transacción en Bitcoin. Si quieres saber más de la misma, puedes leer nuestro artículo dedicado a Bitcoin Script donde explicamos a profundidad que hacen exactamente estas instrucciones.

####  Bitcoin Script:  Tipos de códigos de operación
Los OP_CODES para el Bitcoin Script pueden clasificarse según la función e indicaciones que vayan a ejecutar en el sistema.

Estos códigos pueden ser utilizados para eliminar, añadir, mover o girar elementos en la pila. Analizar y realizar operaciones aritméticas, validar o invalidar transacciones, entre muchas otras más funciones.

A continuación, presentaremos un listado de los códigos de operación clasificados según su tipo y funciones. No obstante, es importante señalar que esta lista no es concluyente ni radical, puesto que existen muchos códigos de operación en el script de Bitcoin y aquí solo se mencionan algunos de ellos.

#####  Códigos de inserción
- **OP_0 = 0x00 y OP_FALSE = OP_0:**  
    Ambos códigos empujan o agregan un elemento o una matriz vacía de bytes a la pila. Ninguno de los dos debe ser confundido con NO_OP
- **OP_PUSHDATA1 = 0x4c, OP_PUSHDATA2 = 0x4d y OP_PUSHDATA4 = 0x4e:**  
    En el primer código, el siguiente byte contiene el número de bytes que se insertarán en la pila. En el segundo código los siguientes 2 bytes contienen el número de bytes que se insertarán en la pila, mientras que en el tercero son los siguientes 4 bytes los que contienen el número de bytes que se añadirán a la pila. En estos códigos el proceso de añadir los bytes se realizará en ==formato endian.==
- **OP_NEGATIVE = 0x4f y OP_TRUE = OP_1:**  
    En este caso, el número negativo -1 se empuja a la pila, mientras que en OP_TRUE el número positivo 1 se empuja a la pila.

#####  Códigos de control
- **OP_NOP = 0x61:**  
    Este código no ejecuta ninguna operación, pero se utiliza en los casos en los que haya que rellenar algún espacio dentro del programa.
- **OP_IF = 0x63 y OP_NOTIF = 0x64:**  
    Ambos códigos se utilizan para ejecutar las declaraciones. En el primer código, se ejecutan si el valor de la pila superior no es FALSE; en el segundo código, se ejecutan si los valores de la pila superior si es FALSE. Así en ambos casos, el valor de la pila superior se elimina.
- **OP_ELSE = 0x67:**  
    Se utiliza para afirmar o negar las declaraciones. En caso de haberse ejecutado los dos códigos anteriores (OP_IF y OP_NOTIF) las declaraciones se niegan. En caso de no haberse ejecutado, las declaraciones se afirman.
- **OP_ENDIF = 0x68:**  
    Se utiliza para terminar un bloque, ya que, sin esto, las transacciones no serían válidas. Un código OP_ENDIF sin un código OP_IF anterior tampoco será válido.
- **OP_RETURN = 0x6a:**  
    Se utiliza para marcar una salida de transacción como no válida.

#####  Códigos de aplicaciones y operaciones de pila
- **OP_TOALTSTACK = 0x6b y OP_FROMALTSTACK = 0x6c:**  
    El primer código se emplea para mover la entrada en la parte superior de la pila alternativa y eliminarla de la pila principal. El segundo código ejecuta el proceso contrario; mueve la entrada hacia la parte superior de la pila principal y la elimina de la pila alternativa.
- **OP_DROP = 0x75 y OP_DUP = 0x76:**  
    Se utilizan para eliminar un elemento de la pila superior y para duplicar un elemento de la pila superior, respectivamente.

#####  Códigos de operaciones de empalmes
- **OP_SIZE = 0x82:**  
    Este código empuja la longitud de la cadena del elemento superior de la pila, sin reventarlo.

Los códigos OP_SUBSTR = 0x7f, OP_LEFT = 0X80 y OP_RIGHT = 0x81 han sido deshabilitados. Se utilizaban para:
1. Devolver una sección en una cadena.
2. Mantener solo los caracteres restantes de un punto específico en una cadena, y
3. Mantener solo los caracteres restantes al lado derecho de un punto específico en una cadena, respectivamente.

#####  Códigos para operaciones numéricas
- **OP_1ADD = 0x8b y OP_1SUB = 0x8c:**  
    Se utilizan para añadir (sumar) o eliminar (restar) 1 a la entrada respectivamente.
- **OP_2MUL = 0x8d y OP_1DIV = 0x8e:**  
    Se utilizaban para multiplicar o dividir por 2 la entrada respectivamente, pero ambos fueron deshabilitados.
- **OP_ABS = 0x90 y OP_NEGATE = 0x8f:**  
    Se utilizan para invertir el signo de la entrada, es decir, para hacer positiva o negativa la entrada respectivamente.
- **OP_MIN = 0xa3 y OP_MAX = 0xa4:**  
    Estos códigos se utilizan para devolver el menor valor de a y b, o en su caso para devolver el mayor valor de a y b respectivamente.

#####  Códigos para codificación y cifrado
- **OP_RIPEMD160 = 0xa6:**   
    Se emplea para codificar la entrada con el algoritmo RIPEMD-160, con la finalidad de obtener hashes más cortos, pero igualmente seguros para la creación de direcciones.
- **OP_SHA1 = 0xa7:**  
    Se emplea para codificar la entrada con el algoritmo SHA-1, el cual se utiliza para calcular y obtener un valor de comprobación única para todas las entradas no mayor a 264 – 1 bit.
- **OP_SHA256 = 0xa8:**  
    Se emplea para codificar la entrada con el algoritmo SHA-256.
- **OP_HASH160 = 0xa9:**  
    Se utiliza para codificar la entrada 2 veces. La primera codificación a través del algoritmo SHA-256 y la segunda con el algoritmo RIPEMD-160
- **OP_HASH256 = 0xaa:**  
    Se utiliza para codificar la entrada 2 veces a través del algoritmo SHA-256.
- **OP_CHECKMULTISIG = 0xae:**   
    Se emplea para realizar una comparación entre la primera firma con cada clave pública hasta encontrar una coincidencia ECDSA. Luego repite el proceso con la segunda firma y las claves públicas posteriores y así sucesivamente hasta que todas las firmas hayan sido verificadas.

#####  Códigos para bloqueo de tiempo
- **OP_CHECKLOCKTIMEVERIFY = 0xb1:**   
    Este código marca como no válida la entrada si el elemento superior de la pila es mayor que el campo establecido como nLockTime, que representa la condición que se debe cumplir. En la aplicación de este código hay varias implicaciones que también hacen que la entrada sea inválida. Por ejemplo, si la pila está vacía o su elemento superior es negativo, entre otros.
- **OP_CHECKSEQUENCEVERIFY = 0xb2:**  
    También se usa para marcar la entrada como no válida si el tiempo de bloqueo es diferente o mayor al valor del elemento superior de la pila.

**Cada uno de estos OP_CODE realiza una función bien definida, y el arreglo conjunto de estos OP_CODE es lo que permite al Bitcoin funciona tal como lo hace. Sin embargo, los OP_CODE no son únicos de Bitcoin. Ethereum, por ejemplo, también tiene su propio registro de OP_CODE que le permite introducir instrucciones a su Ethereum Virtual Machine, y de allí realizar todas las operaciones de esta blockchain.** Eso va desde las transacciones más simples hasta operaciones complejas de smart contracts de esa plataforma. Lo mismo pasa con el resto de criptomonedas que tienen también sus OP_CODES o herramientas análogas para su funcionamiento.

De allí la importancia de los mismos, no solo conocerlos, sino desarrollarlos para ampliar las funcionalidades de las criptomonedas y los ecosistemas que estas contienen.


###  222.U4.4_Bitcoin_Script_-_Smart_Contract

###  Smart Contract usando Bitcoin Script
Un ejemplo sencillo de Smart Contract en Bitcoin Scipt es el conocido HTLC (Hash Time Locked Contract). 

Nos permite realizar operaciones en Bitcoin que nos permiten realizar operaciones de Atomic Swaps y con ello operaciones de Cross-Chain. 

El script básico de HTLC se puede definir según el siguiente formato RFC:
OP_IF
    OP_SIZE 32 OP_EQUALVERIFY
    OP_SHA256 <secret_hash> OP_EQUALVERIFY
    OP_DUP OP_HASH160 <redeem_identity>
OP_ELSE
    <expiry> OP_CHECKLOCKTIMEVERIFY OP_DROP
    OP_DUP OP_HASH160 <refund_identity>
OP_ENDIF
OP_EQUALVERIFY
OP_CHECKSIG

Este script se puede analizar de la siguiente forma dentro de un esquema Cross-Chain:
1. Alice crea un secreto de más de 32 bytes usando el hash SHA-256. Este secreto permitirá mantener la seguridad de la operación de cross-chain que se realizará con Bob y finalmente genera instrucciones para que la operación sea asignada a la dirección que Bob ha publicado para la realización del intercambio. 
    
    - OP_SIZE 32 OP_EQUALVERIFY
    - OP_SHA256 <secret_hash>  OP_EQUALVERIFY
    - OP_DUP OP_HASH160 <redeem_identity>
2. Alice envía la solicitud de intercambio (ETH->BTC) y en ese punto envía el hash secreto a Bob.
3. A partir del hash del secreto, Bob no puede saber el secreto real, por lo que, para saberlo, debe aceptar la solicitud y cumplir con su parte del intercambio.

![[222.B4_transfer.png]]


###  223.B4_Programación_Smart_Contracts_en_Bitcoin_Script-video

###  Programación Smart Contracts en Bitcoin Script
![[223.B4_Programación_Smart_Contracts_en_Bitcoin_Script.mp4]]
[Programacion Smart Contracts en Bitcoin Script](https://app.web3mba.io?wvideo=j18970hyft)

Saludos, en este video les explicaremos uno de los pilares fundamentales que permiten que Bitcoin sea lo que llamamos dinero digital programable. Esto es posible gracias a Bitcoin Script, un sistema de scripting que permite a Bitcoin programar de forma interna las operaciones que se realizan dentro de su red blockchain, así como en la red de nodos que forman parte de esta red conocida como Bitcoin.

Bitcoin Script es un lenguaje de programación bastante sencillo; es muy pequeño en sus aspectos y en lo que puedes hacer con él, pero tiene una funcionalidad muy relevante: permite a los programadores de la red Bitcoin y a los usuarios transferir valor de forma completamente digital y programable entre los diferentes pares que están dentro de la red. No solo eso, Bitcoin Script es lo que hace posible que mis transferencias, o las transferencias que hagamos dentro de la red, lleguen desde el punto A al punto B de forma segura, y que solo las personas autorizadas en medio de esa transacción puedan utilizar el valor que se está transmitiendo.

¿Cómo hace esto posible Bitcoin Script? Pues bien, Bitcoin Script utiliza el poder de la criptografía junto con el de la programación para habilitar a los usuarios de la red en el uso de las diferentes transacciones que se realizan. Por ejemplo, si yo como usuario transmito dinero utilizando mis entradas de Bitcoin a otra persona, genero un script específico que me permite desbloquear mis entradas y enviarlas a esa segunda persona, quien a su vez podrá utilizar sus propios scripts para realizar este pago o los pagos subsecuentes que desee hacer después de recibir el dinero.

Por supuesto, todo esto que estoy diciendo pasa completamente desapercibido, ya que se realiza de forma transparente para el usuario. La idea de Bitcoin Script es que los programadores de Bitcoin puedan habilitar opciones de transacciones digitales completamente nuevas para la red, y que esto sea transparente para los usuarios, porque lo único que importa en este punto es que puedan realizar sus operaciones sin mayores inconvenientes.

Ahora bien, Bitcoin Script es normalmente conocido como un lenguaje del tipo stack o de pila. Es decir, las operaciones que se realizan con Bitcoin Script se apilan unas sobre otras y luego se ejecutan para tener una entrada de datos y una salida de la misma. Esto facilita la generación de nodos que puedan interpretar toda esta información de forma universal y que todos los nodos tengan un consenso sobre si una transacción es válida o no. Para ello, Bitcoin Script se vale de una serie de instrucciones conocidas como opcodes o códigos de operación. En la página oficial de Bitcoin, podemos ver cuáles son estos opcodes.

Los opcodes nos permiten introducir datos dentro de Bitcoin Script para que sean validados o ejecutados por los diferentes nodos. Este es un punto muy importante que quiero enfatizar: al igual que en Ethereum, donde programamos algo en Solidity y la Ethereum Virtual Machine procesa esa información, en Bitcoin ocurre algo similar, pero a un nivel mucho más sencillo. En Bitcoin no tenemos una máquina virtual como tal, sino un ejecutor que toma el Bitcoin Script, realiza las operaciones solicitadas y determina si la operación es válida para incluirla en los bloques.

Ahora bien, ¿qué operaciones podemos realizar dentro de Bitcoin Script? En la página podemos ver la anotación que tenemos disponible. Varios de estos códigos han sido desactivados por los desarrolladores de Bitcoin debido a problemas de seguridad. La idea es mantener Bitcoin Script lo más sencillo y seguro posible. Entre las operaciones que podemos realizar, encontramos los siguientes opcodes y sus capacidades. Por ejemplo, en la parte de constantes, podemos definir constantes con palabras como OP_0 o OP_FALSE, que nos permiten identificar un arreglo de datos vacíos dentro de la pila de ejecución de Bitcoin Script.

También tenemos operaciones especiales como OP_PUSH_DATA, que indican que debemos añadir una determinada cantidad de datos a la pila, dependiendo de una entrada que le otorguemos. Además, contamos con operaciones que nos permiten hacer control de flujo. Esto es importante porque, aunque Bitcoin Script es un lenguaje de scripting limitado en sus funciones, no le quita la capacidad de tener control de flujo, es decir, la capacidad de decidir si se realiza una iteración o no, dependiendo de ciertas condiciones.

Para ello, tenemos códigos como OP_NOP, que no realiza ninguna acción; OP_IF, que ejecuta una determinada acción si se cumple una condición; OP_NOTIF, que actúa si no se cumple una condición; y OP_ELSE, que es otra opción de control de flujo bastante utilizada. También existen otros opcodes como OP_VERIFY, que verifica una operación, y OP_RETURN, que marca una situación como inválida y se utiliza en muchas operaciones como base para realizar las transacciones de Coinbase.

El control de la pila también incluye varias operaciones, como duplicar la pila, abrir el stack y eliminar una instrucción. Para eliminar una instrucción se utiliza el opcode OP_DROP, y para duplicar se utiliza el opcode OP_DUP. Así, tenemos una serie de operaciones que nos permiten manejar diferentes funciones dentro de Bitcoin Script.

Un apunte importante es que, siendo Bitcoin un dinero programable, existe la capacidad de realizar operaciones aritméticas. Sumar, restar y multiplicar son operaciones posibles utilizando Bitcoin Script. Para ello, contamos con varios opcodes que permiten realizar estas operaciones. Sin embargo, es importante mencionar que los opcodes de multiplicación y división están desactivados debido a un problema que se descubrió en Bitcoin, que permitía a ciertos usuarios manipular estos opcodes para realizar operaciones mal formadas que eran validadas por el nodo, permitiéndoles obtener ingresos de forma maliciosa.

Además, hay varios opcodes desactivados por razones de seguridad. También contamos con opcodes para operaciones aritméticas, como verificar si un número es igual a otro, o si es menor o mayor. En un principio, mencioné que con Bitcoin Script se pueden realizar operaciones criptográficas. Esto tiene sentido, ya que la manera en que verificamos operaciones dentro de Bitcoin utiliza la criptografía. Para ello, Bitcoin Script tiene funciones y códigos de operación disponibles, como RIPEMD-160, SHA-1 y SHA-256, que son utilizados para generar diferentes hashes especiales para Bitcoin.

También existen operaciones de bloqueo por tiempo, como OP_CHECK_LOCKTIME_VERIFY (CLTV), que permite bloquear determinadas cantidades de criptomonedas por un tiempo hasta que se cumplan ciertas condiciones. Asimismo, tenemos OP_CHECKSEQUENCEVERIFY (CSV), que tiene funciones similares a CLTV, pero utiliza un sistema de secuencias en lugar de un bloqueo temporal.

Ahora que conocemos un poco sobre las operaciones dentro de Bitcoin Script y sus diferentes opcodes, recomiendo leer y familiarizarse con esta página si deseas adentrarte en el mundo de la programación de Bitcoin. Sin embargo, no es la única manera de hacerlo; puedes utilizar wrappers como Python o BTC, que permiten programar operaciones en Python, pero que luego son traducidas a los opcodes necesarios para generar transacciones que puedan ser entendidas por la red Bitcoin.

Esta lista de operaciones de opcodes nos indica que podemos programar operaciones de diversas índoles con Bitcoin Script. Esto elimina la idea de que Bitcoin Script no tiene la capacidad de programar smart contracts. De hecho, cada vez que realizas una transacción en Bitcoin, las operaciones de distintas índoles se pueden programar en el mismo sistema. Esto es lo que permite programar una transacción en Bitcoin Script, y es posible gracias a un pequeño smart contract dentro de esa operación, ya que Bitcoin Script es un lenguaje de tipo smart contract.

La diferencia entre los smart contracts de Ethereum y los de Bitcoin es que los smart contracts de Bitcoin no son Turing completos. Esto significa que no podemos crear estructuras extremadamente complejas en comparación con lo que podemos hacer con Solidity. Por ejemplo, no podríamos crear un oráculo blockchain como Chainlink sobre Bitcoin, porque no hay capacidad para este tipo de operaciones. Sin embargo, los desarrolladores de Bitcoin entienden que estas limitaciones deben ser superadas, y para ello se han creado diferentes sistemas, como Miniscript y wrappers para Python u otros lenguajes de programación.

Estos wrappers y extensiones buscan llevar a Bitcoin a más lugares para potenciar su uso. Para ver cómo funciona Bitcoin Script en realidad, vamos a mostrar algunos ejemplos en pantalla para que vean cómo es la programación de un Bitcoin Script y hasta dónde se puede llevar este potencial.

Voy a mostrar el primer ejemplo. En este caso, tenemos un comando llamado BTCd, que contiene una serie de datos que iré demostrando. Este primer dato es nuestra firma de Bitcoin. Luego viene la firma hash y aquí están nuestras operaciones. Esta línea que estoy recorriendo es una dirección de Bitcoin que pueden verificar directamente en un mempool. Aquí están nuestras operaciones completas.

Lo que vemos aquí arriba pertenece a nuestro script de verificación. Este script contiene la información de nuestra clave pública y la firma correspondiente para movilizar una determinada cantidad de criptomonedas dentro de una dirección. En este caso, la dirección que estamos viendo es la 12AB8. Esto le indica a Bitcoin Script que tenemos esta dirección, esta firma y estos scripts. Vamos a ejecutar estos scripts dentro de un nodo y verificar si todo es correcto. Si es así, esta persona podrá movilizar el dinero que está en esa dirección.

El primer cuerpo que tenemos aquí son las dos primeras líneas, que serían nuestro script de verificación. Luego viene el script como tal. Primero duplicamos la pila, que tomará esta información y la duplicará. Luego hacemos un hash 160, es decir, realizamos un hash RIPEMD-160 y SHA-256. Después, verificamos si la dirección es igual y luego verificamos las firmas.

Para ejecutar este Bitcoin Script y verlo gráficamente, vamos a limpiar la pantalla y ejecutar un depurador llamado BTCDEP. Este es un depurador oficial de Bitcoin Script que pueden utilizar con confianza. Ahora que sabemos dónde conseguir la herramienta BTCDEP, vamos a ejecutar un pequeño script con un ejemplo de transacción que ya hemos modificado.

Aquí tenemos el script cargado. Vamos a ir ejecutando paso a paso cada una de estas operaciones. El primer paso es duplicar la pila superior. Ya está duplicada. Seguimos con el segundo paso, y la pila se sigue reduciendo mientras ejecutamos el script. Luego duplicamos nuevamente la línea anterior y aquí tenemos el script duplicado.

A continuación, aplicamos OP_HASH160. Lo que sucederá es que tomaremos la firma pública y la transformaremos en una dirección de Bitcoin, que debería ser igual a la dirección 12AB8 que estamos viendo. Ejecutamos el siguiente paso y efectivamente, en el lado del script tenemos nuestra dirección, 12AB8, y en el lado del stack ejecutándose dentro de BTCDEP, tenemos la misma dirección. Esto confirma que la firma que estamos utilizando es correcta.

El siguiente paso es enviar la firma que nos da el script. Ahora verificamos las dos firmas con OP_EQUALVERIFY. El siguiente paso se ejecuta y efectivamente, las operaciones son correctas. El script nos indica que las direcciones son idénticas, lo que nos permite continuar con la operación. Finalmente, verificamos si la firma es correcta y pertenece a quien dice pertenecer. Al aplicar el siguiente paso, confirmamos que la firma es idéntica y pertenece a quien corresponde.

Con esto, hemos terminado la ejecución de nuestro primer Bitcoin Script. Este proceso que acabo de explicar de forma gráfica con BTCDEP es el mismo que se realiza repetidamente con cada operación dentro de Bitcoin. Cada vez que un minero genera un bloque e incluye 1,000 o 1,200 transacciones, los nodos realizan estas operaciones una y otra vez hasta verificar que todo esté correcto. Luego de verificar, ingresan el bloque en la blockchain, validándolo y generando consenso en la red.

Este proceso se repite constantemente dentro de Bitcoin y otras monedas que funcionan con un esquema similar, como Dash, Zcash o Monero, que también tienen sistemas parecidos, aunque con adaptaciones. Si salimos aquí, podemos cerrar y hemos terminado con el primer ejemplo. Ahora, veamos un segundo ejemplo que he preparado.

En este caso, el ejemplo 02 presenta operaciones nuevas. Vamos a dividir un poco el script para hacerlo más legible y explicar cada una de estas operaciones. Aquí tenemos los op_DUP, OP_PUSH, PUSHBYTE y un tema de dirección y hash. Lo que ven en pantalla es una transacción del tipo SetWitness, que es común en la actualidad dentro de la red, ya que la mayoría de las transacciones son de tipo SetWitness o P2SH, que son muy similares.

El script comienza con un PUSHBYTE de 72 y un PUSHBYTE de 65, y al final nos da una clave pública. Luego, se nos pide duplicar la pila, hacer un hash 160 y luego un PUSHBYTE de 20, es decir, tomamos los últimos 20 bytes y verificamos si son idénticos a lo que tenemos en la pila. Así funciona SetWitness. Aquí, como se puede ver, nos falta la formación de las claves, ya que SetWitness divide la información en dos partes: las claves van por un lado, en lo que llamamos el witness o testigo, y la información de la transacción va por el otro.

Vamos a ejecutar este ejemplo. Aquí tenemos nuestro stack cargado. Hay algunas advertencias debido a que el BTC no está completamente sincronizado con los operadores de código de Bitcoin Script, pero podemos obviarlas y seguir adelante. Hacemos el primer paso y cargamos la primera parte del stack. Luego, seguimos cargando el siguiente paso y comenzamos las operaciones de manipulación y verificación.

Primero, realizamos una duplicación y efectivamente, ya está hecha. Luego, hacemos el hash 160 y aquí está nuestro hash de la operación anterior. Continuamos con el siguiente paso, que es hacer el PUSHBYTE y finalmente cargamos la información de la firma y hacemos la verificación. Efectivamente, la firma es correcta, lo que significa que la operación SetWitness que acabamos de ver es válida.

Dentro del script de esta operación SetWitness, todas las operaciones son correctas. Como pueden ver, es bastante sencillo utilizar BTCDEP para programar este tipo de cuestiones. Pueden ser transacciones que hayan sacado de las operaciones en el mempool o de las operaciones dentro de Bitcoin. Por ejemplo, aquí podemos ver una transacción y, si vamos a los detalles, podemos ver toda la información necesaria.

Simplemente tomaríamos esta información, la colocaríamos dentro de BTCDEP y verificaríamos si efectivamente este script, que en este caso es una operación SetWitness y de tipo multifirma, es correcto. También podemos ir paso a paso, que sería lo ideal. Si quiero hacer algo sencillo, como una suma, podríamos escribir BTCDEP OP_1, OP_2, OP_ADD. Así tendríamos nuestro primer stack con el número 1, el número 2 y el OP_ADD. Simplemente pasamos paso a paso y tenemos nuestra operación de suma.

La capacidad de Bitcoin Script para permitirnos programar es amplia, aunque no llega a los niveles de Solidity u otros lenguajes de programación de smart contracts Turing completos. Sin embargo, Bitcoin Script nos permite hacer muchas cosas increíbles a nivel de programación descentralizada. Quiero mostrarles parte de ese poder. Vamos a un proyecto que utiliza Bitcoin Script para realizar un mercado de intercambio, un DEX, un exchange descentralizado. Este es Bisq.

Bisq es un exchange descentralizado que funciona dentro de Bitcoin. Cuando instalas Bisq, realmente estás instalando un nodo de Bitcoin que opera de forma completamente descentralizada. No tiene intermediarios ni funciona con un servidor web como otros servicios descentralizados, como Uniswap. No necesitas intermediarios como Infura en el caso de Uniswap y su wallet MetaMask. Simplemente descargas este software, instalas tu propio nodo y te conectas directamente a un exchange descentralizado donde puedes intercambiar cualquier tipo de moneda.

Este es un ejemplo del potencial que existe detrás de Bitcoin Script. No solo se utiliza para programar operaciones sencillas, sino también para crear aplicaciones más complejas que se apoyan en otras tecnologías para complementar y realizar operaciones. Esto permite crear aplicaciones completamente descentralizadas que no tienen nada que envidiar a otras plataformas como Ethereum, Polkadot o cualquier otro tipo de plataforma web 3.

La web 3 y el corazón de este MBA demuestran que el mundo tal como lo conocemos puede descentralizarse, y estos son ejemplos claros del poder de la descentralización que nos permite el ecosistema de Bitcoin. Espero que les haya gustado este video y nos veremos en otra ocasión.

---

Saludos, en este video les explicaremos uno de los pilares fundamentales que permiten que Bitcoin pueda ser lo que llamamos dinero digital programable. Esto es posible gracias a Bitcoin Script, un sistema de script que le permite a Bitcoin programar de forma interna las operaciones que se realizan dentro de lo que sería su red blockchain o la red de nodos que forman parte de esta red conocida como Bitcoin. Bitcoin Script es un lenguaje de programación bastante sencillo, es muy muy muy pequeño en sus aspectos, en lo que puedes hacer con él, pero que tiene una funcionalidad muy muy relevante y es permitirle a los programadores de de programar. de la red Bitcoin y a los usuarios poder llegar y transferir valor de forma completamente digital y programable entre los diferentes pares que están dentro de la red. No solamente eso. Bitcoin Script es lo que se encarga de hacer posible que mis transferencias o las transferencias que hagamos dentro de la red lleguen desde el punto A al punto B de forma segura y de que solo las personas que están en medio de esa transacción sean las autorizadas para poder llegar y utilizar este valor que se está transmitiendo. ¿Cómo hace posible esto Bitcoin Script? Pues bien, Bitcoin Script lo que hace es que utiliza el poder o une el poder de la criptografía con el de la programación para llegar y habilitar a los usuarios de la red el uso de las diferentes transacciones que se realizan dentro de la red. Por ejemplo, si yo como usuario transmito dinero utilizando mis entradas de Bitcoin a una persona, yo estoy utilizando mis entradas y para eso genero un script específico que me permite utilizar mis entradas, desbloquearlas y enviarlas a esa segunda persona o a esa tercera persona para que esta persona entonces tenga la habilidad de utilizar sus propios scripts y poder realizar este pago o los pagos consecuentes que vaya a realizar después de recibir este dinero. Por supuesto, todo esto que estoy diciendo pasa completamente desapercibido porque se realiza de forma completamente transparente al usuario. La idea de Bitcoin Script es que los programadores de Bitcoin puedan llegar y habilitar opciones de transacciones digitales completamente nuevas para la red Bitcoin y que esto sea completamente transparente a los usuarios porque lo único que importa en este punto para los usuarios es que puedan realizar sus operaciones sin mayores inconvenientes. Ahora bien, Bitcoin Script es normalmente conocido como un lenguaje del tipo stack o de pila. Es decir. Las operaciones que se realizan con Bitcoin Script se apilan unas sobre otras y luego se ejecutan para llegar y tener una entrada de datos y una salida de la misma. Esto obviamente facilita la generación de... nodos que puedan llegar e interpretar toda esta información de forma bastante universal y que puedan tener todos los nodos un consenso sobre si una transacción es válida o no. Para ello, Bitcoin Script se vale de una serie de instrucciones que se le conocen como opcodes o códigos de operación. Que en esta página, que es la página, la wiki oficial de Bitcoin, podemos ver... ¿Cuáles son estos hub codes? Los hub codes simplemente nos permiten llegar e introducir datos dentro de lo que sería Bitcoin Script para que sean validados o sean ejecutados por los diferentes nodes. Y esto es un punto muy importante que te quiero hacer énfasis, y es que, al igual que como pasa en Ethereum, con Solidity, en el que programamos algo, y la Ethereum Virtual Machine agarra esa información, ese smart contract, lo procesa y lo transforma en operaciones. Lo mismo pasa con Bitcoin, pero a un nivel mucho más sencillo. porque en Bitcoin no tenemos una máquina virtual como tal, sino una máquina que se encarga, o un ejecutor que se encarga de tomar el Bitcoin Script, realizar las ejecuciones o las operaciones que está pidiendo, y allí tener la certeza de si la operación es o no pálida para llegar a incluirla dentro de lo que serían los blocks. Ahora bien, ¿qué operaciones podemos hacer o qué rango de operaciones tenemos disponibles dentro de Bconstruct? Pues bien, aquí... En la página podemos ver la anotación que tenemos disponible dentro de Bitcoin Script. Varios de estos códigos han sido desactivados por los desarrolladores de Bitcoin debido a problemas de seguridad. Y la idea es mantener Bitcoin Script lo más sencillo posible, pero también lo más seguro posible. Entonces, entre esas anotaciones, entre esas operaciones que podemos realizar, podemos conseguir los siguientes opcodes y las diferentes capacidades que pueden realizar. Por ejemplo, en el parte de constante, podemos definir constantes con palabras como op0 o opfals, que nos permiten identificar un arreglo de datos vacíos dentro del stack que se está ejecutando de Bitcoin Script. Recordemos que esto significa que se va a llevar al stack o a la pila de ejecución un dato vacío que no tiene ningún valor para que sea identificado. analizado por lo que sería el ejecutor de Bitcoin Script dentro de los nodos. También tenemos operaciones especiales como son opPushData, que simplemente nos indican que debemos una determinada cantidad de datos a la pila, dependiendo de una entrada que le estemos otorgando. También tenemos opEngage, que es también llevar el número menos uno a la stack, o hacer op1True, OP1 o OPTrue, que sería hacer operaciones del tipo lógico dentro del stack. También tenemos operaciones que nos permiten, códigos de operaciones que nos permiten hacer control de flujo. Esto es importante porque recordemos que Bitcoin Script no solamente es un lenguaje de script, es un lenguaje de programación que sea limitado en sus funciones, no le quita la capacidad de tener un control de flujo. Es decir... la capacidad de decidir si se hace una iteración o no se hace, dependiendo de determinadas condiciones. Para ello, tenemos códigos como lo son opNode, que es no hacer nada, prácticamente. opIf, que es si hay una condición y esa condición se cumple, se va a realizar una determinada condición. opNotIf, que es no si se cumple una condición. OPERF, SINO, en este caso, que es también otra opción de control de flujo bastante utilizada. OPDIF, que es en la finalización de una operación, en caso de que sea inválida. OPVERIFY, que es la verificación de una operación, y OPRETURE, que simplemente nos ayuda a marcar nuestra situación como inválida y es utilizada en muchas operaciones como la base para llegar y realizar las Coinbase. OPRETURE es una de las operaciones bastante más utilizadas en este sentido porque nos permite llegar y empujar o añadir informaciones que no deben ser analizadas directamente, sino que son marcadas como inválidas o que directamente son vistas como una información que puede ser agregada a la blockchain sin ningún tipo de procesamiento por parte de lo que sería la máquina de consenso dentro de Bitcoin. También tenemos el control del stack, que en este caso son varias operaciones, como sería la duplicación del stack, la apertura del stub, dropear una instrucción, en este caso, para dropear una instrucción se utiliza el opcode opdrop, para duplicar se utiliza el opcode opdup, y así sucesivamente tenemos una serie de operaciones que nos permiten llegar y manejar diferentes operaciones que podríamos utilizar o que generalmente utilizamos dentro de las capacidades de Bitcoin Script. Un apunte importante, siendo Bitcoin dinero programable, está la capacidad de realizar operaciones aritméticas. Sumar, restar, multiplicar, este tipo de operaciones son también posibles utilizándose con Bitcoin Script. Y para ello, contamos con varios opcodes que son los que vemos aquí ahora en pantalla. como el opcode va a sumar, para sustraer, para multiplicar y para dividir. Muy importante en este punto, que son los opcodes de multiplicación y división, es que están desactivados. Y están desactivados debido a un problema que se descubrió dentro de Bitcoin que llegaba y permitía a ciertos usuarios manipular estos opcodes para llegar y realizar operaciones que estuvieran mal formadas, pero que fueran validadas por el nodo y que al final, pudieran permitirle obtener ingresos de forma completamente maliciosa. Estos opcodes fueron desactivados por el equipo y desde entonces se han mantenido así. Y fíjense que no son los únicos. Hay varios opcodes, por ejemplo, los opcodes de Splice y de Lógica. Por BIT también hay varios de ellos desactivados precisamente por razones de seguridad. También vemos que tenemos opcodes para las partes de multiplicación, la división, para la mod, para lo que es el resto de una división, otro número de operaciones aritméticas, como para verificar si un número es igual a otro, para saber si es menor o igual, si es mayor. Este tipo de operaciones también se pueden realizar con el sistema de Bitcoin Script. En un principio, también había dicho que con Bitcoin Script se pueden hacer operaciones de tipo cripto. Y esto tiene todo sentido porque la manera en que verificamos operaciones dentro de Bitcoin, tiene que utilizar la criptografía. Y para ello, Bitcoin Script tiene las siguientes funciones o los diferentes códigos de operación disponibles, que son RIPEN 160, que es utilizar el hash RIPEN 160 dentro de una operación, SHA1, SHA256, que es el usual SHA256 que hemos visto ya en otros videos. OPHash 160, que es la aplicación de SHA-256 y RipenDX 160 para generar diferentes hashes especiales para Bitcoin. En este caso, por ejemplo, puede ser la dirección de una cuenta de Bitcoin. OPCodeSeparator, que es una operación que realmente no hace nada, sino que hace simplemente un chequeo de firmas. OPCheckSeq. que en este caso, OpenChecksheet, en locom número 172, lo que hace es verificar si una firma pública que hemos añadido dentro de Bitcoin Script es correcta, dependiendo de los datos que le hayamos otorgado. Checksheet Verify, que es la verificación de esa firma. y OPEP Check Multi-SIG, que es la que nos permite crear monederos de múltiples firmas. Esta es la operación que hace posible esa capacidad. También tenemos operaciones de lock time o de bloqueo por tiempo, como en este caso es OPEP Check Lock Time Verify, o como se le conoce también CLTB. que es una transacción especial que nos permite llegar y bloquear determinadas cantidades de criptomonedas, en este caso Bitcoin, por un determinado tiempo hasta que se verifiquen o se cumplan ciertas condiciones. Y también tenemos, en un mismo sentido, OPEC Check Sequences Verify, o también conocido como CSV, que tienen unas funciones bastante parecidas a CLTV, pero que en este caso, en vez de utilizar un lock time o una... o un bloqueo de tiempo, utilizan un sistema de secuencias, tal como lo ejemplifica el VIP 060268, que es el que se encarga de este tipo de operaciones. Ahora bien, ya que conocemos un poco las operaciones que están dentro de... lo que sería Bitcoin Script, sus diferentes opcodes, que recomiendo leer y reconocer bien esta página si quieres entrar en lo que es el mundo de programación de Bitcoin directamente con los Bitcoin Script, que no es la única manera de entrar. Puedes utilizar wrappers como lo que son Python, Python B, que... BTC, que te permite llegar y programar operaciones con Python, pero que luego son traducidas a los OCOPS necesarios para llegar y generar transacciones que puedan ser entendidas por la red Bitcoin. En todo caso, esta lista de operaciones que están aquí de opcodes, nos dicen una cosa muy clara sobre Bitcoin Script, y es que podemos programar operaciones de distintas índoles con el mismo. Y esto elimina un poco la idea de que Bitcoin Script no tiene la capacidad de programar smart contracts. Bitcoin Script tiene la capacidad de programar smart contracts. De hecho, cada vez que haces una transacción en Bitcoin, las operaciones de las distintas índoles se pueden programar en el mismo sistema. Y esto es lo que nos permite, en este caso, programar una transacción en Bitcoin Script. Y esto es lo que nos permite, en este caso, programar una transacción en Bitcoin Script. Y esto es lo que nos permite, en este caso, programar una transacción en Bitcoin Script. Y esto es lo que nos permite, en este caso, programar una transacción en Bitcoin Script. Y esto es lo que nos permite, en este caso, programar una transacción en Bitcoin Script. Y esto es lo que nos permite, Esa transacción es posible por un pequeño smart contract dentro de esa operación, porque Bitcoin Script es un lenguaje de tipo smart contract. La diferencia entre smart contracts de Ethereum y Bitcoin es que los smart contracts de Bitcoin no son Turing completos. ¿Qué significa esto? Que no podemos crear estructuras extremadamente complejas en comparación con lo que podemos hacer con Solidity. Por ejemplo, no podríamos crear con todos estos opcodes que hemos visto, no podríamos crear un oráculo blockchain, por ejemplo, como una especie de chain link sobre Bitcoin, porque no hay la capacidad para este tipo de operaciones. Sin embargo, los operadores o los desarrolladores de Bitcoin entienden que estas limitaciones deben ser superadas y para eso se han creado diferentes sistemas, como es el caso de Miniscript, como es el caso de los wrappers que he comentado para Python o para otros lenguajes de programación. Estos wrappers y estas extensiones lo que buscan es llevar a Bitcoin a más lugares para que pueda ser utilizado y potenciado su uso. Más allá de esto, para ver cómo funciona Bitcoin Script en realidad. Vamos a ver unos pequeños ejemplos y los voy a mostrar en pantalla. para que vean cómo es la programación de un Bitcoin Script. Y también voy a mostrar hasta dónde se puede llevar este potencial. Vamos a reducir un poco esta pantalla aquí. Y vamos aquí a nuestra cónsola. En este caso ya tenemos algunos ejemplos ya preparados. Voy a mostrar el ejemplo número uno. En este caso tenemos un comando llamado btcd. que en este caso tenemos una serie de datos que voy a ir demostrando. Este primer dato que ustedes ven aquí es nuestra firma de Bitcoin. Nuestra firma como tal. Luego viene la firma hacheada. Y aquí vienen nuestras operaciones. Voy a poner esto aquí de manera que podamos revisarla poco a poco. Esto que ven aquí, esta línea que estoy recorriendo aquí en pantalla, es una dirección de Bitcoin. Pueden verificarla directamente en un mempool. Y aquí están nuestras operaciones completas. Muy bien. Aquí lo que vemos es lo siguiente. Aquí tenemos... vemos esto que está aquí arriba, estas dos líneas, pertenecen a nuestro script bookkeep. Nuestro script bookkeep, lo que contiene es la información de nuestra llave pública y la firma correspondiente para movilizar una determinada cantidad de criptomonedas que estén dentro de una dirección. En este caso, la dirección que estamos viendo es la dirección 12AB8, esta que estoy mostrando aquí. Y esto lo que nos dice a Bitcoin Script es que mira, tenemos esta dirección, tenemos esta firma y tenemos estos scripts. Vamos a tomar estos scripts, los vas a ejecutar dentro de un nodo y vas a verificar si todo es correcto, porque si todo es correcto, esta persona puede movilizar el dinero que está en esa dirección y mandarlo a quien lo está enviando. Entonces, el primer cuerpo que tenemos aquí, estas dos primeras líneas, sería nuestro script bouquet. Y luego viene nuestro script como tal. Aquí lo primero que hacemos es una duplicación de la pila. que en este caso va a tomar esta información que está aquí y la va a duplicar. Va a hacer un hash 160. Es decir, va a llegar y va a hacer un hash ripen de 160 y doble sh256. Y luego va a tomar esta dirección, va a verificar si son iguales, y luego va a verificar las firmas. Para ejecutar esto, para ejecutar este Bitcoin Script y verlo más gráficamente, vamos a salir un momento aquí. Vamos a limpiar la pantalla. Vamos a hacer lo siguiente. Bash, ejemplo 01. Y vamos a ejecutar un debuqueador llamado btcdep, que lo podemos buscar aquí. Vamos a buscar rapidito antes de... para mostrarles dónde pueden buscar este debuqueador. btcdep, aquí está. Este es Bitcoin Script Debugger, esto es un debugueador de Bitcoin Script, es oficial de Bitcoin y pueden utilizarlo con completa confianza, es bastante sencillo de compilar para que se pueda agregar su funcionamiento. Muy bien, ahora que sabemos dónde podemos conseguir la herramienta BTCDEP, que es la que vamos a utilizar. Vamos a ejecutar un pequeño script con un ejemplo de transacción que ya hemos modificado, que es el ejemplo que estábamos viendo ahorita en pantalla. Vamos a hacer entonces... Voy a limpiar la pantalla nuevamente. Bash ejemplo 01. Y aquí tenemos a VTCdev ejecutando nuestro script. En este caso, el script que había mostrado en pantalla ya está cargado. Aquí podemos ver el script en forma de pila. y vamos a ir ejecutando paso a paso cada una de estas operaciones. El primer paso es tomar y duplicar todo el stack superior. Ya aquí está. PushStack se ha duplicado. Ya tenemos el primer paso aquí y aquí. Seguimos el segundo paso. Y ya tenemos el segundo paso, ya la pila se sigue reduciendo y vamos haciendo la ejecución continua de este script. Lo siguiente que hacemos es duplicar nuevamente la línea anterior y aquí tenemos el script ya duplicado. Fíjense que tenemos aquí nuestras firmas ya duplicadas. Bien. Vamos a hacer entonces el siguiente paso que es aplicar el ophash 160. ¿Qué va a pasar aquí? Lo que va a pasar es que vamos a agarrar la firma pública, que en este caso es la 044, esta que está acá. Vamos a agarrar esta firma pública. y la vamos a transformar en una dirección de Bitcoin, que en este caso debería ser igual a la dirección 12AB8 que estamos viendo aquí abajo. Vamos a ejecutar el siguiente paso y deberíamos obtener la dirección. Y efectivamente, en el lado del script tenemos nuestra dirección, 12AB8, y en el lado del stack ejecutándose dentro de VTC DEP, tenemos la misma dirección. Efectivamente, la firma que estamos tomando de esta operación es correcta y nos está generando la dirección que necesitamos para llegar y hacer la verificación. Ahora, el siguiente paso es enviar la firma que nos está dando el script. Y ahí está. Ahora, estas dos firmas que están acá, las vamos a verificar con op equal verify. El siguiente paso lo ejecutamos. Y efectivamente, las operaciones son correctas. El script nos está diciendo que las direcciones son idénticas y por ser idénticas nos da la capacidad para seguir con la operación. Finalmente, lo que quedaría es verificar si la firma es correcta y pertenece a quien dice pertenecer. y aplicando el siguiente paso, podemos ver que efectivamente sí, la firma es completamente idéntica y pertenece a quien dice pertenecer. Finalizamos. Y con ello ya hemos terminado la ejecución de un primer Bitcoin Script. Este proceso que acabo de explicar aquí de forma bastante gráfica con BTCDEV. Es el mismo proceso que se realiza una y otra vez con cada una de las operaciones que se tienen o se llevan a cabo dentro de Bitcoin. Cada vez que un menero genera un bloque e incluye 1.000, 1.200 transacciones dentro de ese bloque y estos bloques llegan a los nodos, los nodos realizan estas operaciones una y otra vez hasta que terminan con las 1200 operaciones y con ello verifican que todo esté correcto. Luego de verificar que todo esté correcto, simplemente llegan y ingresan el bloque que ha enviado el dinero a lo que sería el listoreo de la blockchain y con ello se da el visto bueno a ese bloque, se valida y se genera consenso en la red. Todo este proceso se repite una y otra vez todo el tiempo dentro de Bitcoin y dentro de monedas, y que funcionan con el esquema de Bitcoin. Por ejemplo, puede ser Dash, que tiene un sistema muy parecido a lo que es Bitcoin Script. Puede ser Zcash, que también tiene un sistema bastante parecido. Monero también tiene un sistema muy parecido, con adaptaciones para lo que serían sus Bulletproof y lo que sería su máquina virtual, porque ellos sí tienen una máquina virtual a nivel de ejecución. Pero la forma básica, las bases, son estas que acabamos de ver en este ejemplo. Si salimos aquí, podemos llegar y cerrar. Y ya con eso hemos terminado con un primer ejemplo. Vamos a ver un segundo ejemplo que he tenido preparado ya por aquí. En este caso, ejemplo 02. Y vamos a crecer aquí. Y aquí cambia un poco la cuestión. Aquí vemos operaciones nuevas. y vamos a explicar un poco de qué van estas operaciones nuevas. Vamos a dividir un poco el script para hacerlo más legible. Y luego les explicaré poco a poco cómo es cada una de estas operaciones. En este caso ya tenemos los PDUP, POPPASH, PUSHBYTE, y tenemos aquí un tema de dirección y el HX. OK, perfecto. Ya tenemos aquí. Lo que ven en pantalla, aquí en la cónsula, es una transacción del tipo SetTweet. Una transacción del tipo SetTweet como las que vemos normalmente en la actualidad dentro de la red, porque prácticamente la mayoría de las transacciones que se hacen o son tipo SetTweet o P2SH, que son muy parecidas también. Y en este caso, el script cambia un poco. El script empieza primero con un push byte de 72 y un pushbyte de 65. Y al final me da una pubkey, una clave pública. Luego nos está pidiendo que hagamos una duplicación del stack, que hagamos un hash 160 y luego hagamos un pushbyte 20. Es decir, vamos a tomar los últimos 20 bytes y vamos a hacer un push para llegar y verificar si esto es idéntico a lo que tenemos dentro del stack. Así funciona ZTwist. Aquí, como se puede ver, nos hace falta la formación de las claves como tal, porque ZWIT lo que hace es dividir esta información en dos partes. Las claves van por un lado, en lo que llamamos el witness o testigo, y la información de la transacción como tal va por el otro, que es lo que vamos a verificar en este punto. Entonces, vamos a hacer aquí, salimos, y vamos a ejecutar este ejemplo. y aquí tenemos nuestro stack cargado. Tenemos aquí unas... Warnings que en este caso serían... debido a que el BTC no está completamente sincronizado con los operadores de código de Bitcoin Script. Pero podemos simplemente obviar esto y seguir adelante. Vamos a hacer el primer paso. Y ahí cargamos la primera parte del stack. El segundo paso. Ya descargado, seguimos cargando el siguiente paso. Y aquí empiezan las operaciones de manipulación, de información y de verificación. Aquí lo primero que vamos a hacer es una duplicación. Y, efectivamente, ya podemos ver la duplicación hecha. Aquí está. Luego viene la realización del hash 160. Y aquí está nuestro hash 160 de la anterior operación. Seguimos entonces con el siguiente paso que es hacer el pushbite y finalmente cargamos la información de la firma y hacemos la verificación. y efectivamente la firma es correcta. Hemos conseguido que la información sea correcta y que nos lo valide la operación. Esto significa que la operación setWidth que acabamos de ver es correcta. Dentro de lo que sería el script que va a esta operación setWidth, todas las operaciones están correctas. Seguimos y verificamos que efectivamente todo está perfectamente. Entonces, como puedes ver, es bastante sencillo utilizar BTCDEV para llegar y programar este tipo de cuestiones. Pueden ser directamente transacciones que hayas sacado de lo que serían las operaciones de la main pool, o de lo que serían las operaciones dentro de Bitcoin. Por ejemplo, aquí podemos ver una transacción. Y si vamos a los detalles, podemos ver toda la información necesaria para tal cuestión. Aquí está el script. Simplemente. tomaríamos esta información, lo colocaríamos dentro de BTCDepth y ya con ello podríamos verificar si efectivamente este script, tal como está escrito, que en este caso es una operación setwith y de tipo multifirma, tal como aparece aquí en la pantalla, ya con esto podríamos llegar a incluirlo dentro de BTCDepth y verificar si efectivamente la operación es correcta. o podemos ir paso a paso como sería lo ideal. En este caso, por ejemplo, si quiero hacer algo muy sencillo, como sería una suma, podríamos llegar y escribirlo. BTCDEP OP1, OP2, OPADD. Y aquí ya tendríamos nuestro primer stack. Tendríamos el número 1, el número 2 y el OPADD. Simplemente pasamos paso por paso. y tenemos nuestra operación de suma. La capacidad de BTC y de Bitcoin Script para permitirnos programar es muy amplia, aunque no llega a los niveles de Solidity o de otros lenguajes de programación Smart Contract Turing completo. BTC, Bitcoin Script, nos permite hacer muchas cosas completamente increíbles a nivel de programación descentralizada. Y quiero mostrarles parte de ese poder. Vamos aquí a un proyecto que utiliza Bitcoin Script para realizar un mercado de intercambio, un DEX, un exchange descentralizado. Este es Pisk. y BISC es un exchange descentralizado que funciona dentro de Bitcoin. De hecho, cuando instalas BISC, realmente estás instalando un nodo de Bitcoin que funciona de forma completamente descentralizada. No tiene ningún intermediario, no funciona con un servidor web como funciona en otros servicios descentralizados, como en el caso de Uniswap. No necesitas ningún intermediario, como sería Infura en el caso de Uniswap y su wallet MetaMask. absolutamente nada simplemente descargas este software te instala tu propio nodo, te instala todos los servicios que necesitas y te conecta directamente a un exchange descentralizado en el que puedes intercambiar cualquier tipo de moneda y se ve tal cual como ves en pantalla Este es un ejemplo del potencial que existe detrás de Bitcoin Script. No solamente es para programar operaciones sencillas. También puedes utilizarlo para programar aplicaciones como estas, que son mucho más complejas, que se apoyan en otras tecnologías para llegar y complementarse y poder realizar operaciones o aplicaciones, en este caso, para poder crear aplicaciones que sean completamente centralizadas y que no tienen nada que envidiar a otras. a otras plataformas como serían Ethereum, Polkadot o cualquier otro tipo de plataforma web 3 como la conocemos normalmente, pero que también y extrañamente entra en lo que sería web 3. La web 3 y el corazón de este MBA es demostrar de que el mundo es un mundo. web tal como lo conocemos ahora puede descentralizarse y estos son ejemplos muy claros del poder de la descentralización que nos permite el AppKeychain. Espero que les haya gustado este video y nos veremos en otra ocasión.


###  224.B4_DLC-video

###  DLC
![[224.B4_DLC.mp4]]
[DLC](https://app.web3mba.io?wvideo=vgugowyhqq)

Hablemos ahora de los DLC. Los Discrete Block Contracts (DLC) son una propuesta que busca convertir a Bitcoin en una blockchain con medios propios y nativos para crear oráculos blockchain, algo que hasta ahora era imposible de realizar. Últimamente, gran parte del desarrollo de Bitcoin se ha centrado en ofrecer mejoras a su privacidad y en su capacidad para ejecutar scripts más potentes. Mejoras como Taproot y Graftroot apuntan precisamente a esto. Sin embargo, los DLC tienen un objetivo un poco más específico: están diseñados para conectar la blockchain de Bitcoin con el mundo exterior. Es decir, los DLC buscan establecer puentes de comunicación que lleven información del mundo real a la blockchain. Esto permite que, una vez allí, esa información sea procesada por smart contracts dentro de Bitcoin o cualquier otra blockchain que implemente los DLC.

En este sentido, es comprensible que conectar la blockchain al mundo real no sea una tarea sencilla. Sin embargo, es una funcionalidad muy apreciada por los desarrolladores de aplicaciones descentralizadas. De hecho, las finanzas descentralizadas (DeFi) necesitan este tipo de funciones para poder ejecutarse correctamente. De ahí que en Ethereum los oráculos sean algo muy común, ya que son los encargados de llevar información del mundo real a los protocolos DeFi o a las DApps que se ejecutan sobre la red y requieren estos datos. En este caso, Chainlink es uno de los proyectos más conocidos de oráculos sobre Ethereum. Pero Bitcoin, al igual que muchas otras criptomonedas derivadas, enfrenta un desafío diferente, dado que Bitcoin Script está limitado en funciones. Este tipo de funcionalidades son casi imposibles de implementar sobre Bitcoin de forma nativa. En su lugar, es necesario crear todo un protocolo de segunda capa, como RSK o Stacks, para agregar estas capacidades.

La propuesta del creador de los DLC pretende cambiar esta situación y permitir que Bitcoin pueda implementar oráculos de forma nativa en su blockchain. Las posibilidades son innumerables, comenzando porque Bitcoin finalmente podría tener un conjunto de aplicaciones descentralizadas propias. Esto ampliaría enormemente su funcionalidad y masificaría aún más su uso. Por otro lado, podría generar problemas si no se resuelven los desafíos de escalabilidad que ya enfrenta Bitcoin. Ciertamente, la función de los DLC es interesante, pero se presenta un grave problema en el horizonte: la escalabilidad. Este problema podría no ser del todo insuperable, ya que el creador de los DLC mencionó que podrían ejecutarse sobre Lightning Network. ¿Cuál sería el resultado? Las operaciones de los DLC podrían realizarse por miles en un canal de Lightning Network dedicado a esta tarea. Una vez que se alcance el límite del canal, simplemente se cierra, se emite el bloque en la blockchain de Bitcoin y se cierran las cuentas para todas las partes involucradas. De esta forma, se posibilita que los DLC realicen miles e incluso cientos de miles de operaciones sin que ello tenga un impacto indeseado sobre la blockchain de Bitcoin.

Sin embargo, por otro lado, ya no sería nativo. Incluso es posible llevar los DLC a sistemas compatibles con Lightning Network, como es el caso de Lumino Network de RSK, donde podría potenciar enormemente la funcionalidad de este protocolo de segunda capa de Bitcoin. No solo eso, el sistema podría también trasladarse a otras redes o protocolos de segunda capa que cumplan con las funciones HTLC y firmas NOR. Actualmente, los DLC sobre Bitcoin son una construcción cada vez más cercana. Parte de la tecnología de los DLC depende de la activación de Taproot y Mast, dos tecnologías que han sido activadas recientemente en Bitcoin. Sin embargo, para el completo funcionamiento del protocolo DLC es necesario habilitar algunas funciones adicionales que permitan su desarrollo integral sobre Bitcoin y sobre Lightning Network.

No obstante, en la comunidad de Bitcoin muchas cosas han cambiado. Si bien en sus inicios se pensaba que Bitcoin no necesitaría grandes desarrollos para smart contracts avanzados, esta idea ha ido cambiando radicalmente en los últimos años. La creación de Taproot y la implementación de Schnorr abrieron las puertas a ello. Además, se busca mantener la descentralización de Bitcoin para este tipo de construcciones, dejando de lado la necesidad de proyectos externos como RSK o Stacks para estas operaciones. Así, los desarrolladores de Bitcoin buscan construir todo lo que necesitan para smart contracts avanzados en Bitcoin de forma nativa, aprovechando la mayor red descentralizada del mundo cripto, que cuenta ya con más de 20,000 nodos core y un número superior a 30,000 nodos de Lightning Network.

Dicho esto, la implementación de DLC llevará a Bitcoin a un nuevo nivel, ya que sus smart contracts nativos podrán ejecutarse no solo sobre la Layer 1 de Bitcoin, sino también sobre Lightning Network, lo que haría que las comisiones y la velocidad de estas operaciones sean cientos de veces superiores a las de cualquier red blockchain activa actualmente, incluso superior a Ethereum 2.0 y sus shards. Pero, ¿significaría esto que no podemos hacer uso de los DLC actualmente? Para nada. Podemos usar esta tecnología como Tech Preview junto a otras capacidades de la red Bitcoin en su testnet y explorar el potencial de los DLC aplicados sobre esta red. Así podríamos vislumbrar el potencial de esta tecnología, aunque aún solo sea posible sobre la testnet.

Desde hace años, contemplamos el problema de escalabilidad de Bitcoin y su conexión con el mundo externo. Los oráculos y los DLC abren un nuevo universo para todo tipo de funcionalidades, lo que permitiría la aplicación, por ejemplo, de smart contracts sobre Bitcoin, algo que, a pesar de no haberse visto en el pasado, hoy sí es una realidad y una necesidad. Para implementar efectivamente los DLC sobre Bitcoin, aún deben transcurrir ciertas innovaciones tecnológicas y mejoras. Sin embargo, la comunidad ya está en ello y se puede probar la tecnología de los DLC sobre la testnet de Bitcoin para realizar pruebas y seguir mejorando esta red, con la esperanza de que pronto sea una realidad.


###  225.U5.1_DLCs

###  ¿Qué son los DLCs?
Los Discrete Log Contracts o DLC, son una propuesta que busca convertir a Bitcoin en una Blockchain con medios propios y nativos para crear oráculos Blockchain, algo que de momento es imposible de realizar. 

La idea detrás de los DLC proviene de la mente de Tadge Dryja del MIT, quien es un conocido desarrollador de Bitcoin y que ha estado detrás de ideas como Lightning Network (LN) y UTreeXO.

####  Discrete Log Contracts (DLC) : Smart Contracts para Bitcoin
Últimamente mucho del desarrollo de Bitcoin está centrado en ofrecer mejoras a su privacidad y a su capacidad de ejecutar scripts más potentes.

Mejoras como Taproot y Graftroot apuntan precisamente a esto, y entre ellas llegan los Discrete Log Contracts (DLC). Sin embargo, los DLCs tienen un objetivo un poco más específico. 

Y es que estos están diseñados para conectar la Blockchain de Bitcoin con el mundo fuera de la Blockchain. Es decir, los DLC buscan establecer puentes de comunicación que lleven información del mundo real a la Blockchain. Para que una vez allí esa información sea procesada por Smart Contracts dentro de Bitcoin, o cualquier otra Blockchain que implemente los DLCs.

En tal sentido, es comprensible que conectar la Blockchain al mundo real es una funcionalidad muy apreciada por los desarrolladores de aplicaciones descentralizadas. De hecho, las finanzas descentralizadas o DeFi necesitan de este tipo de funciones para poder funcionar de forma correcta. De allí el hecho de que en Ethereum los oráculos sean algo común, porque son estos los que llevan información del mundo real a los protocolos DeFi (o DApps) que se ejecutan en Ethereum y necesitan de estos datos. En ese caso, Chainlink es uno de los proyectos más conocidos de oráculos sobre Ethereum.

> Pero Bitcoin, así como muchas criptomonedas derivadas, son otra historia. Dado que Bitcoin Script está limitado en funciones, este tipo de funciones son casi imposible de implementar sobre Bitcoin de forma nativa. En su lugar, se hace necesario crear todo un protocolo de segunda capa (como el de RSK o Stacks) para agregar estas funcionalidades.

Pues bien, la propuesta de Tadge Dryja quiere cambiar esto y permitir que Bitcoin pueda implementar oráculos de forma nativa en su Blockchain. Las posibilidades de esto son muchas, empezando porque Bitcoin finalmente podría tener un conjunto de aplicaciones descentralizadas DeFi propias. Algo que ampliaría de sobre manera su funcionalidad y masificaría aún más su uso. Por otro lado, generaría problemas si no se solventan los problemas de escalabilidad que sufre Bitcoin.

####  Lightning Network y los DLCs
La función de los Discrete Log Contracts (DLC) es interesante, pero se presenta un grave problema en el horizonte: la escalabilidad.

Pues bien, esto podría no ser un problema del todo, ya que Tadge Dryja ha creado los DLC para que puedan ser ejecutados sobre Lightning Network. 

¿Resultado? Las operaciones de DLC pueden realizarse por miles en un canal de Lightning Network dedicado a esta tarea. Y una vez se llegue al límite del canal, simplemente este se cierra, se emite el bloque en la Blockchain de Bitcoin, y se cierran las cuentas para todas las partes involucradas.

**De esta manera, sería posible que los DLC puedan realizar miles e incluso cientos de miles de operaciones sin que ello tenga un impacto indeseado sobre la Blockchain de Bitcoin. Aunque es cierto, no sería nativo ya.**

**Incluso, es posible llevar los DLC a sistemas compatibles con Lightning Network, como es el caso de la Lumino** Network de RSK, en donde podría potenciar enormemente la funcionalidad de este protocolo de segunda capa de Bitcoin. No solo eso, el sistema podría trasladarse a otras redes o protocolos de segunda capa que cumplan con las funciones HTLC y firmas Schnorr.

####  Discrete Log Contracts (DLC), estado actual
Parte de la tecnología de DLC depende de la activación de Taproot y MAST, dos tecnologías que han sido activadas recientemente sobre Bitcoin.

Sin embargo, para el completo funcionamiento del protocolo DLC es necesario habilitar algunas funciones adicionales que permitirán su completo desarrollo sobre Bitcoin y Lightning Network.

![[225.B4_dlcs.png]]

**Sin embargo, en la comunidad Bitcoin muchas cosas han cambiado. Si bien, en sus inicios se pensaba que Bitcoin no necesitaría de grandes desarrollos para Smart Contracts avanzados, esta idea ha cambiado radicalmente en los últimos años. La creación de Taproot y la implementación de Schnorr abrieron las puertas para ello, eso además de la idea de mantener la descentralización de Bitcoin para este tipo de construcciones, dejando de lado la necesidad de proyectos externos (como RSK o Stacks) para este tipo de operaciones.**

De esta manera, los desarrolladores de Bitcoin buscan construir todo lo que necesitan para Smart Contracts avanzados en Bitcoin, de forma nativa, aprovechando la mayor red descentralizada del mundo crypto (Bitcoin cuenta con más de 20 mil nodos Core, y un número superior a 30 mil nodos LN). **Dicho esto, la implementación de DLC llevará a un nuevo nivel a Bitcoin, porque sus Smart Contracts nativos podrán ejecutarse no solo sobre la Layer1 de Bitcoin, sino también sobre Lightning Network,** con lo que las comisiones y velocidad de estas operaciones sería cientos de veces superior a la de cualquier red Blockchain que se encuentre activa actualmente, incluso superior a Ethereum 2.0 y sus shards. 

¿Significa todo esto que no podemos hacer uso de los DLC actualmente? Para nada, podemos usar dicha tecnología como “tech preview” junto a todas las capacidades de la red Bitcoin testnet y el poder de los DLC aplicados sobre esta red, para ver el potencial de esta tecnología.


###  226.U5.2_DLCs-Funcionamiento

###  ¿Cómo funciona un DLC?
En el whitepaper presentado por Tadge Dryja, este especifica claramente el funcionamiento básico de los DLC. 

En primer lugar, debes saber que un DLC es un contrato que tiene valor monetario.

Cuando un DLC es creado, actúan tres entidades. Dos de ellas son las partes que están realizando el intercambio, y una tercera parte es el ==oráculo.== **Este último es quien dará a conocer los datos necesarios para llevar a cabo la negociación.** Dependiendo de los datos otorgados por el oráculo, se realiza una distribución de fondos atendiendo a las condiciones estipuladas por el contrato.

**Pero es gracias a la estructura de la Blockchain, que las partes que actúan en una DLC jamás se conocen como tal. Es más, ni siquiera el oráculo es capaz de obtener dichos datos.** Esto garantiza que las operaciones son privadas y seguras, y al mismo tiempo, que dichas operaciones sean descentralizadas. No solo eso, el uso de firmas Schnorr resulta vital en este funcionamiento, y a la vez el uso de tecnologías como **Taproot y Graftroot**, pues son estas las que amplifican la funcionalidad final de los DLC. Dicho de otra manera, los DLC son una tecnología complementaria a estas otras tecnologías ya mencionadas.

Ahora bien, esto es solo una vista superficial de cómo funciona un DLC, así que ahondemos un poco más sobre esta tecnología. En especial, sobre su apartado “discreto” y lo que permite estas características: las firmas Schnorr.

####  Firmas Schnor:  La discreción de los DLC
El funcionamiento de los DLC recae especialmente en las firmas Schnorr.

Estas firmas son el método elegido para crear las firmas digitales necesarias para que un contrato multipartita pueda ser ejecutado de forma confiable. 

**Recordemos que las firmas Schnorr son capaces de ejecutar una forma de criptografía conocida como firmas con umbral (threshold signature).**

Ello significa que, varias partes pueden participar en la firma digital de un contrato o transacción de criptomonedas. Todo ello sin que ninguna de las partes sepa cuál es la firma de cada una de las partes, ni los datos secretos asociados a dicha firma. De hecho, es la firma de todas las partes la que al final garantiza una firma única y uniforme para el contrato o transacción.

Imagina esto de la siguiente manera:
- **Dos personas crearán un contrato a futuro de Bitcoin.**   
    Ambas partes han decidido crear este contrato y confiar en un oráculo para determinar si en el plazo de tiempo definido en el oráculo se cumplen las condiciones que favorezcan a una u otra de las partes involucradas. 
- **En este punto, establecidas las condiciones, se comienza con la creación del DLC.** Así, cada una de las partes crea su propia firma Schnorr, incluyendo al oráculo.
- **Una vez se han creado las firmas y firmado el script o Smart Contract,** este se envía a Blockchain a la espera de que se cumplan las condiciones. 
- **Las condiciones son monitoreadas constantemente por el oráculo,** que al término de la operación es consultado por la información necesaria para el cumplimiento del Smart Contract. 
- **Esta información es entregada por el oráculo, junto con su firma Schnorr** y una vez se verifica la autenticidad de la información, el DLC activa las condiciones del contrato dada la información recibida. 
- **De esta forma, el Smart Contract creada por las partes en su momento** enviará los fondos de acuerdo a lo estipulado, y todo ello sin ninguna intermediación.

**En este ejemplo, las firmas Schnorr son vitales porque estas son las que demuestran de forma clara que la información es correcta (en el caso del oráculo) y de que las partes (ganadora o perdedora) han recibido la información y que están de acuerdo con la misma.** 

De hecho, si una de las partes intentara reclamar el dinero sin autorización del oráculo, el dinero podría ir directamente a su contraparte, desmotivando así acciones maliciosas.

**Adicionalmente, el hecho de usar firmas Schnorr y de poder unirse con contratos como los impulsados por Taproot y Graftroot solucionan un problema común con los smart contact: la privacidad.** Y es que, estas creaciones están pensadas en proteger la misma de la mejor manera posible en todo momento.

Básicamente, el funcionamiento de DLC depende de la siguiente estructura:

![[226.B4_estructura.png]]

En esta imagen podemos ver las UTXOs, que pueden ser manejadas por Alicia y Bob, las cuales son emparejadas on-chain en una operación multifirma (2-de-2). 

Sin embargo, esta operación solo se aplicará una vez se cumplan ciertas condiciones off-chain que serán analizadas por los oráculos DLCs. 

En nuestra imagen, vemos que hay 4 condiciones off-chain, siendo las tres primeras las realizaciones de las operaciones programadas por los Smart Contracts DLC y la última, una cláusula de devolución en caso de que no se cumplan ninguna de las condiciones programada, permitiendo que Alice y Bob recuperen su dinero. 

**En toda esta estructura hay un punto importante:** **las condiciones del Smart Contract y la transacción no son reveladas sino hasta el final de la operación, momento en el que el resultado queda grabado en la Blockchain de Bitcoin.** Esto significa que las condiciones del Smart Contract son privadas, y solo son conocidas por Alice y Bob, nadie más puede revisarlas, salvo aquellas que son cumplidas y quedan grabadas en la Blockchain. 

####  Oráculos en DLC
Un oráculo en Blockchain, no es más que una entidad que firma mensajes como reacción a eventos del mundo real.

Antes de que se produzca el evento, el oráculo anuncia un nonce público que se utilizará para producir posteriormente una firma. 

La clave pública utilizada para la firma también debe conocerse de antemano, pero no es necesario que sea única para cada evento. Una vez que se ha producido el evento, un oráculo libera un mensaje firmado sobre el resultado del evento utilizando el [nonce](https://es.cointelegraph.com/explained/what-is-the-nonce-a-vital-number-in-bitcoin) (y la clave pública) anunciados previamente.

En tal sentido, una característica importante de DLC es que las firmas del oráculo pueden utilizarse sin una petición explícita de los participantes en el contrato. Esta característica es la razón de la parte de "registro discreto" del nombre, ya que el protocolo, dependiendo de su implementación e instanciación, permite a las partes ocultar rastros de sus contratos al oráculo.

Lo anterior se puede ver gráficamente en la siguiente imagen:

![[226.B4_participante.png]]

  ![[226.B4_fuera_de_la_cadena.png]]

En este caso, podemos ver la “vista de participante” es decir, la vista que tendría toda aquella persona que participe en el Smart Contract DLC. Son ellos los únicos que podrán ver la información de las operaciones, viendo el DLC, el resultado del oráculo y toda la información almacenada en el mismo. Sin embargo, quienes estén fuera del sistema no podrán ver nada de esto, para ellos, la transacción será simplemente una transacción de Bitcoin o LN dentro de la red, la cual pueden verificar en todo momento sin problemas y sin revelar datos del sistema. 

![[226.B4_vista_ajena.png]]  

####  Ejecución de confianza mínima
Una segunda característica de los DLC es que las dos partes implicadas en el contrato no necesitan confiar la una en la otra.

La configuración y ejecución del contrato es tal que se garantiza que siempre podrán cerrar el contrato unilateralmente. 

**Con el uso de firmas adaptadas, es imposible que una parte se comporte mal y la interacción entre las partes solo es necesaria durante la fase de configuración.** Las partes también están protegidas contra oráculos defectuosos que no produzcan una firma en la ocurrencia del evento a través de un mecanismo de reembolso.

La versión actual de la especificación no ofrece protección contra la colusión de una parte con un oráculo. Sin embargo, estos mecanismos ya están previstos (a través de pruebas criptográficas contra-fraudes) a los fines de brindar mayor seguridad a esta implementación.


###  227.U5.3_DLCs-Ejemplos

###  Ejemplos de DLC
Una de las formas en la que podemos probar el poder los de DLCs sobre Bitcoin, es usando la implementación realizada por Suredbits, con su software Bitcoin-S y Krystal Bull. 

![[227.B4_ejemplo_1.png]]

En este caso, descargaremos la versión 1.4.0 de Krystal Bull desde su web oficial de [GitHub](https://github.com/bitcoin-s/krystal-bull).

![[227.B4_ejemplo_2.png]]

Una vez descargado el software, podemos instalarlo y comenzar con el proceso de creación de nuestro primer DLC. En este caso, solo debemos hacer clic en “Create New Oracle” y comenzar con este proceso:

![[227.B4_ejemplo_3.png]]

Este proceso nos permite crear el monedero que manejará el oráculo y los DLCs asociados al mismo, como tal el proceso se da por medio de un monedero HD, en el que veremos la información de la seed.

![[227.B4_ejemplo_4.png]]

En este caso, nuestro oráculo tendrá el nombre de “BTC Price” y colocaremos nuestra clave para su manejo. Una vez terminado este proceso de configuración, podemos ver nuestro oráculo, la clave pública y dirección asociada al mismo.

![[227.B4_ejemplo_5.png]]

**Ahora ¿Cómo configurar este oráculo?** Pues bien, teniendo en cuenta que deseamos controlar el precio de Bitcoin, y que este dato es del tipo “numérico”, debemos crear un Evento Numérico para su control. Así, al presionar “Create Numeric Event” comenzamos a indicar los datos del precio de BTC que deseamos vigilar.

Así especificamos que nuestro oráculo tendrá:
1. Un precio de 45.000 USD por cada BTC
2. Vigilará la unidad BTC/USD

![[227.B4_ejemplo_6.png]]

Y creamos el evento. Al crearlo podremos verlo en el dashboard de nuestro Krystal Bull. Si queremos ver nuestro oráculo dentro de la red, todo lo que debemos hacer es hacer clic en “Send to Oracle Explorer” y allí podremos ver el oráculo en funcionamiento ([enlace al oráculo creado](https://oracle.suredbits.com/announcement/9b528c1bc206bfff6fbc443e1db93ca1e97895940d35ed363cc422fc452b58e5)). 

![[227.B4_ejemplo_7.png]]

![[227.B4_ejemplo_8.png]]

Toda la información que podemos ver en la captura anterior es nuestro oráculo DLC ya habilitado en la red. De hecho, en la imagen superior está desplegada en hexadecimal y abajo, la podrás ver en formato JSON, de forma más legible. 

![[227.B4_ejemplo_9.png]]

**En este momento, nuestro DLC ya ha sido creado, tenemos un oráculo que está atento al precio del BTC pero necesitamos alimentarlo con el precio para que funcione, después de todo el oráculo es simplemente un vigía de la realidad off-chain, uno que toma los datos de esa realidad y los traslada a la Blockchain y sus Smart Contracts.** Para lograr esto, es posible usar cualquier tipo de API que te permita obtener la información que buscas (incluyendo otras plataformas de oráculos blockchains) e inyectar dicha información. En este punto, el desarrollador tiene completo control y todo lo que necesita es acceso a dicha API y un nodo de Bitcoin para lograrlo. 

**Para este ejemplo, haremos algo más sencillo, lo haremos de forma manual, pero el resultado final será el mismo:** nuestro Smart Contract mostrará el resultado que hemos configurado. **Este proceso se llama “Attestation”** y lo podemos completar agregando el dato esperado por el Smart contrat (el precio de BTC), en este caso introducimos el valor actual de BTC en mercado:

![[227.B4_ejemplo_10.png]]

Para ello abrimos nuestro evento (o lo que es lo mismo interactuamos con el DLC) y agregamos el dato de Attestation, firmamos el evento y lo enviamos al explorador de oráculos, para ver los resultados:

![[227.B4_ejemplo_11.png]]

Con ello en el explorador quedará evidencia del oráculo y podemos observar el mismo de forma totalmente descentralizada. 

![[227.B4_ejemplo_12.png]]

####  Posibles usos previsibles con este ejemplo
**Ahora bien, una de las preguntas que seguramente te harás con este ejemplo es ¿Qué utilidad puede tener esto? Pues bien, imagina un exchange descentralizado (DEX) y piensa ¿Cómo saben estos exchanges el precio de un activo en todo momento? La respuesta, es que los DEX piden a oráculos como el que mostramos arriba información sobre el token o criptomoneda que vigilan.** 

Por supuesto, esto es un proceso que se realiza de forma automática y continua, pero eso es algo posible usando los DLCs, ya que para automatizar todo lo que hemos realizado paso a paso, solo faltaría programar un script o API que realice estas operaciones de forma continua, siendo que esta tarea es sencilla, en comparación con programar el Smart Contract que controla y permite ese proceso.

De hecho, en Suredbits han hecho esto, puesto que tienen un bot funcionando que maneja el precio de Bitcoin de forma diaria, una forma muy clara de demostrar el potencial de la tecnología. 

![[227.B4_ejemplo_14.png]]

Por supuesto, si podemos hacer algo como esto, es posible crear cualquier tipo de estructura, y eso es a lo que apuntan los DLCs, permitir la creación de Smart Contracts avanzados sobre Bitcoin y Lightning Network, aprovechando todo el potencial de ambas redes. 

¿Quieres una dApp DeFi en Bitcoin? DLC permite crearla. ¿Quieres una aplicación de mensajería o red social sobre Bitcoin? Los DLCs son una respuesta a ello. ¿Una Stablecoin o token sobre BTC? Eso también los DLC lo hacen posible. 

Si deseas saber más sobre Bitcoin-S y los DLCs, puedes revisar la [documentación oficial](https://bitcoin-s.org/docs/wallet/dlc) del proyecto.


###  228.B4_Qué_es_DeFi-video

###  Qué es DeFi
![[228.B4_Qué_es_DeFi.mp4]]
[Que es DeFi](https://app.web3mba.io?wvideo=8f3ek5356e)

¿Qué es DeFi? DeFi, o Decentralized Finance (finanzas descentralizadas en español), es el término que se utiliza para definir una gran tendencia que ha surgido en torno a la tecnología blockchain en los últimos años. DeFi busca desarrollar pequeñas piezas de servicios financieros tradicionales, pero con un grado adicional de transparencia y descentralización. Estas pequeñas piezas, como si fueran bloques de Lego, son combinables entre sí con el fin de crear un ecosistema de soluciones que, en conjunto, ofrezcan una alternativa mejorada a los sistemas financieros tradicionales. Esta es la idea que ha impulsado la creación del término DeFi y que ha llevado su evolución hasta el punto actual. De hecho, en la actualidad es imposible pasar por alto el gran impacto que DeFi tiene en el mundo cripto. Por esta razón, abrimos un espacio para conocer qué es DeFi y cómo esta idea está cambiando el panorama financiero global.

Imagina un mundo donde cualquier persona pudiera crear productos financieros transparentes con los que cualquiera, en cualquier parte del globo, pudiera interactuar. No importa dónde te encuentres, si tienes un banco o no, si posees un monedero cripto, puedes utilizar un servicio financiero ofrecido por un protocolo DeFi. Además, debido a que sus funcionalidades son comunes entre ellos, como mencioné antes, son como piezas de Lego que puedes conectar entre sí. DeFi busca transformar las estructuras de finanzas centralizadas que tenemos actualmente en estructuras descentralizadas sin necesidad de terceros de confianza, ejecutando todo esto sobre smart contracts o contratos inteligentes dentro de una blockchain, donde quede reflejado de forma transparente un registro escrito e inalterable de cada acción realizada. Todo lo que ocurre dentro de esos smart contracts queda registrado en la blockchain, que, como sabemos, es algo que siempre se puede observar.

El impacto de algo como esto es enorme. Llevamos apenas unos años y la creatividad de la comunidad mundial está dando forma a versiones alternativas de casi todos los productos financieros existentes. Y no solo eso, sino que también se están creando instrumentos financieros nunca antes imaginados, como las bolsas descentralizadas, que más adelante cubriremos. Imagina que necesitas obtener un crédito para emprender un negocio, pero no tienes acceso a activos reales o ahorros en moneda fiat que te sirvan como colateral. Es más, quizás ni siquiera puedes usar un banco porque eres una de esas miles de millones de personas que no están bancarizadas. Gracias a DeFi, puedes solicitar ese préstamo en dólar digital (USDT, USDC, BUSD) utilizando capital cripto, es decir, criptomonedas como Bitcoin u otros dólares digitales. Este préstamo será controlado y aprobado no por un humano o un banco tradicional, sino por un smart contract en la blockchain que decidas utilizar.

Si te preocupa tu capacidad técnica, porque quizás no la tengas, no todo el mundo ha nacido con conocimientos en desarrollo tecnológico. Si te preocupa tu habilidad para analizar y verificar la fiabilidad del servicio DeFi que estás utilizando, puedes confiar en el análisis que miles de personas llevan a cabo continuamente sobre estos protocolos. El hecho de que todos los contratos y las operaciones que se realizan en ellos sean públicos implica que cualquiera puede cuestionarlos y, de hecho, estará incentivado a hacerlo, ya que también está en juego su dinero. En el futuro, dado el impacto de esta tecnología, no será raro que en las escuelas se enseñe a los niños a leer smart contracts. Gracias a DeFi, no necesitas estar bancarizado; no necesitas llevar decenas de papeles, hacer filas en bancos para entregar esos documentos y esperar semanas, incluso meses, a que te den una respuesta. En su lugar, desde la comodidad de tu sofá con tu smartphone, podrás realizar este proceso. Esto puede parecer irrelevante en algunos países, pero en otros es de una utilidad similar a la que permitió el acceso a Internet.

Las DeFi, no obstante, pueden ser mucho más. Pueden ser el vehículo para la economía y las finanzas de un mundo cada vez más presente que, con la ayuda de la tecnología blockchain, puede comenzar a descentralizarse. Serán el medio que abra las puertas a inversiones internacionales sin tanta burocracia, costos y tiempo, y con mayores niveles de confianza y transparencia. En definitiva, un vehículo para que las personas no bancarizadas puedan acceder a servicios sin las restricciones de los bancos, teniendo las mismas condiciones para evolucionar en su desarrollo personal.

¿Cuál es el origen de DeFi? Si piensas que las DeFi tienen su origen en el nacimiento de Bitcoin, tienes razón; Bitcoin es definitivamente la primera plataforma DeFi del mundo, pero el origen de la idea es mucho más antiguo. Nick Szabo, supongo que lo conoces, es una figura que muchos asocian con Satoshi Nakamoto, aunque nunca lo sabremos con certeza. Szabo apuntaba, tal vez sin saberlo, al nacimiento de las DeFi cuando presentó su idea de los smart contracts en 1995. Como ves, estas ideas han estado circulando durante muchos años, pero no es algo reciente; simplemente ahora tenemos la capacidad técnica para llevarlas a cabo. En 1995, Nick Szabo ya planteaba estos smart contracts, una idea sin duda adelantada a su época. Sin embargo, no fue hasta la llegada de Ethereum en 2014 y su desarrollo en 2016 que se vivió un cambio radical en esta idea. Ethereum y sus smart contracts permitieron a los desarrolladores crear cualquier cosa que pudieran imaginar sobre una blockchain. Lo que comenzó como un experimento, algo que simplemente se iba a probar, ahora se está transformando en un movimiento por sí mismo, un ecosistema financiero descentralizado que opera de manera autónoma, generando miles de millones de dólares cada mes desde todas partes del mundo.

Muchos desarrollos apuntan a que soluciones similares también podrán ofrecerse en las soluciones de segunda capa de Bitcoin. Este ecosistema DeFi, entre 2018 y 2019, mantuvo un desarrollo constante, y durante los primeros meses de 2020, el crecimiento fue aún más impresionante, alcanzando su punto culminante en 2021, del cual hablaremos más adelante. Este crecimiento ha sido totalmente sin precedentes. Incluso ha llegado a un punto en el que los límites entre los sistemas descentralizados (es decir, estos sistemas DeFi) y los sistemas centralizados de la banca tradicional comienzan a difuminarse. Ya no sabes cuándo estás en un sistema DeFi o en un sistema centralizado tradicional. Todo esto es gracias al trabajo de miles de personas anónimas que ahora nos permiten contar con mercados de liquidez, sistemas de préstamos y exchanges descentralizados.

Ahora que ya conocemos el concepto de DeFi, sus orígenes y las diferencias entre diferentes modelos financieros digitales, veamos cuáles son las características específicas de las DeFi. Primero, funcionan en base a la tecnología blockchain y a los smart contracts. En segundo lugar, pueden ser extremadamente seguras. Esto no significa que siempre lo sean, pero tienen el potencial de serlo gracias a que utilizan técnicas criptográficas avanzadas para asegurar que la plataforma, el acceso y el uso de las mismas sean realizados solo por personas autorizadas. Tercero, pueden contar con altos niveles de descentralización. De nuevo, esto depende de cómo se implemente, pero pueden alcanzar ese nivel de descentralización, es decir, tienen la capacidad de operar sin que una cadena burocrática se imponga sobre las funciones de la plataforma. Claro, esto no es así con todos los sistemas y protocolos disponibles, pero la posibilidad está presente.

En cuarto lugar, encontramos que no requieren confianza en terceros. Este es un punto muy importante, ya que significa que la interacción en una plataforma es directa entre el usuario y la plataforma. Los terceros de confianza son innecesarios porque esa tarea será realizada por la blockchain, que llevará el registro de todo. En quinto lugar, son transparentes. Es otra gran característica de las DeFi, ya que puedes observar todo lo que ocurre dentro de la blockchain y verificar exactamente esos smart contracts. Como mencioné, se construyen utilizando software libre y cada línea de código puede ser auditada por cualquier persona. Además, las movilizaciones de recursos, es decir, cuando el dinero pasa de un smart contract a otro, también son auditable, porque todo ello tiene su lugar dentro de la blockchain.

El acceso a una plataforma DeFi no tiene fronteras. Puedes estar en cualquier país del mundo y acceder a sus servicios sin inconvenientes. De hecho, esto es algo que hemos visto increíblemente en los últimos meses, sobre todo en 2021, cuando vimos a personas en Filipinas participando en un juego que quizás hayas oído hablar, Axie Infinity. En Filipinas, un país que claramente no está entre los más desarrollados del planeta, encontraron en DeFi y en la posibilidad de participar en estos juegos dentro de la blockchain una oportunidad que les permitió salir adelante y conseguir un ingreso extra en un momento tan delicado como fue la pandemia. Así que todos estos sistemas permiten la entrada y la participación de cualquier persona en cualquier lugar del mundo, y la posibilidad de acceder a ellos es tan simple como tener un teléfono móvil y un monedero.

Hablemos ahora de los pros y los contras de esta tecnología. Por supuesto, como toda tecnología, tiene sus aspectos positivos y negativos. Entre los pros, encontramos que habilita el acceso a servicios financieros para millones de personas que, como mencioné, pueden no estar bancarizadas. Quiero detenerme un momento aquí en la importancia de estar bancarizado, ya que no todo el mundo tiene esta capacidad. Tú probablemente puedes ir al banco y decir: "Hola, soy Antonio. Vengo a hablar de mi cuenta". Eso no ocurre en muchos lugares donde la gente no tiene estas oportunidades. Gracias a DeFi, esto es posible, y representa una oportunidad de oro para llevar desarrollo y libertad financiera a quienes, por diversas razones, no han podido disfrutar de estos servicios.

Dentro de los pros también encontramos que permite que la financiación internacional de empresas y proyectos sea mucho más sencilla. Las plataformas DeFi pueden ajustarse a las necesidades del público para llevar desarrollo e inversiones donde se necesitan. Y dichas inversiones pueden provenir de cualquier lugar del mundo. Solo hay que ver la cantidad de dinero que ha aflorado gracias a la creación de estos sistemas. Sí, mucho de ello es riqueza virtual, pero también se ha generado mucha riqueza tangible. Además, las DeFi crean un nuevo punto de diversificación económica y desarrollo. De hecho, pueden significar un importante punto de desarrollo económico a mediano plazo debido al enorme potencial de criptomonedas como Bitcoin.

Habiendo cubierto estos pros, y créeme, hay muchos más, veamos algunos de los contras. La seguridad, en primer lugar, sigue siendo un aspecto a mejorar dentro de las plataformas DeFi. Si bien la blockchain ha demostrado ser una tecnología muy segura, aún quedan muchas cosas por pulir, especialmente en lo que respecta a la seguridad y auditoría de los smart contracts. Un fallo en un smart contract puede significar un colapso en la plataforma, como demostró el caso de DAO en los inicios de Ethereum y otros experimentos fallidos que hemos visto en los últimos años.

En segundo lugar, otro de los contras es que los protocolos de actuación ante la volatilidad de las criptomonedas no siempre están bien ajustados. Muchas plataformas DeFi han creado mecanismos de funcionamiento que garantizan su estabilidad económica frente a la volatilidad de las criptomonedas. Sin embargo, no pueden realmente garantizarla, y vemos que muchos de estos mecanismos a veces resultan insuficientes o simplemente no protegen al ecosistema frente a las fuertes fluctuaciones que se observan en este mercado. Una situación triste que ocurrió recientemente es la de Luna y UST, cuya fluctuación y acciones de corrección han demostrado que la descentralización y protocolos de actuación mal ajustados pueden ser una debilidad para estas plataformas si no se manejan correctamente.

Finanzas descentralizadas y fintech. Creo que es útil dedicar un momento a analizar ambas, porque seguro que has oído hablar de fintech, pero ¿en qué se diferencian de las finanzas descentralizadas que estamos cubriendo? Tenemos en nuestras manos tres modelos de finanzas que, hasta cierto punto, tienen un mismo objetivo: ofrecernos herramientas financieras potentes para ayudarnos a manejar de manera más sencilla nuestras finanzas y carteras de inversión. Estamos hablando, claro, de las finanzas tradicionales, ese banco del que he estado hablando, las nuevas fintech, que son empresas que tienen aplicaciones sobre las finanzas tradicionales, y en tercer lugar, las DeFi.

Las finanzas tradicionales ya las conocemos: el modelo centralizado de toda la vida, altamente dependiente de los bancos, enrevesado a veces, complejo muchas otras y, a menudo, inalcanzable para una gran parte de la población mundial. Hablamos de un modelo que ya vemos como en su ocaso, no solo por su incapacidad de innovar, sino porque los mismos que lo sostienen han comenzado a entender que esas herramientas ya no funcionan en el mundo actual. De los intentos de renovar y mejorar ese viejo sistema surge nuestro segundo modelo: las FinTech, o tecnologías financieras. Aquí hablamos de un intento de crear un sistema de finanzas digitales que permita alcanzar a una mayor cantidad de población, que sea rápido, eficiente, barato, global y, sobre todo, más sencillo de manejar que la banca tradicional.

Desde la década de los 90 y principios del nuevo milenio, las fintech se elevaban como el pináculo de la tecnología financiera y parecían marcar el próximo salto evolutivo de las finanzas globales. Sin embargo, esto quedó en un segundo plano con la creación de Bitcoin, la llegada de Ethereum y los primeros sistemas DeFi. La posibilidad de construir finanzas descentralizadas más universales, totalmente sin fronteras, cambió definitivamente las reglas del juego. No solo por su funcionamiento, sino también por las posibilidades que ofrecen las finanzas descentralizadas.

Podemos compilar ahora una pequeña lista que nos ayudará a diferenciar entre estos tres modelos. Una fintech es un ente centralizado, construido sobre un software y con entornos controlados y censurables. Esta palabra es importante. Por otro lado, una DeFi despliega su software sobre una blockchain descentralizada. Los contratos de una fintech son contratos que siguen el constructo legal típico que todos conocemos, mientras que en DeFi estos contratos son establecidos de igual manera para todos. El corazón de una DeFi y sus servicios son los smart contracts en blockchains que podemos ver, auditar y verificar libremente. Las decisiones de aprobación de una fintech están atadas a una cadena burocrática más larga o más corta, lo que significa que, como usuarios, podemos estar esperando una respuesta a nuestras solicitudes durante meses, días, semanas o incluso horas. Pero en DeFi, todo ocurre dentro de la cadena, de forma inmediata entre tú y la plataforma. En la mayoría de los casos, la cadena ni siquiera tiene que tener constancia de lo que está pasando. El contrato está en la cadena, se ejecuta y ya está. La aprobación se realiza de forma automática si cumples o excedes los requisitos que la plataforma exige para acceder a sus servicios.

Una fintech, por seguir con las diferencias, utiliza bancos y toda la estructura de finanzas tradicionales para hacerte llegar los recursos que solicitas. Como mencioné, una fintech es básicamente una aplicación sobre las finanzas tradicionales. Esto significa que necesitas ser alguien bancarizado y tener un registro en el sistema para participar con ciertas garantías. También significa que ese dinero puede ser censurado o limitado si así lo desean. En DeFi, esto no es algo de lo que debas preocuparte. No necesitas tener cuenta bancaria; solo necesitas un monedero de criptomonedas donde puedas recibir e interactuar con tus fondos. Ante esta visión, queda claro que una fintech es simplemente un ente financiero tradicional, pero digitalizado. Algunos proyectos fintech bien reconocidos a nivel mundial son Revolut o PayPal, por si necesitas ejemplos. Pero ya sabemos todos cuáles son y ahora entendemos en qué se diferencian de las DeFi.

Hablemos de los potenciales casos de uso de DeFi. Porque hemos estado hablando de DeFi un buen rato, ya sabemos lo que son, su origen y las diferencias con otros tipos de tecnologías. Hablemos realmente de para qué se usa esto, porque probablemente has vivido sin usar DeFi toda tu vida. ¿En qué medida podrías usarlo? En primer lugar, las DeFi nos sirven como un puente financiero entre la riqueza de los tenedores de criptomonedas y un mundo lleno de servicios financieros que pueden emplearse haciendo uso específicamente de esa riqueza acumulada en los diferentes monederos. Dicho esto, entre los casos de uso más típicos podemos mencionar los siguientes.

Sistemas de lending descentralizados, o préstamos descentralizados, son uno de los principales casos de uso de las DeFi en la actualidad, y uno de mis favoritos. El sistema es sencillo. Si una persona desea un préstamo y quiere usar sus criptomonedas como colateral, puede hacerlo sin problemas. El sistema funciona de manera muy similar a las fintechs o finanzas tradicionales. La diferencia principal es que no tienes que registrarte en ningún sitio, ni siquiera presentarte. Todo lo que necesitas es un monedero con criptomonedas. Te conectas al sistema a través de tu monedero y este sistema comprueba inmediatamente si tienes alguno de los activos que acepta como colateral. Un par de firmas con tu monedero es todo lo que te separa de obtener un crédito, normalmente en dólar digital (USDT, USDC), que recibirás de inmediato. Tu colateral seguirá accesible para ser retirado en cualquier momento, a cambio, claro, de devolver el préstamo. Una importante ventaja aquí del sistema DeFi es que los tipos de interés los define el mercado y no un banco central, lo que permite condiciones totalmente distintas a las que ofrecen los servicios financieros tradicionales.

Esto es algo que puedes hacer hoy mismo si quieres. Si tienes dinero en un monedero, puedes ir a un protocolo DeFi, verás que te piden un colateral. Si tienes el token que te piden, imagina que te piden ETH como colateral, el sistema verá que tienes ETH y te dirá: "Con este ETH que tienes, puedes pedir hasta esta cantidad de dólares como préstamo". Depositas ese ETH y te llevas el préstamo. Luego, para devolverlo, simplemente envías USDT o el USD que hayas recibido al protocolo y este te devuelve tu colateral. Este sistema es realmente interesante.

Pero vayamos al siguiente caso: los mercados descentralizados. Este es otro caso de uso de las DeFi que, si el anterior me gustaba, este me encanta. Creaciones como los exchanges descentralizados, conocidos como DEX o DEXs, son como los pools de inversiones o derivados financieros. Todos estos sistemas de staking son posibles gracias a DeFi. Es necesario hacer especial mención a los mercados descentralizados, porque esta parte es muy diferente a lo que vemos en los mercados tradicionales. Si entiendes lo que son los mercados de lending y comprendes los mercados descentralizados, puedes entender rápidamente cómo funciona DeFi.

Imagina que tienes una bolsa. Todos sabemos lo que es la bolsa. En la bolsa hay precios, por ejemplo, de Coca-Cola. La acción de Coca-Cola se mueve, la gente compra y vende. Esto se hace a través de un libro de órdenes. ¿Qué es el libro de órdenes? Es algo que existe en los mercados tradicionales. Tienes órdenes de venta, gente que está vendiendo Coca-Cola a diferentes precios, y órdenes de compra, gente que está comprando Coca-Cola a diferentes precios. Ahí tienes ese libro de órdenes, donde puedes ver la profundidad de las órdenes por ambos lados. Donde se cruzan, ese es el precio que ves en la bolsa o, si compras el periódico al día siguiente, el precio de cierre fue el último que se cruzó entre venta y compra.

Esto es posible en los mercados tradicionales, pero no en los mercados descentralizados. Los mercados descentralizados tuvieron que encontrar una solución a este problema. No puedes tener un libro de órdenes en DeFi, porque eso significaría que tienes que firmar y pagar por poner tu orden en ese libro. Nadie va a pagar por poner su orden en el libro para ver si en algún momento se ejecuta. Por eso se inventaron los mercados descentralizados. Todos los precios que ves en los tokens en las bolsas descentralizadas, que son la base de DeFi, se crean de la siguiente manera: hay un pool, una piscina de liquidez, donde hay un token contra otro. Igual que Coca-Cola cotiza contra el dólar, puedes imaginar que hay acciones de Coca-Cola y dólares en una piscina. En función de cuántos dólares y cuántas acciones de Coca-Cola hay, tendrás un precio u otro. Si tienes 10 dólares y 10 acciones de Coca-Cola, el precio de una acción de Coca-Cola será un dólar. Pero si quieres comprar una acción de Coca-Cola, tendrás que depositar un dólar. Entonces habrá 11 dólares y 9 acciones de Coca-Cola porque te has llevado una. Eso cambia el precio porque ya la cantidad de uno y de otro cambia. Así es como funcionan los mercados descentralizados.

También tenemos sistemas de pagos. Las características de estas plataformas les permiten ser un puente de confianza para procesar pagos de distintas blockchains utilizando una infraestructura externa y autónoma. De hecho, pagar con dólar digital empieza a ser una realidad muy extendida, ya que un pago internacional con dólar digital se liquida en minutos, mientras que uno a través de los medios tradicionales tarda desde varias horas, en el mejor de los casos, a varios días, que suele ser lo normal. Finalmente, también encontramos servicios bancarios y de seguros. El hecho de que todos los protocolos estén conectados entre sí, como mencioné con los bloques de Lego, permite a las blockchains crear servicios bancarios de todo tipo por terceros que no necesitan la aprobación o el consentimiento de otros sistemas. Esto nos brinda la oportunidad de acceder a un nivel de innovación jamás visto antes y una capacidad de interacción que hace posibles servicios financieros y bancarios que serían imposibles con las finanzas tradicionales. Uno de los casos más interesantes es el de sistemas que ofrecen servicios de seguros o inversiones totalmente ajenos a los sistemas bancarios tradicionales.

En este punto, es claro que el potencial de las DeFi para ofrecer servicios y soluciones es muy variado, tan variado como la inventiva de las personas que desarrollan dichos sistemas. Dediquemos ahora un momento a los riesgos, porque hemos estado hablando de las ventajas y características un buen rato. Detengámonos un momento a hablar de los riesgos a tener en cuenta al acceder al mundo DeFi. En DeFi, todo tiene sus imperfecciones, como cualquier otro sistema que se está trabajando e innovando. Existen riesgos que provienen de que todavía no está todo ajustado. Hay cosas que aún necesitan mejoras. De hecho, es importante conocer los riesgos antes de entrar de lleno en este mundo. Si no lo haces, es posible que aprendas a base de errores, que, francamente, así es como hemos aprendido todos, así que tampoco pasa nada.

Entre estos riesgos, podemos mencionar los siguientes. Los contratos y plataformas pueden ser complejos de entender, y usar DeFi no es algo que cualquiera pueda hacer, por mucho que a veces te pueda parecer lo contrario. Si entras a una aplicación descentralizada e intentas realizar una operación, seguramente verás que hay conceptos que para una persona común pueden parecer extraños, como staking o pooling. Además, los contratos de DeFi y las explicaciones en la web de la aplicación, así como los smart contracts de dichas aplicaciones, pueden parecer escritos en una lengua perdida que nadie entiende, lo que puede conllevar riesgos. Si no entiendes bien, puedes estar haciendo algo que realmente no deseas hacer. Por esto, creo que es importante que seas consciente de que DeFi, aunque ofrece enormes posibilidades, también presenta riesgos. Es fundamental saber en qué estás participando e invirtiendo. Para llegar a ese nivel de comprensión, lo único que necesitas es dedicar un poco de tiempo a probar y entender qué hace la plataforma, comprender exactamente cómo funciona y cuáles son las herramientas que tienes a tu disposición. De esta manera, podrás evitar situaciones desafortunadas, como la pérdida de tu inversión. Aunque, como mencioné, al principio, perder un poco de dinero probando es algo común.


###  229.U6.1_DeFi_-_¿Qué_es?

###  Qué es DeFi?
DeFi o Decentralized Finance (Finanzas Descentralizadas, en español) es el nombre que está definiendo una gran tendencia que se está dando entorno a la tecnología Blockchain en los últimos años.

DeFi busca desarrollar pequeñas piezas financieras tradicionales, pero con un grado extra de transparencia y descentralización. 

Estas pequeñas piezas, como si fueran piezas de Lego, son combinables entre sí con el fin de desarrollar todo un ecosistema de pequeñas soluciones que en su conjunto formen una gran solución para las finanzas. De este modo, se podrá invalidar la necesidad de instituciones financieras centralizadas y opacas que ya no aportan valor.

Esa es la idea que ha impulsado la creación del término “DeFi”, y la que ha llevado su evolución hasta el punto actual. De hecho, en la actualidad es imposible pasar por alto el altísimo impacto que DeFi tiene en el mundo cripto. Por esa razón, abrimos un espacio para conocer que es DeFi y como esta idea está cambiando el mundo financiero global.

####  DeFi, la idea que está cambiando el mundo financiero
Imagina un mundo donde cualquier persona pudiera crear productos financieros transparentes, justos y eficientes, haciendo que los bancos, las grandes financieras, prestamistas y empresas de seguros pasen a un segundo plano. O mejor aún, se vuelvan completamente innecesarias y desaparezcan. 

**Pero también un mundo donde cualquier persona pueda interactuar con esos productos de forma libre.**

**Pues bien, esto es lo que es DeFi. Es decir, quiere convertir las estructuras de finanzas centralizadas que tenemos ahora, en estructuras descentralizadas, sin terceros de confianza, ejecutada sobre Smart Contracts o contratos inteligentes, dentro de una Blockchain donde quede reflejado de forma transparente un registro escrito e inalterable de cada acción realizada.**

El impacto de una tendencia como esta es gigantesco. Apenas estamos en sus primeros años y ya la creatividad de la comunidad mundial está dando forma a versiones alternativas de casi todos los productos financieros ya existentes.

**Imagina que tienes la necesidad de obtener un crédito para emprender. En lugar de ir a un banco, puedes ir a una plataforma DeFi y solicitar un préstamo.** Dicho préstamo tiene unas condiciones (salvando los tecnicismos) bastante claras y transparentes. Todo esto gracias a que dicho préstamo va a ser controlado por un Smart Contract público e inmutable.

**No solo eso, todas las acciones que se realicen en las plataformas quedan visibles y grabadas de forma inmutable también en la Blockchain.** Tal vez usted no tiene el conocimiento para verificar la fiabilidad del servicio DeFi, pero debido a su característica de transparencia, miles de ojos podrán analizarlo y cuestionarlo, alertando de su mal funcionamiento si así fuera. Y en el futuro, dado el impacto de esta tecnología, seguro que en la escuela se enseña a los niños a leer Smart Contracts transparentes.

> Gracias a DeFi, no necesitará estar bancarizado, no necesitará llevar decenas de papeles, hacer filas para entregarlos y esperar semanas para una respuesta. En su lugar, desde la comodidad de su sofá, con su smartphone podrá hacer todo el proceso recibiendo el dinero en su poder.

**No obstante, las DeFi pueden ser mucho más, pueden ser el vehículo para la economía y las finanzas de ese mundo cada vez más presente que con la ayuda de la tecnología Blockchain comience a descentralizarse.** El vehículo que abra las puertas a inversiones internacionales sin tanta burocracia, costes y tiempo y con mayores niveles de confianza y transparencia. **Un vehículo para que las personas no bancarizadas puedan acceder a servicios sin las dictaduras de los bancos, teniendo iguales condiciones de evolucionar personalmente en su desarrollo.**

####  Origen del DeFi
Si eres de los que piensan que las DeFi tienen su origen con el nacimiento del Bitcoin, estás en lo cierto. Bitcoin es definitivamente la primera plataforma DeFi del mundo. Pero el origen de la idea es mucho más antiguo.

Nick Szabo apuntaba, tal vez sin saberlo, al nacimiento de las DeFi cuando presentó su idea de los Smart Contracts en el año de 1995. Eso es 13 años antes de la creación del Bitcoin, una idea sin duda adelantada a su época. 

**Sin embargo, no fue hasta la llegada de Ethereum en 2014, lo que supuso un cambio radical a esta idea.** Ethereum y sus Smart Contracts permitían a los desarrolladores crear cualquier cosa que pudieran imaginar sobre una Blockchain. Y justamente eso lo que empezó con un experimento ahora se está transformando en un movimiento por sí mismo, en un ecosistema financiero descentralizado que opera miles de millones de dólares cada mes. 

**Un ecosistema que durante los años 2018 y 2019 mantuvo un desarrollo constante, y durante los primeros meses de 2020 ha tenido un crecimiento sin precedente. Incluso ha llegado al punto que ha revalorizado los proyectos Blockchain al permitir crear puentes entre las finanzas tradicionales y las criptomonedas.** 

Gracias a ese trabajo ahora podemos contar con mercados de liquidez, sistemas de préstamos y exchanges descentralizados (DEX), siendo todo esto solo el comienzo. 

####  Características de las DeFi
Ahora que, ya que conocemos el concepto, sus orígenes y la diferencias entre modelos financieros digitales, conozcamos cuales son las características de las DeFi. 

1. **Funcionan en base a la tecnología Blockchain y de los Smart Contracts.**
2. **Son muy seguras.** Esto gracias a que usan técnicas criptográficas potentes para asegurar que la plataforma, el acceso y uso de las mismas pueda ser realizado solo por personas autorizadas.
3. **Cuentan con altos niveles de descentralización.** El mayor potencial de las DeFi es su alto nivel de descentralización. Es decir, tienen la capacidad de actuar sin necesidad que una cadena burocrática se imponga por encima de las funciones de la plataforma.
4. **Sin confianza en terceros.** Esto significa que la actuación en una plataforma es directa entre el usuario y la plataforma en sí. Los terceros de confianza son innecesarios porque esa tarea será realizada por la Blockchain. Es esta estructura la que llevará el registro de todo de forma segura e inmutable. 
5. **Transparentes.** Otra gran característica de las DeFi es su transparencia. Al ser construidas sobre software libre cada línea de código de las plataformas es auditable. Además las movilizaciones de recursos son auditables, porque todas ellas tienen lugar sobre la Blockchain. 
6. **Sin fronteras.** El acceso a una plataforma DeFi no tiene fronteras. Puedes estar en cualquier país del mundo y acceder a sus servicios sin inconvenientes.  

####  Pros y Contras
Como toda tecnología tiene sus pros y contras, y por esa razón examinaremos algunos de ellos. 

#####  Pros
1. **Habilita el acceso a servicios financieros a millones de personas que no están bancarizadas.** Esto es sin duda una oportunidad de oro para llevar desarrollo y libertad financiera a quienes por distintas razones no han podido gozar de estos servicios. 
2. **Permite que la financiación internacional de empresas y proyectos sea mucho más sencilla.** Las plataformas DeFi pueden ajustarse a las necesidades de un público objetivo con el fin de llevar desarrollo e inversiones allí donde se necesitan. Y dichas inversiones pueden provenir de cualquier lugar del mundo de forma segura. 
3. **Crea un nuevo punto de diversificación económica y desarrollo.** De hecho, las DeFi pueden significar un importante punto de desarrollo económico en el mediano plazo debido al enorme potencial económico de criptomonedas como Bitcoin.

#####  Contras
1. **La seguridad aún sigue siendo un punto a pulir dentro de las plataformas DeFi.** Si bien, la Blockchain ha demostrado ser una tecnología muy segura, aún quedan muchas cosas por mejorar, en especial, con el nivel de seguridad y auditoría de seguridad de los Smart Contracts. Un fallo en un Smart Contract significa un fallo en la plataforma, tal como lo demostró The DAO.
2. **Protocolos de actuación ante la volatilidad de las criptomonedas.** Muchas plataformas DeFi han creado mecanismos de funcionamiento que garantizan su estabilidad económica frente la volatilidad de las criptomonedas. Sin embargo, muchas veces estos mecanismos parecen insuficientes. O simplemente no protegen del todo al ecosistema frente a las fuertes fluctuaciones. Una situación que lleva a pérdidas millonarias. Un caso de este tipo es MakerDAO y DAI, cuyas fluctuaciones y acciones de corrección han dejado ver que la descentralización y protocolos de actuación mal ajustados muchas veces pueden ser una debilidad para estas plataformas, si no se manejan de forma correcta.

####  DeFi y FinTech ¿Cuáles son sus diferencias?
Tenemos  tres modelos de finanzas que hasta cierto punto tienen un mismo objetivo en común: Ofrecernos herramientas financieras potentes para ayudarnos a fortalecer nuestras finanzas y portafolios.

**Sin embargo, la forma en cómo logran esto es completamente distinta para cada uno de esos modelos. Sí, estamos hablando de las finanzas tradicionales, las nuevas FinTech y por supuesto del DeFi.** 

Las finanzas tradicionales ya las conocemos, el modelo centralizado, altamente dependiente de los bancos, enrevesado, complejo e inalcanzable para la gran mayoría de la población mundial. Hablamos de un modelo que vemos ya como entra en su ocaso, no solamente por su incapacidad de innovar, sino porque los mismos que los sostienen han empezado a entender que esas herramientas ya no funcionan en el mundo actual.

**De los intentos de renovar y mejorar ese viejo sistema, sale nuestro segundo modelo, las FinTech (Financial Technologies – Tecnologías Financieras). Hablamos de un intento de crear un sistema de finanzas digitales que permita alcanzar a mayor cantidad de población que sea rápido, eficiente, barato, global y sobre todo más sencillo de manejar.** Desde la década de los 90 e inicios del nuevo milenio, las FinTech se elevaban como el pináculo de la tecnología financiera y parecían que serían el próximo salto evolutivo de las finanzas globales. 

**Sin embargo, eso quedó atrás con la salida del Bitcoin, la llegada de Ethereum y los primeros sistemas DeFi.** El hecho de poder construir finanzas descentralizadas, más seguras, más universales, sin fronteras, definitivamente cambió las reglas del juego, no solo por su funcionamiento sino también por las posibilidades de las DeFi.  

Así podemos compilar Una pequeña lista nos podrá ayudar a diferenciarlas: 
1. **Una FinTech es un ente centralizado, construido sobre software y con entornos controlados y censurables.** Por otro lado, una DeFi, trabaja despliega su software sobre una Blockchain descentralizada.
2. **Los contratos de una FinTech son contratos que siguen el constructo legal que todos conocemos.** Mientras que en DeFi esos contratos son establecidos iguales para todos, el corazón de una DeFi y sus servicios son los Smart Contracts en Blockchain que podemos ver y auditar libremente. 
3. **Las decisiones de aprobación de una FinTech están atadas a una cadena burocrática, larga o corta, eso significa tiempo que como usuarios perdemos esperando una respuesta a nuestras solicitudes.** Por otro lado, en una DeFi la cadena se reduce entre tú y la persona que te dará el crédito. En ocasiones, la cadena ni siquiera existe, porque la aprobación se realiza de forma automática si cumples o excedes los requisitos que la plataforma pide para acceder a sus servicios.
4. **Una FinTech usa bancos y toda la estructura de finanzas tradicionales para hacerte llegar los recursos que pides.** Eso significa que sí o sí, necesitas ser alguien bancarizado y con registro en el sistema para participar con ciertas garantías. También significa que ese dinero puede ser censurado o limitado si así lo desean. En DeFi, esto no es algo que deba preocuparte. No necesitas tener cuenta bancaria, solo una wallet de criptomonedas donde recibir tus fondos y el resto tienes libertad.

**Ante esta visión queda bastante claro que una FinTech es un ente financiero digitalizado.** Algunos proyectos FinTech bien reconocidos a nivel mundial son Coinbase, Revolut o Paypal, por nombrar solo algunos.

![](https://files.cdn.thinkific.com/file_uploads/636320/images/90e/07b/d5d/defi_vs_finhtech-01.png)

####  Potenciales casos de uso del DeFi
¿De qué nos sirven las DeFi en la actualidad? ¿Cuáles son sus usos? En primer lugar: las DeFi nos sirven de puente financiero entre la riqueza de los tenedores de criptomonedas y un mundo de servicios financieros que pueden otorgarse haciendo uso de esa riqueza para generar -a su vez- más riqueza con ella. 

Dicho esto, entre los potenciales casos de uso de DeFi podemos mencionar:
1. **Sistemas de lending descentralizados:** Es uno de los principales casos de uso de las DeFi en la actualidad. El sistema es sencillo: **si una persona desea un préstamo y quiere usar de colateral o garantía sus criptomonedas puede hacerlo sin problemas.** El sistema funciona de forma muy similar a las FinTechs o finanzas tradicionales. **Pero DeFi suele ofrecer mejores condiciones de interés y generalmente los préstamos suelen aprobarse casi de forma instantánea.** Atrás quedan las horas en el banco, el enviar documentos digitales y esperar días para una respuesta, con DeFi basta interactuar con la DApp, realizar el depósito de garantía exigido y tendrás en tu poder el dinero que has requerido en préstamo y todo en unos minutos. 
2. **Mercados descentralizados:** Otro caso de uso de las DeFi son los mercados descentralizados. Creaciones como los exchanges descentralizados (DEX), los pools de inversiones, derivados financieros, sistemas de stakings, mercados de predicción, y más son posibles gracias al DeFi. 
3. **Sistemas de pagos:** Otro uso que se le da a las DeFi es el de sistemas de pagos. Las características de estas plataformas les permite ser un puente de confianza para procesar pagos de distintas Blockchain haciendo uso de una infraestructura externa, descentralizada y autónoma. 
4. **Servicios bancarios y de seguro:** Otro uso de las DeFi es la de ofrecer servicios del tipo “bancario” sin ser exactamente un banco. Por ejemplo, hay protocolos DeFi que permiten a sus usuarios realizar una determinada inversión. Pero al cabo de un tiempo, puedes recibir dicha inversión con un margen de ganancia, y todo gracias a los intereses que la misma ha generado. Pero no solo eso, sino que también hay sistemas que permiten la emisión de monedas estables (stablecoins), así como sistemas de identificación digital y de seguros financieros. 

En este punto es claro que el potencial de las DeFi para ofrecer servicios y soluciones es variado, tan variado como la inventiva de las personas que desarrollen dichos sistemas. 

####  Riesgos a tener en cuenta en el mundo DeFi
En DeFi no todo es perfecto. Existen riesgos que es bueno conocer antes de entrar de lleno en este mundo. Entre ellos podemos mencionar:

#####  Contratos y plataformas complejas de entender y usar
**El DeFi no es para todo el mundo,** por mucho que quieran hacer ver lo contrario. Si entras a una DApp DeFi e intentas realizar una operación, seguramente verás que en medio de todo eso hay conceptos que para una persona promedio pueden parecer extraños. No solo eso, los contratos de DeFi y explicaciones de la web de la aplicación, así como el Smart Contract de dichas aplicaciones, puede parecer una lengua perdida del mundo para la mayoría de las personas. 

Dicho esto, es bueno que seas consciente de que, si bien DeFi ofrece enormes posibilidades, debes en primer lugar saber en qué estás participando e invirtiendo, y eso pasa por aprender y comprender qué es lo que hace la plataforma, como lo hace y qué herramientas tienes a disposición. Todo ello con el fin de evitar situaciones penosas como la pérdida de tu inversión.

#####  Una descentralización incompleta
Las aplicaciones DeFi si bien se ejecutan en una Blockchain como Bitcoin, Ethereum, EOS o TRON, esto no significa que las mismas sean plenamente descentralizadas. 

Generalmente, los protocolos y aplicaciones DeFi tienen algún punto de centralización que les permite tener un determinado grado de control para situaciones en las que se amerite intervención inmediata. Un ejemplo de esto es MakerDAO y su stablecoin DAI. 

**Si bien MakerDAO funciona como una entidad descentralizada, las figuras detrás del desarrollo del protocolo tienen lo que podría llamarse un “Botón de Pánico” llamado “Emergency Shutdown”.** **Esta funcionalidad del protocolo permite cerrar todo el funcionamiento de MakerDAO y DAI para evitar que los inversores sufran pérdidas graves por algún problema en la colateralización del protocolo.** Puedes imaginar que, así como hay funciones como estas en MakerDAO, el resto de proyectos también tendrá una función parecida e incluso mayor. 

Pero, ¿Por qué esto es un riesgo? Si lo piensas un poco, funciones como estas pueden ser aprovechadas por actores maliciosos dentro y fuera del protocolo para causar daño dentro del mismo. También es un riesgo porque muchos DeFi se venden como una panacea de descentralización, cuando la realidad es muy distinta. Un problema que se agrava si añadimos la aparición de protocolos DeFi que no son más que una estafa de libreto. 

**En pocas palabras, conoce bien el proyecto donde participas, conoce sus funciones, pero sobre todo conoce la comunidad que lo mantiene. Una comunidad transparente no ocultará nada,** como el caso de MakerDAO que hicieron pública la información sobre “Emergency Shutdown” y las razones para su creación. Si sospechas de algo como eso, mantente alerta, en especial con proyectos nuevos y poco conocidos. 

#####  La seguridad no es infalible
Es cierto que la seguridad en Blockchain es excelente, también es cierto que esta no es infalible. 

El mejor ejemplo de esto lo vemos en los varios proyectos DeFi que han sufrido de problemas de seguridad relacionados con sus Smart Contracts y que han supuesto robos millonarios a sus plataformas. **Plataformas como dForce, Uniswap, Balancer, Bancor, bZx y  Synthetix, son solo algunas de las víctimas de los hacks más sonados en este sector.** 

El problema es más grave aún, porque la seguridad de los Smart Contracts depende de dos factores. En primer lugar, depende de la buena codificación y construcción de los mismos por parte de los desarrolladores del protocolo DeFi. Así un buen proyecto, codifica, revisa y audita sus Smart Contracts de forma constante. De esa forma, si detecta un error lo corrige rápidamente sin dilaciones. 

En segundo lugar, la seguridad también depende de la buena programación de las funciones que hacen posible su funcionamiento directo en la Blockchain. Por ejemplo, un problema de seguridad en una función de la EVM que afecte a estos Smart Contracts, y automáticamente la seguridad de los mismos está en peligro. **El problema con este último punto es que la seguridad ya no depende tanto del desarrollador del protocolo DeFi. En su lugar, depende de los desarrolladores Blockchain, y en caso de que no pueda ser mitigado correctamente, se tendrá un grave problema de seguridad.** 

Sí, suena a cuento de terror. Y que una tecnología que se asume ultra segura pueda tener estos problemas, sorprende. Sin embargo, son problemas reales, de hecho, la función DELEGATECALL de EVM, fue la causa de un ataque que se dio a las wallets de Parity en 2017. 

#####  El peligro de las estafas
Si has estado suficiente tiempo en el mundo cripto, seguramente recordarás el Boom de las ICO de 2017 y 2018. 

Y también sabrás lo que ello significó para muchos: pérdidas millonarias y estafas por doquier. En este punto, **las DeFi están comenzando a pasar por el mismo proceso. De hecho, hay cientos de proyectos que se disfrazan de DeFi para estafar a quienes caen en la trampa de hacer dinero fácil y rápido.**

De hecho, en medio del boom DeFi, que está de moda, no es raro ver como las plataformas buscan la forma fácil de desarrollar sus ideas. **Un ejemplo de esto lo vemos en dForce, quienes simplemente copiaron el protocolo de Compound (versión 1) para lanzar su plataforma.** **Como resultado, la plataforma dForce cayó víctima de un problema de seguridad que no detectaron y tuvieron grandes pérdidas.**

Como esta situación muchas más pueden darse: copiar un Smart Contract, cambiar algunas cosas y lanzar un servicio con el único fin de estafar a quienes caigan en la trampa. Es algo que sucede más a menudo de lo que piensas y una de las razones por la que debes estar muy atento cuando entras al mundo DeFi.

####  Plataformas DeFi en la actualidad
En la actualidad, el desarrollo de las plataformas DeFi es gigantesco. Bitcoin y Ethereum recogen las más grandes e importantes. Solo entre estos dos proyectos ya el 70% de la capitalización de las criptomonedas es controlado, eso son casi 200 mil millones de dólares.

Eso ha atraído a muchas empresas a empezar a explorar la creación de herramientas, DeFi, algunas con más éxito que otras, pero entre ellas podemos mencionar:
1. **Bisq:** Un protocolo de intercambio P2P construido especialmente para Bitcoin y completamente descentralizado.
2. **RSK:** Un protocolo y conjunto de servicios identificados como RIF OS, una plataforma de desarrollo completa que incluye Smart Contracts, identidad digital, almacenamiento descentralizado, pagos instantáneos, puentes cross-chains, sistema de pago integrado, comunicaciones descentralizadas y generación de mercados descentralizados.
3. **0x:** un protocolo para la construcción de intercambios descentralizados P2P que funciona sobre Ethereum. 
4. **Bancor:** Un sistema de intercambio de tokens construido sobre Ethereum.
5. **Compound:** Un protocolo de pool de inversiones con opciones de lending, yield farming, liqidity mining que ha tomado gran relevancia durante 2020 hasta el punto de desplazar por dos semanas a MakerDAO como la DeFi de mayor valor.
6. **Kyber:** Un protocolo de swap para integrar funcionalidades de intercambio en aplicaciones con operaciones cross-chain.
7. **MakerDAO y DAI, una DAO:** Una stablecoin diseñada para facilitar la creación de aplicaciones financieras construida sobre Ethereum.
8. **Augur:** Un protocolo para la creación de mercados de predicción.
9. **Curve:** Un DEX de stablecoins.

**Esta es una pequeña lista de algunas de las aplicaciones DeFi más importantes que existen en la actualidad.** Nombrarlas todas sería una tarea titánica debido a la diversidad de herramientas que existen en la actualidad. Pero las acá mencionadas se han ganado un sitial de honor debido a su seriedad, compromiso y desarrollo activo. Ante esto no queda duda que las DeFi y sus distintas aplicaciones serán cada vez más importantes en el futuro. Después de todo, apenas estamos explorando estas herramientas y reconociendo su alcance.


###  230.B4_CeFi_vs_DeFi-video

###  CeFi vs DeFi
![[230.B4_CeFi_vs_DeFi.mp4]]
[CeFi vs DeFi](https://app.web3mba.io?wvideo=x9t8x7c9qq)

Vamos a comparar ambos modelos. Las CeFi pueden parecer un poco similares a las finanzas tradicionales, ya que son finanzas centralizadas, pero veremos las diferencias entre ambos. Como mencionamos anteriormente, las finanzas descentralizadas, o DeFi, han crecido de forma explosiva en los últimos cinco años dentro del ecosistema blockchain. Esta realidad la conocemos gracias a los avances en blockchain y su capacidad para programar datos, así como a la posibilidad de crear servicios descentralizados, en contraposición a lo que las finanzas centralizadas nos permiten. Este es el punto en el que se diferencian.

Por eso, creo que es importante dedicar un momento a entender cuáles son las diferencias entre CeFi y DeFi. Escucharéis mucho sobre CeFi, así que prestad atención, esta parte es importante. ¿Qué es CeFi? En primer lugar, CeFi, o finanzas centralizadas, son aquellas aplicaciones o servicios financieros en los que los usuarios confían en personas para que administren los fondos y ofrezcan los servicios de manera adecuada. Estas son empresas centralizadas que garantizan el éxito de sus productos y el bienestar de sus clientes. Aunque estas compañías pueden utilizar algún tipo de dinero digital, aquí es donde se habla de CeFi y se diferencia de las finanzas tradicionales. Sin embargo, hay muy poca innovación en términos de estructura, que es uno de los elementos clave, como hemos visto en las DeFi.

Un buen ejemplo de CeFi serían los neobancos o fintechs dentro del mundo cripto, como BlockFi o Nexo. En contraposición, las DeFi son empresas o proyectos donde no existe un garante, ya que el servicio se ejecuta de forma descentralizada y todo lo que garantiza la seguridad es la plataforma desarrollada sobre la blockchain. En todo caso, los usuarios conocen esta realidad y la aceptan, lo que les permite realizar transacciones sin depender de una única autoridad centralizada, como podría ser una corporación. A raíz de esto, los usuarios pueden elegir entre un amplio abanico de servicios aquel que mejor se ajuste a sus necesidades. Un buen ejemplo de estos servicios descentralizados podría ser Aave, en el ámbito del lending descentralizado, o Uniswap, la principal bolsa descentralizada.

Sigamos diferenciando CeFi y DeFi. Existen tres aspectos esenciales para distinguir entre ambas, y estos elementos son, primero, la arquitectura. En este punto, CeFi tiene una arquitectura del servicio que está centralizada y depende de una serie limitada de elementos para su funcionamiento. Mientras que en DeFi, esta arquitectura es descentralizada y depende de un esquema de consenso. El funcionamiento, en todo caso, se mantiene y depende de estas estructuras. Por ejemplo, un neobanco presta servicios gracias a los servidores donde se aloja el servicio. La caída de esos servidores o el cierre de los mismos puede dejar al usuario sin acceso. En DeFi, aunque el sistema de control de la red puede verse afectado, la información no se perdería, ya que siempre habría nodos con una copia de la blockchain, con toda la información hasta ese momento. Además, si una web se cae, el protocolo sigue siendo accesible directamente desde la blockchain. Esta es una de las fortalezas de desarrollar un proyecto sobre la blockchain.

En segundo lugar, hablemos de la lógica. La lógica del servicio es la que permite que su funcionamiento sea sostenible. En un proyecto CeFi, la lógica del negocio permanece como un secreto empresarial, siendo conocida solo por las partes autorizadas. Mientras que en DeFi, esta lógica se desarrolla de forma pública y abierta, generalmente como desarrollos de software libre, lo que las hace totalmente transparentes. En CeFi, como mencioné, la lógica depende de las aplicaciones que se ejecutan en el servidor del servicio. En cambio, en DeFi, esta lógica depende de los smart contracts y la red blockchain sobre la que se ejecutan, contratos que son accesibles para cualquier persona.

Y en tercer lugar, hablemos de la gobernanza, como último punto en discordia. Aquí encontramos que se produce una separación de poderes por parte de la sociedad a la hora de ofrecer el servicio o decidir cuál es el servicio. En CeFi, la gobernanza es ejercida por sus directivos, que suelen ser un grupo muy reducido de personas, todas ellas con intereses en mantener el control. Pero en DeFi, la gobernanza puede extenderse no solo a los creadores, sino también a los usuarios del sistema. Por ejemplo, en CeFi, las decisiones sobre el funcionamiento dependen de sus inversores, mientras que en DeFi, esas decisiones pueden estar en manos de los propios usuarios. Incluso en los casos en los que la gobernanza es realmente abierta, lo común es que se puedan proponer cambios o mejoras para que el resto de la comunidad vote sobre su implementación.

Bien, hablemos de los usos para ambos, usos para DeFi y usos para CeFi. Tanto las DeFi como las CeFi pueden aplicarse a cualquier tipo de servicio financiero tradicional y relacionado con criptomonedas, como el comercio al contado, el comercio de derivados, préstamos, entre otros. Lo que hemos comentado anteriormente en cuanto a casos de uso que se aplican a las DeFi también podría aplicarse a las CeFi, con las diferencias ya mencionadas. Las conversiones entre criptomonedas y monedas fiat también están disponibles en ambos ecosistemas. Además, ambas plataformas, DeFi y CeFi, pueden brindar servicios entre cadenas, aunque los mecanismos aquí varían. En general, ambas tendencias tienen usos similares, pero el enfoque es muy distinto.

Un aspecto específico de DeFi es la tokenización de activos. Por poner un ejemplo, Synthetix aloja un ecosistema DeFi donde los usuarios pueden crear los llamados activos sintéticos, que son tokens ERC20 o RC20 que representan activos en el mundo real. Los usuarios pueden eventualmente liquidar esos activos sintéticos y comerciarlos en un exchange dedicado. Los activos sintéticos tienen un gran potencial y beneficios que pueden permitir en el futuro. Este tipo de activos, como mencioné, nacen gracias a la descentralización y la capacidad de los sistemas DeFi de innovar, algo que es mucho más lento y complicado de comprender en los sistemas CeFi.


###  231.U6.2_CeFi_vs_DeFi

###  CeFi vs DeFi: Comparativa entre ambos modelos
Las finanzas descentralizadas (DeFi) han crecido de forma explosiva en los últimos cinco años dentro el ecosistema Blockchain.

Esto ya es una realidad, gracias a la tecnología Blockchain. Su capacidad de programación y la posibilidad de crear servicios descentralizados, en contraposición a los que las finanzas centralizadas (CeFi) nos permiten.

En este punto nos podemos preguntar ¿Qué es CeFi y cuáles son las diferencias entre CeFi y DeFi?

####  ¿Qué es CeFi?
CeFi o finanzas centralizadas, son aquellas aplicaciones o servicios financieros en los que los usuarios confían en las personas para que administren los fondos y lleven los servicios de manera correcta. 

Estas son empresas centralizadas que son los garantes del éxito de sus productos y del bienestar de sus clientes. Aunque estas compañías pueden estar utilizando un nuevo tipo de dinero digital, hay muy poca innovación en términos de estructura, que es uno de los elementos clave de las DeFi. **Un buen ejemplo de CeFi, serían los neobancos o fintechs como Celsius, BlockFi o Nexo.**

> Las DeFi son empresas o proyectos donde no existe un garante, ya que el servicio se ejecuta de forma descentralizada y todo lo que garantiza la seguridad es la plataforma desarrollada sobre Blockchain. 

En todo caso, los usuarios conocen esta realidad y la aceptan, con lo que pueden realizar transacciones sin depender de una única autoridad centralizada, como una corporación. El resultado de esto es que los usuarios tienen libertades mayores a la hora de decidir qué hacer con sus activos digitales. **Un buen ejemplo de estos servicios son AAVE o Uniswap, cuyo funcionamiento es descentralizado.**

####  Diferenciando CeFi y DeFi
Encontramos que existen tres aspectos esenciales para diferenciar entre CeFi y DeFi, y estos elementos son:
1. **Arquitectura.**  
    **En este punto, CeFi tiene una arquitectura del servicio que está centralizada y depende de una serie limitada de elementos para su funcionamiento. Mientras que en DeFi, esta arquitectura es descentralizada y depende de un esquema de consenso.** El funcionamiento en todo caso se mantiene y depende de estas estructuras. Por ejemplo, un neobanco presta servicios gracias a los servidores donde se aloja el servicio, la caída de esos servidores deja al banco sin acceso. Sin embargo, en DeFi esto no es un problema, la red es tan amplia que la caída de uno o varios nodos no tiene ningún impacto. El sistema seguirá funcionando sin contratiempos. 
2. **Lógica.**  
    La lógica del servicio es la que permite que su funcionamiento sea sostenible. En proyecto CeFi, la lógica de negocio permanece como un secreto empresarial siendo conocido solo por las partes autorizadas para ello. Mientras que e**n DeFi, esta lógica se desarrolló de forma pública y abierta** (generalmente siendo desarrollos software libre) lo que les hace transparentes. En CeFi, la lógica depende de aplicaciones que son ejecutadas en el servidor del servicio, mientras que en DeFi, esta lógica depende de los smarts contracts y la red Blockchain sobre la que se ejecutan dichos smart contracts.
3. **Gobernanza.**  
    En este punto es donde se produce una separación de poderes del servicio. En CeFi, la gobernanza es ejercida por sus directivos, un grupo muy reducido de personas, todas ellas con intereses en mantener el mismo. Pero **en DeFi, la gobernanza se extiende no solo a los creadores sino también a los usuarios del sistema.** Por ejemplo, en CeFi las decisiones sobre el funcionamiento del mismo depende de sus inversores, pero en DeFi, esas decisiones se toman en general por consenso de todos los participantes interesados en formar parte de la gobernanza del protocolo, dejando que cada participante tenga poder de voto para decidir.

####  DeFi vs CeFi: Usos
Tanto las DeFi como las CeFi pueden aplicarse a cualquier tipo de servicio financiero tradicional y relacionado con criptomonedas, como comercio al contado, comercio de derivados, préstamos y más.

**Las conversiones entre criptomonedas y monedas fíat también están disponibles en ambos ecosistemas. Además, las dos plataformas, CeFi y DeFi, pueden brindar servicios entre cadenas, aunque los mecanismos varían.**

En general, las dos tendencias tienen usos similares, pero el enfoque es muy distinto. Un aspecto específico para DeFi es la tokenización de activos. Por ejemplo, Synthetix aloja un ecosistema DeFi donde los usuarios pueden crear los llamados activos sintéticos, que son tokens ERC-20 que representan activos en el mundo real. Los usuarios pueden eventualmente liquidar esos activos sintéticos y comerciarlos en un exchange dedicado. Los activos sintéticos tienen un gran potencial, capaz de hacer el comercio de derivados más flexible, accesible y transparente.


###  232.B4_Futuro_del_DeFi-video

###  El futuro del DeFi
![[232.B4_Futuro_del_DeFi.mp4]]
[Futuro del DeFi](https://app.web3mba.io?wvideo=2xvmh40ctu)

En esta sección vamos a hablar un poco sobre el futuro, pero realmente no deberías hacerme demasiado caso. DeFi se mueve a una velocidad vertiginosa y lo que voy a comentar ahora son cosas que estamos observando y el posible futuro que veremos en los próximos meses y años. Sin embargo, realmente nadie vio venir lo que se convirtió en DeFi. Nadie esperaba sistemas como SushiSwap, por ejemplo. ¿Quién iba a pensar que se crearía una bolsa descentralizada que sería especialmente épica en dimensiones y cuya estética sería la del sushi? Nadie podía imaginar esto. Lo mismo ocurre con PancakeSwap; ¿quién iba a imaginar un pancake como la imagen de una bolsa? Por lo tanto, no sabemos hacia dónde va a evolucionar esto, ni hacia dónde nos llevará DeFi. El futuro es algo que la comunidad de personas de cualquier parte del planeta va a crear. Lo que funcione, se seguirá haciendo, y lo que no, se dejará de hacer. Pero, bueno, hablemos un poco de lo que podría ser el futuro.

Las finanzas descentralizadas se han transformado en una de las grandes innovaciones de la industria blockchain y de las empresas que forman parte de este ecosistema. Esta tecnología no solo plantea una alternativa a las instituciones financieras tradicionales, sino que también revoluciona toda la industria financiera, habilitando servicios que de otra manera no serían posibles. Esta evolución es especialmente visible en redes como Ethereum, Polygon, Avalanche, Solana e incluso en las segundas capas de estos servicios. En todos ellos, la evolución ha sido enorme. De hecho, en DeFi Llama, por ejemplo, podemos ver en este gráfico cómo ha sido el crecimiento en TBL, que significa Total Value Locked, es decir, la cantidad de dinero depositada en estos sistemas.

Recordemos un momento los sistemas de lending descentralizado. Estos sistemas, que funcionan como bancos cripto, permiten que las personas depositen dinero, y gran parte de este dinero se almacena allí. Otro lugar donde se deposita mucho dinero es en las pools que crean los mercados, esos mercados descentralizados que mencionaba antes, en los cuales hay dos activos: un dólar digital, normalmente, y un token que puede ser Ethereum o cualquier otro. Bien, pues ese TBL, como vemos en el gráfico, fue de 253.000 millones de dólares en noviembre de 2021, y la tendencia ha sido claramente alcista. De hecho, observamos que desde 2019 a 2021, la línea es prácticamente vertical.

Podemos ver de cerca la evolución de los distintos proyectos DeFi observando en esta otra gráfica los 10 proyectos más grandes del ecosistema y su participación en el mismo. La mayoría de ellos son proyectos que son parcialmente descentralizados y que han formado parte de este ecosistema desde 2017, algunos también desde 2019. En estos 10, podemos ver lo que hoy se encuentra entre los principales proyectos dentro de DeFi. Estos datos, tanto el TBL como los principales proyectos, nos dejan claro otro punto: DeFi era una serie de plataformas separadas, pero a medida que la interoperabilidad entre cadenas se va manifestando, y esos bloques de Lego se van conectando, lo que encontramos es que las diferentes plataformas DeFi se han ido integrando.

En esta nueva era, la estrategia del yield farming agregado y cross-chain, es decir, entre diferentes cadenas, ha sido fundamental, permitiendo que los ecosistemas interactúen financieramente, trasladando valor entre unas cadenas y otras e incrementando su potencial de crecimiento. Hablemos del auge de las DeFi 2.0. La llegada de las DeFi 2.0 revolucionó rápidamente la industria a lo largo de 2021. Esta versión mejorada del concepto DeFi actual ha abordado las principales debilidades existentes, al tiempo que aprovecha sus fortalezas para presentar a los usuarios nuevas y emocionantes alternativas en el camino hacia la tan ansiada independencia financiera.

A diferencia de la versión anterior de DApps o aplicaciones descentralizadas, que estaba orientada a los usuarios, DeFi 2.0 está más dirigida a un enfoque B2B, Business to Business. Los protocolos DeFi 2.0 aprovechan el hecho de que la primera generación de DApps impulsó con éxito a la industria al crear una base de usuarios inicial y proporcionan un feedback de valor incalculable que los futuros desarrolladores pueden utilizar para construir la próxima ola de DApps, con el objetivo de asegurar la supervivencia a largo plazo del sector. Es en este punto cuando las DeFi comenzaron a desarrollar mecanismos de gobernanza avanzados, comercio delegado y listados en CoinGecko y CoinMarketCap. Estas plataformas no solo han impulsado el mundo hacia DeFi 2.0, sino que también han marcado el camino para la revolución DeFi 3.0.

Hablemos un momento de DeFi 3.0. Actualmente, este modelo de DeFi, esta nueva versión, representa la próxima evolución de DeFi que está en construcción. En este punto, DeFi busca convertirse en un espacio de servicios. Básicamente, busca que el concepto de DeFi transforme su ecosistema en un servicio. Por ejemplo, el Farming as a Service. La idea es transformar a las DeFi en un servicio accesible y personalizable a las necesidades de sus usuarios. Esto significa que el usuario no tiene que encontrar el protocolo y participar directamente, sino que habrá un servicio que le permita hacer esto con las garantías que ofrece un tercero.

A través de su enfoque DeFi 3.0, varios proyectos están creando las bases para el éxito de todo el ecosistema. Su intención es establecer un ecosistema que revolucione los sistemas financieros tradicionales, manteniendo el objetivo inicial de las DeFi. Con la ayuda de los contratos inteligentes, se busca permitir que los usuarios tengan un control absoluto sobre los servicios financieros, con la seguridad que brindan esas terceras partes, y también se permitirá el comercio en el ámbito de las finanzas descentralizadas. En resumen, se están simplificando las inversiones estratégicas al agregar las recompensas a los titulares de tokens a través de recompras y otros mecanismos financieros. Su objetivo final sería otorgar al titular del token los derechos de propiedad y el control sobre todas las decisiones de inversión relacionadas con el proyecto en cuestión.

La idea sería lo que hemos estado hablando sobre la evolución hacia DeFi 2.0, pero esta vez ofrecida por un tercero que simplifica toda la operativa. Por si, como decía al principio, no eres una persona que se sienta cómoda trabajando con este tipo de ecosistemas descentralizados. Así que, en definitiva, tú decidirás si te diriges directamente a lo que pueden ser estas DeFi 3.0, que esperamos que sean la nueva evolución de DeFi, donde un tercero simplifica el proceso por ti, o si te sientes más aventurero y prefieres explorar DeFi 2.0, donde tendrás que involucrarte más y probar los sistemas por ti mismo.

Mi recomendación aquí sería, bueno, la de ir directamente a DeFi 2.0, probar un poco, dedicar algo de tiempo y, sí, posiblemente un poco de dinero, pero muy poco, simplemente para ver cómo funciona y así adquirir ese conocimiento de primera mano. Pero si ves que todo esto te supera, podemos esperar a ver qué nos traen las DeFi 3.0. Sin embargo, como he mencionado antes, no sabemos si las DeFi 3.0 acabarán siendo así. El futuro ya se verá.


###  233.U6.3_DeFi_-_Futuro

###  El Futuro del DeFi
Las finanzas descentralizadas (DeFi) se han transformado en una de las grandes innovaciones de la industria Blockchain y las empresas que forman parte dentro del mismo. 

Esta tecnología no solo plantea una alternativa a las instituciones financieras tradicionales, sino también revolucionar toda la industria financiera habilitando servicios que de otra manera no podrían ser posibles.

Esta evolución es especialmente visible en redes como Ethereum, Polygon, Avalanche y Solana, donde la evolución de las DeFi ha sido enorme. De hecho, en DeFiLlama podemos seguir muy de cerca esa evolución, detectando que, en noviembre de 2021, el mercado tuvo un TVL de 253 mil millones de dólares, y la gráfica muestra el crecimiento enorme que ha tenido el sector desde el año 2019.

![[233.B4_crecimiento.png]]

De hecho, podemos ver muy de cerca la evolución de los distintos proyectos DeFi, teniendo que los 10 proyectos más grandes del ecosistema y su participación en el mismo. La mayoría de ellos son proyectos DeFi totalmente descentralizados y que han estado formando parte del ecosistema desde 2017, siendo algunos del 2019, durante el boom DeFi. 

![[233.B4_boom.png]]

**Estos datos nos dejan claro otro punto: DeFi en un principio era una serie de plataformas separadas, pero a medida que la interoperabilidad entre cadenas (gracias a los _bridges cross-chain_) fue aumentando, las plataformas DeFi se fueron integrando.** En esta nueva era, la estrategia del Yield Farming agregado y Cross-Chain fue fundamental, permitiendo que los ecosistemas pudieran interactuar financieramente trasladando valor entre las cadenas e incrementando su potencial de crecimiento. Este es el inicio de las DeFi 2.0

####  El auge de las DeFi 2.0
La llegada de las DeFi 2.0 ha conquistado rápidamente las industrias.

Esta versión mejorada del concepto DeFi actual ha abordado las principales debilidades existentes al tiempo que aprovecha las fortalezas para presentar a los usuarios alternativas nuevas y emocionantes en el camino hacia la independencia financiera.

**A diferencia de la versión anterior de dApps, que estaba orientada a los usuarios, DeFi 2.0 está más orientada a un enfoque B2B (_Business-to-Business_).**

Los protocolos DeFi 2.0 aprovechan el hecho de que la primera generación de dApps impulsó con éxito la industria al crear una base de usuarios inicial y proporcionar primitivas críticas de DeFi que los futuros fabricantes ahora pueden utilizar para construir la próxima ola de dApps. Y el objetivo de esto es asegurar la supervivencia a largo plazo del sector.

Es durante este punto, cuando las DeFi comenzaron a desarrollar mecanismos de gobernanza avanzados, comercio delegado y listados de CG y CMC, la plataforma no solo ha impulsado el mundo DeFi 2.0, sino que también ha marcado el camino para la revolución DeFi 3.0.

####  DeFi 3.0: El nuevo futuro de las DeFi
Las DeFi 3.0 son la próxima evolución de las DeFi en construcción. 

En este punto, DeFi busca convertirse en un espacio de servicios. 

Básicamente, busca el concepto de DeFi transforme su ecosistema en un Servicio (por ejemplo: Farming-as-a-Services / FaaS). La idea es transformar a las DeFi en un servicio accesible y personalizable a las necesidades de sus usuarios.

**A través de su enfoque DeFi 3.0, el proyecto está creando las bases para el éxito de todo el ecosistema. La intención del proyecto es establecer completamente un ecosistema para interrumpir los sistemas financieros tradicionales.** Con la ayuda de los contratos inteligentes, el proyecto quiere permitir que los usuarios tengan un control absoluto sobre la funcionalidad principal y el comercio en el ámbito de DeFi.

En resumen, están simplificando las inversiones estratégicas al agregar las recompensas a los titulares de sus tokens a través de recompras y reflejos. Su objetivo final sería otorgar al titular de la ficha los derechos de propiedad y el control sobre todas las decisiones de inversión relacionadas con el proyecto.


###  234.B4_Metamask-video

###  Metamask
![[234.B4_Metamask.mp4]]
[Metamask](https://app.web3mba.io?wvideo=f53d91fctk)

Metamask es el puente que permite a los usuarios interactuar con Web3. Web3 abarca todas estas aplicaciones descentralizadas que forman parte de las redes blockchain. Metamask es un tipo de wallet HD, es decir, "hierarchical deterministic". Este tipo de wallets permite al usuario generar varios tipos de wallets, distintas e ilimitadas, y acceder a ellas a través de una única contraseña. Esta contraseña es una cadena de caracteres alfanuméricos que resulta ilegible para el ser humano. Para facilitar su uso, se emplean códigos mnemotécnicos, que transforman esta cadena de caracteres en palabras que sí son legibles. Comúnmente, se conoce a Metamask como una wallet, pero en realidad es un llavero.

Para entenderlo mejor, imagina un llavero que tenemos con las llaves de casa, por ejemplo, donde tendríamos la llave del patio, la llave de la puerta principal o incluso la llave del garaje. Todas estas llaves, que representan las wallets, están unidas por una anilla, que es lo que las convierte en un llavero. Y eso es, en esencia, Metamask: un llavero de cuentas que puedes generar dentro de la aplicación. Esta aplicación está disponible en formato de extensión para navegadores, inicialmente en Chrome y más tarde en Firefox, Opera, Brave y Edge. El desarrollo de Metamask estuvo a cargo de dos desarrolladores, Aaron Davis y Dan Finlay, quienes sentaron las primeras bases del proyecto en 2016. La idea detrás de Metamask era sencilla y revolucionaria: permitir a los usuarios utilizar su navegador web para interactuar de manera fácil, rápida y segura con sus dApps.

Para ello, Metamask utiliza la interfaz y API web de Ethereum, web3.js. Esta librería oficial de Ethereum es fundamental para las posibilidades que ofrece Metamask. Gracias a ella, se puede crear un proxy o puente de comunicación entre las dApps, Metamask y los usuarios. El trabajo resultó ser un gran reto técnico, especialmente en lo que respecta a mantener la seguridad necesaria para sus usuarios. Sin embargo, Metamask logró su objetivo y el 14 de julio de 2016 se presentó su primera versión. En ese momento, la extensión estuvo disponible para el navegador Chrome y sus derivados. Posteriormente, se lanzó la versión para Firefox, permitiendo el uso de la extensión en ese navegador. Desde entonces, Metamask se ha convertido en la forma más fácil de acceder a las dApps a través de una interfaz amigable, sin necesidad de configurar nada.

¿Cómo funciona Metamask? Su funcionamiento se basa en el uso de Web3.js, una librería que forma parte del desarrollo oficial de Ethereum. Web3.js fue creada para permitir la creación de aplicaciones web que puedan interactuar con la blockchain de Ethereum. Gracias a esta librería, páginas web y extensiones pueden aprovechar el poder de Ethereum y sus características. Técnicamente, lo que hace Metamask una vez que lo tienes instalado como extensión en el navegador es inyectar un código en cada página web que visitas. Este código actúa como una sonda que pregunta: "¿Hay alguien que me entienda? ¿Hay alguien que sepa quién soy?".

Cuando accedes a una web que es una dApp, esta ya está interactuando con el smart contract que actúa como servidor de la aplicación. En ese momento, la web responde a la sonda lanzada por Metamask y le dice: "Sí, yo te entiendo, vamos a interactuar". Así se establece la conexión entre la web a la que has accedido y la wallet de Metamask, permitiéndote utilizar la aplicación, ya sea para enviar transacciones o realizar otras interacciones que tenga el smart contract. Como mencionamos antes, las wallets HD son una de las aplicaciones más accesibles en el mundo. Además de permitir la conexión a la web, también facilitan el acceso a través de dispositivos móviles.

Es importante destacar que esta cadena alfanumérica se transforma en palabras legibles mediante códigos mnemotécnicos, y estos códigos son la clave para desencriptar el almacenamiento de información que contiene todas las wallets que hayas creado. A menudo, en foros de internet, hay usuarios que cambian de una wallet a otra en diferentes ordenadores o después de haber eliminado la extensión. Al recuperar su cuenta de Metamask con su passphrase, que es esta cadena de palabras legibles, descubren que tienen todos sus fondos disponibles. Esto genera la confusión de que, si han transferido los fondos, estaban teóricamente en su ordenador y ahora están disponibles en otro, lo que sugiere que se han sincronizado con algún servidor externo.

Sin embargo, esto no es cierto. Cuando un usuario cambia de wallet de un navegador a otro o a otro ordenador, la passphrase que utiliza para recuperar la cuenta es todo el almacenamiento de información que contiene todas las wallets, es decir, el llavero mencionado anteriormente. Una vez que introduces esa passphrase, que es el contenido del llavero, se te pedirá la clave para desencriptar esa passphrase. Por eso, siempre tendrás todos los datos localmente y podrás moverlos de un dispositivo a otro sin necesidad de que estén sincronizados con un servidor centralizado.

Metamask se puede utilizar principalmente para dos tipos de operaciones: transacciones de Ethereum entre dos wallets y las interacciones con los smart contracts o dApps, que son la parte visible de esos smart contracts. Cuando accedes a Metamask para realizar una transacción de wallet a wallet, como en el primer caso, Metamask tiene por defecto sus proveedores seleccionados, que son Infura y Etherscan. Estos son los nodos con los que se conectará Metamask para realizar las transacciones que intentas hacer desde la extensión. Al mismo tiempo, en la segunda opción, cuando interactúas con una web y esta envía órdenes a la extensión de Metamask para que firmes esas transacciones, si la web no tiene preferencias de nodos, Metamask utilizará sus proveedores por defecto. Sin embargo, la web puede sobrescribir esos proveedores por defecto redirigiendo las operaciones que firmes desde tu wallet hacia otros nodos, otras redes de nodos, entre los que también se encuentran Infura y Etherscan, que son los más utilizados, además de otras redes.


###  235.U7.1_Metamask

###  Metamask
MetaMask es una extensión o plugin para navegadores web que permite a los usuarios interactuar fácilmente con las dApps de la Blockchain de Ethereum.

Esto es posible, porque MetaMask hace de puente entre las dApps y los navegadores web facilitando el uso y disfrute de las mismas.

Gracias a esto, los usuarios son capaces de utilizar de forma sencilla dichas aplicaciones distribuidas y todo de forma integrada desde su navegador favorito. Con soporte para Firefox, Chrome, Opera y Brave, MetaMask ha acercado el mundo de las dApps al público en general.

El desarrollo de MetaMask estuvo a cargo de dos desarrolladores, Aaron Davis y Dan Finlay. Fueron ellos quienes sentaron las primeras bases del desarrollo de MetaMask en el año 2016. **La idea detrás del proyecto era sencilla y revolucionaria. MetaMask permitiría a los usuarios usar su navegador web para interactuar fácilmente con sus dApps favoritas, de forma rápida y segura.**

Para ello, MetaMask usaría la interfaz y API web de Ethereum, web3.js. Esta librería oficial de Ethereum sería la base fundamental del mundo de posibilidades ofrecidas por MetaMask. Gracias a ella sería posible crear un proxy o puente comunicacional entre las dApps, MetaMask y los usuarios.

![[235.B4_puente.png]]  

**El trabajo resultó ser todo un reto técnico, en especial por el tema de mantener la seguridad necesaria para sus usuarios. Sin embargo, MetaMask logró su cometido y el 14 de julio de 2016 se presentó su primera versión.** En este punto, la extensión estuvo disponible para el navegador Chrome y derivados. Más tarde se presentaría su versión para Firefox, permitiendo el uso de dicha extensión en ese navegador.

Desde entonces MetaMask se ha transformado en la forma más fácil de acceder a las dApps a través de una interfaz fácil de usar. Todo ello sin necesidad de configurar absolutamente nada.

####  ¿Cómo funciona MetaMask?
El funcionamiento de MetaMask es gracias al uso de web3.js, una librería que forma parte del desarrollo oficial de Ethereum. web3.js fue creada con el fin de permitir la creación de aplicaciones web que pudieran interactuar con la Blockchain de Ethereum.

Gracias a ella, páginas web y extensiones pueden aprovechar el poder de Ethereum y sus características.

**En tal sentido, MetaMask fue creada para ser un monedero del tipo HD para Ethereum y una herramienta para interactuar con dApps.** Para lograr ambos cometidos, MetaMask establece un canal de comunicaciones entre la extensión y la dApp en cuestión. Una vez que la aplicación reconoce que MetaMask está presente, se habilita y puede ser utilizada por el usuario.

> Habilitada la dApp, el usuario puede realizar todas y cada una de las acciones o eventos que permite la misma. Desde la compra o venta de tokens, hasta el acceso a recursos o cualquier servicio que preste la misma. 

Todas y cada una de estas acciones tiene un costo, uno que debe ser cancelado en Ethereum o en el token indicado para el mismo. En cualquiera de los casos, MetaMask cuenta con las herramientas necesarias para manejar dicha interacción.

**Es decir, MetaMask no solo genera un monedero de criptomonedas, sino que controla cada interacción del usuario con la dApp, y realiza las operaciones necesarias para que dichas operaciones se lleven a cabo.** Todo ello se lleva a cabo en un medio de comunicación seguro y con el uso de criptografía fuerte. MetaMask posee la capacidad de generar sus propias claves asimétricas, guardarlas localmente y gestionar su acceso. Incluso, MetaMask tiene la capacidad de usar nodos de Ethereum (del tipo Geth, por ejemplo) personales para garantizar mayor seguridad y privacidad en el uso, incluso es posible usar monedero hardware wallets para garantizar una mayor seguridad a nuestros fondos en dicho monedero. 

![[235.B3_web3js.png]]

####  ¿Cómo instalar MetaMask?
La instalación de MetaMask no implica mayores dificultades. Al ser una extensión para navegadores popular y probada, la misma se encuentra disponible en la tienda o repositorio de extensiones.

**Basta con acceder a la tienda de tu navegador y descargarla para usarla en tu navegador web de preferencia.**

En el caso de Chrome, podrás encontrarla aquí. En caso de que tengas un navegador derivado de Chrome como Opera, Brave o Vivaldi, dicha extensión funcionará perfectamente. Si en su lugar, utilizas Firefox, la extensión podrás encontrarla en este enlace. También puedes acceder a la extensión desde el sitio web oficial de MetaMask. Esta detectará tu navegador y te dirigirá al enlace correcto para la instalación de la extensión

En este caso, te advertimos de que tengas mucho cuidado con las extensiones que instales en tu navegador. Recuerda que existen muchos casos de suplantación de identidad (phishing) entre las extensiones por lo que se debe verificar muy bien lo que se instala. Para ello lo mejor es usar los medios oficiales y atender a las actualizaciones ofrecidas por la propia plataforma. Estas comprobaciones le permitirán disfrutar al máximo de tu experiencia con MetaMask.

####  Ventajas y desventajas de MetaMask
#####  Ventajas
1. **Creada con la librería web3.js lo que garantiza que podrás usar todo el poder de Ethereum.**
2. **Completamente software libre,** por lo que puede auditar su código y disfrutar de actualizaciones y parches de seguridad muy rápidamente.
3. **Capacidad de almacenar claves privadas** de forma local asegurando al máximo tus activos criptográficos.
4. **Permite la creación de monederos por medio de HD.** Esto ayuda a que los usuarios puedan realizar copias de seguridad de sus cuentas a través de las semillas.
5. **Permite el uso de varias cuentas y redes Ethereum** gracias a la creación de perfiles de uso.
6. Tiene un modo privado que **ofrece un alto nivel de seguridad** a los datos de sus cuentas, gracias al uso del EIP 1102.
7. **Permite mantener cualquier token ERC-20 en el mismo monedero.** De hecho, permite almacenar varios tokens ERC-20 al mismo tiempo.
8. **Tiene un alto nivel de integración con sitios** como Coinbase, ShapeShift o MyEherWallet para poder recargar el monedero de MetaMask.
9. **Permite el uso de nodos Ethereum remotos o locales**, permitiendo un alto nivel de seguridad en ambos casos.
10. Ofrece a nuestro navegador la capacidad de **interactuar con la mayoría de DApps.**
11. **Cuenta con protecciones internas** que bloquean casos de phishing u otros vectores de ataques que pongan en peligro sus fondos.

#####  Desventajas
1. **El hecho de que sea una extensión para navegadores significa que estos pueden rastrear toda la actividad de MetaMask.** Este es un caso especialmente cierto para Chrome, pues Google realiza una fuerte minería de datos de todos los usuarios de su navegador.
2. Pese a todas las protecciones de MetaMask, esta sigue siendo un monedero online con todas sus desventajas. **Una vulnerabilidad en la extensión o el navegador puede poner en peligro todos sus fondos.**
3. **MetaMask está limitado solo a interactuar con los Smart Contracts y Dapps que señalan.** No puede hacer mucho más como, por ejemplo, rehacer o escribir un nuevo Smart Contract.
4. **El hecho de depender de redes externas para su funcionamiento, agrega un punto de fallo en el esquema de seguridad.** La extensión puede ser segura, pero si los nodos no solo son, esto puede significar la pérdida o robo de información y fondos de los usuarios.


###  236.U7.2_Metamask-Instalación

###  Instalación y configuración inicial de MetaMask
Se trata de una extensión para navegadores popular y probada. La misma se encuentra disponible en la tienda o repositorio de extensiones. 

De esta forma, basta con acceder a la tienda de tu navegador y descargarla para usarla en tu navegador web de preferencia.

En el caso de Chrome, podrás encontrarla aquí. En caso de que tengas un navegador derivado de Chrome como Opera, Brave o Vivaldi, dicha extensión funcionará perfectamente. Si en su lugar, utilizas Firefox, la extensión podrás encontrarla en este enlace. También puedes acceder a la extensión desde el sitio web oficial de MetaMask. Esta detectará tu navegador y te dirigirá al enlace correcto para la instalación de la extensión

En todo caso, ten mucho cuidado con las extensiones que instales en tu navegador. Recuerda que existen muchos casos de suplantación de identidad (phishing) entre las extensiones por lo que se debe verificar muy bien lo que se instala. Para ello lo mejor es usar los medios oficiales y atender a las actualizaciones ofrecidas por la propia plataforma. Estas comprobaciones le permitirán disfrutar al máximo de tu experiencia con MetaMask.

####  Proceso detallado de instalación y configuración
Dependiendo del navegador que utilices (Chrome, Edge o Firefox) es muy probable que con el paso anterior hayas instalado la extensión de MetaMask en el mismo. 

Ahora bien, aquí te guiaremos paso a paso en el proceso para que tengas tu MetaMask funcional al 100%. Este tutorial lo realizaremos sobre Firefox, pero es exactamente igual para el resto de navegadores.

#####  01| Comenzar con el setup del monedero
Realizada la instalación del monedero MetaMask verás una pantalla de bienvenida en la que debes hacer clic en “Empezar”.

![[236.B4_comenzar.png]]

#####  02|Crear un monedero
El siguiente paso te dará dos opciones:
1. **Importar un monedero:** En este caso, MetaMask te pedirá que uses Seed Phrase (o clave de respaldo) para recuperar un viejo monedero MetaMask que hayas tenido en posesión. Este proceso te restaura ese monedero y debes tener la Seed Phrase y la clave de ese monedero a la mano.
2. **Crear un monedero:** Para crear un nuevo monedero desde 0. Para este ejemplo elegiremos este paso.

![[236.B4_crear.png]]

#####  03|Aceptar las condiciones de uso de Metamask
En este punto MetaMask te hace saber que recolectan algunos datos que le son útiles para mejorar su monedero. Igualmente, te hacen saber que esos datos son anónimos y que no serán utilizados para rastrear tu actividad y mucho menos venderlos a terceros. En este punto, tienes la opción de “No aceptar” o “Aceptar”, en ambos casos, podrás configurar el monedero sin problemas.

  

#####  04|Crear la contraseña del monedero
Comienza lo realmente importante en la creación de nuestro monedero. Esta clave es la que permitirá que puedas desbloquear el monedero para su uso y de igual forma, es usada como entropía a la hora de crear el monedero. Todo esto significa que esta clave deber ser muy segura, por lo que te recomendamos usar claves alfanuméricas (con números y letras), con símbolos, mayúsculas y minúsculas, y con una extensión que no puede ser menor de 8 caracteres.

Un buen ejemplo de una clave con este tipo de opciones sería:
#*L45!Crypt0!50n!L1b3rt4d*#

En este caso hemos usado todas las opciones anteriores junto con una técnica de mnemotecnia para tener siempre presente nuestra clave segura en todo momento.

![[236.-B4_contraseña.png]]

#####  05|Respaldar la Seed Phrase
Creada nuestra contraseña, MetaMask comienza a generar nuestra Seed Phrase la cual debemos copiar de forma muy cuidadosa en un papel o cualquier medio seguro. Recuerda en todo caso lo siguiente:

La Seed Phrase y la contraseña del monedero son tu dinero, si las pierdes no podrás recuperarla, así que asegúrate de guardarlas en un lugar muy seguro.

![[236.B4_frase.png]]

Esta Seed Phrase deberás copiarla y luego MetaMask te pedirá que la confirmes para saber que ha sido copiada de forma correcta. Al confirmar la Seed Phrase entonces ya tendrás configurada tu MetaMask y podrás usarla sin inconvenientes con los ETH o tokens que desees.

Respaldando la seed con ello terminaría la configuración del monedero MetaMask.

![[236.b4_finalizacion.png]]


###  237.U7.3_Metamask-Tips_de_seguridad

###  Tips de Seguridad para MetaMask
La seguridad del monedero es lo más importante para mantener tus criptomonedas seguras. Si eres un usuario de MetaMask, estos son algunos Tips para mantener la seguridad:
1. **Usa una clave segura para tu monedero,** no dejes el mismo sin esta, con el fin de que puedas garantizar que solo pueda ser accedido usando la clave correcta. 
2. **Usa el monedero MetaMask en un navegador distinto al navegador de uso diario.** Es decir, usa un navegador Web distinto para navegar y otro navegador para usarlo con las dApps y usar el monedero. 
3. **Si eres un usuario Windows o GNU/Linux, mantén tu monedero en una cuenta local distinta a la cuenta que normalmente usarías para las tareas diarias.** Este punto te ayudará a separar el acceso al monedero, de ser posible en una cuenta sin permisos administrativos y protegida con clave segura. Esto evitará que alguien pueda acceder a la cuenta y al monedero. 
4. **Si tienes un monedero hardware, usa el mismo para que controle clave privada de tu monedero MetaMask.** Esta medida de seguridad hará que puedas usar el monedero MetaMask como un monedero de visualización, pero si quieres realizar operaciones deberás usar el monedero hardware para la firma correspondiente.
5. **MetaMask es un monedero no-custodio y puedes configurar su acceso a la red usando tus propios nodos en lugar de los nodos de Infura/ConsenSys.** Si usas tus propios nodos, podrás usar MetaMask sin temor a que se te vete el acceso a la red Ethereum, y adicional, mantendrás tu acceso de forma más privada (ConsenSys/Infura mantienen un registro completo de todas tus operaciones).
6. **No olvides respaldar de forma segura tu seed phrase,** mantener el acceso a la misma asegura que puedas recuperar tu cuenta y el saldo en ella en cualquier momento. 
7. **Mantén el monedero limpio de “Sitios Conectados”.** Cada vez que MetaMask se conecta a una dApp, se genera una cierta apertura de permisos en el monedero, una práctica recomendable en este punto es, borrar esos permisos una vez termines de usar la dApp, así evitarás que cualquier actividad maliciosa pueda usar esos permisos para acceder al monedero.
8. **Mantén tu navegador libre de cookies o cualquier información temporal,** para ello, borra los temporales de tu navegador en cada sesión. 
9. **Agrega y usa los marcadores del navegador para ir directamente a los sitios de interés,** esto en lugar de acceder por los buscadores o enlaces que estén en sitios de terceros.


###  238.B4_Iniciación_a_Metamask-video

###  Iniciación a Metamask
![[238.B4_Iniciación_a_Metamask.mp4]]
[Iniciacion a Metamask](https://app.web3mba.io?wvideo=y38ekvssmy)

Uno de los monederos más útiles dentro del mundo cripto es, sin duda, MetaMask. MetaMask es un monedero que puede ser utilizado dentro de la red de Ethereum y redes compatibles con la Ethereum Virtual Machine. En este caso, es fácil instalarlo en cualquier sistema, ya que es una aplicación web; es decir, podemos instalarla en nuestros navegadores sin mayores inconvenientes. A continuación, haremos un ejemplo de cómo instalarlo en el navegador web Firefox.

La dirección de la página oficial de MetaMask es metamask.io. Desde aquí podemos descargar nuestra wallet MetaMask a través de un botón que nos lleva directamente a la página de addons o plugins de Firefox. Simplemente agregamos la extensión y esperamos un momento a que se complete la descarga para poder empezar a utilizar este monedero.

Ahora que tenemos instalada la extensión en nuestro navegador, comenzamos con el proceso de configuración. Simplemente debemos hacer clic en "Empezar" y seguir con el proceso. Lo primero que debemos elegir es si ya tenemos una frase secreta de recuperación o si vamos a establecer una nueva configuración. En este caso, vamos a crear una nueva cartera porque comenzaremos el proceso desde cero. Sin embargo, si ya tienes o has tenido una cartera MetaMask creada, puedes utilizar el proceso de importación para recuperar el contenido de esa antigua wallet. En este caso, comenzaremos una nueva.

Aquí debemos aceptar y configurar una clave segura. Una vez establecida la clave, simplemente debemos aceptar los términos de uso y comenzar con la creación de nuestra wallet. Lo siguiente es copiar la frase secreta de recuperación, o lo que sería lo mismo, la seed phrase, que consiste en las siguientes palabras. Una vez confirmada, simplemente hacemos clic y ya tenemos nuestra MetaMask creada. Automáticamente, MetaMask nos permite conectarnos a la red principal de Ethereum, lo que significa que podemos utilizar y enviar Ethereum o cualquier tipo de token compatible con esta red.

Sin embargo, también tenemos la opción de utilizarla con las redes de prueba de Ethereum, como Ropsten, Kovan, Rinkeby o un nodo interno que sería, en este caso, localhost:8545. Anteriormente, mencionamos que MetaMask es compatible con cualquier red que tenga retrocompatibilidad con la Ethereum Virtual Machine. Esto significa que podemos utilizar MetaMask con redes como Polygon, Binance Smart Chain o cualquier otra red que sea compatible con la EVM.

¿Cómo podemos agregar estas redes fácilmente a MetaMask y controlarlas todas desde este monedero? Para eso, hay una web muy conocida llamada Chainlist que nos permite añadir este tipo de redes adicionales a nuestro monedero MetaMask. Estamos en Chainlist y vamos a conectar nuestro monedero para empezar a agregar las redes disponibles. Conectamos nuestro monedero y rápidamente podemos ver la solicitud de conexión. Al conectar, automáticamente tenemos la opción de agregar las redes disponibles en Chainlist.

Fíjense que la primera red que aparece es Ethereum Mainnet, seguida de Binance Smart Chain, Avalanche, Polygon, Cronos, Phantom, Arbitrum y Optimism. Todas estas redes son compatibles con la EVM y, por lo tanto, pueden ser utilizadas directamente con MetaMask. Para agregar una de estas redes, en este caso, vamos a agregar la red Polygon. Simplemente debemos ir a Polygon y seleccionar "Agregar a MetaMask". Rápidamente se nos presenta la siguiente interfaz que nos indica que la red que vamos a agregar se llama Polygon Mainnet. La dirección URL de la red que nos permitirá conectar nuestro monedero con la red Polygon es PolygonRPC.com, y el identificador de la cadena es el número 137. Si hacemos clic en "Agregar red", automáticamente podemos ver que tenemos Polygon Mainnet agregado a nuestra wallet MetaMask.

Si estamos en Polygon, podemos ir a lo que se llama Polygon Bridge y rápidamente conectarlo a nuestra MetaMask, permitiéndonos interactuar con la misma, ya que estamos utilizando la red Polygon dentro de nuestro navegador. Chainlist, en este caso, es simplemente una recopilación de diferentes redes y puntos de conexión que nos permiten utilizar nuestra MetaMask con las diversas redes disponibles. Por ejemplo, podemos conectar Optimism, que es una L2 muy utilizada dentro de Ethereum. Simplemente lo agregamos y aquí están todos los datos para conectarnos a la red Optimism, que es bastante interesante dentro del ecosistema.

Si queremos agregar otras redes, simplemente debemos buscarlas en el listado de Chainlist y agregarlas a nuestro funcionamiento dentro de MetaMask. Como pueden ver, MetaMask es bastante potente y tiene sus pros y contras. En primer lugar, debemos tener mucho cuidado con las redes que estamos agregando a MetaMask, ya que recordemos que esto tiene acceso completo a nuestro monedero. Es decir, debemos ser cautelosos con las diferentes aplicaciones y webs que utilizamos para asegurarnos de que la red que estamos utilizando es la correcta y que el servicio es confiable, evitando así que nuestro monedero sea hackeado.

Chainlist, por ejemplo, es una aplicación muy conocida y su dirección es chainlist.org, facilitándonos el acceso a las diferentes redes. Sin embargo, siempre deben verificar dos veces las direcciones y asegurarse de que las aplicaciones descentralizadas sean lo suficientemente confiables para realizar este tipo de interacciones sin problemas.

Agregar direcciones o redes adicionales a MetaMask utilizando Chainlist también se puede hacer de forma manual. Simplemente debemos ir a configuración y, en la sección de redes, podemos agregar las redes que deseemos utilizando todos los datos manualmente. Si quieren conectarse a una red específica compatible con MetaMask, simplemente deben buscar los datos en las páginas web de los proyectos y agregarlos tal como aparecen aquí, para que puedan interactuar con estas redes sin inconvenientes. Esto hace que MetaMask sea un monedero muy potente y completamente adaptable a las necesidades del usuario.

Otra situación importante es hacer los respaldos correspondientes a las configuraciones, o más precisamente, a la frase de recuperación. Si no han copiado correctamente la clave de recuperación en el proceso inicial de configuración de MetaMask, pueden ir a la sección de seguridad y privacidad y hacer clic allí. Simplemente ingresan su clave y automáticamente podrán ver la frase secreta o seed de este monedero para que puedan recuperarlo. Esto es importante porque más adelante realizaremos un proceso de reconfiguración de nuestra MetaMask junto a un software de desarrollo llamado Ganache, que utilizaremos para hacer una configuración especial dentro de nuestro nodo Ganache y utilizarlo como monedero para interacciones con las DApps que estemos aplicando o desarrollando.

Como pueden ver, es bastante sencillo manejar este tipo de monederos, así que espero que les haya gustado este vídeo y que repliquen lo aprendido en sus hogares.


###  239-0.B4_Servicios_Sociales_Descentralizados-video

###  Servicios Sociales Descentralizados
![[239.B4_Servicios_Sociales_Descentralizados.mp4]]
[Servcios Sociales Descentralizados](https://app.web3mba.io?wvideo=suj5w682gp)

Los NFT y el metaverso son los temas en auge en el ecosistema de las criptomonedas en este momento, pero es posible que el próximo gran auge sean las redes sociales descentralizadas. Esto se debe a que existe un considerable número de usuarios que sienten una desconfianza total hacia las redes sociales tradicionales, debido al excesivo control y, sobre todo, a la manipulación de la información. Además, empresas como Facebook, Twitter y LinkedIn, entre otras, ingresan enormes sumas de dinero utilizando los datos de los usuarios, como tú y como yo, como moneda de cambio para obtener rentabilidad. Gracias a la blockchain, la solución a este problema ya es una realidad y pasa por el desarrollo de redes sociales descentralizadas. Estas redes son libres y de código completamente abierto, lo que garantiza que cualquier persona pueda tener acceso a ellas en cualquier lugar del mundo. Asimismo, evita que cualquier entidad o empresa pueda utilizar o manipular la red y los datos a su favor, y, por supuesto, previene algo tan importante como la censura del contenido.

El funcionamiento de las redes sociales descentralizadas se basa en un sistema llamado Peer-to-Peer, es decir, un sistema de persona a persona, en el que cada nodo forma parte de una red y se puede acceder a ella de forma completamente autónoma. Además, este software puede ser construido de forma comunitaria entre todos los miembros de la comunidad y es completamente de libre acceso. Por tanto, las reglas y el funcionamiento de la red serían totalmente transparentes para todos los usuarios. Estamos en pleno proceso de evolución de la Web 2 hacia la Web 3.0, que es una web inteligente capaz de interpretar e interconectar una mayor cantidad de estratos de forma descentralizada y, lo más importante, sin intermediarios.

Te contaré una historia que ocurrió el año pasado. Julian York, un activista de la libertad de expresión, fue expulsado temporalmente de Facebook por compartir imágenes parcialmente desnudas en Twitter. Las fotos eran parte de una campaña alemana de concientización sobre el cáncer de mama en la que se veían claramente los pechos de una mujer. Facebook marcó la publicación como una violación de sus normas comunitarias, que prohíben estrictamente la publicación de la mayoría de estos tipos de desnudos en esa plataforma. Aunque la suspensión duró solo 24 horas, tuvo un gran impacto en el desarrollo del trabajo de York. ¿Y esto por qué? Simplemente porque, sin acceso a Facebook, York no pudo completar su trabajo ni publicar comentarios en otros sitios de noticias que utilizaban la herramienta de comentarios de Facebook para participar. Sin las credenciales de Facebook, York no podía acceder a otras aplicaciones en las que se utilizaba Facebook como método de inicio de sesión. Entonces, está claro que las redes sociales descentralizadas son una evolución directa hacia la libertad, hacia el control propio de tu contenido y de tus datos, y hacia una monetización independiente que nos llevará a la liberación de las finanzas descentralizadas.

Por un lado, su gobernanza sería abierta y todos podrían participar en la misma. Por otro lado, las acciones que involucren a personas externas a la plataforma serían muy difíciles de realizar. Para esto, la opción de detenerlo y hacer frente quedaría totalmente en manos de la comunidad. En una red descentralizada, el elemento negativo, es decir, la persona que crea ese ataque, sería completamente minimizado, porque la comunidad votaría para disminuir o negar la participación de esa organización o individuo. Dicho esto, podemos definir a las redes sociales descentralizadas como aquellas que operan en servidores o nodos que se ejecutan de forma completamente independiente. Esto quiere decir que estas redes sociales no están en manos de ninguna empresa, sino que sus usuarios son quienes toman las decisiones sobre su funcionamiento, actualizaciones y la forma de operar de estas redes.

Su principal característica es el uso de la blockchain y los sistemas de contratos inteligentes, conocidos como smart contracts. Estas plataformas descentralizadas se caracterizan por los siguientes elementos clave, y es importante que los tengas muy en cuenta porque utilizan la tecnología blockchain. La principal característica de la tecnología blockchain es la transparencia. Gracias a la red de datos abiertos, cualquier persona en la red puede ver los datos casi en tiempo real. De alguna manera, la blockchain devuelve la confianza en la privacidad a las redes sociales gracias a su naturaleza criptográfica. Por otra parte, la posibilidad de que haya un robo de datos es prácticamente cero. El control estaría, por tanto, en manos de los usuarios. A diferencia de las plataformas tradicionales, las redes sociales descentralizadas fomentan la independencia sin una autoridad central. La propiedad sobre los datos personales, el control sobre el contenido o la censura recaen solo sobre el usuario. Esto significa que ningún individuo o empresa puede dictar las reglas a otros usuarios o grupos de usuarios. Además, protege la privacidad y aumenta la seguridad.

Las preocupaciones de los usuarios sobre el control de sus datos personales han llevado al establecimiento del Reglamento General de Protección de Datos en la Unión Europea. Sin embargo, esta legislación considera a las empresas de redes sociales como procesadoras de datos, por lo que todavía mantienen el control sobre absolutamente todos nuestros datos. En estas redes sociales descentralizadas, los usuarios pueden crear cuentas sin tener que vincularse a ninguna identidad, como un correo electrónico o un número de teléfono. Esto no es necesario para tener un perfil en las redes sociales descentralizadas. Además, suelen basarse en la criptografía de clave pública para la seguridad de las cuentas, lo cual es fundamental, ya que utilizaríamos una clave encriptada en lugar de depender de una sola organización central que proteja tu clave o todos tus datos. Esto fomenta la libertad de expresión y la resistencia a la censura.

En las redes sociales tradicionales, las entidades son las que establecen las reglas de participación de todos los usuarios. En cambio, en las redes descentralizadas, las reglas las define el propio usuario o, en algunos casos, la comunidad. Es decir, ninguna autoridad puede modificar o eliminar el contenido creado por los usuarios, ni puede hacer nada que no esté autorizado por el usuario en sí. Esta característica ha generado mucho debate. Por un lado, están quienes piensan que prohibir los mensajes violentos en las redes sociales ayuda a proteger a los usuarios, mientras que otros consideran que la prohibición va en contra de los ideales de la libertad de expresión. Los usuarios pueden bloquear a estas personas, grupos o contenidos, pero no pueden evitar que participen en las diferentes redes. Así que vaticino que aún queda mucho por debatir en este sentido.

Por otro lado, tenemos la neutralidad económica, que significa fundamentalmente que los usuarios cambian a las redes sociales descentralizadas porque buscan liberarse de todo lo que implica la publicidad invasiva. En las redes sociales descentralizadas, además, buscamos nuevas formas de monetización. Queremos generar ingresos a través de nuestro contenido para mantener redes solventes. Por ejemplo, pagando con criptomonedas, los usuarios pueden crear, curar o consumir contenido en estas diferentes redes sociales descentralizadas. De esta manera, se incentiva a los creadores a centrarse en la calidad y a los usuarios a interactuar en la plataforma con estos contenidos.

Uno de los ejemplos claros de estos cambios en redes sociales es OneClick. OneClick es una red social que ha ido evolucionando con el tiempo, aunque tiene una vida muy corta desde su nacimiento. Actualmente se definen como el Amazon de los NFT. Esta plataforma permite crear y comprar cualquier tipo de NFT. Además, es bastante intuitiva y muy similar al Marketplace de OpenSea. No es una red social en sí, pero es importante que la conozcas. Es un proyecto de red social descentralizada que presenta una cadena de bloques especializada en alojar aplicaciones de redes sociales descentralizadas. Esto significa que cualquier persona o desarrollador puede crear una red social y alojarla en esta red. Además, es importante que sepas de su existencia porque es una red vertical, es decir, única y exclusivamente creada para desarrollar redes sociales. Esta red ofrece formas novedosas para que los creadores de contenido generen flujos de ingresos y también puedan interactuar con su audiencia.

Otra plataforma es Meme. En Meme se pueden publicar videos, blogs, imágenes, establecer estados y enviar mensajes, chatear por video de forma segura, en grupos o directamente con amigos. Es una red bastante versátil y avanzada. En esta plataforma se utiliza un sistema de recompensa con tokens, que permite a todos los usuarios ganar y gastar esos tokens. Esto se utiliza para impulsar las publicaciones, obtener una cuenta de usuario premium que cuesta unos cinco tokens al mes y acceder a infinidad de funcionalidades dentro de la plataforma.

Por otro lado, tenemos la red Pixify. Pixify es una alternativa a Instagram. En ella puedes controlar tus datos y tu privacidad, permitiendo que los usuarios vean solo las imágenes que tú deseas que vean. Todo esto se logra sin ver ningún tipo de anuncio. Obtiene los mismos conceptos básicos de la plataforma de compartir fotos, pero no tiene un algoritmo que impulse una línea de tiempo. Es decir, en el feed solo verás las publicaciones en orden cronológico, sin recopilar información de la experiencia de usuario personalizada dentro de la plataforma.

No es un secreto que las plataformas de blogging y noticias centralizadas están censuradas constantemente por instituciones y empresas, lo que coacciona la libertad de expresión y censura el contenido digital. Contar con plataformas descentralizadas permite una información colaborativa, sin censura y respetando la autoría del contenido publicado. Otra red social es Mastodon. Mastodon es una plataforma gratuita de código abierto que funciona como una especie de microblogging, muy similar a Twitter. De hecho, el día que Elon Musk anunció que quería comprar Twitter, se unieron a esta plataforma más de 30,000 nuevos usuarios. Parece increíble, ¿verdad? Una persona que se une a Mastodon se incorpora a una instancia específica que puede interoperar con otras instancias, permitiendo que los usuarios interactúen en diferentes nodos.

Mirror es otra plataforma de escritura descentralizada, diseñada para ayudar a los creadores a conectarse con un público objetivo de manera directa e innovadora. Esa es una de las principales atracciones de las redes sociales descentralizadas. Además, en ella es fácil convertir todos los artículos que se publican en NFTs. DLive es una plataforma de transmisión de video en directo que empodera a creadores y espectadores a través de un revolucionario sistema de recompensas. Aquí, los streamers pueden quedarse con el 80% de los ingresos de las suscripciones, mientras que los espectadores también reciben tokens por ver e interactuar con ese contenido. En general, DLive intenta ser única en ofrecer diferentes formas para que las personas sean recompensadas. Tanto los espectadores como los creadores de contenido tienen la oportunidad de ganar.

Sin lugar a dudas, estamos en el momento perfecto para comenzar a utilizar todas estas plataformas, monetizar tu contenido y proteger todos tus datos. ¿Cuál será la plataforma que destaque por encima del resto? Eso aún está por descubrir. Así que, pruébalas todas y elige cuál te gusta más.


###  239-1.B4_Redes_Sociales_Centralizadas

###  La desconfianza en las Redes Sociales Centralizadas
Uno de los mayores problemas de nuestra sociedad actual la podemos ver en las redes sociales centralizadas como Facebook, Instagram, TikTok, Twitter y Snapchat.

Las redes sociales centralizadas rastrean, almacenan y venden nuestros datos para obtener ganancias, y al mismo tiempo, crear perfiles completos de nuestra actividad en Internet para bombardearnos de publicidad y seguir rastreándonos.

Aunque una distopía de ciencia-ficción, es la realidad que nos toca vivir todo el tiempo que nos conectamos a estas redes sociales y, de seguir así, el problema solo seguirá aumentando.

Las grandes compañías de Internet se han hecho con los primeros puestos de las empresas más valoradas del mundo gracias a la venta de datos. Una vez que agregas tu correo y contraseña y empiezas a hacer uso de dichos servicios, todos tus datos quedan en sus manos para venderlos. Incluso bajo la RGPD, las empresas buscan cualquier resquicio posible para sacar datos y darles uso comercial a los datos. Básicamente, las redes sociales “si algo es gratis, entonces el producto eres tú”, se ha desvelado con más relevancia últimamente.

> Cuando un usuario publica información en las redes sociales, es consciente de que se está dirigiendo al mundo, pero, al mismo tiempo, debe saber que también lo está haciendo al conjunto de corporaciones que le están escuchando y toman sus datos para usarlos para sus propios intereses.

Por ejemplo: 
- Twitter durante este 2021 ha generado un total de 571,8 millones de dólares procedentes de licencias de datos. 
- Esto es el 11% de todos los ingresos que la empresa tuvo durante 2021. 
- De hecho, los ingresos por la venta de datos no solo se han incrementado, sino que, al mismo tiempo, han impulsado de forma sustancial su negocio de publicidad, el cual depende de esta venta de datos. 
- Un negocio win-win para la empresa, pero loss-loss para sus usuarios que ven invadida su privacidad a niveles nunca vistos.

Twitter es, en este punto, la punta del Iceberg en comparación con los gigantes de Meta, Facebook e Instagram. **Tras el escándalo de Cambridge Analytica, sabemos que Facebook no solo vende datos, sino que dichos datos se usan activamente para manipular la opinión pública, convirtiendo este negocio en un arma de manipulación social.** 

El alcance es enorme porque en las redes sociales de Meta hay más de 2,5 mil millones de usuarios y, eso es, más de un cuarto de la población mundial actual (estimada en 8 mil millones para 2021). 

En este contexto, las redes sociales se han visto rodeadas de un halo de desconfianza que hace que la opinión pública se aboque y les ataque. Por un lado, las fake news se sirven a la orden del día en ella, por el otro la creciente polarización, se unen a algoritmos que incentivan la polémica y las luchas internas dentro de la red, junto con censura selectiva, dejan claro un punto: las redes sociales centralizadas no son confiables, porque el poder que tienen es tal, que pueden transformar a sociedades enteras en simples peones. 

  ![[239.B4_centralizadas.png]]


###  239-2.B4_Redes_sociales_Descentralizadas

###  Redes Sociales Descentralizadas
Frente a la creciente desconfianza de las redes sociales centralizadas, la solución a ese problema pasa por la construcción de redes sociales descentralizadas, libres y de código abierto.

Estos tres puntos garantizarían que cualquiera pudiera tener acceso, que nadie podría usar y manipular la red a su favor y, por supuesto, evitaría la censura. 

1. Estas redes funcionarían bajo el concepto de redes Peer-To-Peer (P2P). 
2. Cada nodo forma parte de la red y puede acceder a ella de forma totalmente autónoma. 
3. Su software sería una construcción comunitaria y de libre acceso
4. Las reglas y funcionamiento de la red serían transparentes para todos.

**Esto no es una utopía, es una realidad que incluso se ha podido ver hasta cierto punto en medios centralizados, pero que están construidos por grandes comunidades, con reglas y desarrollos libres.** Por ejemplo, el mayor servidor IRC del mundo del software libre era el conocido Freenode, un lugar donde grandes proyectos de software libre tenían un lugar para reunirse y conversar, de forma libre y comunitaria. IRC es un servicio híbrido, es decir, depende de servidores para comunicar a las partes, pero una vez conectados, las partes pueden establecer comunicación P2P off-the-record. 

> Los servidores de Freenode eran ampliamente conocidos y usados, hasta que su administración (en manos de Andrew Lee, CEO del VPN PIA y Freenode) traicionó los principios que regían el ecosistema y comenzó con una serie masiva de despidos y dropping de privilegios en el servidor. 

La comunidad reaccionó rápidamente con renuncias y abandonos masivos, construyendo la red Libera Chat, lo que ha convertido a Freenode en una sombra y una mancha en la comunidad. Si, IRC es un servicio centralizado, pero la existencia de reglas claras, una comunidad respetuosa de las mismas y un software libre disponible para todos, daban la seguridad necesaria para que cualquiera pudiera expresar sus ideas en dicha comunidad, y si alguien buscaba imponer su posición por sobre todos los demás, este tipo de cosas son las que terminan sucediendo. 

**Frente a esto, las redes sociales descentralizadas son una evolución directa y la respuesta apropiada. Por un lado, su gobernanza sería abierta y todos pueden participar en la misma, por la otra, eventos en los que una persona intente a la fuerza tomar el poder serían muy difícil de realizar, y de hacerlo, la opción de detenerlo y hacer frente a dicho elemento queda en manos de la misma comunidad atacada.** Esto evitaría que una red conocida simplemente tenga que “abandonarse y autodestruirse”, porque un elemento busca controlarla. En una red descentralizada, sería el elemento negativo el que terminaría minimizado, porque la comunidad votaría por minimizar su participación e incluso negar su participación, si dado el caso, muestra total irrespeto por las reglas de la comunidad. 

Podemos definir a las redes sociales descentralizadas de la siguiente manera:
- Son aquellas que operan en servidores que se ejecutan de forma independiente. 
- Son redes sociales que no están en manos de ninguna empresa, sino que son sus usuarios los que toman las decisiones.
- Su principal característica es el uso de Blockchain y de sistemas de contratos inteligentes. De esta manera, los usuarios tienen más control y autonomía. 
- El usuario puede configurar su red social y determinar cómo funciona y qué pueden decir los usuarios.  
 
![[239.B4_descentralizadas.png]]

####  ¿Cómo funcionan?
Las redes sociales descentralizadas se caracterizan por los siguientes elementos claves:

#####  Tecnología Blockchain
La principal característica del Blockchain es la transparencia. 

Gracias a la red de datos abierta, cualquier persona en una red puede ver los datos casi en tiempo real.  De alguna manera, el Blockchain devuelve la confianza en la privacidad de las redes sociales gracias a su naturaleza criptográfica. Por otra parte, la probabilidad de que haya un robo de datos es casi cero.

#####  Control en manos del usuario
A diferencia de las plataformas tradicionales, las redes sociales descentralizadas fomentan la independencia sin una autoridad central.  

La propiedad sobre los datos personales, el control sobre el contenido o la censura, recae en el usuario. Es decir, ningún individuo o empresa puede dictar las reglas de otros usuarios o grupos. 

#####  La privacidad y seguridad
Las preocupaciones de los usuarios sobre el control de sus datos personales han llevado al establecimiento del Reglamento General de Protección de Datos (RGPD) en Europa. 

Sin embargo, esta legislación considera a las empresas de redes sociales como las “procesadoras de datos” por lo que todavía siguen teniendo control sobre los datos.

En las redes sociales descentralizadas, los usuarios pueden crear cuentas sin tener que vincularse con identidades, como una dirección de correo electrónico o un número de teléfono. 

Además, las redes sociales descentralizadas suelen basarse en la criptografía de clave pública para la seguridad de la cuenta, en lugar de depender de una sola organización para proteger los datos de los usuarios.

#####  Libertad de expresión y resistencia a la censura
En las redes sociales tradicionales, las entidades son las que establecen las reglas de participación de los usuarios. En cambio, en las descentralizadas, las reglas las pone el propio usuario.

Es decir, ninguna autoridad puede modificar o eliminar el contenido creado por los usuarios.

Esta característica ha creado mucho debate. Por una parte, están los que piensan que prohibir los mensajes violentos ayuda a proteger a los usuarios de las redes sociales, mientras otros consideran que las prohibiciones van en contra de los ideales de la libertad de expresión. Si bien los usuarios pueden bloquear estos grupos, no pueden evitar que participen en la red.

#####  Neutralidad Económica
La neutralidad económica es esencial para muchos que recurren a las redes sociales descentralizadas, quienes buscan liberarse de la publicidad invasiva.

Las redes descentralizadas buscan nuevas formas de monetización para mantenerse solventes. Por ejemplo, pagando con criptomonedas a sus usuarios por crear o curar contenido. De esta manera, se incentiva a los creadores de contenido a centrarse en la calidad.


###  239-3.B4_Redes sociales descentralizadas - Proyectos

###  Proyectos de redes sociales descentralizadas
Alguno de los proyectos de redes sociales descentralizadas más importantes que existen en la actualidad son:

####  Lbry
LBRY es uno de los protocolos más desarrollados dentro del ecosistema de las redes sociales descentralizadas y su objetivo es sencillo: Ser un espacio para la publicación de contenido audiovisual seguro y libre de censura. 

LBRY es un protocolo construido sobre Blockchain, que busca crear una enorme red de nodos descentralizados con los que puedes interactuar libremente. Como resultado, tienes una red llena de creadores de contenido que suben sus vídeos y mantienen el funcionamiento de la red en todo momento, porque nadie tiene el control del contenido ni del ancho de banda que está disponible para su funcionamiento. 

LBRY se puede dividir en dos partes: 
1. **Una Blockchain** para mantener a sus nodos unidos y debidamente monetizados. 
2. **Un sistema de almacenamiento y distribución de contenido** para que todos puedan subir y descargar aquel contenido que sea de su interés.

La monetización es posible por el token nativo LBC (LBRT Credits), el cual es usado para subir contenido y mantener el mismo dentro de la red por el tiempo que desees, porque al final, todo el contenido siempre está bajo tu absoluto control. 

Acceder a ese contenido es posible gracias a un protocolo P2P muy parecido a IPFS, ya que usa la tecnología DHT (que es usada en IPFS y BitTorrent) y un derivado del protocolo Kademlia. Es este sistema el que permite almacenar los datos de forma descentralizada y acceder a ellos cuando se desee. Como resultado, LBRY tiene en su haber una gran cantidad de datos, cuenta con un protocolo propio (conocido como LBRY Protocol – lbry://) y una comunidad que va creciendo rápidamente. 

Otras opciones como LBRY son PeakD y Dtube, cuyas tecnologías son bastante parecida y tienen un mismo fin: permitirnos el acceso a streaming de calidad desde cualquier parte del mundo, sin censura y respetando nuestra privacidad. 

####  Hive
Hive es una Blockchain nacida de la controversia dentro de la comunidad Steemit. 

Después de que Justin Sun, CEO de TRON, tomó el control de la startup Steem, parte de la comunidad alrededor de esa red decidió separarse e iniciar la red Hive. 

Desde entonces, Hive ha sido una red rápida, escalable y robusta para construir redes sociales Web 3.0. Su principal servicio en este sentido es Hive Blog, un espacio de microblogging donde tienes la libertad de crear contenido y monetizarlo por medio de visitas, lecturas y tips que recibas de la comunidad. Todo ello es mantenido por la criptomoneda nativa, el token Hive el cual es esencial para la economía de todos los servicios que la red Hive presta y mantiene accesibles para todos. 

####  Aether
Aether es una red social del tipo P2P que busca construir comunidades y espacios muy parecidas a Reddit.

Por medio de su potente aplicación, Aether te permite acceder a un universo de publicaciones que están relacionadas con tus intereses y selección personal de contenido, poniéndote en contacto con estos espacios para que puedas participar y retroalimentar a los mismos.


###  240.B4_Internxt-video

###  Internxt
![[240.B4_Internxt.mp4]]
[Internxt](https://app.web3mba.io?wvideo=v7y1qwi2x9)

Internext es una empresa de almacenamiento en la nube que busca garantizar la seguridad y la privacidad que las grandes tecnológicas no logran ofrecer. Se trata de una startup impulsada por Wira, la aceleradora de Telefónica; Angels, la sociedad de inversión de Juan Roch; la escuela de negocios SADE de The Venture City; y el antiguo director de tecnología de Coinbase. Aunque actualmente cuentan con más de 300,000 usuarios activos, desde Internext se distancian del mercado masivo, enfocándose únicamente en el usuario que prioriza ante todo la privacidad. Sus productos estrella son DRIVE y WIRE, y próximamente lanzarán SEND, un servicio de envío de archivos mediante enlaces de caducidad programable e independiente de nuestro alojamiento personal. Entre sus planes futuros también se encuentra ofrecer una VPN y un servidor de correo electrónico dentro de un abanico de funcionalidades de suscripción única, siempre con la defensa de la confidencialidad de nuestros datos como bandera.

Básicamente, en Internext detectamos un problema: el internet que conocemos estaba monopolizado por gigantes tecnológicos cuyo fin era extraer datos del usuario, siendo este último el producto. Así, decidí crear una especie de internet alternativo, centrado en el usuario y en proteger su privacidad. Es decir, que al usar internet no tengas que venderte al mal diablo, sino que puedas acceder a servicios alternativos a los que ofrecen Google, Facebook, Microsoft, Amazon y otros, sin perder tu derecho a la privacidad y sin tener que compartir tus documentos o correos privados con terceros, evitando que puedan ser hackeados. Para ello, hemos desarrollado servicios alternativos a los que existían en ese momento, como una alternativa a Google Drive, que es nuestro Internet Drive, y una alternativa a Google Fotos, que es Internetx Fotos. También lanzaremos una alternativa a WeTransfer, que será Internet Exchange. La idea es crear un conjunto de servicios similares a G Suite, ya que el internet se compone de una serie de servicios. Cuando usas internet, ¿qué utilizas? O Google o Facebook. Nuestra propuesta son alternativas a estos servicios, enfocadas en la privacidad.

En términos prácticos, la diferencia es clara: Google, Apple y otras grandes empresas son más susceptibles a ser hackeadas. Por ejemplo, iCloud fue hackeado hace unos años, y fotos de Jennifer Lawrence y otras actrices se filtraron por internet. La idea es evitar que eso suceda, y en Internext nuestro enfoque está en que no ocurra. En esencia, un cloud no es más que servidores ubicados fuera de donde tú estás. Si quiero acceder a una página web o a un archivo que no está en mi móvil, me conecto a un servidor que está en otra ubicación, y este me envía la información que deseo ver. Al final, el cloud son servidores en alguna parte que te envían información. Hasta ahora, lo que sucedía es que Google, Amazon y otras grandes empresas operan centros de datos, como Dropbox, donde almacenan información. Esto es relativamente fácil de hackear porque es centralizado. Además, estas empresas tienen la clave de desencriptación de tus archivos, lo que las convierte en un blanco claro para ataques.

Un cloud descentralizado comparte el concepto de cloud, pero la diferencia es que, en lugar de almacenar un archivo en el centro de datos de Dropbox, donde ellos tienen la clave de desencriptación, en Internext los archivos se encriptan, no guardamos la clave de desencriptación y se fragmentan. Lo que hacemos es distribuir esos fragmentos alrededor del mundo en diferentes servidores. Si un atacante intenta hackear uno de tus archivos, como una foto personal, le sería prácticamente imposible, ya que al atacar un servidor solo encontraría fragmentos encriptados de archivos que no sirven para nada. Esta es la idea: la descentralización aplicada a nuestro caso de uso garantiza un mayor nivel de privacidad y seguridad. Por parte de la empresa, en el caso de Internext, no podemos acceder a esa información porque, además de estar distribuida, no tenemos la clave de desencriptación.

Es importante que la gente sepa que si quiere hacer algo en el mundo blockchain y descentralizado, habrá muchos obstáculos técnicos que no tendría si desarrollara un juego en un servidor convencional. Al principio, permitíamos que cualquier persona almacenara archivos, pero el problema que encontramos fue que era muy lento. Si cualquiera podía almacenar archivos, había personas con conexiones Wi-Fi lentas o que apagaban sus ordenadores, lo que requería mantener muchas copias de los ficheros. La ventaja de la descentralización, que es más económica porque utiliza espacio no ocupado por centros de datos, se perdía porque había que mantener muchas réplicas de los archivos. Así, nos encontramos en un momento en el que era más caro, más lento y menos fiable, ya que a veces perdíamos archivos si se apagaban varios ordenadores. Aunque intentamos evitarlo con un sistema de matrices similar al que utilizan los DVDs, que permite seguir escuchando música aunque el disco esté rayado.

A nivel de limitaciones, enfrentamos problemas de velocidad, fiabilidad y costes. Para solucionarlo, adoptamos un enfoque similar al de Bitcoin y Ethereum. Aunque Bitcoin es descentralizado, la realidad es que no conozco a ningún particular que esté minando Bitcoin en su ordenador. En nuestra infraestructura descentralizada, cada vez más profesionales almacenan datos, personas que realmente quieren dedicarse a esto y que se comprometen a pagar por sus servidores y mantener una conexión a internet adecuada para solventar estos problemas. Lo principal es que en el equipo fundador de la startup, si vas a hacer un proyecto tecnológico, especialmente en la industria blockchain, es fundamental contar con personas capacitadas que puedan llevar a cabo el proyecto. El tiempo de desarrollo, como mencionabas, será seguramente largo si deseas crear algo tecnológico, lo que implica muchos costes. Por lo tanto, deberás contratar a gente en algún momento. Si puedes evitar contratar desde el principio, aumentarás la probabilidad de sobrevivir, ya que tendrás menos costes a corto plazo, especialmente al inicio, cuando no cuentas con muchos fondos.

Internext se desarrolló de esta manera. Yo soy el fundador, pero me formé en programación, blockchain y negocios. Comencé por mi cuenta, pero después de unos años empezamos a contratar. Fueron varios años de desarrollo desde que surgió la idea de Internext en mi último año de carrera, entre 2017 y 2018, hasta que realmente lanzamos el producto al mercado en 2020-2021. Nuestro primer producto, DRIVE, lleva en el mercado poco más de un año y medio. Al principio, muy poca gente creía que realmente podríamos hacerlo. Era una idea ambiciosa, y yo era muy joven, recién graduado. El primer MVP, considerando todos los obstáculos técnicos que enfrentamos, era bastante lento; a veces, al intentar descargar un archivo, no funcionaba y tenías que volver a intentarlo. La experiencia de usuario también necesitaba mejoras, y aunque era ilusionante, había mucho trabajo por hacer. Hemos estado trabajando durante años para desarrollar un proyecto serio. Diría que el Internext que conocemos hoy comenzó a desarrollarse en 2020-2021, cuando logramos tener un MVP razonable y empezamos a escalar y profesionalizarlo, creando nuevos productos.

Cuando comenzamos Internext, el contexto era diferente. Hubo muchos problemas con Ethereum, que se volvió muy caro y relativamente lento en comparación con otras blockchains. Nuestro modelo es un poco híbrido: tenemos nuestra propia infraestructura y también nos apoyamos en la red de Ethereum, tanto para la infraestructura como para los pagos. Contratar a un desarrollador de blockchain o integrarlo en tu equipo fundador es lo mejor. O, si prefieres, puedes aprender Solidity, el lenguaje de programación utilizado en la red de Ethereum, o aprender otro lenguaje según lo que desees hacer. Go también está muy de moda ahora. En el espacio blockchain, estamos viendo que muchas personas han detectado la oportunidad de hacer dinero, lo que ha generado mucho humo. Muchos intentan aplicar blockchain a cosas que no tienen sentido, buscando cómo inventar una criptomoneda para enriquecerse rápidamente. Creo que la reflexión debe ser al revés: primero, identifica un problema real que deseas solucionar, como en mi caso, la privacidad, y luego busca las tecnologías adecuadas. En nuestro caso, no solo utilizamos blockchain; empleamos una variedad de lenguajes de programación y herramientas para resolver el problema.

Lo que estamos viendo ahora es que muchas soluciones se están aplicando a problemas que no existen en el ecosistema. Creo que, al final, solo quedarán unos pocos proyectos que realmente tengan un negocio sostenible detrás. No se puede mantener el hype indefinidamente; es necesario contar con un negocio real que genere ingresos y que ofrezca soluciones a problemas reales. En el ecosistema de Web3 y más allá, fuera del hype de términos como Web3 y Metaverso, lo que realmente quedará son proyectos que solucionen problemas reales y cuenten con un buen equipo detrás. Estoy convencido de que el 99% de lo que existe ahora, al igual que ocurrió en 2018, desaparecerá, y espero que esta vez no regrese.

Actualmente, estamos ayudando a 300,000 personas a resolver problemas de privacidad. La idea es alcanzar un millón de usuarios este año y, a partir de ahí, llegar a tres o cuatro millones el año siguiente. Nuestro objetivo es seguir mejorando la parte de DRIVE, especialmente en el sector B2B y Enterprise. Este producto es muy interesante en sectores como la salud y la educación, donde es crucial proteger datos de pacientes o de niños en escuelas. También es relevante para el sector institucional, para prevenir problemas como el espionaje. En definitiva, es un producto muy atractivo en el ámbito B2B Enterprise, donde vamos a centrar gran parte de nuestros esfuerzos el próximo año, y ya estamos comenzando a hacerlo este año. Además, continuaremos creando ese G Suite, no solo con DRIVE, FOTOS y SEND, sino también desarrollando nuevos servicios.


###  241.B4_Trazable-video

###  Trazable
![[241.B4_Trazable.mp4]]
[Trazable](https://app.web3mba.io?wvideo=7l0evnyvbo)

Trazable es una empresa que implementa la tecnología blockchain con el propósito de ofrecer garantías de seguridad, transparencia y confianza a la industria alimentaria. Desde el inicio del proyecto, tienen claro que la digitalización ha llegado para quedarse. Su modelo de negocio y su propuesta de valor se centran en formar parte de esta transformación, dotando a los departamentos de calidad de las empresas de las herramientas digitales necesarias para trazar la cadena de producción, distribución y compra de los alimentos. En marzo, lanzaron su propio token, el cual integra la cadena de bloques como una solución eficiente para analizar y automatizar la logística en el suministro. Su adaptabilidad al modelo tradicional ha supuesto la modernización y el acercamiento de esta nueva tecnología tanto a clientes como a inversores.

Trazable es un software de gestión de calidad que nace con la idea de lograr que las empresas de la industria alimentaria tengan trazabilidad desde el campo hasta la mesa, algo que antes no tenían, ya que solo contaban con información sobre su proceso productivo. Al conocer las necesidades de estas empresas, nos damos cuenta de que requieren una etapa previa: digitalizar sus procesos actuales. Muchos de ellos aún utilizan papel, lo que genera ineficiencias que pueden impactar en la seguridad alimentaria y en la confianza del consumidor. Por ello, hemos desarrollado una solución que les ayuda a digitalizarse, a tener un mayor control de la calidad y de la seguridad alimentaria, y, lo más importante, a conectarse con el resto de actores de la cadena y certificar toda esa información en blockchain para que el consumidor final pueda participar en la historia de los productos. En términos simples, se trata de la capacidad que tiene una empresa de saber de dónde provienen las materias primas o los componentes que utiliza en su producto, y a dónde envía ese producto. Esto es clave en la industria en general, porque cuando surge un problema, es fundamental saber qué ha ocurrido y ser capaz de rastrear, como se conoce en la industria, desde aguas abajo a aguas arriba, o viceversa, para identificar el problema y su impacto.

El primer inconveniente es la ineficiencia que genera tener toda la información en papel y archivada en carpetas. Cuando se necesita realizar ejercicios de trazabilidad, se pierde mucho tiempo, o a veces, el operario que debía registrar la información no está presente y se pierde ese papel. Esto puede parecer sencillo, pero en una empresa que produce grandes cantidades de alimentos, con lotes y lotes de productos, es fácil olvidar detalles. Tener un entorno digital es el primer desafío que hemos identificado. El siguiente reto es que, si se desea tener un control total de la trazabilidad, es necesario compartir información, lo cual a menudo es complicado en la industria. ¿Quién gestionará los datos? ¿Puedo entrar en conflictos de intereses con proveedores o clientes? Además, estamos hablando de cadenas que son globales, donde hay empresas que no se conocen entre sí. Entonces, ¿cómo se gestionará esa confianza o esa información? Este es otro problema importante.

Como puedes imaginar, comenzamos con una idea: lograr que las empresas tengan trazabilidad desde el campo hasta la mesa, y eso había que validarlo con las empresas. Fue un proceso largo de diálogo con empresas alimentarias y directores de calidad. En 2018, coincidimos con Embutidos Martínez, que vio sentido en nuestra propuesta. Recordamos con cariño ese primer caso de éxito, ya que fue un choque entre la idea que teníamos y la realidad. Pensábamos que todo iba a estar digitalizado y que sería sencillo conectar blockchain y trazabilidad, pero nos encontramos con directores de calidad y operarios que tenían dificultades incluso para manejar un Excel. Aprendimos que era necesario un paso previo, y aunque logramos sacar adelante ese caso de éxito, nos dio una lección sobre dónde estábamos.

Creo que la labor de Trazable a corto plazo es evangelizar, estar presentes y hablar sobre la importancia de la digitalización y los sistemas de gestión de calidad, que muchas empresas aún no tienen. Utilizan Excel, correos electrónicos, se comunican con los proveedores por teléfono y tienen sistemas ERP y de laboratorio, pero no cuentan con un software específico para calidad. Existen, pero no se utilizan. Esta labor de evangelización es algo que nos corresponde, junto con todas las ventajas que esto conlleva. Afortunadamente, la administración está tomando medidas y apoyándonos, ya que los principales distribuidores también están impulsando esta digitalización. Comienzan a exigirla porque ven que es un valor que los clientes demandan cada vez más. Estamos en un momento de cambio, y observamos que es una tendencia importante a nivel de mercancía.

A priori, lo que hemos explicado puede parecer complicado. Decir que hay que integrarse y trabajar con el equipo de IT puede asustar, pero es todo lo contrario. El proceso de hacer entender y romper esas barreras mentales sobre por qué hay que cambiar la forma de hacer las cosas es más largo que el proceso de incorporación. Al final, el proceso es registrarse. Una vez que aceptas y ves el valor de la herramienta, te registras, obtienes tu usuario y contraseña, y accedes a un SaaS que funciona en línea y está en la nube, como HubSpot o Salesforce, pero es una herramienta de calidad. Desde allí, puedes conectarte con el ERP o utilizar módulos como la gestión de incidencias, el gestor documental y todos los controles que debe realizar la empresa, como no conformidades y limpieza. Puedes hacerlo de manera sencilla, creando registros o carpetas del gestor documental con solo unos clics y comenzando a usarlo en tu día a día.

Desde Trazable, estamos siempre disponibles y contamos con un equipo de producto que te ayuda a entender la herramienta. También tenemos un Help Center en línea donde puedes acceder a tutoriales de cada etapa. El proceso de uso es muy sencillo. Cambia la percepción de la empresa sobre el retorno que pueden obtener en términos de tiempo, ahorro de costes o incluso incremento de ventas al utilizarlo. En la actualidad, estamos en una etapa anterior a la ingesta automática de datos, que se relaciona más con los sistemas MES que cubren la producción o el ERP. En nuestro caso, abarcamos todos los controles operativos de producción, limpieza y puntos críticos. La realidad es que el 90% de los clientes con los que trabajamos utilizan hojas impresas donde los operarios registran la fecha, la hora o un valor de la máquina. Ese Excel luego se archiva, o un técnico de calidad introduce selectivamente esos datos en un Excel para tener información y poder hacer predicciones. Nosotros transformamos eso en una tablet, donde ya se introducen los valores y se realiza un análisis, evitando problemas e inconsistencias, y generando estadísticas automáticas en ese momento. Lo más importante es que tienes tu información digital, que puede ser explotable y conectarse con el resto de eslabones de la cadena, hacia el consumidor, que es quien tiene el poder de compra.

Hasta ahora, no estábamos prestando atención al consumidor. La empresa podía ofrecer información, pero hoy en día, ¿qué quiere el consumidor? Ya no solo le importa si el producto es más barato o más caro, sino que lo más importante es el sabor. En el ámbito alimentario, esto es fundamental. Luego, la calidad y la seguridad alimentaria son prioritarias, seguidas del precio y el origen, que cada vez cobra más relevancia. La sostenibilidad también está ganando fuerza como un tema importante. La gente quiere saber más y alinearse con el propósito de las empresas, pero hasta ahora no contaba con un canal de comunicación. Independientemente de sus esfuerzos por buscar y obtener esos datos, no había un canal donde pudiera ver la información y conocer la historia de ese producto. Por ello, decidimos conectar esos puntos que teníamos.

Una de las soluciones que vimos con sentido fue trabajar en el espacio de blockchain a través del token. Esto cubría nuestra necesidad de tener un eje central que ayudara a generar un entorno de confianza entre los actores, depositando esa confianza en la tecnología y fomentando la colaboración. El token de Trazable nos sirve como un elemento diferenciador en otros proyectos y, a corto plazo, como una forma de capitalización para hacer crecer el proyecto y llevarlo al siguiente nivel. Hasta el momento de la ICO, habíamos conseguido medio millón de euros en financiación, parte de la cual provino de inversores. Conocíamos las diferentes etapas del proceso. La financiación con inversores es como casarse con alguien y meter a personas en el proyecto, por lo que la confianza es crucial. La ICO, en cambio, es una vía alternativa que surge de la tecnología y busca añadir actores clave, como los consumidores, para conectarlos con las empresas. Así, cerramos el círculo de manera perfecta, alineando la financiación con el objetivo a medio y largo plazo que queremos alcanzar.

Ahora, la situación es complicada, pero depende de si tiene sentido para ellos, ya que, como saben, el token requiere tiempo y dedicación para mantenerlo. Si se hace únicamente por conseguir financiación, no tiene sentido, porque eso desviará el enfoque, que es lo más importante en un proyecto. Donde estamos ahora es el resultado de todos los aciertos y errores que hemos cometido. No repetiría todos los errores que hicimos. De hecho, comenzamos Trazable enfocados en la industria del lujo y luego pivotamos hacia la alimentación. La idea inicial era introducir la tecnología en el sector del lujo para certificar productos y combatir las falsificaciones. En ese momento, mi socio Lucas y yo no teníamos recursos y queríamos probar rápidamente. La industria del lujo se mueve más lentamente, con empresas más grandes y deslocalizadas, por lo que nos resultó más fácil testear en la industria alimentaria.

En ese proceso, conocimos a una empresa de productos cárnicos, específicamente de jamones y aceites de lujo, que estaba interesada en combatir las falsificaciones, pero también en aportar valor al consumidor. Así comenzamos a explorar la industria alimentaria, identificando problemas de seguridad alimentaria y otros desafíos que nos llevaron a concluir que, en un entorno como el de España, con una industria muy grande y empresas de todos los tamaños, era mucho más fácil realizar pruebas. Así fue como conocimos a Embutidos Martínez, nuestro primer caso de éxito, y avanzamos con Trazable.

Funcionamos con cuatro pilares: crecimiento, producto, tecnología y ventas o negocio, donde todo se retroalimenta. El eje central es el producto, donde el cliente es lo más importante. Trabajamos mucho con empresas y pruebas, y recibimos muchos insumos de ventas o crecimiento que se validan en historias de usuario. Luego, la tecnología se adapta para que el producto evolucione en la dirección que nuestros clientes necesitan. En 2023 o 2024, nuestro objetivo es convertirnos en el software de referencia en gestión de calidad. Así como piensas en un CRM y mencionas Salesforce o HubSpot, queremos que Atrazable sea el referente en software de gestión de calidad. Además, planeamos introducir la utilidad del token dentro de nuestra solución de software y conectar a la red, finalizando la conexión entre usuarios y empresas dentro del producto que ofrecemos.

Estamos testeando aquí porque en muchas industrias somos referentes, también a nivel europeo y mundial en varios sectores. Nuestro objetivo es probar y, si es posible, lanzar este año en otros mercados, ya que somos una solución global. Las cadenas de suministro son complejas, y tenemos clientes que cuentan con proveedores en todo el mundo, así como algunos en Latinoamérica, y queremos expandirnos a otros mercados.


###  242.B4_Blocknitive-video

###  Blocknitive
![[242.B4_Blocknitive.mp4]]
[Blocknitive](https://app.web3mba.io?wvideo=r91dtd38c5)

Blocknative nace a partir de la consultora Eman Gitti, al detectarse la necesidad de aplicar una tecnología tan disruptiva como la blockchain a soluciones concretas de procesos complejos. Su misión se centra en poner el foco en la innovación y la digitalización, aplicándolas a la resolución de problemas mediante tecnología descentralizada y cognitiva. Funciona mediante software colaborativo de código abierto, como Hyperledger, ofreciendo así soluciones adaptables gracias a la aplicación de una arquitectura modular flexible. Además, cuenta con alianzas clave con empresas relevantes del sector tecnológico como Oracle e IBM. Este proyecto contiene en su ADN el respeto por la privacidad y la seguridad a la hora de agilizar la transformación digital de un mercado en constante evolución.

Blocknative es una startup que surge en 2018 como un spin-off de una consultora con más de 17 años en el mercado, presente en España, México y Estados Unidos. Al observar el éxito de las nuevas tecnologías, crearon un hub digital de inteligencia artificial, Big Data y Blockchain, y decidieron que Blockchain podría tener un negocio aparte, dando lugar a la creación de Blocknative, apoyada en el contexto de la nueva GDPR. Así, desarrollaron un producto único en Europa que ayuda a solventar la trazabilidad del uso de datos, cumpliendo con la GDPR, normativa que comenzó a aplicarse el 25 de mayo de 2018. Nos gusta combinar datos y procesos con blockchain, siempre desde un punto de vista B2B. Lo que más me enamora de esta tecnología es su capacidad de ser transversal. Esto es algo que escucho frecuentemente de los clientes, quienes preguntan: "¿Pero en qué sector?" La respuesta es: en todos, porque, como hemos mencionado, estamos en datos y procesos, y todas las empresas tienen ambos.

Lo que hemos hecho es desarrollar una plataforma con distintos módulos para solucionar casos de uso de negocio. Uno de ellos es la trazabilidad del consentimiento. Por ejemplo, en un caso de uso que tenemos, se trata de la interoperabilidad entre empresas del grupo, que pueden crear una base común. Al ser distintas sociedades, deben cumplir la GDPR de manera diferente, pero nosotros colocamos nuestra capa por encima de la base de datos, y la herramienta actúa como un regulador que permite o no el uso de los datos. Otro caso de uso muy interesante que estamos comenzando a explorar, especialmente para un operador de telecomunicaciones o un ayuntamiento, es proporcionar visibilidad a los clientes sobre la trazabilidad de sus datos. Es decir, permitir que el cliente visualice qué consentimientos ha otorgado, qué finalidades ha firmado, qué se ha hecho con sus datos y a quién se han entregado, incluso en relación con una tercera empresa.

Desde el punto de vista de los procesos, tenemos casos de uso muy variados. Por ejemplo, trabajamos en la certificación de energías renovables, que luego tokenizamos, con la idea de emitir un pequeño certificado para un marketplace. También abordamos la trazabilidad digital de productos, como en el caso de un router que se instala en casa. Las telecomunicaciones enfrentan el problema de no tener trazabilidad sobre esos routers, lo que lleva a que cobren a los clientes sin saber dónde están. Por ello, tenemos dos casos de uso que permiten trazar de forma inequívoca la identidad digital del router desde su creación, pasando por el almacén de la telco, hasta llegar al cliente y ser instalado. Durante todo ese proceso, pueden ocurrir dos cosas: que el cliente se dé de baja voluntariamente o que se produzca una baja no voluntaria. En ambos casos, se puede certificar que el router ha regresado a la tienda, o incluso renovarlo por un tiempo determinado, manteniendo siempre el control de su identidad.

Dependiendo del caso de uso, siempre explicamos que blockchain no es la solución para todo. Debe tener una utilidad específica y un caso de uso que nos ayude a desarrollarla. Puede tener una vertiente muy B2B, que ayuda a reducir costos y mejorar la eficiencia del back office, ya que blockchain es, en esencia, una tecnología de backend. Es cierto que, dependiendo del caso de uso, se puede combinar con otras tecnologías, como la inteligencia artificial generativa y Big Data, para mejorar la fidelización de los clientes y la experiencia del usuario, lo que a su vez genera negocio. Sin embargo, repito, esto dependerá del caso de uso y puede aportar de diferentes maneras.

Nuestro producto está disponible en formato SaaS y en la nube. Actualmente, estamos enfocados en Latinoamérica, principalmente en México, y atendiendo a ciertos clientes que prefieren no utilizar SaaS, optando por soluciones en sus propias nubes, por lo que vendemos con licencia. No obstante, también ofrecemos la opción SaaS. Ambos productos cuentan con una experiencia de cliente muy sencilla. Hemos logrado el éxito en dos aspectos: primero, centrarnos en los procesos, que son lo que realmente aporta valor a los negocios; y segundo, eliminar la complejidad del blockchain para los clientes mediante un caso de uso, ofreciendo una solución que puedan utilizar sin necesidad de entender que están utilizando blockchain. Puedo enseñarte cómo funciona sin mencionar la palabra blockchain, y tú estarás aprovechando todos los beneficios que esta tecnología ofrece. Luego, si preguntas cómo se ha hecho, te diré que es en blockchain. Creo que ese es uno de nuestros mayores logros.

Podemos tener una prueba de concepto lista en menos de un mes, a menos que se complique con integraciones o sistemas de información. Si se trata de un caso de uso sencillo, incluso podríamos tenerlo funcionando en dos semanas. Nuestro enfoque principal es la trazabilidad. Además, contamos con otros productos paralelos, como nuestra propia plataforma de NFTs, que permite a los usuarios diseñar, crear y gestionar sus propios NFTs, incluyendo la posibilidad de establecer royalties. También tenemos una alianza con Block Impulse, una plataforma ICO que ayuda a las empresas a crear nuevos proyectos y generar su token. No solo les asistimos en el diseño de la plataforma, sino que también les ayudamos a crear su token, lo cual es un proceso complejo que incluye la elaboración del white paper, la estructura económica y legal, y la parte de marketing. Si desean profundizar en la parte de marketing, les recomendamos contratar a un experto en esa área.

¿Qué es blockchain? Para mí, como lo explico a mi entorno que no tiene conocimientos en el tema, es como un Excel en el que múltiples participantes pueden interactuar, quedando registrada la trazabilidad de las acciones de manera inmutable y visible para todos. Entonces, ¿cuándo tiene sentido utilizar blockchain? Como mencioné, cuando hay más de un participante. Si se va a utilizar para una empresa, ¿puede ser útil? Sí. ¿Realmente aportará valor? Depende. Habrá casos en los que sí. Si necesitas realizar una certificación específica, entonces sí, pero en realidad no estarías utilizando blockchain. La tecnología blockchain tiene la ventaja de permitir muchas aplicaciones, pero actualmente solo estamos utilizando alrededor del 20% de su potencial. Por lo tanto, es necesario educar a las empresas para que comiencen con un pequeño pilar y, una vez que tengan la base, puedan incorporar smart contracts para automatizar procesos.

No soy un experto en finanzas o en el mundo de las DeFi, pero creo que hay un gran potencial en ese ámbito. Desde mi perspectiva, blockchain es tan transversal que puede aplicarse a todos los sectores. Sin embargo, es cierto que las empresas que adoptan esta tecnología suelen ser aquellas con capacidad de inversión e innovación, que están dispuestas a ser pioneras en su implementación para mejorar la eficiencia. Otros sectores que considero muy interesantes son las telecomunicaciones y los seguros, que siempre están presentes de una forma u otra. En el caso de la banca, aunque hay menos ejemplos, hemos trabajado en proyectos relacionados con importaciones y exportaciones, donde hay muchos participantes y un gran volumen de documentación que certificar. Si todos suben la documentación correspondiente a una plataforma y se va certificando, se genera seguridad y se reduce la carga de conciliación de papeleo.

El retail también tiene un gran potencial para cambiar con blockchain. Un caso interesante que hemos explorado en México es la logística inversa de medicamentos, que involucra al laboratorio, distribuidor y cliente final, incluso cuando el medicamento regresa. Algunos medicamentos no pueden ser redistribuidos, mientras que otros pueden volver al mercado, dependiendo de su fecha de caducidad. Certificar toda esta documentación es crucial. Una de las preguntas que nos hicieron las farmacias fue: "¿Qué gano yo con esto?" La respuesta es que, a corto plazo, no ganarás nada, pero el éxito radica en que el distribuidor y el laboratorio te incentiven a compartir y colaborar en este ecosistema, ya que ellos también obtendrán beneficios. Actualmente, se estima que en México se pierden 66 millones de dólares al año debido a la falta de trazabilidad. Si logramos reducir esa pérdida a 10 millones, incentivando a las farmacias, eso sería un éxito, ya que habríamos recuperado 54 millones.

Blockchain es una tecnología más y un concepto de digitalización. No se puede digitalizar de 0 a 100; debe hacerse de manera gradual. Es cierto que en el mundo de Hyperledger Fabric, donde se desarrollan procesos de negocio, puedes optar por soluciones de código abierto que son muy económicas, o contratar a IBM, que es uno de los líderes en esta tecnología, aunque a un costo más elevado. En la fase inicial, puede parecer que estás haciendo una inversión costosa en tecnología. Sin embargo, si logras cambiar la mentalidad y buscar casos de uso que se automaticen, considero que, según ciertos cálculos, blockchain puede ser una tecnología más económica que otras en el mercado y, sobre todo, escalable. Creo que blockchain tiene mucho sentido porque ayuda a garantizar la integridad de los datos y su uso, promoviendo un ecosistema colaborativo. Es fundamental que todos los datos estén ligados a un consentimiento, y eso es crucial; romper esa cadena puede generar problemas significativos.


###  243.B4_Trazable-Lucas_Salinas-video

###  Trazable
![[243.B4_Trazable.mp4]]
[Trazable](https://app.web3mba.io?wvideo=x6th69298c)

Empezamos en la incubadora de Demium. Yo acabé allí por accidente, mientras que Pablo creo que sí fue premeditado al entrar. Nos conocimos un viernes en un evento de captación de talento, donde se reúnen mentes que quieren emprender o que buscan algo diferente. Ese viernes nos conocimos y, el lunes, nos tocó trabajar juntos en el mismo equipo, un poco por suerte. Ese lunes comentamos que íbamos a trabajar juntos durante los próximos meses, aunque en ese momento no te planteas que tienes delante a la persona que verás todas las mañanas durante los próximos cinco años de tu vida.

Gran parte del desarrollo de Trazable ha implicado mucha investigación, lo que nos ha permitido experimentar con redes como Ethereum, Bitcoin y redes privadas como Hyperledger, en colaboración con proyectos lanzados junto a IBM o Intel, entre otros. También hemos trabajado con blockchains de distintos tipos: públicas, permissionadas, privadas y sin permissionar. Cuando comenzamos Trazable, a finales de 2017, la carrera ya no se centraba tanto en cuál era la blockchain más eficiente, sino en empezar a explotar la capa de aplicación. Esto es parte de la razón por la que Trazable decidió asentarse en ese ámbito y trabajar en llevar esta tecnología a la industria, que aún no la tenía tan comúnmente adoptada. En ese momento, las decisiones sobre qué blockchain utilizar solían basarse en lo que era viable a nivel de negocio y en cómo defender un modelo de negocio. En nuestro caso, al ir a la industria, el gran volumen de transacciones no podía soportar blockchains con altas tarifas, ya que eso desmantelaría cualquier modelo. Esto era especialmente relevante en un momento en el que Ethereum, por ejemplo, experimentaba picos altos en las tarifas.

La mayoría del desarrollo que hemos realizado ha sido en Ethereum, lo que nos ha llevado a profundizar en Solidity. Es un mundo que requiere casi tiempo completo para alcanzar una verdadera experiencia, especialmente con el crecimiento de ese lenguaje y la adopción de la tecnología. Además, cuando observamos el mercado actual de NFTs o tokens, que en última instancia son contratos inteligentes que operan por debajo, a pesar de que existen otros tipos de contratos, es evidente que hemos adquirido mucha experiencia en este ámbito. Puede que no sea la tecnología o el lenguaje más idóneo para comenzar en el desarrollo, pero es una parada obligatoria si eres desarrollador y deseas adentrarte en este mundo. Esto se debe, sobre todo, al mercado de aplicaciones disponibles para desarrolladores que quieren empezar, desde editores de código hasta extensiones. Todos los desarrolladores, en algún momento, tenemos un conjunto de herramientas que nos ayudan en nuestro día a día.

En el caso de Solidity, debo decir que me he apartado de eso desde hace tiempo, así que imagino que el mercado habrá evolucionado mucho. Sin embargo, en aquel momento, cuando estaba trabajando en ello, no era algo tan amigable. Personalmente, me he visto en la necesidad de enfrentarme a otros retos, como escalar el equipo y entender las líneas de desarrollo, así como cómo pueden afectar a la economía de la empresa al desarrollar de una forma u otra. Mi rol ha evolucionado hacia una zona en la que debo trabajar muy de la mano con el negocio, entender sus necesidades y ofrecer la mejor solución. Al final, siempre se busca algo bueno, bonito, barato y rápido, pero lo más importante es llegar.

Cuando hablamos de una tecnología descentralizada como blockchain, nos referimos a que al escribir una pieza de código en Solidity y desplegarla, estás firmando una transacción. Esa transacción es inmutable, lo que significa que lo que hayas introducido allí permanecerá. Por lo tanto, si esa pieza de código tiene un error, el error se vuelve inmutable. De hecho, uno de los miembros del equipo lo apodó "Persistir Bugs", que es uno de los inconvenientes de desarrollar aplicaciones industriales en tecnologías como blockchain. Obviamente, tienes tu entorno de staging, donde puedes realizar pruebas, pero esto cambia tu mentalidad al diseñar aplicaciones, que ya no están hechas para ser actualizadas, sino que deben ser aplicaciones cuya vida en producción sea efímera, preparándote para cambiar a una nueva versión que deberás desplegar, sin poder actualizar la antigua. El diseño de la aplicación debe permitir redirigir todo lo que hayas generado a esa nueva versión. Esto te obliga a pensarlo de otra manera, y ahí radica parte del reto, que también es parte de lo bonito. Sin embargo, tienes más variables; estás en un entorno B2B, vas a la industria, y el volumen de transacciones no solo depende de lo que has desplegado y la lógica que tienes, sino de cómo se comportará esa lógica o esa red en particular en la que se está ejecutando, así como del cliente específico o del sector que comienza a interactuar con esas transacciones.

Decidimos no reinventar la rueda. El token es un estándar, un ERC20, que ya está auditado. En nuestro caso, nos apoyamos en Open Zeppelin, que ya tiene los estándares desarrollados. No tiene sentido volver a hacerlo, ya que lo más probable es que cometas un error y no vale la pena asumir ese riesgo. Por lo tanto, utilizamos contratos inteligentes que ya están auditados y estandarizados, los desplegamos con nuestros parámetros iniciales y ya tenemos algo funcional que se comporta de manera adecuada.

En el caso del sistema de trazabilidad y la tecnología blockchain, cuando Trazable nació en 2017, estábamos en un momento en el que comenzaba a explotar el desarrollo de la capa de aplicación, pero no tanto el desarrollo de una blockchain más eficiente. Era un momento en el que se hacía blockchain para todo. Muchas veces te preguntabas: "¿Hace falta blockchain aquí?" y parecía que sí. Una de las cosas que nos sucedió es que había secretismo en torno a las estrategias de las empresas que fabricaban sistemas de trazabilidad en blockchain, lo que nos obligó a experimentar mucho. Siempre digo que hemos desarrollado alrededor de nueve sistemas de trazabilidad que, en ese momento de tanto hype, se apoyaban completamente en la tecnología blockchain. A medida que aprendimos y evolucionamos, el sistema fue pasando a capas en las que blockchain se utilizaba para lo que realmente tenía sentido, y el resto del sistema que no tenía sentido debía salir de ahí. ¡Chao!

La trazabilidad es un efecto; cuando deseas consultar la trazabilidad de algo, es porque ha habido una serie de hitos que han ocurrido antes. Esos hitos, esas piezas de Lego que forman la trazabilidad, son como las piezas de este algoritmo. Siempre que entramos con un cliente nuevo, necesitamos, primero, evaluar esas piezas y luego saber cómo montarlas para que encajen en nuestro sistema, que es el que evaluará esas piezas y el orden en que entran para poder construir ese "muñeco". Lo que tenemos diseñado es un sistema de trazabilidad que no deja de ser un proceso en el que fabricas un producto. Para ese producto, has adquirido materias primas que, para otro actor o empresa, eran su producto. Con esas materias primas, no solo las has utilizado para tu producto, sino que además lo has distribuido o utilizado, lo que puede convertirlo en un subproducto para la empresa siguiente en la cadena.

Lo que más me atrae ahora mismo, y desde el principio, es la propia criptomoneda de Ethereum, principalmente por la innovación que introdujeron al implementar la máquina virtual. Esto ya no se limitaba a una transacción en la que ibas a persistir información, sino que te permitía, con estos contratos inteligentes, persistir lógicas de negocio. Me sigue pareciendo una maravilla y creo que esa capa de aplicación aún tiene mucho por explorar. Como proyecto, te mencionaría por ejemplo Decentraland, dentro de Ethereum. Es un metaverso, un token diseñado para las personas que construyen dentro de ese entorno, pensado para seguir avanzando e innovando en blockchain. Es ideal que quienes se acerquen ya tengan una base, lo que les ayudará a entender mejor la documentación, que no sea la primera que reciban en su vida, sino que ya sepan de qué se trata. Una vez que entras, es cuestión de paciencia, prueba y error. Lo que aprenderán en Solidity es muy valioso, especialmente cuando lo mezclan con tecnologías de desarrollo web, porque ahí es donde hablamos del Web 3. Podrán crear rápidamente aplicaciones pequeñas que interactúen con contratos inteligentes que ya hayan desplegado, sin necesidad de programarlos desde cero, utilizando estándares. Así, pueden crear su propio camino de aprendizaje que los motive con pequeños hitos y, rápidamente, acabar desarrollando cosas que digan: "¡Ostras! ¡Está bastante bien!".


