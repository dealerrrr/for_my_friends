---
title: Tecnologías Descentralizadas | Bloque 4
URL: https://app.web3mba.io/courses/take/bloque-4-tecnologias-descentralizadas/lessons/39251447-1-1-redes-p2p-alberto-martin
lang: es-AR
---
# B4. Tecnologías Descentralizadas
## U1. Redes P2P
###  Redes P2P (Video)
![[194.B4_Redes_P2P.mp4]]
[Redes P2P](https://app.web3mba.io?wvideo=fzixx1kbn5)

Las redes P2P surgen de la necesidad de conectar ordenadores de forma punto a punto, es decir, de manera directa, sin un servidor intermediario que medie en la comunicación. Este concepto comenzó a desarrollarse en los años 80, cuando, dentro de los protocolos UNIX y GNU, se buscaba la posibilidad de transferir archivos sin depender de un servidor central que pudiera almacenar una copia de esos archivos. Actualmente, quienes utilizan distribuciones GNU, MacOS y similares, suelen emplear herramientas como SSH o SCP, que son métodos para conectarse a un servidor remoto. El origen de todo esto radica en la implementación de las primeras redes P2P, que fueron evolucionando con diferentes características y necesidades a lo largo del tiempo, dando lugar a lo que conocemos hoy. Ejemplos de redes P2P populares en la actualidad son BitTorrent y, a nivel técnico, el protocolo SCP mencionado anteriormente, que en esencia permite realizar una copia de datos de un punto A a un punto B.

Para entender cómo funcionan estas redes, es necesario analizar su funcionamiento desde un enfoque técnico. Si observamos cómo se transmite un mensaje a través de HTTP en Internet, notamos que existen diferentes niveles de jerarquía en los paquetes. En el protocolo TCP/IP, hay siete niveles. En las redes P2P, trabajamos en el nivel 7, que es el de aplicación, donde intentamos crear una red de nodos que tengan direcciones de sus vecinos, lo que nos permite construir una mini Internet donde todos pueden acceder a los datos de los demás. Las principales ventajas de una red P2P son varias. La primera es que no requiere un único punto de fallo, algo que siempre está presente en una red centralizada. Al eliminar el problema del "single point of failure", se abren nuevas posibilidades, como la descarga de archivos de manera distribuida. No es necesario tener una única representación del archivo, sino que puede estar distribuido y ser descargado desde múltiples fuentes simultáneamente. Además, podemos compartir información no solo con un servidor, sino de manera fragmentada y simultánea en muchos lugares.

En España, las primeras implementaciones de redes P2P fueron programas como Kazaa, eMule y Napster, que buscaban redistribuir contenido que tradicionalmente estaba protegido por derechos de autor, dándole una nueva vida a través de la comunicación entre pares. En esa época, se observaron no solo las ventajas, sino también algunas desventajas de estas redes. Al ser distribuidas, es fundamental cuidar la calidad del contenido que circula, ya que un archivo corrupto puede ser distribuido y es responsabilidad de los miembros de la red identificarlo y eliminarlo. Para que esto funcione, se necesita un software que cada cliente pueda descargar y un conjunto de nodos que ejecuten dicho software. Una vez que cada cliente participa, comienza el proceso de conocer a sus vecinos. En esencia, se necesita una red de vecinos, donde uno pueda pedir sal, otro pimienta, y a su vez, ofrecer leche y pan. Para lograr esto, es necesario tener tablas de paginación que contengan índices para descubrir qué tiene cada uno. Esto funciona bien a pequeña escala, pero se complica a mayor escala.

Una de las primeras redes basadas en texto fue el IRC, un caso curioso de redistribución P2P, ya que no comenzó como tal. Inicialmente, había un directorio central que almacenaba el índice de vecinos con sus direcciones, lo que permitía iniciar conversaciones. Sin embargo, llegó un momento en que los usuarios no querían que su comunicación pasara por ese índice central y deseaban un entorno donde los miembros de la comunidad tuvieran el control. Así, se pasó de tener una tabla de índices central a múltiples tablas de índices distribuidas. Ya hemos mencionado algunas ventajas de estos sistemas desde un punto de vista filosófico y de uso, pero también es importante considerar sus ventajas y desventajas a nivel técnico.

Entre las ventajas, destaca que una red P2P no puede ser censurada. En países donde los ISPs están controlados por el gobierno, como en China, hay restricciones para acceder a ciertas páginas web. Al distribuir el contenido de manera P2P, no hay un servidor DNS que pueda denegar el acceso a una ruta específica, ya que es una red de nodos la que proporciona ese contenido. Si hablamos de escalabilidad para compartir archivos de video o audio, como en los casos iniciales de BitTorrent, hemos visto una evolución significativa. Al principio, las descargas eran bloqueadas y se realizaban entre pares, pero ahora podemos tener particiones distribuidas que almacenan fragmentos de diferentes proveedores, lo que permite un acceso más rápido a nuestros archivos en comparación con la descarga desde un servidor centralizado.

Otra ventaja es que el sistema es agnóstico respecto al tipo de archivo que se desea compartir. En la misma red y ecosistema, se pueden enviar desde un tweet hasta descargar una canción o una base de datos de wallets comprometidos. La clave es que solo se necesita establecer una infraestructura y, a partir de ahí, cualquier tipo de información puede fluir libremente. Sin embargo, al considerar las desventajas del sistema, es importante analizar qué sucede con una red de gran escala. El rendimiento de esta red dependerá del tipo de algoritmo utilizado para la distribución de nodos. Según el tipo de archivo que se desee distribuir, algunos tendrán mayor calidad que otros, y la replicación de la información será más lenta en función del número de nodos que se mantengan. Por ello, ciertas redes distribuidas o P2P pueden no ser operativas para determinados casos de uso.

Aunque una red distribuida es prácticamente incensurable, no es un protocolo que, por defecto, garantice privacidad, a menos que esté diseñado específicamente para ello. Por ejemplo, en Alemania, el tráfico de BitTorrent es monitoreado por los ISPs, y se pueden imponer multas por compartir contenido protegido por derechos de autor. Este tipo de tráfico puede estar acompañado de medidas secundarias que aseguren la privacidad, como utilizar una red P2P sobre Tor o a través de una VPN con características específicas. Es fundamental tener en cuenta que la red distribuida ofrece libertad de distribución, pero no garantiza privacidad sobre lo que se comparte.

Por último, es importante mencionar los problemas estructurales que pueden surgir. Todo tipo de red y ecosistema tiene sus pros y sus contras, y en las redes distribuidas P2P, existen casos de uso que pueden ser vulnerables a ataques, como el ataque de eclipse. En un ataque de este tipo, se intenta aislar un nodo, creando un "eclipse" sobre él, lo que puede tener diversas finalidades, como reducir su capacidad de minería o inyectar transacciones fraudulentas. Esto se logra mediante la creación de nodos replicantes que apuntan a vecinos cercanos, y es crucial que las tecnologías en entornos cripto estén diseñadas para ser resilientes a este tipo de ataques.

¿Cómo se relaciona todo esto con las criptomonedas? Todo comenzó con la primera blockchain, Bitcoin. Cuando Satoshi diseñó el sistema, se inspiró en cómo funcionaba BitTorrent. En aquella época, BitTorrent ya utilizaba algoritmos para distribuir la carga entre diferentes nodos, y se adoptó un enfoque similar en Bitcoin. ¿Cómo se traduce esto en la minería? La minería es el proceso de encontrar la solución a un bloque y añadirlo a la cadena. El bloque que se añade se retransmite a todos los nodos. Si tenemos un número fijo de nodos y mineros, el sistema debe ser lo suficientemente robusto para evitar que ningún agente activo que valide transacciones pueda introducir una transacción maliciosa. Esto se relaciona con la regla del 51%, que establece que si más de la mitad de los nodos están de acuerdo en algo, ese algo se considera cierto. Para introducir una transacción maliciosa, sería necesario engañar a esa mayoría en un corto período de tiempo.

¿Qué sucede en un escenario específico? Si tenemos, por ejemplo, 20 mineros y 100 nodos, y 10 de esos mineros controlan el 80% de los nodos, lo que a escala actual es prácticamente imposible, esos mineros podrían intentar inyectar una transacción maliciosa. Si logran que la mayoría de los nodos acepten esa transacción, se generaría una situación en la que algunos nodos la aceptarían y otros no, lo que provocaría un hard fork. Un hard fork es la bifurcación de la blockchain, donde se crean dos redes P2P diferenciadas, cada una con sus propias reglas de consenso. Este tipo de algoritmos y prácticas no se limitan a Bitcoin. Todas las redes blockchain son distribuidas y cada una tiene su propia participación en ciertos algoritmos que han evolucionado con el tiempo.

Es importante mencionar la diferencia entre Bitcoin y Ethereum. Si observamos cómo se realiza la minería en la actualidad, tanto en Bitcoin como en Ethereum, notamos patrones distintos. Bitcoin permite que, con cierta potencia de cómputo, se logre un mejor rendimiento en la minería. En cambio, Ethereum premia la descentralización en la minería. ¿Qué implica tener una minería que prioriza la descentralización en lugar de la eficiencia? Que, evidentemente, es menos eficiente. Al buscar descentralización, se requiere una mayor duplicidad de datos y más mensajes intercambiados para sincronizar todo, lo que ralentiza el proceso y se traduce en tarifas de gas más altas.

El algoritmo utilizado en Ethereum se llama Cadembly, del cual hablaremos más adelante. Es importante destacar que no es el único en este tipo de implementación; otros protocolos como IPFS o Filecoin siguen características similares. Tanto IPFS como Filecoin buscan crear una red P2P donde se distribuyan archivos de manera libre, permitiendo que cada uno de nosotros actúe como un nodo activo con participaciones en esos archivos. Al tener participaciones, se asegura la confidencialidad del archivo completo y, gracias al algoritmo que se centra en la distribución, se garantiza su robustez, no solo para la privacidad, sino también para la imposibilidad de su distribución no autorizada.

Es relevante mencionar que Ethereum no está solo en este tipo de implementación; Cadembly también ha sido adoptado por proyectos como IPFS y Filecoin, que buscan crear redes distribuidas para intercambiar archivos P2P, permitiendo que cualquiera de nosotros sea un nodo activo. Aquí, nuevamente, se resalta la importancia de contar con un algoritmo que favorezca la descentralización masiva, aunque esto afecte un poco el rendimiento. Esto se debe a que, al subir un dato a esta nube distribuida, se busca que esté muy fragmentado para que nadie tenga acceso al archivo completo y, al mismo tiempo, que nadie tenga el poder suficiente para reconstruirlo.

Desde esta perspectiva, comenzaremos a ver poco a poco el uso característico de Cadembly. Este algoritmo ha sido elegido para su implementación en Ethereum, Filecoin y otros proyectos por su robustez a la hora de encontrar caminos entre nodos cuando uno de ellos desaparece, y su capacidad para soportar ataques de denegación de servicio. La característica principal de este algoritmo es que no organiza los nodos de manera aleatoria, sino que los estructura en forma de árbol. Se forma un árbol binario donde se distribuyen particiones de archivos, transacciones o cualquier tipo de información.

Cuando tenemos este árbol de nodos, que se puede imaginar como un sauce, es necesario contar con una posibilidad algorítmica para acceder a cada nodo en caso de que ocurra un fallo. Esta es la ventaja del algoritmo. Es eficaz para prevenir ataques de denegación de servicio, que buscan bombardear una familia de nodos y hacer que no puedan aceptar más transferencias. Con Cadembly, se garantiza que, como máximo, en 20 pasos se puede acceder a cualquier nodo, y si uno falla, se salta y se busca el siguiente. Si ese nodo también está inactivo, se continúa buscando hasta encontrar uno operativo. A menos que toda la red sea derribada, se puede encontrar un nodo sano en un máximo de 20 pasos.

Si profundizamos en la implementación técnica de este algoritmo, es necesario contar con una cantidad de nodos distribuidos que hayan descubierto a sus vecinos. Una vez que se identifican los vecinos, se deben almacenar en un índice, conocido como tabla de hash. Esta tabla de hash es como la primera hoja de un libro, donde se tiene una dirección parcial que permite llegar a un vecino. Si al llegar a un vecino este no puede proporcionar servicio, se salta al siguiente. Este proceso requiere que, a medida que los vecinos fallen, se pregunte a la red por nuevos vecinos. Por ello, hay varias operaciones específicas en cualquier red distribuida que utilice este tipo de algoritmo, que incluyen: "dame mi información", "toma información" y "hola, buenos días". El "hola, buenos días" es un ping; si se hace ping a una dirección, debe responder con un pong, lo que se añade a la hoja de índices. Esto ocurre en tiempo real y de manera distribuida.

Por eso, a pesar de que Ethereum tiene un alto nivel transaccional, gran parte de los mensajes se utilizan para mantener la integridad de la red. Esto se debe a que, en la actualidad, hay intentos constantes de introducir software malicioso, y es la robustez del algoritmo la que nos protege. Cuando se dice que cierta blockchain tiene un consumo eléctrico elevado o que otra tiene un consumo menor, a menudo se basa en las necesidades de esa blockchain, no solo para validar transacciones, sino para mantener la robustez mencionada. Por lo tanto, algoritmos como el que estamos discutiendo tendrán un tráfico mayor que aquellos que permiten la centralización, lo que puede llevar a la conclusión de que Ethereum tiene un consumo eléctrico más alto y un rendimiento inferior en comparación con Solana, por ejemplo. Además, es importante considerar que Bitcoin utiliza un sistema de prueba de trabajo (proof of work), mientras que Ethereum está en transición hacia un sistema de prueba de participación (proof of stake), lo que también influye en las diferencias en el consumo eléctrico y la eficiencia transaccional.

###  Redes P2P
Las redes P2P o redes _peer-to-pee_r, son un tipo de red de computadoras que permiten la comunicación directa entre las mismas, sin necesitar de intermediario alguno.

La creación de esta tecnología resultó vital no solo para mejorar nuestras comunicaciones, sino para ofrecer herramientas de privacidad, que sirvieron a miles de personas para comunicar su voz al mundo entero. 

Hoy, las redes P2P son un elemento clave de muchos protocolos digitales, siendo uno de ellos los protocolos que hacen posible el funcionamiento descentralizado de las criptomonedas.

####  ¿Qué es una red P2P?
Una red P2P o peer-to-peer, es un tipo de red digital donde un grupo de personas o máquinas participan de forma completamente descentralizada.

Es decir, **es una red donde no hay un punto central de conexión o control,** **por lo que cada una de ellas es totalmente autónoma,** estableciendo conexiones y compartiendo información de forma igualmente autónoma. Todo esto es posible, porque las redes P2P han sido programadas para responder a un protocolo de comunicaciones y consenso común, que les permite realizar este tipo de tareas sin que un tercero tenga intervención alguna en el proceso. 

Para lograr este funcionamiento, las redes P2P se construyen sobre protocolos que se ejecutan sobre los protocolos de Internet (TCP/IP, UDP o de cualquier otra índole que lo permita). De allí que, a los protocolos P2P se le reconozca como protocolos de aplicación o Layer 7, según el modelo _Open Systems Interconnection_ u OSI. Esto significa que los protocolos P2P necesitan para su funcionamiento el uso de otros protocolos más abstractos para poder funcionar, pero que al mismo tiempo, los hace más sencillos de construir y hacer funcionar.

Gracias a esto, los protocolos P2P, han sido ampliamente utilizados desde su creación para distintos usos. Algunos legales, otros un tanto grises, pero pese a ello hay una cosa muy clara: Los protocolos P2P son muy potentes y permiten la creación de estructuras descentralizadas, ==difícilmente censurables y de uso libre.== Por esa razón, criptomonedas como Bitcoin fueron construidas sobre la base de protocolos P2P.

###  Historia de las redes P2P
El origen de la primera red P2P, la podemos rastrear hasta la creación del protocolo UUCP o _Unix-to-Unix Copy Protocol_, en el año 1980. 

UUCP (_UNIX-to-UNIX Copy Protocol_) es un conjunto de programas UNIX que permite copiar y enviar archivos entre diferentes sistemas UNIX, o para enviar comandos que se ejecuten en otro sistema UNIX, todo ello mientras exista una comunicación directa entre ambos sistemas.  

![[198.B4_uucp.png]]

Si eres, usuario de GNU/Linux, BSD o MacOS, seguramente te vendrá a la mente un protocolo que hace esto en la actualidad: ssh. Pues bien, UUCP es por decirlo de una forma el origen del mismo, ya que su **objetivo es el mismo: comunicar dos sistemas de forma directa para enviar y recibir archivos.** 

**Por supuesto, UUCP es un protocolo que poco se usa hoy en día, sin embargo, su legado es inolvidable, porque dicho protocolo es lo que dio origen a USENET y los BBS, dos elementos que hoy en día se siguen usando.** Por ejemplo, el BBS de EfectoLinux o FideNet, son dos ==BBS== que se mantienen activos en nuestros días, y nos hacen recordar al “Internet antes del Internet”, a la vez que nos permiten acceder a archivos antiguos que de otra manera se hubieran perdido hace mucho. En ==USENET==, las opciones son mucho más amplias, ya que la red se ha mantenido activa gracias a un sistema de suscripciones de pago para acceder a dichos servicios, teniendo comunidades muy activas en este sentido. 

  ![[198.B4_fidonet.png]]

Dicho esto en su momento, USENET y el protocolo UUCP fueron la cumbre de las comunicaciones. De hecho, el movimiento cypherpunk inició con el uso de este protocolo. Personajes como Saint Jude, Eric Hughes, Timothy C. May, David Chaum, hacían uso de estos sistemas para compartir información en los tablones BBS de la comunidad Cypherpunks. 

> Eran los primeros años de la computación, y en ese momento, ya se vislumbraba mucho de las posibilidades futuras de este tipo de protocolos y de computadores mucho más potentes y capaces.

Más tarde, en 1983, llegó al mundo el protocolo TCP/IP. Básicamente, este nuevo protocolo buscaba flexibilizar la creación de grandes redes globales, de hecho, es la base de construcción de lo que hoy conocemos como Internet. Esto último, se hizo realmente posible cuando se estableció el sistema o modelo OSI (definiendo las siete capas de abstracción que contamos actualmente en Internet) en 1989 y, finalmente, con la llegada del protocolo WWW (World Wide Web) en 1990.

####  La era del IRC
En 1988, nacería ==Internet Relay Chat (IRC)== un sistema de mensajería basado en texto que fue desarrollado por Jarkko Oikarinen. Si bien IRC nació bajo un esquema centralizado (cliente-servidor) el sistema fue mejorado para convertirse en uno híbrido, en el cual la conexión principal se mantenía del modo cliente-servidor, pero se habilitaba también un modo de comunicación directa entre personas (Cliente-a-Cliente Directo o DCC) que para mayor seguridad podía usar un esquema Off-The-Record (OTR) usando criptografía de clave pública entre esos clientes. 

**IRC tuvo un tremendo éxito por varias razones: es fácil de usar, permite unir grandes comunidades, se da en tiempo real y es altamente personalizable. De hecho, muchas comunidades de criptografía y desarrollo de software libre aún usan IRC para sus comunicaciones, siendo software como Bitcoin o Ubuntu, dos de esas comunidades que aún usan IRC para comunicarse.** 

####  La era de la compartición de archivos y el nacimiento del P2P real
Con la masificación de Internet, comenzó una nueva era, una en la que era posible compartir archivos de forma rápida y sencilla. Proyectos de software libre y privativo trabajaron para hacer de este tiempo una “era dorada” en la que podías compartir tus fotos, vídeos y cualquier creación digital con comunidad, amigos y familia en todo el mundo, sin necesidad de intermediarios.

IRC fue al inicio de todo esto, el medio más usado para tal fin, ya que permitía este tipo de acciones. Sin embargo, no era eficiente y su dependencia de un servidor para lograr la comunicación de las partes era un problema. Pero en 1996 se publicó ==HotLine Connect,== una aplicación creada Adam Hinkley. **HotLine Connect era una red completamente P2P para compartir archivos que utiliza un sistema de trackers para permitir que dos usuarios pudieran intercambiar información.** Sin embargo, su desarrollo se detuvo debido a la dificultad de encontrar material y la inestabilidad de su protocolo, algo de lo que IRC-DCC no sufría. 

Para 1999, nacería otro contendiente conocido como Direct Connect (DC), el cual al igual que IRC-DCC necesitaba de un servidor central, para luego permitir que las partes conectadas al mismo, pudieran interconectarse entre ellas por medio de una conexión directa. No dejaba de ser un sistema híbrido, alejado de una implementación P2P pura. 

#####  La llegada de Gnutella, la primera red P2P real
En el año 2000, nacería Gnutella de Justin Frankel y Tom Pepper. Frankel y Pepper eran trabajadores de Nullsoft, la empresa creadora del reproductor Winamp y el servicio de streaming de audio Shoutcast. Su experiencia los llevó a la creación del que sería considerado el primer protocolo P2P realmente funcional y que incluso a día de hoy es usado de forma activa por al menos 12 millones de personas en todo el mundo. 

Gnutella funciona gracias a un modelo conocido como ==“boostrap network”== en el que cada cliente busca al menos un nodo al que conectarse, descargar la lista de nodos conocidos y así en lo sucesivo, ir descargando distintas listas para ir mapeando la red a la que se conecta. 

![[198.B4_gnutella.png]]

En dicha lista hay nodos con distintas funciones, como cachés y supernodos.  

- Los primeros tenían como función mantener un listado del archivo más solicitado y la dirección de un nodo que tuviera dicho archivo, facilitando y acelerando la búsqueda de los archivos deseados. 
- Los segundos tenían como función, hacer que las búsquedas realizadas pudieran propagarse más rápidamente por la red, con el fin de que los nodos con la información solicitada respondieran al llamado, algo vital para la escalabilidad de la red. 

**En todo caso, Gnutella pasó a convertirse en el protocolo más usado para el P2P ocupando el 40% del tráfico de Internet para este tipo de protocolos, y con ese desarrollo saldrían proyectos como FastTrack (MLDonkey) o eDonkey, siendo este último desarrollado por Jed McAleb, quien es más conocido por haber creado el exchange de criptomonedas Mt.Gox (que luego fue vendido a Mark Karpeles), y ser parte de los proyectos Ripple y Stellar, como CTO de ambos proyectos.** 

#####  BitTorrent y Kademlia, las tecnologías para la descentralización completa
Fue BitTorrent quien finalmente lograría alcanzar la cúspide del P2P. 

Diseñado por Bram Cohen en abril de 2001, **BitTorrent se ha transformado en uno de los proyectos P2P de mayor impacto en todo el mundo,** siendo que cerca del 28% del tráfico de todo el Internet a nivel mundial se debe a este protocolo, en el cual participan unos 200 millones de personas diariamente.

> El éxito de BitTorrent se debe al uso de dos tecnologías, Peer Exchange y DHT. El primero es una solución bastante parecida a la que se puede ver en Gnutella, donde los nodos se conectan a trackers con el fin de encontrar nodos con un determinado archivo y descargarlo.

El problema de esta solución es que, al bloquear a los trackers, se detiene el funcionamiento de la red, requiriendo de una intervención manual para su funcionamiento (agregando las direcciones IP de los nodos a mano). Pero DHT resuelve todo esto, gracias al uso del protocolo ==Kademlia.== 

**Kademlia es un protocolo que permite crear una tabla hash distribuida para redes informáticas descentralizadas peer-to-peer diseñada por Petar Maymounkov y David Mazières en 2002.** Este sistema permite crear una estructura de la red y habilitar el intercambio de información a través de las búsquedas de nodos. En una red Kademlia cada nodo se identifica con un número o ID de nodo. El ID de nodo no solo sirve como identificación, sino que el algoritmo Kademlia utiliza el ID de nodo para localizar valores (normalmente hashes de archivos o palabras clave). 

De hecho, el ID de nodo proporciona un mapa directo a los hashes de los archivos y ese nodo almacena información sobre dónde obtener el archivo o recurso. Con esa información, Kademlia permite que el BitTorrent DHT sea totalmente descentralizado. De allí, que los muchos intentos de gobiernos, ISP y distintas organizaciones de poder para parar el funcionamiento de BitTorrent no hayan surtido efecto. BitTorrent y todas las redes que adaptaron Kademlia, ahora son indetenibles. 

####  Relación de las redes P2P y las criptomonedas
Cuando Satoshi Nakamoto creó Bitcoin, él sabía que tratarían de detenerlo por cualquier medio. 

No era un “pensamiento conspiranoico”. En 2008 los intentos por detener las redes P2P estaban en su punto más álgido, y solo se compartían archivos. Imagina ¿Qué harían si en vez de compartir archivos compartieran dinero, algo incluso más valioso que el dinero que ellos creaban de la nada? Con eso en mente, Nakamoto miró a BitTorrent y el protocolo Kademlia que le hacía inmune a tales intentos y lo adaptó al protocolo de Bitcoin. 

**Como resultado, Bitcoin es hoy una red de más de 10 mil nodos públicos (y otro número no determinado de nodos privados) que hacen funcionar a su red de forma segura, descentralizada e indetenible.** 

¿Pero, solo Bitcoin lo usa? Pues no. La verdad es que proyectos como Ethereum (y sus derivados descentralizados) usan Kademlia. Proyectos como IPFS, Filecoin, Siacoin o Storj, también usan Kademlia para sus nodos. 

![[196.B4_kademilla.png]]

Con ello queda claro una cosa, Nakamoto aprendió de la historia y, como buen aprendiz decidió no cometer los errores del pasado. Una enseñanza que caló en el resto de proyecto y que ahora no permite ver que P2P es el camino no solo a la descentralización, sino también a la libertad financiera y tecnológica.

###  Funcionamiento de las redes P2P
El funcionamiento de una red P2P es relativamente sencillo. 

Básicamente, lo que se hace es construir un protocolo (lenguaje) de comunicaciones que permita a las personas que usan dicho software comunicarse de forma directa y sin intermediarios con otros computadores.

Sin embargo, el mayor problema frente a la construcción de estos sistemas es: ¿Cómo diseñar un sistema que no necesite un directorio centralizado para comunicarse con otros computadores que ejecuten el mismo software?

Este es un problema complejo, pero la situación se puede solventar de una forma bastante efectiva con dos medidas bien definidas:
1. **En primer lugar, hacer que el software sea capaz de compartir información de conexión sobre quienes ejecutan el mismo.** Así, cada computador que ejecuta el software es capaz de tener un directorio de computadores conectados y servirse de ellos para conectarse al nodo que desea.
2. **Incentivar la mayor descentralización posible de la red.** Es decir, hacer que muchas personas ejecuten el software creando sus propios nodos y, por tanto, aumentando el tamaño de la red. De esta manera, se mejora su alcance y las posibilidades de la misma.

**Es decir, mientras más pares o peers (computadores ejecutando el software P2P) tenga la red, más posibilidades hay de que la red no pueda ser censurada, su funcionamiento será más resistente y, mejor capacidad tendrá la misma.** En los primeros sistemas P2P, como USENET o IRC, los sistemas y sus conexiones se hacían conocer por medios escritos, llamadas, o el mismo sistema que tenía un tablero de pares a los cuales poder conectarse. Así, cada nuevo integrante en la red, tenía acceso a la lista de peers y se autoañadía para que otros pudieran establecer comunicación con ellos en caso de requerirlo. No solo eso, ese nuevo peer podía ser la puerta de entrada a la información de peers que pudieran bloquearse.

> Pero la creación de redes más grandes como el IRC, DCC, DC++, Napster, Gnutella, BitTorrent e incluso Bitcoin cambió drásticamente esto. Ahora cada nodo se conectaba a un punto, obtienen una lista de peer iniciales (o nodos semillas).

Y a partir de allí, cada nodo es capaz de recrear una lista propia de nodos que pertenecen a la red. Como resultado, se obtiene una mejor resistencia a la censura y la red puede crecer más rápidamente.

Por supuesto, el funcionamiento de cada protocolo es distinto. IRC, por ejemplo, es un sistema híbrido (parte centralizada, parte descentralizada) de servidores que pueden darte la capacidad de conectarte punto a punto con una persona. Pero DC+ (con el nuevo protocolo ADC) y Gnutella, son completamente descentralizados. Sus redes están pensadas para que, de forma automática, la red se ajuste con la entrada y salida de nuevos nodos a la red.

**Lo mismo pasa en Bitcoin, donde la red comenzó con una sola semilla, la iniciada por Satoshi Nakamoto, y desde entonces, la red ha ido creciendo paulatinamente para convertirse en una red con un tamaño superior a los 10 mil nodos en activos públicos que se conocen. Por supuesto, el objetivo de Bitcoin es distinto al de una red como Gnutella, pero los principios del protocolo se mantienen: comunicar a dos partes sin intermediarios.**

![[197.B4_p2p.png]]

####  Ventajas y Desventajas
#####  Ventajas
1. **Una red P2P es resistente a la censura.** Una red P2P altamente descentralizada es prácticamente imposible de censurar.
2. **Ofrecen una resiliencia inigualable**. Si un nodo cae, otro nodo puede ocupar su lugar. Por eso dicen que las redes P2P pueden sobrevivir a una catástrofe nuclear. Porque estas pueden destruir muchos nodos, pero si solo uno sobrevive, la red puede reconstruirse por completo.
3. **Las redes P2P pueden llevar a soluciones de escalabilidad** potentes para presentar servicios únicos con alcance global.
4. **Al no depender de entidades centrales,** las P2P generan más confianza en sus usuarios. 
5. **Ofrecen un alto nivel de ancho de banda.** Esto gracias a que aprovechan el ancho de banda de cada participante, para transformarlo en propio de la red.
6. **Sirven para transmitir información digital de cualquier tipo.** Desde tu canción favorita a cientos de millones de dólares en segundos.

#####  Desventajas
1. **Una red P2P es resistente a la censura, pero no te hace anónimo a menos que esté diseñada para ello,** incluso, si esa red usa cifrado. El mejor ejemplo es BitTorrent, donde los ISP pueden detectar el uso del protocolo, y con ello advertir a las autoridades de la descarga ilegal por parte de un usuario.
2. **El diseño de las redes P2P generan que a mayor tamaño aumente la ==latencia.==** Es decir, para que una información llegue a todas las partes que forma la red, se tomará más tiempo en una red P2P de gran tamaño que en una de menor tamaño. De allí que se busquen nuevos algoritmos y protocolos que ayuden a superar este problema.
3. **Los protocolos P2P tienen una serie de problemas estructurales conocidos.** Casos como los ataques MITM para tomar el control de nodos, debido a que estos deben estar conectados todo el tiempo de forma pública, son uno de estos fallos. También los protocolos **son susceptibles a ataques de enrutamiento o cosas tan sigilosas como un ataque Eclipse o un ataque Erebus.**

#####  Ejemplo de como funciona una red P2P en criptomonedas
Para ejemplificar el funcionamiento de una red P2P tomaremos el caso de Bitcoin. 

**Nakamoto puso en funcionamiento su nodo y un minero con el fin de comenzar a generar los bloques de la red.** Durante varios días Nakamoto hizo este trabajo él solo, era el único nodo de la red. En ese momento, Bitcoin por irónico que parezca, estaba totalmente centralizado porque el único nodo y minero estaban en manos de una sola persona.

Sin embargo, **a los pocos días se unió a la red el conocido Hal Finney**, creando el segundo nodo de la red. En ese momento, cuando Finney puso en funcionamiento su nodo, paso lo siguiente:
1. **El nodo de Finney** no tenía información alguna: no había Blockchain, no tenía historial, estaba vacío. 
2. **Comenzó a buscar algún nodo conocido** sin necesidad de un intermediario y se encontró con el nodo de Satoshi, quien ya llevaba varios días funcionando y con un historial creado. 
3. **El nodo de Finney se conectó y comenzó a sincronizarse con el nodo de Nakamoto,** teniendo cuidado de verificar toda la información que le fuera entregada. Una vez sincronizados, el nodo de Nakamoto y Finney tenían el mismo historial y un control 50/50 de la red (Finney también era un minero). 

![[197.B4_finney.png]]

En este punto, la red pasó de ser de una red centralizada a ser una red débilmente distribuida, pero era un primer paso. El protocolo de Bitcoin había sido creado para que a medida que más nodos se conectaran, estos nuevos nodos tuvieran la misma relevancia que el resto.

El proceso que se acaba de describir arriba, se mantiene hoy en día en Bitcoin. Cada vez que una persona instala un nodo completo de Bitcoin, este nodo hace exactamente el mismo proceso: buscar los nodos que están activos en la red, sincronizar y verificar la información, y al sincronizarse, se vuelve parte del sistema de consenso protegiendo a la red de cualquier manipulación. 

Un punto importante a tener en cuenta son los controles de la red. Por ejemplo, si Bitcoin pasaba a 100 nodos y 20 mineros, los nodos tendrían el 1% de peso en el consenso de la red (1% x 100 nodos = 100% del consenso) y los 20 mineros se dividirán la capacidad de generar bloques, de acuerdo a su poder minero. En este punto hay varios posibles escenarios:
1. **Si el 51% de los nodos está de acuerdo con lo que hacen los mineros,** entonces su bloque será aceptado y el resto de la red se le unirá en consenso. 
2. **Si el 51% de los nodos rechaza el trabajo de los mineros,** entonces el bloque será rechazado y ese será el consenso de la red.  
3. **Si hay cambios en las reglas de consenso de algunos nodos,** entonces se producirá un ==hard fork,== dividiendo a la red y su Blockchain en dos partes:
    - Los que aceptan las nuevas reglas de consenso.
    - Los que no reconocen las reglas de consenso.
4. **Si hay cambios en las reglas de consenso pero son opcionales o no vitales,** entonces estamos ante un ==soft fork.== Esto no romperá el consenso de la red, pero habrá una parte de ella que no será capaz de interpretar la información, pero si verificar que el resto es correcto.

Como se puede ver, el proceso de buscar los nodos es lo realmente vital para el funcionamiento de una red P2P y su descentralización. 

**En la actualidad, Bitcoin logra esto gracias al uso de un derivado de Kademlia y Gossip Protocol (dos protocolos centrados en ofrecer una red P2P totalmente descentralizada). Además, con el fin de acelerar la búsqueda de nodos, Bitcoin ha creado los llamados “Supernodos”, que nos son más que nodos especiales que se dedican a crear tablas de nodos completos de Bitcoin, a los cuales los nuevos nodos pueden conectarse para empezar la sincronización.** 

La idea es acelerar el proceso de unión a la red, ya que los “Supernodos” solo son una “guía”, ya no son capaces de proveer más información que direcciones de nodos. Esto es vital para evitar una búsqueda de mucho tiempo en una red como Internet donde hay cientos de millones de dispositivos conectados, y que resulta mucho más sencilla y segura que usar una lista escrita en un foro de Internet.

###  Kademlia
Se trata de un protocolo de comunicación _peer-to-peer_ que implementa tablas hash distribuidas. 

Diseñado por Petar Maymounkov y David Mazieres para descentralizar las redes informáticas P2P.

La estructura de la red en Kademlia está representada por un árbol binario, en el que cada nodo (la hoja del árbol) tiene su propio identificador único que define su posición en el árbol. Esta es una de las muchas versiones de los sistemas DHT.

La red Kademlia se caracteriza por tres elementos constantes que son: 
1. **Elemento Alfa:**  
    Un pequeño número que representa el grado de conexiones paralelas en la red, generalmente 3;
2. **Elemento B:**  
    Tamaño en bits (número de bits) de las claves que identifican los nodos y los datos almacenados y recibidos; en la versión básica de Kademlia es 160, la longitud del hash de la función SHA-1;
3. **Elemento K:**  
    Número máximo de contactos almacenados en un contenedor, generalmente 20.

El primer y tercer elemento son elementos estándar dentro del protocolo Kademlia, mientras que el segundo elemento es una mejora agregada por diversos protocolos derivados de Kademlia. Tienen como finalidad crear un medio de identificación por hash de los nodos, datos y funcionamiento de red, con el fin de evitar colisiones.

####  Nodos dentro de la red Kademlia
La red Kademlia consta de una serie de nodos cooperativos que se comunican entre sí y almacenan información entre ellos.

**Cada nodo tiene un ID de nodo, un número binario pseudo-único que identifica y especifica la ubicación del nodo en la red.**

Un nodo es simplemente un usuario de red, una estación de trabajo que ejecuta una aplicación que admite un protocolo de red determinado: en este caso Kademlia.

Además de la dirección IP, el nodo tiene una clave sobre la base de la cual puede ser reconocido y encontrado en la red. Dentro de la red, un bloque de datos (valor) también se puede asociar con una cadena binaria B de longitud fija (clave de valor). El nodo, cuando necesita valor, lo busca en los nodos más cercanos a la clave. Un nodo necesita almacenar un valor y lo almacena en los nodos más cercanos a la clave.

![[198.B4_kademilia.png]]

Para el correcto funcionamiento de los nodos dentro de una red Kademlia, es necesario que se respeten los siguientes puntos básicos para los mismos:

####  ID de nodo
Los equipos de la red se identifican por sus direcciones IP y claves que definen su ubicación en Kademlia. 

El ID de nodo es un número binario con una longitud de **B = 160 bits.**

En la versión básica de Kademlia, cada nodo selecciona su ID de acuerdo con un procedimiento pseudoaleatorio indefinido. Es importante que cada ID de nodo sea único e igualmente distribuido; de eso se trata el diseño de red.

####  Claves
Los datos almacenados en Kademlia se definen como un valor asignado a la clave correspondiente.

Esto se debe a las propiedades de las [tablas hash distribuidas](https://es.wikipedia.org/wiki/Tabla_de_hash_distribuida). Los datos almacenados o recibidos de la red deben tener una longitud de clave de B. Es así como los ID de nodo también deben distribuirse por igual. Hay varias formas de garantizar esto. **El más popular es crear un hash utilizando una función de hash segura SHA-1 (o cualquier otra función hash que agregue esta capa de seguridad).** Los pares se almacenan en los nodos cuyo ID está más cerca de la clave.

####  Distancia: Métrica XOR
La operación de Kademlia se basa en gran medida en el uso de operaciones XOR (OR eXclusivo) como métricas. La distancia entre claves o ID de nodo (por ejemplo, x e y) se define de la siguiente manera:

==**distancia (x, y) = x ^ y**==

Donde “^” representa el operador XOR. El resultado se obtiene de la operación XOR realizada en cada bit de los argumentos. **E****s la operación más importante del protocolo Kademlia, porque es la responsable de la correcta determinación de la proximidad entre nodos y, entre las claves y un nodo.**

Un ejemplo de esto lo podemos ver en la siguiente tabla:

|Tabla de Verdad de Xor|
|---|---|---|
|a|b|a XOR b|
|0|0|0|
|0|1|1|
|1|0|1|
|1|1|0|

- **Los nodos de Kademlia organizan sus contactos siguiendo este esquema,** con el fin de que otros nodos tengan un máximo de k contactos de todos sus conocidos. Estos son los denominados contenedores k. Los contenedores se organizan en función de la distancia entre el nodo y los contactos en el contenedor. 
- **Como resultado de esta función,** Kademlia garantiza que los distintos subconjuntos de la red P2P puedan interconectarse unos con los otros por distintos caminos, almacenando los nodos de mayor alcance (aquellos con mayor frecuencia de conexión) al final de la lista de nodos conocidos, y los nodos de menor alcance (aquellos con menor frecuencia de conexión) se colocan al principio de la lista de nodos conocidos. 
- **De esta manera, este sistema garantiza que toda la red esté conectada.** Asegura que los nodos tengan conexiones provenientes de distintos subconjuntos de la red y garantiza que la red pueda ser recorrida al completo sin importar si varios de los nodos caen, agregando resiliencia.

![[198.B4_xor.png]]

####  Tamaño de contenedor
En Kademlia, la constante "k" se establece en 20, lo que hace que sea muy poco probable que en redes grandes los contactos en cualquier contenedor puedan desaparecer en una hora.

Al intentar calcular esta probabilidad, se debe considerar la política que lleva a que los contactos de larga duración almacenados en la matriz sean preferidos como contactos más recientes. 

**"k" es el valor del sistema del protocolo de red Kademlia.** 

Este valor por supuesto puede cambiar a valores mucho mayores para agregar mayor seguridad, pero al mismo tiempo se incrementa un poco la latencia entre las distintas partes de la red. 

####  Contactos
Los contactos en Kademlia se almacenan en forma de tres de los siguientes elementos:
1. ID de nodo: ID de nodo
2. Dirección IP
3. Puerto UDP

- Los diseñadores de Kademlia no tuvieron en cuenta el uso de direcciones IPv6 o protocolo TCP / IP en lugar de UDP y la posibilidad de que un nodo tenga varias direcciones IP. 
- En Kademlia es importante enviar mensajes rápidamente entre nodos. Para ello, se utiliza un protocolo de comunicación sin conexión UDP. 
- ==UDP== es un protocolo sin conexión, por lo que no hay sobrecarga para el establecimiento de la conexión y el seguimiento de la sesión (a diferencia de TCP). Tampoco existen mecanismos para controlar el flujo y la retransmisión de datos. La ventaja de tal simplificación de la estructura es la mayor velocidad de transmisión de información y la falta de tareas adicionales que deben ser manejadas por el usuario que utiliza este protocolo.

Por supuesto, esto también tiene algunos problemas de seguridad y de integridad de datos que son tratados por diferentes mecanismos por las aplicaciones que usan Kademlia. En especial, los desarrolladores de sistemas P2P que usan Kademlia y UDP, deben crear protecciones contra el spoofing ( suplantación de identidad) , los ataques DDoS, entre otras amenazas. 

####  Protocolo
La documentación original de Kademlia dice que el protocolo tiene cuatro procedimientos de conexión remota.

1. PING
2. STORE
3. FIND_NODE
4. FIND_VALUE

También especifica otros procedimientos que deben ocurrir durante su llamada como algún otro protocolo. 

Es bueno agregar estos procedimientos y otros protocolos a lo que llamamos protocolo Kademlia. Al comunicarse en la red, cada nodo (enviando un RPC o cualquier otro mensaje) proporciona información sobre su destinatario en forma de dirección IP, puerto UDP e ID de nodo.

#####  1 | PING
Este procedimiento RPC implica que un nodo envía un mensaje PING a otro nodo que se supone que responde con un mensaje PONG si está activo.

El procedimiento tiene un efecto de dos factores: el destinatario del mensaje PING debe actualizar el contenedor que corresponde al remitente, y si hay respuesta, el remitente debe actualizar el contenedor correcto para el destinatario. Todos los paquetes de rutinas RPC requieren que contengan el ID de nodo asignado por el remitente. Es un número pseudoaleatorio de longitud B (160 bits). 

También debe ser posible responder al mensaje PING con el procedimiento RPC para forzar o permitir que el originador (el remitente del procedimiento RPC) proporcione información adicional a su destinatario. Puede ser una dirección IP diferente o un conjunto de direcciones IP, o el protocolo preferido para futuras comunicaciones. El mensaje se usa al agregar contactos al contenedor y durante la conexión de inicio.

#####  2 | STORE
El remitente del mensaje RPC STORE proporciona una clave y un bloque de datos y requiere que el destinatario almacene los datos y los ponga a disposición para búsquedas posteriores por clave. 

Esta es una operación básica para compartir datos en la red Kademlia, no iterativa.

#####  3 | FIND_NODE
El procedimiento FIND_NODE toma una clave de 160 bits como parámetro: El ID del nodo que se busca.

El destinatario del mensaje devuelve hasta k contactos en forma de tres, que sabe que están más cerca de la clave. El destinatario debe devolver triples si es posible. Puede devolver menos de k contactos siempre que devuelva todos los contactos que conoce. Esta es la operación básica de búsqueda de nodos y, por lo tanto, recursos en la red Kademlia no iterativa.

#####  4 | FIND_VALUE
El procedimiento FIND_VALUE toma una clave de 160 bits del valor buscado como parámetro. 

Si el valor de clave correspondiente está presente en el receptor, los datos asociados se devuelven al iniciador del procedimiento.

De lo contrario, el procedimiento es equivalente a FIND_NODE y se devuelve el conjunto de los k contactos más cercanos a la clave buscada. Esta es una operación básica de búsqueda de recursos de Kademlia no iterativa.

## U2. Descentralización
###  Descentralización (Video)
![[199.B4.Descentralización.mp4]]
[Descentralizacion](https://app.web3mba.io?wvideo=yb3idnrmip)

Ya no solo por el white paper de Satoshi, sino por toda la comunidad que existía en aquella época a su alrededor. Estos eran los cypherpunks, y lo que buscaban entre ellos era tener un sistema que, por un lado, no estuviese controlado por el Estado y, por otro lado, tuviese una privacidad por diseño y por matemáticas que no dependiese de un organismo central que pretenda mantenerla, o en el que haya que confiar para que la mantenga. A su vez, buscaban distintos tipos de niveles de encriptación. Cuando un sistema falla, debe haber un sistema secundario. Si el secundario falla, debe haber un terciario. Esto se llama esteganografía.

Dentro de esta comunidad inicial se encuentran los primeros empleados de Sound Microsystems, quienes fueron los creadores de la lista de correo de Cypherpunks. Podemos ver un poco cuáles son esas ideas originales. No se basaba tanto en un déficit financiero, como podríamos pensar hoy en día, sino que estaba muy centrado en separar la privacidad del Estado. Tal es el hecho que, a día de hoy, tiene millones en su cartera y se dedica, año sí, año no, a seguir denunciando al gobierno de Estados Unidos por violaciones de privacidad. Gente que, en un principio, tenía muy claro el núcleo de... Oye, queremos, por un lado, la privacidad, y queremos, por otro lado, la seguridad, así como la independencia de un tercero para poder actuar libremente.

Para comentar brevemente las diferencias entre centralizado, descentralizado y distribuido, debemos empezar diciendo que no son conjuntos disjuntos. Centralizado y descentralizado son, evidentemente, tipos opuestos, pero ambos pueden ser distribuidos. Solo será no distribuido en sus etapas más tempranas. Si montas una startup pasado mañana, en esos primeros días lo más probable es que levantes un servidor web que represente tu negocio, una página web para ofrecer un servicio. Ojalá te vaya muy bien y tengas que escalarlo. Cuando necesites escalarlo, ya no será suficiente tener una única implementación de tu servidor. Tendrás que separar capas entre interfaces, middleware y capa de datos, y empezar a escalar horizontalmente la forma en que manejarás cada una de las peticiones que te llegan. Para lograr esto, lo que montarás es un sistema distribuido.

Facebook, Twitter, B2Me, mi propia empresa, todos nosotros somos sistemas distribuidos en cuanto hemos alcanzado cierto tamaño. ¿Cuál es la diferencia entre un sistema centralizado y uno descentralizado? El punto único de fallo. En cualquier sistema centralizado, siempre hay una entidad que puede desconectar el servicio y acabar con la operación. Siempre puede haber una entidad centralizada, como un gobierno, que puede denegar a tu empresa o a tu organismo social el acceso a su servicio.

¿Qué sucede cuando se pasa de un sistema centralizado a uno descentralizado? Que tenemos dos obligatoriedades. Un organismo descentralizado siempre debe ser distribuido. ¿Por qué? Porque no hay un punto único de fallo, ya que no hay un máster que dirija todo, y por ello necesitamos que entre todos mantengamos la estructura. Si decimos que un sistema descentralizado debe ser distribuido, en el fondo estamos hablando de duplicaciones del mismo código que todos estamos ejecutando al mismo tiempo y compartiendo esa información. Con esto, ganamos y perdemos; es un poco lo que hemos comentado en unidades anteriores: robustez, rendimiento y la crítica posibilidad de ser censurados por un sistema externo. Para cada caso de uso, tendremos que elegir cuál es la mejor solución.

###  Descentralización
####  Su importancia para las redes Blockchain y las criptomonedas
¿Por qué necesitamos la descentralización?  
¿Es realmente necesaria?

La respuesta corta es:  
Sí, necesitamos de la descentralización hoy más que nunca. 

La descentralización se ha mostrado como el camino correcto para construir servicios de amplio acceso para todos, para evitar que pocos puedan controlar esos servicios y también para evitar que cualquiera con poder pueda simplemente decretar su extinción porque así lo desea.

####  Acceso para todos:  Libertad y privacidad 
El primer punto a favor de la descentralización es que nos permite crear estructuras en la que todos podemos participar de forma libre, plena y privada.

Un servicio basado en Blockchain pasa de las fronteras y de ideas anacrónicas sobre cómo acceder a un determinado servicio. 

**El mejor ejemplo de esto son las criptomonedas. Cualquier persona en el mundo puede acceder a ellas para tener libertad económica y financiera, a la vez que protege su privacidad.** 

> Te permite obtener, desde cualquier parte del mundo, una cantidad en ETH con el fin de interactuar con el enorme ecosistema de aplicaciones descentralizadas de Ethereum.

Este simple hecho te brindaría acceso a un conjunto de aplicaciones financieras que de otra forma sería imposible de alcanzar y podrías usar la mayor parte de ellas sin necesidad de pasar por procesos de KYC que violen tu privacidad. 

Por supuesto, esto no solo aplica a esa criptomoneda. La práctica totalidad de las criptomonedas te permiten acceder a funciones muy parecidas. Bien sea porque quieres usarlas como medio de ahorro, inversión, etc. o como sistema de pago internacional, remesas o cualquier otro uso que desees. Después de todo, la descentralización de Blockchain y las criptomonedas apunta a dos cosas: total libertad y respeto a tu privacidad. 

Esos principios no solo aplican al dinero, sino también a otros servicios. Por ejemplo, puedes usar una identidad digital basada en Blockchain para usar tus datos para acceder a una red social descentralizada. Sin embargo, con esa misma identidad digital basada en Blockchain, puedes proteger tu nombre, edad y otros datos sensibles al acceso de terceros no deseados. Todo eso mientras las personas de la red pueden verificar que cualquier cosa escrita por ti realmente lo es, haciendo más difícil con ello los bulos y las fake news. 

####  Descentralizando el control
![[200.B4_descentralizacion.png]]

Permite crear estructuras de control que no están en manos de un reducido grupo de personas, sino que nos coloca a todos a un mismo nivel.

La descentralización nos ayuda a igualar las reglas de juego entre los poderosos y los que no tienen tanto poder, a la vez que nos permite a todos participar en un sistema bajo un conjunto de reglas bien definidos.

Esto podemos ejemplificarlo de forma muy sencilla:
- **Un minero de Bitcoin puede tener un enorme poder de minería, pero si hace mal su trabajo, la red trabajará en conjunto para rechazar ese trabajo, evitando que manipule a su favor el sistema.** 
- Incluso en caso de que ese poder de minería alcance o supere el 51%, los integrantes de la red detectarán el caso y actuarán en consecuencia para evitar que tal poder siga actuando en su contra.

> Suena idealista, pero esta es una realidad que se ha visto en la práctica dentro del mundo Blockchain.

En Bitcoin, por ejemplo, hubo un grupo minero que alcanzó el 51% de todo el poder minero y, al darse cuenta de esto, la comunidad advirtió sobre el hecho. Al poco tiempo, ese grupo minero comenzó a perder poder minero y dejó de funcionar. Este es un ejemplo de la comunidad actuando en contra de la centralización, protegiendo lo más preciado para ellos: La descentralización de la red. 

Vimos otro ejemplo de descentralización cuando Gavin Andresen trató de imponer su visión sobre el tamaño de los bloques de Bitcoin, intentando impulsar una propuesta de mejora de Bitcoin (BIP) pasando de los canales regulares. 

**La comunidad rápidamente actuó en su contra y por ello fue expulsado del desarrollo de Bitcoin. Desde entonces, Andresen ha pasado de ser una gran figura respetada en la comunidad, a simplemente, ser parte de su historia, una que terminó de la peor manera posible.**

 Una historia que tiene un mismo reflejo en Bitcoin SV, un proyecto que languidece lentamente mientras sus creadores intentan sostener un castillo de naipes formado de mentiras y un control centralizado absurdo en su desarrollo. 

####  Generación de valor con reglas claras
En consonancia con el control tenemos la generación o acuñación de monedas.

¿Qué detiene a un banco central de imprimir dinero sin control?  
La respuesta es clara: Absolutamente nada. 

**Si así lo desean, pueden imprimir tanto dinero como deseen. No tienen límite y ellos mismos lo reconocen. Ese poder es un verdadero peligro, uno que ya nos ha tocado vivir en muchas ocasiones.** 

La descentralización de Blockchain y las criptomonedas nos ayuda a controlar esto, por medio de reglas muy claras que indican la forma y cantidad de dinero que se puede imprimir. **Una idea que usualmente se suele usar en contra de los pro-cryptos es que el** [**modelo deflacionario**](https://economipedia.com/definiciones/deflacion.html)**, que muchas monedas usan, es insostenible y que llevaría a una espiral deflacionaria sin control que haría que la economía de los países se contraiga a mínimos históricos.**

Apuntan a ese supuesto y lo atacan con la necesidad de crear [sistemas inflacionarios](https://economipedia.com/definiciones/inflacion.html), para resolver el problema. La realidad es que los desarrolladores de muchas criptomonedas no son insensatos. Conocen bien las debilidades y fortalezas de cada sistema (deflacionario e inflacionario) y, por ello, en el ecosistema puedes ver criptomonedas que usan un sistema u otro dependiendo de su objetivo. 

> Bitcoin es deflacionario, está diseñado para que solo existan unos 21 millones de monedas y nada más, y toda esa emisión no terminará hasta el año 2144.

Todo su sistema económico o ==tokenomics,== se sostiene sobre la base de un sistema en el que los mineros crean una cantidad de monedas en cada bloque (6,25 BTC en la actualidad), y esa cantidad se reduce a la mitad cada 4 años aproximadamente. 

**Cuando ya se hayan emitido todos los BTC, los mineros seguirán su trabajo bajo una premisa muy clara:** R**ecibirán comisiones por los usuarios de la red y esas comisiones tendrán tal valor, que por si solo cualquier minero querrá mantenerse trabajando en la red.** Hasta el momento la premisa se mantiene, porque BTC paso de ser una moneda de valor 0 a tener un valor superior a los 69 mil $ USD. ¿Qué precio tendrá BTC para 2144? Nadie lo sabe, pero de seguir el desarrollo hasta el momento, es posible que sea muy superior a esa cifra. 

**En comparación, Ethereum sigue un modelo inflacionario, uno pensado para producir unos 18 millones de monedas al año, y que se ha mantenido prácticamente inamovible desde su creación.** Sus mineros y usuarios saben el nivel de inflación que tendrá ETH, y con base en eso, pueden crear modelos predictivos sobre distintos elementos económicos y financieros para su ecosistema, especialmente para sus aplicaciones DeFi. En ambos casos, las reglas que rigen la generación de monedas son claras. Siempre se han cumplido y se rigen por medio de software ejecutada de forma descentralizada. Nadie puede con un simple botón agregar más monedas o hacerse con el control de todas ellas. 

**Pero, para un banco central, controlar la emisión o hacerse con el control de las monedas es tan sencillo como presionar un botón para agregar los 0 que quiere en su base de datos, o emitir un boletín para subir al 100% el encaje legal del país. Con ambas acciones, no solo te hacen más pobre (por la devaluación de la moneda) sino que frenan la capacidad para acceder a créditos, pagar deudas y en definitiva, terminan empobreciendo a toda la población de forma general.** 

####  Evitando la censura
Otro gran beneficio de la descentralización es que evita la censura. 

Por ejemplo:  
Un país ha decidido envenenar sus servidores DNS y filtra toda conexión en Internet para evitar que puedas navegar por ciertos sitios que ellos consideran “ofensivos y peligrosos”. 

**Una red descentralizada como la presente en la Blockchain ayudaría a evitar que este tipo de acciones realmente censuren todo tipo de disidencia, a la vez que protege su privacidad.** 

Tres proyectos descentralizados que buscan evitar esto son: 
1. IPFS
2. Orchid
3. Ethereum Name Services

#####  1 | IPFS
No es Blockchain, pero es descentralizado y está íntimamente relacionado con proyectos Blockchain como Ethereum o Filecoin (el cual es un derivado de IPFS). 

IPFS permite que puedas acceder a documentos e información de forma totalmente descentralizada, de manera que puedas evitar la censura que un tercero pueda imponerte.

#####  2 | Orchid
Es un sistema de VPNs que permite enmascarar y cifrar tu conexión entre varios puntos a los fines de evitar la censura. 

Los túneles VPNs de Orchid, son una forma sencilla de evitar estas prácticas manteniendo la seguridad de tu conexión, y el sistema funciona gracias a la tecnología Blockchain y una red descentralizada de nodos desperdigados por todo el mundo. 

#####  3 | Ethereum Name Services 
Permite acceder a servicios DNS y de identidad digital seguros y no manipulables, para que puedas navegar o contactar con personas en todo el mundo, teniendo la seguridad de que no podrán ser suplantados por un tercero. 

Tal como se puede observar en todos los casos mencionados, la descentralización resulta fundamental y de allí que todos debamos proteger este espacio con el fin de seguir teniendo servicios seguros, privados y confiables para todos.

###  Modelos de funcionamiento de las redes Blockchain
Las redes Blockchain pueden organizarse en distintos modelos de funcionamiento. 

1. Centralizada 
2. Descentralizada 
3. Distribuida

Cada una de estas configuraciones tiene sus ventajas, inconvenientes, diferencias y cosas en común.

![[201.B4_modelos.png]]

####  1 | Redes centralizadas
Una red de ordenadores centralizada es aquella en la que cada ordenador que la conforma es periférico y está conectado a una unidad central.

Son conocidas generalmente como redes cliente-servidor, porque cada computador (cliente) debe conectarse a un servidor para solicitar y recibir la información deseada.

Así, esta unidad central ejerce todo el control y gestión de la red. Es decir: toda la responsabilidad y poder de decisión recae sobre un solo elemento, en este caso una máquina o una entidad.

![[201.B4_centralizada.png]]
_Imagen 1: Ejemplo de una red centralizada_

**Esta configuración de red es la más utilizada debido a su simplicidad y escalabilidad.** 

Las redes centrales son capaces de manejar grandes cantidades de información rápidamente, lo que las hace perfectas para servicios de alta demanda. Esto se debe a que un servidor maneja el consenso total de la red, sus datos son en toda extensión: la realidad de la red. 

Por supuesto, esto significa que este tipo de redes son las más inseguras y menos resilientes a los ataques. Veamos algunos casos para entender esto:
1. **Si un cliente pide un dato al servidor, la respuesta del mismo resultará 100% confiable para el cliente, incluso aunque esa información sea errónea.** El cliente no tiene forma de saber si la data ha sido manipulada de alguna manera y, por tanto, este tipo de situaciones pueden suceder perfectamente. 
2. **Otro ejemplo de su debilidad lo vemos en su resistencia a los ataques.** Supongamos que un hacker ataca al servidor y logra acceder al mismo. Ese hacker no solo puede robar toda la información de la red, sino que puede directamente dañarla y dejar a la red completamente fuera de servicio.

**Generalmente, puedes ver este tipo de arreglos dentro de las empresas.** Esa es la razón por la cual un fallo es capaz de afectar a todos dentro de la empresa. Por supuesto, para evitar esto se tienen copias de seguridad y servidores paralelos. Pero como el funcionamiento de la red sigue completamente centralizada, solo se mitigan los peligros, no se solucionan. 

**Un buen ejemplo lo podemos ver en Blockchains como Ripple. Si bien la red cuenta con varios nodos repartidos en todo el mundo, las decisiones para su desarrollo y control están centralizadas en la empresa Ripple.** Otro ejemplo en Blockchain es la plataforma Hyperledger: un proyecto de software libre cuya finalidad es crear redes Blockchain para uso empresarial y con un control centralizado ajustado a las necesidades de dichas empresas. Este desarrollo fue pensado para ser controlado por empresas, limitando o incluso negando el acceso a la red por parte de elementos fuera de la empresa.

**Ambos casos (Ripple y Hyperledger) son redes muy rápidas, capaces de hacer frente a gran cantidad de usuarios de forma concurrente. Pero el hecho de que sean redes centralizadas limita su confiabilidad, seguridad, privacidad y resiliencia.** 

####  2 | Redes descentralizadas
Las redes descentralizadas son aquellas en las que no existe una sola unidad central.
En su lugar existe una serie de ordenadores que funcionan en conjunto para controlar y manejar la red.

De esta forma se agrega un cierto nivel de tolerancia a fallos gracias a que este conjunto de ordenadores asume determinadas tareas de la red.

**Sin embargo, en este tipo de redes aún existe riesgo de un fallo catastrófico total. Esto es posible porque las redes descentralizadas aún pueden fallar si queda fuera de servicio el coordinador de la red.** Con la caída de un ordenador coordinador, el resto de los ordenadores de esa sub-red quedan sin servicio y desconectados de la red principal. Si por ejemplo, el ordenador coordinador de red principal cae, el resto de las subredes quedan desperdigadas. En cualquiera de los casos, la pérdida de un coordinador llevaría a una desconexión de menor o mayor magnitud.

Una concepción errónea sobre este tipo de redes es que la actuación de los coordinadores es completamente autónoma. La verdad es que estos actúan como una unidad central dentro de una red más grande. Un vestigio de las redes centralizadas que aún sobrevive dentro de este modelo.

Un buen ejemplo de este tipo de redes son:
-  Facebook
- Twitter
- Google

Todos estos servicios cuentan con subredes dentro de una gran red y en su conjunto son capaces de manejar todos los servicios que prestan. 

**En el mundo de las criptomonedas, dos ejemplos de este tipo de redes son:**
- Polkadot
- Solana

#####  Polkadot
Acceder a la red Polkadot implica tener un conjunto de nodos (nodos, collators, nominadores y validadores). Cada nodo tiene su función específica y para acceder a su trabajo requiere de hardware, software y staking distintos.

 Sin embargo, los números de nodos que puede alcanzar Polkadot son pequeños en comparación con Bitcoin u otras redes. Y la razón de ello es que, a mayor tamaño y velocidad, la red requiere de una cantidad de recursos que difícilmente pueden ser alcanzados (a menos que se agrupen dichos nodos en servicios en la nube). Como resultado, la red Polkadot no supera los 1700 nodos, distribuidos en menos de 120 localidades.

![[201.B4_polkadot.png]]
_Imagen 2: Mapa de nodos dentro de Polkadot_

#####  Solana
Solana se encuentra en una situación parecida. 
Con sus 1749 nodos validadores en activo, 22 nodos Superminority y 1678 nodos RPC (los encargados de dar acceso a app como MetaMask), la red está bien descentralizada. Pero en el mapa podemos ver que su distribución geográfica está sobre todo centrada en América del Norte y Europa. 

Esta condición, junto a la existencia de los 22 Superminority, hace de Solana una red que sufre de problemas de inestabilidad, hasta el punto de haber sido reiniciada en varias ocasiones por este problema. Esto deja claro que su descentralización es débil, y eso explica por qué la comunidad indica que la descentralización de Solana es incompleta. 

![[201.B4_solana.png]]
_Imagen 3: Dashboard mostrando los datos de la red Solana y la distribución de nodos._

####  3 | Redes distribuidas
Finalmente, tenemos a las redes distribuidas en las que no existe ningún centro de control individual o colectivo.

Significa que cada una de las partes en una red distribuida son iguales y no tienen la capacidad de filtrar o alterar la información dentro de la red, porque de hacerlo, el resto de la red detectaría el cambio y se podrían tomar medidas para remediar dicha manipulación. 

Así, gracias a esta estructura, si algún ordenador falla o es atacado este no desconectará al resto o afectaría el funcionamiento del resto. 

> El ejemplo más claro de este tipo de redes es Internet. Desde su nacimiento, Internet fue pensado para ser una red completamente distribuida.

En principio, fue una red muy centralizada debido a los pocos ordenadores que estaban conectados en ese momento. Pero a medida que aumentaron los ordenadores interconectados, Internet pasó a convertirse en una red distribuida.

#####  BitTorrent
Otro buen ejemplo de redes distribuidas son las redes de compartición de archivos P2P como BitTorrent. 

Esta red está formada por más de mil millones de usuarios y cerca de 250 millones de ellos se mantienen en activo de forma diaria. La red es tan grande que poco más del 27% del tráfico de Internet en todo el mundo tiene su origen en esta red. 

**Con esos datos está claro que BitTorrent es la mayor red distribuida después de Internet** y no debería sorprendernos, puesto que su tecnología ha demostrado no solo adaptarse a los tiempos, sino también proveer de un medio rápido para compartir información sin limitaciones. 

#####  Bitcoin
El mejor ejemplo de red distribuida en el mundo Blockchain lo podemos ver en Bitcoin. 

**Actualmente, la red de Bitcoin cuenta con más de 15 mil nodos públicos activos y hay potencialmente la misma cantidad en nodos privados (un total de 30 mil nodos desperdigados por todo el mundo).**

Esto convierte a Bitcoin en la red de criptomonedas más grande de la actualidad, y sus desarrolladores abogan para que siga creciendo, para de esa forma seguir fortaleciendo la red.

##  U3. Qué son los Smart Contracts
### Qué son los Smart Contracts (Video)
![[202.B4._Qué_son_los_Smart_Contracts.mp4]]
[Que son los Smart Contracts](https://app.web3mba.io?wvideo=53mfvgpjg3)

Antes de indagar en lo que es un smart contract, primero debemos recordar qué significa un contrato. Un contrato no es más que un acuerdo entre dos o más partes, un entorno donde se define lo que se puede hacer, cómo se puede hacer y qué sucede si algo no se cumple. Es decir, son unas reglas del juego que permiten a todas las partes que lo aceptan entender en qué consistirá la interacción que van a realizar. Hasta ahora, los contratos han sido medios verbales o documentos escritos. Estos documentos están sujetos a las leyes y jurisdicciones territoriales y, en ocasiones, requieren de notarios, lo que implica más costos, tiempo y la intervención de terceros en el proceso. Debido a esto, no son accesibles para cualquier persona. Y esto no es lo peor; los contenidos de los contratos pueden estar sujetos a interpretación.

En cambio, un smart contract o contrato inteligente es capaz de ejecutarse y hacerse cumplir por sí mismo de manera autónoma y automática, sin intermediarios ni mediadores, y sin interpretaciones distintas a las que se especifican en la propia programación del mismo. Así, básicamente, un smart contract se trata de un script, un código informático, escrito en un lenguaje de programación definido y aceptado por la red blockchain sobre la que se ejecuta. Por otro lado, un smart contract puede ser creado y llamado por personas físicas y jurídicas, pero también por máquinas u otros programas que funcionan de manera autónoma. Un smart contract tiene validez sin depender de autoridades. Esto se debe a su naturaleza. Es un código visible para todos y que no se puede modificar al existir sobre la tecnología blockchain. Esto le confiere un carácter descentralizado, inmutable y transparente.

La primera vez que se tiene constancia pública de los smart contracts es a través del jurista y criptógrafo Nick Szabo, quien mencionó públicamente el término en un documento en internet en el año 1995. Dos años después, en 1997, desarrolló un documento mucho más detallado explicando los smart contracts y un glosario básico aplicable a los mismos. Por ello, se considera a Nick Szabo como el padre de los smart contracts, incluso en momentos en que la tecnología era inaplicable. La razón de esto es que no había un sistema lo suficientemente autónomo y seguro para hacer realidad esta visión.

La tecnología para hacer realidad los smart contracts llegó con la creación de Bitcoin. Satoshi Nakamoto se dio cuenta de la necesidad de un lenguaje de programación capaz de permitir realizar operaciones dentro de Bitcoin de forma descentralizada, y que dicho lenguaje fuera fundamental para la protección de los activos en la red. La idea se desarrolló hasta crear el conocido como Bitcoin Script, el primer lenguaje de programación para smart contracts del mundo. Si bien Bitcoin Script es un lenguaje limitado en su alcance, cumple perfectamente con las características básicas de los smart contracts racionalizados por Nick Szabo. De hecho, Bitcoin Script ha sido utilizado para crear protocolos más complejos dentro de Bitcoin, como OmniLayer, ColorCoins, Counterparty, RGB, Lightning Network y otros que pueden existir.

Adicionalmente, Bitcoin también cuenta con algunos smart contracts ya creados que se ejecutan por defecto y de manera transparente para el usuario. Por ejemplo, cada vez que realizas una operación de Bitcoin usando el modelo de transacción, en realidad estás creando un smart contract dentro de la red Bitcoin, en la que transfieres una determinada cantidad de Bitcoin a otra persona, usando tu clave privada y la pública de esa persona, asegurándote de pagar la comisión correspondiente al minero y obteniendo tu cambio, si queda, por la operación que realizas. Ejemplificando, podrían desarrollarse nuevos productos o aplicaciones como, por ejemplo, mercados distribuidos que permitieran implementar contratos P2P y trading en los mercados con Bitcoin, postulándose como un competidor completo al sistema financiero actual.

Un buen ejemplo de esto es BISC, considerado por la comunidad como el primer DEX de criptomonedas. El funcionamiento del sistema hace uso de Bitcoin Scripts y otros lenguajes para garantizar la seguridad de los intercambios que se realizan en esta aplicación. ¡Gracias por ver el video! El funcionamiento de los NFTs como Rare PPS o Spell of Genesis es una muestra del potencial de los smart contracts sobre Bitcoin, utilizando Bitcoin Script. Otro ejemplo es Lightning Network, que es la Layer 2 de Bitcoin. Depende de potentes smart contracts para hacer un puente que lleve tus satoshis de la red mainnet de Bitcoin a la red de Lightning Network, permitiéndote usarlos dentro de la misma.

Otros usos posibles pueden ser para manejar propiedades como automóviles, teléfonos, casas o elementos no físicos. Controlados a través de la cadena de bloques, conforman las llamadas Smart Property. Mediante el uso de contratos y propiedades inteligentes, se permite que el nivel de confianza sea mucho mayor, reduciendo el fraude, los honorarios de mediación para terceros y llevando las operaciones a un nuevo nivel. Y es que los smart contracts se sirven de la tecnología y Bitcoin para existir, algo que beneficia a Bitcoin, pues está atrayendo mucha más atención y cientos de miles de nuevos usuarios a su ecosistema.

Esta lógica que puede aplicarse a las transacciones de Bitcoin se realiza a través del uso de un lenguaje propio, permitiendo que sea la misma blockchain quien determine qué hacer, basándose en las indicaciones programadas. Esto significa que tenemos una transacción con instrucciones que nos permiten realizar una operación con una blockchain. Y es que, además de ser una transacción, también es una transacción de un sistema de datos, que nos permite operar con un sistema de datos. Y es que, además de ser una transacción, también es una transacción de un sistema distribuido e inmutable, brindando una seguridad completa y sin interpretaciones.

Por supuesto, los smart contracts no son exclusivos de Bitcoin y tampoco son el espacio donde más desarrollados se encuentran. Por ejemplo, en Ethereum, los smart contracts de esta red son mucho más sencillos de implementar y las posibilidades de creación son incluso mayores. Debido a esto, Ethereum es considerada la red perfecta para el uso e implementación de smart contracts, aunque existen varios competidores como Polygon, Solana, Algorand o Cardano, entre otros.

###  ¿Qué son los Smarts Contracts?
Un contrato es un acuerdo entre dos o más partes, donde se define lo que se puede, cómo se puede hacer y qué pasa si no se hace. 

Es decir, unas reglas de juego que permiten a todas las partes que lo aceptan entender en qué va a consistir la interacción que van a realizar.

**Hasta ahora los contratos han sido medios verbales o documentos escritos. Estos documentos están sujetos a las leyes y jurisdicciones territoriales, y en ocasiones requieren de notarios. Es decir, más costes, tiempo y terceros que intervienen en el proceso.** Debido a ello, no son accesibles para cualquier persona. Y esto no es lo peor: los contenidos de los contratos pueden estar sujetos a la interpretación.

**En cambio, un Smart Contract o contrato inteligente, es capaz de ejecutarse y hacerse cumplir por sí mismo, de manera autónoma y automática, sin intermediarios, ni mediadores y sin interpretaciones distintas más allá de la que se especifican en la programación del mismo.** Así, básicamente un Smart Contract se trata de un “script” (código informático) escrito con un lenguaje de programación definido y aceptado por la red Blockchain sobre la que se ejecuta. 

Por otro lado, un Smart Contract puede ser creado y llamado por personas físicas y/o jurídicas. Pero también por máquinas u otros programas que funcionan de manera autónoma. Un Smart Contract tiene validez sin depender de autoridades. Esto se debe a su naturaleza: es un código visible por todos y que no se puede cambiar al existir sobre la tecnología Blockchain. Esto le confiere un carácter descentralizado, inmutable y transparente.

####  El nacimiento
La primera vez que se tiene constancia de forma pública sobre los Smart Contracts es a través del jurista y criptógrafo Nick Szabo, quien mencionó públicamente el término en un documento por Internet en el año de 1995.

Dos años después, en 1997, desarrolló un documento mucho más detallado explicando los Smart Contracts y un glosario básico aplicable a los mismos. 

De allí, que se considere a Nick Szabo como el padre de los Smart Contract, incluso en momento en los que su tecnología era inaplicable. La razón de ello, es que no había un sistema lo suficientemente autónomo y seguro para hacer realidad esta visión. 

- **La tecnología para hacer realidad a los Smart Contracts llegó con la creación de Bitcoin.** 
- Satoshi Nakamoto se dio cuenta de la necesidad de un lenguaje de programación capaz de permitirle realizar operaciones dentro de Bitcoin de forma descentralizada y que dicho lenguaje fuera fundamental para la protección de los activos en la red. 
- **La idea la desarrolló hasta crear el conocido Bitcoin Script, el primer lenguaje de programación para Smart Contracts del mundo.** 
- Si bien, Bitcoin Script es un lenguaje limitado en su alcance, este perfectamente cumple con las características básicas de los Smart contracts racionalizados por Nick Szabo. Y de hecho, Bitcoin Script ha sido perfectamente usado para crear protocolos más complejos dentro de Bitcoin (como OmniLayer, Colored Coins, Counterparty, RGB, Lightning Network, entre otros)

**Bitcoin también cuenta con algunos Smart Contract ya creados que se ejecutan por defecto y de manera transparente al usuario. Por ejemplo, cada vez que realizas una operación de Bitcoin usando el modelo de transacción tradicional, en realidad, estas creando un Smart Contract dentro de la red Bitcoin.** En esta operación traspasas una determinada cantidad BTC a otra persona usando tu clave privada y la pública de esa persona, asegurándote de pagar la comisión correspondiente al minero y obteniendo tu cambio (si queda) por la operación que realizas. 

![[203.B4_smart.png]]
  
####  Smarts contracts en Bitcoin
Podrían desarrollarse nuevos productos o aplicaciones como, por ejemplo:
1. **Mercados distribuidos que permitieran implementar contratos P2P y trading en los mercados con Bitcoin, postulándose como un competidor completo al sistema financiero actual.** Un buen ejemplo de esto es Bisq, considerado por la comunidad como el primer DEX de criptomonedas (exchange descentralizado). El funcionamiento del sistema hace uso de Bitcoin Scripts y otras formas de lenguaje para garantizar la seguridad de los intercambios que se dan en esta aplicación.
2. El funcionamiento de los NFTs como [Rare Pepes](https://rarepepes.com/) o [Spell of Genesis](https://spellsofgenesis.com/), son una muestra del potencial de los Smart Contracts sobre Bitcoin usando Bitcoin Script. 
3. Otro ejemplo es la red [Lightning Network](https://lightning.network/), la Layer2 de Bitcoin. Depende de potentes Smart Contracts para hacer un puente que lleve tus satoshis de la red mainnet de Bitcoin la red LN, y que puedas usarlas dentro de la misma de forma libre. 
4. **Otros usos posibles pueden ser para manejar propiedades como automóviles, teléfonos, casas o elementos no físicos controlados a través de la cadena de bloques conforman las nombradas Smart Property.** Mediante el uso de los contratos y con propiedades inteligentes se permite que el nivel de confianza sea muy superior, reduciendo el fraude, los honorarios de mediación para terceras partes y permite que las operaciones se lleven a un nuevo nivel.

  ![[203.B4_smart-btc.png]])

  Los Smart Contracts se sirven de la tecnología de Bitcoin para existir, algo que le viene genial a Bitcoin, pues está haciendo que reciba mucha más atención trayendo cientos de miles de nuevos usuarios a su ecosistema. 

**Esta lógica que puede aplicarse a las transacciones Bitcoin se realiza a través del uso de todo un lenguaje propio, permitiendo que sea la propia Blockchain la que determine qué hacer basándose en las indicaciones programadas. Esto quiere decir que tenemos una transacción con unas instrucciones de forma distribuida e inmutable, dando una seguridad completa y sin interpretaciones.**

Por supuesto, **los Smart Contracts no son exclusivos de Bitcoin** **y tampoco son el espacio donde más desarrollados se encuentran.** En Ethereum los Smart Contracts de esta red son mucho más sencillos de implementar y las posibilidades de creación son incluso mayores. Debido a esto, **Ethereum es considerada la red perfecta para el uso e implementación de los Smart Contracts,** y junto a ella, existen varios contrincantes: Polygon, Solana, Algorand y Cardano.

###  Funcionamiento de los Smart Contracts (Video)
![[204.B4_Funcionamiento_de_los_Smart_Contracts.mp4]]
[Como funcionan los Smart Contracts](https://app.web3mba.io?wvideo=hlkf46d962)

La forma más sencilla de entender cómo funciona un Smart Contract es a través de un ejemplo. Imagina por un momento que estás en una línea de producción de puertas de seguridad, donde el punto más crítico es el brazo robótico, encargado de colocar en su sitio y realizar la soldadura de cada una de las partes de las puertas. Este brazo robótico está programado para llevar a cabo toda su tarea de forma autónoma. Nadie le ayuda; lo único que necesita es que le lleven los materiales necesarios a su ubicación. Hasta ese punto, nada difiere de la realidad industrial que tenemos actualmente. Sin embargo, este brazo robótico es capaz de hacer cosas que, con los medios actuales, un brazo robótico no podría. Una de esas cosas es, por ejemplo, solicitar mantenimiento a las empresas que lo han creado cada cierta cantidad de horas, siguiendo parámetros de mantenimiento recomendados que fueron aceptados por la empresa al momento de adquirirlo.

No solo eso, el brazo puede gestionar el pago de estos mantenimientos por su propia cuenta. Esto es posible gracias a que puede verificar que dicha operación se ha realizado. Es capaz de revisar el hardware, comprobar que se han hecho los ajustes de mantenimiento y verificar que las reparaciones se han efectuado. Entonces, genera un registro completo de toda la operación e informa del mismo a los encargados de la zona de producción. Al mismo tiempo, antes, durante y después del mantenimiento, el brazo robótico mantiene comunicación con el resto de la línea de producción para avisar, por ejemplo, cuándo va a interrumpir su trabajo, el tiempo estimado de la interrupción y, al final, el tiempo real de la parada. También informa que ya está listo para volver a entrar en acción, porque su mantenimiento ha sido exitoso y su capacidad operativa está dentro de los rangos esperados.

Básicamente, el brazo robótico se ha transformado en un ente de trabajo totalmente autónomo, capaz de gestionar su propio mantenimiento y comunicarse con el resto de la línea de producción y la empresa para realizar un seguimiento verificable de su producción y de su estatus en tiempo real. El ejemplo podría parecer una historia de ciencia ficción, pero es tan real que actualmente empresas de todo el mundo se dedican a lograr esto con un solo fin: mejorar la productividad de las empresas, la seguridad dentro de las mismas y entrar en la era de la automatización y descentralización operativa. De hecho, se le conoce con un nombre bastante particular: la industria 4.0, que abarca la inclusión de tecnologías como IoT, inteligencia artificial, robótica y blockchain dentro de nuestras industrias para hacer más eficientes sus capacidades productivas.

Al fin y al cabo, el mantenimiento adecuado del brazo robótico de nuestro ejemplo es lo que asegura una buena operatividad de la empresa. Que él mismo gestione toda esa operativa deja espacio para que las personas dentro de la empresa puedan centrarse en mejorar sus productos u ofrecer nuevos productos adaptados a las necesidades del mercado, así como reducir los gastos y mejorar la producción. Todo lo anterior es posible gracias a los Smart Contracts, ya que estos elementos definen una serie de reglas, acciones y eventos que son aceptadas por todas las partes y que se ejecutan de forma totalmente autónoma. Una vez que se ponen en ejecución, solo pueden alterarse bajo el consenso de las mismas partes, evitando que un contrato pueda ser reescrito de forma unilateral. Esto último es bastante común y generalmente lleva a malos resultados.

La gestión de recursos en este contexto depende de la compra de servidores, discos duros, ancho de banda, equipos de soporte, UPS, generadores eléctricos, etcétera, así como de software para gestionar toda la granja de servidores. Todo ello conlleva un completo reto de administración y gestión de recursos, que muchas veces son limitados frente a una demanda cada vez mayor. Esta realidad lleva a las empresas a usar sus recursos de forma muy poco eficiente y, en el proceso, se producen errores que pueden ser especialmente costosos para la empresa, pero aún más para sus propios clientes. ¿Cómo de costoso? Pues una pérdida total de una granja de servidores, y todo simplemente por un mantenimiento realizado de forma incorrecta y por unos recursos mal gestionados en el tiempo.

¿Ha pasado algo así? La respuesta es que sí. El caso más sonado, aunque no reciente, ha sido el de VH, que perdió prácticamente dos granjas de servidores por errores administrativos de construcción y de mantenimiento acumulados. Errores que pudieron evitarse haciendo un uso eficiente de sus recursos para evitar el triste desenlace que al final ocurrió: la pérdida de millones de sitios web, miles de terabytes de datos y varios negocios afectados por lo sucedido, incluyendo varios servicios de exchanges de criptomonedas. En el ámbito de las criptomonedas, hay una frase bien conocida por todos: "El código es la ley". Esta frase hace referencia a que lo escrito en el software de los nodos es lo que realmente se hace cumplir en todo momento, siendo que la única manera de cambiarlo es mediante el consenso de la misma comunidad para aceptar dicho cambio.

Básicamente, no debe haber nada fuera del código, sino todo dentro del código. Esta máxima se cumple con los Smart Contracts. Un Smart Contract es simplemente un conjunto de instrucciones informáticas que se ejecutan dentro de una blockchain. Ese conjunto de instrucciones es inamovible; no se pueden cambiar. Si decides interactuar con un Smart Contract, lo haces cumpliendo con tu deseo de hacerlo y por tu libre albedrío, ya que el Smart Contract y las instrucciones que contiene son transparentes; puedes verlas y verificarlas en cualquier momento usando, por ejemplo, un explorador de bloques. Así, lo que ocurre al interactuar con el Smart Contract es algo que aceptas y que está en consonancia con lo que sus creadores han programado. Básicamente, es un contrato tradicional, solo que este no tiene forma de cambiar sus condiciones. Las que están escritas son las condiciones que siempre se habrán de cumplir.

Veamos, por ejemplo, el siguiente Smart Contract de Bitcoin. Este Smart Contract está escrito en Bitcoin Script y básicamente le dice a los nodos de la red Bitcoin lo siguiente: toma los datos de la clave pública y la firma, y copia ambos a la pila de ejecución. Duplica la clave pública dentro del stack. Realiza una operación que se llama RIPEMD-160 sobre la clave pública duplicada y verifica si el resultado de la operación anterior es igual al hash que empieza por 12 y acaba en 8C. Finalmente, se chequea la firma y se verifica que es correcta. ¿De qué sirve todo esto? Este sencillo Smart Contract se conoce como P2PKH y, aunque no diga nada, es la forma más común de transferir valor dentro de la red de Bitcoin. Este script garantiza que solo la persona que recibe una transacción pueda movilizarlo, porque es quien tiene todos los elementos para demostrar y completar las condiciones de uso de Bitcoin que están contenidas en el Smart Contract.

Todo este proceso se da on-chain, es decir, el Smart Contract está en la blockchain y cuando un usuario interactúa con él, dicha interacción se realiza en forma de una transacción que luego es almacenada en un bloque, gracias al trabajo de un minero o nodo validador. Sin embargo, en este punto, el Smart Contract aún no está del todo ejecutado; luego, los nodos ven la operación, verifican la misma y, si todo es correcto, entonces esta es definitivamente ejecutada y aceptada. Este principio básico se mantiene en todas las blockchains, con algunos cambios ajustados a la estructura de funcionamiento de cada una de ellas o a las capacidades de programación de las mismas. Esto deja claro una cosa: Bitcoin sí tiene Smart Contracts. Son complejos y tal vez no tan potentes como en otras plataformas, pero los tiene.

###  Funcionamiento de los Smart Contracts
Imagina por un momento que estás en una línea de producción de puertas de seguridad.

- El punto más crítico es el del brazo robótico encargado de colocar en su sitio y hacer la soldadura de cada una de las partes de las puertas. 
- Este brazo robótico está programado para hacer toda su tarea de forma autónoma, nadie le ayuda, lo único que necesita es que se lleven los materiales necesarios a su sitio. 

Hasta este punto, nada difiere de la realidad industrial que tenemos actualmente. Sin embargo, este brazo robótico es capaz de hacer cosas que con los medios actuales un brazo robótico no podría: 
- **Solicitar mantenimiento a la empresa que lo ha creado cada determinada cantidad de horas,** siguiendo los parámetros de mantenimiento recomendados que fueron aceptados por la empresa al momento de adquirirlo. 
- **El brazo puede gestionar el pago de dichos mantenimientos por su propia cuenta. Esto gracias a que puede verificar que dicha operación se ha realizado** (es capaz de revisar el hardware y saber si se ha hecho los ajustes de mantenimiento y reparaciones), genera un registro completo de toda la operación e informa del mismo a los encargados de la zona de producción.
- **Durante y después del mantenimiento, el brazo robótico mantiene comunicación con el resto de la línea de producción** para avisar cuando interrumpirá su trabajo. También indicar el tiempo estimado y real de su parada, e informar que ya está listo para volver en acción porque su mantenimiento es óptimo y su capacidad operativa está en los rangos esperados.

**El brazo robótico se ha transformado en un ente de trabajo totalmente autónomo,** en el que incluso es capaz de gestionar su propio mantenimiento y comunicarse con el resto de la línea de producción y empresa, para realizar un seguimiento verificable de su producción y de su estatus en tiempo real.

####  Smart Contracts , la era de la automatización y la descentralización
Empresas de todo el mundo se abocan a lograr esto con un solo fin: Mejorar la productividad de las empresas, la seguridad dentro de las mismas y entrar en la era de la automatización y descentralización operativa.

Se le conoce con un nombre bastante particular: Industria 4.0. 

**Abarca la inclusión de tecnologías como el** [**IoT**](https://es.wikipedia.org/wiki/Internet_de_las_cosas)**, IA, robótica y Blockchain, dentro de nuestras industrias para mejorar y hacer más eficientes sus capacidades productivas.** 

Al fin y al cabo, el mantenimiento correcto del brazo robótico de nuestro ejemplo es lo que mantiene la buena operatividad de la empresa, y que el mismo gestione toda esa operativa deja espacio para que las personas dentro de la empresa puedan centrarse en mejorar sus productos u ofrecer nuevos adaptados a las necesidades del mercado, así como se reducen los gastos y se mejora la producción. 

![[205.B4_3.0_4.0.png]]

**Todo lo anterior es posible gracias a los Smart Contracts, ya que estos elementos definen una serie de reglas, acciones y eventos que son aceptados por todas las partes y que se ejecutan de forma totalmente autónoma.** Es más, una vez se ponen en ejecución, solo pueden alterarse bajo el consenso de esas mismas partes, evitando que un contrato pueda ser reescrito de forma unilateral. 

Esto último es bastante común y generalmente lleva a malos resultados. Por ejemplo, una empresa de almacenamiento y hosting depende de comprar servidores, discos duros, ancho de banda dedicado, equipos de soporte (UPS, unidades generadoras eléctricas, edificios climatizados, equipos de seguridad, entre otros) y software para gestionar su granja de servidores. Todo ello conlleva a un completo reto de administración y gestión de recursos, recursos que muchas veces son limitados frente a una demanda cada vez mayor. 

> Esa realidad lleva a las empresas a usar sus recursos de forma poco eficiente, y en el proceso se producen errores, errores que pueden ser especialmente costosos para la empresa, pero aún más costosos para sus clientes. ¿Qué tan costosos? Una perdida total de una granja de servidores y todo simplemente por un mantenimiento realizado de forma incorrecta y recursos mal gestionados en el tiempo. 

**¿Ha pasado algo así? La respuesta es sí, y el más sonado (que no reciente) ha sido el caso de OVH, que perdió prácticamente dos granjas de servidores por errores administrativos, de construcción y de mantenimiento acumulados**. Errores que pudieron evitarse haciendo uso eficiente de sus recursos para evitar el triste desenlace: la perdida de millones de sitios web, miles de terabytes de datos y varios negocios afectados por lo sucedido (incluyendo varios servicios de Exchanges de criptomonedas). 

####  El código es la Ley
En criptomonedas hay una oración que es bien conocida por todos:
==El código es la Ley==

La misma hace referencia a que lo escrito en el software de los nodos, es lo que realmente se hace cumplir en todo momento, siendo que la única manera de cambiarlo, es por medio del consenso de la misma comunidad para aceptar dicho cambio. Fuera de esto, nada fuera del código, todo dentro del código. 

Pues bien, esta máxima se cumple con los Smart Contracts. Un Smart Contract es simplemente un conjunto de instrucciones informáticas que se ejecutan dentro de una Blockchain. Ese conjunto de instrucciones es inamovible, no se pueden cambiar. Si decides interactuar con un Smart Contract, lo haces cumpliendo con tu deseo de hacerlo y por libren elección, ya que **el Smart Contract y sus instrucciones son transparentes: puedes verlas y verificarlas en cualquier momento** usando un explorador de bloques. Así, lo que pase al interactuar con el Smart Contract es algo que aceptas y que está en consonancia con lo que sus creadores han programado. 

**Básicamente, es un contrato tradicional, solo que en este no tiene forma de cambiar sus condiciones: las que están escritas, son las condiciones que siempre se habrán de cumplir.**

#####  Veamos, por ejemplo, el siguiente Smart Contract de Bitcoin:
pubKey: 304502203f004eeed0cef2715643e2f25a27a28f3c578e94c7f0f6a4df104e7d163f7f8f022100b8b248c1cfd8f77a0365107a9511d759b7544d979dd152a955c867afac0ef78601
signature: 044d05240cfbd8a2786eda9dadd520c1609b8593ff8641018d57703d02ba687cf2f187f0cee2221c3afb1b5ff7888caced2423916b61444666ca1216f26181398c
OP_DUP OP_HASH160 
12ab8dc588ca9d5787dde7eb29569da63c3a238c 
OP_EQUALVERIFY OP_CHECKSIG

**Este Smart Contract está escrito en Bitcoin Script** y básicamente les dice a los nodos de la red Bitcoin, lo siguiente:
1. Toma los datos de la pubKey y signature, copia ambos a la pila o stack de ejecución.
2. Duplica la pubKey dentro del stack. 
3. Realiza una operación RIPEMD-160 sobre la pubKey duplicada.
4. Verifica si el resultado de la operación anterior es igual a 12ab8dc588ca9d5787dde7eb29569da63c3a238c.
5. Finalmente, chequea la firma y verifica que sea correcta.

¿Para qué sirve todo esto?. 

**Este sencillo Smart Contract se conoce como P2PKH y es la forma más común de transferir valor dentro de la red Bitcoin.** Este scirpt garantiza que solo la persona que recibe una transacción pueda movilizarlo, porque es quien tiene todos los elementos para demostrar y completar las condiciones de uso para el BTC que está contenido por el Smart Contract o Bitcoin Script. 

![[205.B4_script.png]]
_Imagen 1: Demostración gráfica de que el script anterior se cumple totalmente._

Todo este proceso se da On-Chain. Es decir, el Smart Contract está en la Blockchain y cuando un usuario interactúa con el mismo, dicha interacción va en forma de una transacción que luego es almacenada en un bloque gracias al trabajo de un minero o validador. Sin embargo, en este punto, el Smart Contract aún no está del todo ejecutado sino que luego los nodos ven la operación, verifican la misma y si todo es correcto es definitivamente ejecutada y aceptada. Este principio básico se mantiene en todas las Blockchain, con algunos cambios ajustados a la estructura de funcionamiento de la Blockchain o las capacidades de programación de la misma. 

**Bitcoin SÍ tiene Smart Contracts.**
Que son complejos y no tan potentes como en otras plataformas es una cosa muy distinta a no tenerlos en absoluto, como muchas personas suelen decir en redes sociales, en una forma de ataque a esta criptomoneda.

###  Smart Contracts en Ethereum (Video)
![[206.B4_Smart_Contracts_en_Ethereum.mp4]]
[Smart Contracts en Ethereum](https://app.web3mba.io?wvideo=ah4ak77jnf)

Hasta la llegada de Ethereum, los smart contracts siguieron el esquema establecido por Bitcoin. En primer lugar, porque era muy sencillo de implementar y, en segundo lugar, porque su seguridad es insuperable. Bitcoin Script es un lenguaje limitado. Las acciones también son limitadas, y la revisión y auditoría de sus instrucciones es tal que romper el lenguaje es muy complejo. Por esa razón, muchos desarrolladores ven a Bitcoin Script como una especie de jardín amurallado. Las posibilidades que ofrece son fenomenales, pero esto nos lleva a una pregunta: ¿qué hay más allá de esas murallas? Los innovadores siempre buscan nuevos océanos, y la primera creación exitosa en salir del estándar de Bitcoin fue Ethereum.

Ethereum lo cambió todo con la llegada de la Ethereum Virtual Machine (EVM) y el lenguaje de programación Solidity. La EVM fue creada para ser una máquina virtual con enormes capacidades, siendo la principal la de ejecutar el lenguaje de programación Solidity. Solidity es un derivado de JavaScript que tiene el poder de ser un lenguaje Turing completo. En comparación, Bitcoin Script es un lenguaje de tipo Turing incompleto. Esto quiere decir que tiene un conjunto de instrucciones y capacidades mucho más limitadas. Más allá de las diferencias entre las blockchains de Ethereum y Bitcoin, los smart contracts siguen el mismo principio: el código es la ley. Este código está grabado en la blockchain, donde permanece protegido por la red, siendo ejecutado y verificado por los nodos que la conforman.

Dicho esto, tal vez recuerdes el Bitcoin Script que mencionamos antes. Ahora observa un smart contract en Ethereum creado con el lenguaje Solidity. Es mucho más legible, ¿verdad? Este es un ejemplo muy básico de smart contract en Ethereum. De hecho, es el código base de un token ERC20. Un ERC20 es un smart contract que te permite crear una nueva criptomoneda que funcione sobre Ethereum. Esta moneda tendrá su propia contabilidad y disfrutará de la seguridad de esta red. Esto solo es el principio del poder de los smart contracts, una tecnología que aún tiene mucho que ofrecernos dentro del universo descentralizado y de Web3, un universo donde las empresas pueden ganar y ofrecer mucho a sus usuarios.

Ahora bien, seguramente te preguntarás: ¿qué podemos hacer con los smart contracts en Ethereum? ¿Cuáles son sus límites? La verdad es que sus límites son prácticamente infinitos. Tomemos un sencillo ejemplo. Cuando pensamos en préstamos, generalmente imaginamos ir a un banco y solicitar uno, como una hipoteca, en la que la garantía de nuestro préstamo es, por ejemplo, nuestra casa o cualquier otro inmueble de valor. En consonancia con el valor del inmueble, recibiremos el préstamo del banco con determinadas condiciones que muchas veces pueden cambiarse, ya sea por leyes o porque el banco, en su letra pequeña, se reserva el derecho de hacer dichos cambios. Puede que consideres esto injusto, pero al firmar el contrato con el banco, estás aceptando esas condiciones y ya no hay vuelta atrás.

Sin embargo, en Ethereum, gracias a sus smart contracts, podemos crear un contrapeso. Las finanzas descentralizadas, o DeFi por sus siglas en inglés, se han convertido en un producto destacado de la economía actual. Estos no son más que programas descentralizados cuyo funcionamiento está controlado por un smart contract. Las instrucciones del smart contract son claras y no se pueden alterar; no hay letras pequeñas. Básicamente, lo escrito es lo que se cumple en todo momento: el código es ley, como hemos mencionado. Pero su función no se limita a eso, porque podemos usar los smart contracts para crear nuestro propio banco descentralizado, ofrecer créditos y tomar como garantía de esos créditos otras criptomonedas de gran valor en el mercado.

###  Smart Contracts en Ethereum
Hasta la llegada de Ethereum, los Smart Contracts seguían el esquema mostrado por Bitcoin. 

- Era muy sencillo de implementar
- Su seguridad era insuperable. 

Bitcoin Script es un lenguaje limitado, las acciones son igualmente limitadas y la revisión/auditoría de sus instrucciones es tal que romper el lenguaje es extremamente complejo. 

Por esa razón, muchos desarrolladores ven a Bitcoin Script como un "_walled garden_" (jardín amurallado). 

Las posibilidades que ofrece son fenomenales, pero eso nos lleva a la pregunta: ¿Qué hay más allá de esas murallas? Los innovadores, siempre en búsqueda de nuevos océanos por navegar, pensaron en ello y **la primera creación exitosa en salir del “Bitcoin Standard” fue Ethereum.** 

**Ethereum lo cambió todo con la llegada de la Ethereum Virtual Machine (EVM) y el lenguaje de programación Solidity.** La EVM fue creada para ser una máquina virtual con enormes capacidades, siendo la principal ejecutar el lenguaje de programación Solidity: Un derivado de JavaScript que tiene el poder de ser un [lenguaje Turing Complete](https://es.wikipedia.org/wiki/Turing_completo) y mucho más sencillo de aprender y programar. Básicamente, esto quiere decir que, si puedes pensar o soñar alguna herramienta digital, Solidity tiene la capacidad de hacerla realidad. En comparación, Bitcoin Script es un lenguaje del tipo Turing Incomplete, con un set de instrucciones y capacidades limitadas. 

Pero más allá de las diferencias entre la Blockchain de Ethereum y Bitcoin, los Smart Contracts siguen el mismo principio: El código es la Ley. Y ese código está grabado en la Blockchain, donde permanece protegido por la red, siendo ejecutado y verificado por los nodos que forman la misma. 

![[207.B4_evm.png]]

####  Smart Contract en Ethereum creado en lenguaje Solidity
```
pragma solidity ^0.8.0;


interface IERC20 {


    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);


    function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);




    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}


contract ERC20Basic is IERC20 {


    string public constant name = "ERC20Basic";
    string public constant symbol = "ERC";
    uint8 public constant decimals = 18;




    mapping(address => uint256) balances;


    mapping(address => mapping (address => uint256)) allowed;


    uint256 totalSupply_ = 10 ether;




   constructor() {
    balances[msg.sender] = totalSupply_;
    }


    function totalSupply() public override view returns (uint256) {
    return totalSupply_;
    }


    function balanceOf(address tokenOwner) public override view returns (uint256) {
        return balances[tokenOwner];
    }


   
 function transfer(address receiver, uint256 numTokens) public override returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender]-numTokens;
        balances[receiver] = balances[receiver]+numTokens;
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }


    function approve(address delegate, uint256 numTokens) public override returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }


    function allowance(address owner, address delegate) public override view returns (uint) {
        return allowed[owner][delegate];
    }


    function transferFrom(address owner, address buyer, uint256 numTokens) public override returns (bool) {
        require(numTokens <= balances[owner]);
        require(numTokens <= allowed[owner][msg.sender]);


        balances[owner] = balances[owner]-numTokens;
        allowed[owner][msg.sender] = allowed[owner][msg.sender]-numTokens;
        balances[buyer] = balances[buyer]+numTokens;
        emit Transfer(owner, buyer, numTokens);
        return true;
    }
}
```

Mucho más legible, ¿no es así? Pues bien, este es un ejemplo muy básico de Smart Contract en Ethereum, de hecho, **es el código base de un token ERC-20, un Smart Contract que te permite crear una nueva moneda que funciona sobre Ethereum, teniendo su propia contabilidad y disfrutando de la seguridad de esta red.** 

Y esto es solo el principio del poder de los Smart Contracts, una tecnología que aún tiene mucho que ofrecernos dentro del universo descentralizado y Web 3.0. Un universo donde las empresas pueden ganar y ofrecer mucho a sus usuarios. 

####  Posibilidades infinitas
¿Qué podemos hacer con los Smart Contracts en Ethereum? ¿Cuáles son sus límites? La verdad es que sus límites son prácticamente infinitos.

Ejemplo:
- Pensamos en ir a un banco y solicitar un préstamo. Generalmente, una hipoteca, en la que la garantía es nuestra casa o cualquier otro inmueble de valor. 
- En consonancia con el valor del inmueble, recibiremos el préstamo del banco con determinadas condiciones, que muchas veces pueden cambiarse, bien sea por leyes o porque el banco, en su “letra pequeña” se reserva el derecho de hacer dichos cambios. Puede que lo veas como algo injusto, pero al firmar el contrato con el banco, aceptas esas condiciones, no hay vuelta atrás.
- **En Ethereum gracias a sus Smart Contracts podemos crear un contrapeso.** Las Finanzas Descentralizadas (DeFi) no son más que programas descentralizados cuyo funcionamiento está controlado por un Smart Contract. 
- **Las instrucciones del Smart Contract son claras:** No se pueden alterar y no hay “letras pequeñas”, lo escrito es lo que se cumple en todo momento. 

Pero su función no se limita a eso, podemos usar los Smart Contracts para:

1. Crear nuestro banco descentralizado
2. Ofrecer créditos
3. Tomar como garantía de esos créditos criptomonedas de gran valor en el mercado. 

**Uno de los mayores ejemplos en este sentido es** [**AAVE**](https://aave.com/)**, una plataforma DeFi que desde sus inicios redefinió la forma en la que podemos acceder a préstamos en Blockchain.** Simplemente basta con tener cierta cantidad de criptomonedas, ponerlas en el protocolo y con ello puedes solicitar un préstamo en la plataforma, usando esas criptomonedas como garantía. Es un banco, solo que no hay gerente, ni secretaría, ni asesor. Solo eres tú y el Smart Contract, no hay nada más.

#####  Pero ¿Cómo se sostiene y desarrolla una aplicación si no hay nadie que la gobierne y controle? 
- **Esto recae en la comunidad**, ya que, así como los Smart Contracts habilitan las funciones de préstamos, también es posible habilitar acciones de gobernanza. 
- **Cada persona que desea participar en la gobernanza de AAVE, debe hacer una pequeña inversión** con el fin de obtener poder de voto. 
- **La inversión garantiza que la persona actúe en pro de la plataforma**, ya que su buen funcionamiento, significa que su inversión será próspera.  
- **Los Smart Contracts habilitan a determinado número de personas que pueden decidir**, en conjunto, cuáles serán las tasas de interés, los pagos de comisiones y otros aspectos de AAVE para su buen funcionamiento y sostenibilidad. 
- No hay una sola voz gobernando el protocolo, sino que todos los que forman parte del mismo y pueden hacer valer su voz, dentro de lo que se conoce como **Organización Autónoma Descentralizada (DAO)**, otra creación posible gracias a los Smart Contracts.

**Estas dos funciones (DeFi y DAO), son solo algunas de las posibilidades que pueden construirse gracias a los Smart Contracts en Ethereum,** son parte de la creatividad de un colectivo que busca hacer de la descentralización algo común y al alcance de todos, una descentralización donde los Smart Contracts son parte fundamental para lograrla.

###  Ethereum Virtual Machine (Video)
![[208.B4_Ethereum_Virtual_Machine.mp4]]
[Ethereum Virtual Machine](https://app.web3mba.io?wvideo=ie9iw82v20)

La Ethereum Virtual Machine (EVM) es una máquina virtual que forma parte del ecosistema blockchain de Ethereum. Esta máquina virtual es capaz de ejecutar una amplia gama de instrucciones, lo que le permite una gran flexibilidad a la hora de realizar diferentes operaciones. Sin embargo, para simplificar la programación en esta máquina virtual, se creó un lenguaje especializado de alto nivel llamado Solidity. A través de este lenguaje de programación, se facilita la creación de los smart contracts. En primer lugar, Solidity se transforma en los códigos de operación de Ethereum, conocidos como Opcodes, y luego en un Bytecode. Este bytecode es finalmente ejecutado por la Ethereum Virtual Machine para realizar las operaciones especificadas en el smart contract que se escribió inicialmente.

Todo esto hace que la Ethereum Virtual Machine funcione como un verdadero computador, ejecutando desde las operaciones más sencillas hasta las más complejas. Como buen proyecto de software libre, toda esta información sobre los bytecodes y opcodes está bien documentada, así que no hay que preocuparse. En pocas palabras, dada la característica descentralizada de Ethereum y su capacidad de almacenar smart contracts en los nodos de la red, la EVM puede ejecutar las órdenes programadas en dichos smart contracts. Así, Ethereum se convierte en un gran ordenador mundial descentralizado, capaz de realizar instrucciones que resuelvan casi cualquier tarea específica. Todo esto ocurre dentro de la misma red de Ethereum.

Todas estas instrucciones se encuentran escritas en los llamados contratos inteligentes de Ethereum. Estos contratos son un tipo de cuenta que posee su propio código y se habilitan desde el momento en que llegan a la blockchain. Lo mejor de todo es que, para poder usar el potencial de la EVM, solo necesitamos tener algo de Ether e interactuar con alguna aplicación descentralizada, contrato inteligente o crear nuestro propio contrato. No existe ninguna limitación; cualquiera puede aprovechar el poder que la EVM pone a su disposición. Suena increíble, y lo es. La EVM es un trabajo de desarrollo enorme que requirió grandes esfuerzos por parte de personas muy talentosas, como Gavin Wood y Greg Colvin.

Gavin Wood fue quien creó el conocido como "Yellow Paper" de Ethereum. Este documento técnico especifica las ideas y capacidades iniciales de la EVM. Por otro lado, Greg Colvin es conocido como el principal desarrollador de la EVM. Estas dos personas, junto con el equipo que las acompañó, permitieron la creación de la Ethereum Virtual Machine, una tecnología que transformó a Ethereum en un ecosistema único dentro de las demás tecnologías que utilizan blockchain. Todo esto gracias a que la EVM es una parte integral del funcionamiento interno de Ethereum y representa una verdadera innovación en el desarrollo de estas tecnologías.

Con el fin de evitar que algún programador pueda atentar contra la seguridad de la red, la Ethereum Virtual Machine realiza una completa abstracción del sistema, manejando el acceso a los recursos de los computadores y limitando sus acciones en un ambiente controlado o de máquina virtual. A su vez, la EVM permite simplificar el desarrollo y la actualización de aplicaciones y características disponibles. La Ethereum Virtual Machine permite el diseño y la ejecución de smart contracts. Además, gracias a Solidity y otros lenguajes soportados, podemos crear estos smart contracts de forma sencilla y manejable. Aunque la EVM por sí misma no es capaz de ejecutar directamente el lenguaje, sí lo hace mediante una técnica conocida como compilación de instrucciones. Con esta técnica, podemos obtener los opcodes necesarios.

Por su parte, Solidity es un lenguaje de programación de alto nivel, muy similar a JavaScript o C++. Este lenguaje está orientado a la creación de contratos inteligentes. De esta forma, la mayor parte del código fuente de los contratos está escrito en este lenguaje y, después, se compila a esos códigos de operación comprensibles para la Ethereum Virtual Machine. La EVM utiliza estos códigos de operación, o opcodes, para crear los contratos inteligentes y realizar tareas específicas. Estas limitaciones llevan a la EVM a crear métodos de trabajo que le permitan realizar sus operaciones. Entre ellas, una de las más importantes es la memoria de contratos. Dicha memoria sirve para almacenar información a la que la EVM podrá acceder rápidamente en el futuro.

Por otro lado, para almacenar datos de manera indefinida y hacerlos accesibles para futuras ejecuciones de contratos, se puede usar el almacenamiento por contratos. Este actúa, esencialmente, como una base de datos pública desde la cual los valores se pueden leer externamente sin tener que enviar una transacción al contrato, es decir, sin comisiones. Los opcodes son una parte muy importante y esencial de la Ethereum Virtual Machine. Estos códigos de operación definen las operaciones válidas que la EVM puede realizar. En la Ethereum Virtual Machine existe la capacidad de ejecutar hasta 256 opcodes distintos, aunque en la actualidad no se han definido tantos códigos. La razón es que el desarrollo de la EVM no ha requerido la creación de tales códigos, y los desarrolladores son cuidadosos al incluir nuevos códigos debido a estas limitaciones en los números mencionados.

Un aspecto importante de los opcodes es que son un nivel intermedio de programación para la Ethereum Virtual Machine. El primer nivel está dado por Solidity y otros lenguajes de programación de alto nivel similares. Un segundo nivel serían estos opcodes, y por último tendríamos el bytecode, que es el resultado de compilar los opcodes. Básicamente, el bytecode es el equivalente al lenguaje máquina de la Ethereum Virtual Machine, algo prácticamente imposible de entender y describir para un ser humano. Sin embargo, al ser Ethereum una blockchain pública y un proyecto que aboga por la apertura y transparencia, el lenguaje bytecode de la EVM se puede descompilar. Es decir, podemos transformar el bytecode en opcodes y de allí volver a llevarlo a un lenguaje cercano a Solidity. Esto es importante, ya que brinda a la Ethereum Virtual Machine la capacidad de mantener de forma abierta y clara el contenido de un smart contract, además de permitir reconocer la ABI de la que dispone.

Un dato relevante es que la ABI se refiere a cómo se pueden codificar las llamadas de un contrato para la EVM y, al revés, cómo leer los datos de las transacciones que genera dicho contrato. La red de Ethereum ha sido nombrada como la computadora global, debido a que cada uno de los nodos conectados a la red ejecuta una instancia de la EVM, al mismo tiempo que todos realizan las instrucciones de forma idéntica con el fin de mantener un consenso sobre el estado del sistema. Esta particularidad de Ethereum hace que su cálculo sea un poco más lento y costoso en comparación con un ordenador común, pero le brinda mayores ventajas, como una alta defensa contra fallas bizantinas, una mayor protección e integridad de los datos y una mayor resistencia a la censura. Así, Ethereum funciona como una computadora mundial descentralizada de uso general, en una red entre pares, una red peer-to-peer.

Los smart contracts y las aplicaciones descentralizadas desarrolladas en la Ethereum Virtual Machine podrían incluso asumir funciones de internet, tal como la conocemos hoy en día. Además, podrían permitirnos la creación de economías más estables, ya que su funcionamiento puede ser garantizado y no está sujeto a interpretaciones humanas. Con la aplicación de elementos como la distribución de archivos, la ejecución de contratos inteligentes, las aplicaciones descentralizadas y muchos otros, se elimina la necesidad de confiar en terceros, ya que, si no se cumplen estos términos programados, simplemente el contrato no se ejecutará. Sin embargo, podemos comparar su nacimiento y desarrollo con la Internet de los años 90. Nadie tiene idea de lo que traerá el futuro. Pero, sin duda alguna, la Ethereum Virtual Machine evolucionará con el tiempo y le permitirá convertirse en una red mucho más sólida.

Un ejemplo de esa evolución lo podemos ver en las distintas actualizaciones que se han ido dando a la misma. Por ejemplo, las actualizaciones de Byzantium, Constantinople, Estambul y London. En estos casos, la Ethereum Virtual Machine sufrió varios cambios, agregándose nuevos opcodes y mejorando ciertas prestaciones de la misma. En un futuro, con la llegada de la Ethereum Virtual Machine 2.0, la EVM evolucionará hasta ser finalmente reemplazada por lo que se llama eWASM, Ethereum Web Assembly, el cual mejorará enormemente las capacidades de generación de aplicaciones descentralizadas dentro de Ethereum 2.0. La EVM permite el desarrollo de una mayor cantidad de aplicaciones y que estas puedan ejecutarse sobre una misma red blockchain sin afectar a otras operaciones que estén dentro de la misma red.

Los contratos inteligentes diseñados en la Ethereum Virtual Machine son invariables y pueden ejecutarse y hacerse cumplir de manera autónoma y automática, eliminando la burocracia, los altos costos y el tiempo de espera típicos de los contratos tradicionales. Sin embargo, la Ethereum Virtual Machine es sustancialmente menos eficiente que muchas otras máquinas virtuales convencionales. Esto se debe, básicamente, a que su diseño se basó en la utilidad del momento y no en un alto rendimiento. Los cambios y mejoras experimentados por la Ethereum Virtual Machine han sido pocos hasta ahora, por lo que no está optimizada en cuanto a la velocidad para las distintas plataformas de hardware que existen. El diseño de la Ethereum Virtual Machine no está dirigido a la portabilidad, lo que limita los espacios en los que dicha máquina virtual puede implementarse y ejecutarse.

Como has podido ver, estas son algunas de las características y el funcionamiento de la Ethereum Virtual Machine, que al final es, de alguna manera, el corazón de Ethereum y lo que permite que se puedan ejecutar estos smart contracts.


### Ethereum Virtual Machine
Ethereum Virtual Machine o EVM, es una máquina virtual que forma parte del ecosistema Blockchain de Ethereum. 

Es capaz de ejecutar una amplia gama de instrucciones que le permiten una gran flexibilidad a la hora de realizar distintas operaciones.

Sin embargo, para hacer más sencilla la programación para esta máquina virtual se creó un lenguaje especializado de alto nivel llamado Solidity. A través de este lenguaje de programación se facilita la creación de los Smart Contracts. 

**En primer lugar, se transforma Solidity a los códigos de operación de Ethereum (OP_CODES) y luego a un bytecode. Este bytecode es finalmente ejecutado por la EVM para realizar las operaciones especificadas en un Smart Contract.** Todo ello hace que la EVM puede funcionar como un computador de verdad, ejecutando desde las más sencillas hasta las más complejas operaciones. 

Como buen proyecto de software libre, toda esta información sobre los bytecodes y OP_CODES está bien documentada y un espacio excelente para leer sobre esto, es [Ethereum Virtual Machine Opcodes (ethervm.io)](https://www.ethervm.io/)

  ![[209.B4_opcodes.png]]
_Imagen 1: Muestra de algunos OP_CODES dentro de la EVM_

Así, en pocas palabras, dada la característica descentralizada de Ethereum y su capacidad de almacenar Smart Contracts en los nodos de la red, y que con EVM pueden ejecutarse las órdenes programadas en dichos Smart Contracts, **Ethereum se convierte en un gran ordenador mundial descentralizado.** Uno que es capaz de realizar instrucciones que lleven a la resolución de cualquier tarea específica. De hecho, puede resolver casi cualquier problema computacional y todo esto ocurre dentro de la misma red Ethereum.

Todas estas instrucciones se encuentran escritas en los llamados contratos inteligentes de Ethereum.  

- Estos contratos son un tipo de cuenta que posee su propio código, y se habilita desde el mismo momento en el que llegan a la Blockchain. 
- Lo mejor de todo es que para poder usar el potencial de EVM tan solo debemos tener algo de Ether e interactuar con alguna DApp, contrato inteligente o hacer nuestro propio contrato. 
- No existe ninguna limitación, cualquiera puede aprovechar el poder que EVM tiene a su disposición.

**Suena increíble y lo es, EVM es un trabajo de desarrollo enorme que requirió de enormes esfuerzos por parte de gente muy talentosa, y que conocerás a continuación.**

####  ¿Quién la creó?
Las mentes maestras detrás del desarrollo de la EVM son Gavin Woods y Greg Colvin.

Gavin Woods fue quien creó el conocido Yellow Paper de Ethereum. 

En dicho documento técnico, se especifican las ideas y capacidades iniciales de la EVM. Por otro lado, Greg Colvin es conocido como el principal desarrollador de la EVM.

Estas dos personas y el equipo que las acompañó, permitieron la creación de la EVM. Una tecnología que transformó a Ethereum en un ecosistema único dentro de las demás tecnologías que usan Blockchain. Todo gracias a que EVM es una parte integral del funcionamiento interno de Ethereum y representa una verdadera innovación en el desarrollo de estas tecnologías.

![[209.B4_yellow_paper.png]]
_Imagen 2: Introducción del Yellow Paper de la EVM_

####  ¿Cómo funciona la Ethereum Virtual Machine (EVM)?
Con la finalidad de evitar que algún programador pueda atentar contra la seguridad de la red, la EVM realiza una completa abstracción del sistema.

Manejando el acceso a los recursos de los computadores y limitando sus acciones en un ambiente controlado o de máquina virtual.

A su vez, la EVM permite simplificar el desarrollo y actualización de aplicaciones y características disponibles para las aplicaciones descentralizadas.

La EVM permite el diseño y la ejecución de Smart Contract. Además, gracias a Solidity (u otros lenguajes soportados) podemos crear estos Smart Contracts de forma sencilla y manejable. **Aunque la EVM por sí misma no es capaz de ejecutar directamente este lenguaje, si lo hace por medio de una técnica conocida como ==compilación de instrucciones,== con el cual obtenemos los OP_CODES necesarios.** 

Por su parte, Solidity es un lenguaje de programación de alto nivel muy similar al JavaScript y a C++. Este lenguaje está orientado a la creación de contratos inteligentes. De esta forma, la mayor parte del código fuente de los contratos está escrito en este lenguaje y luego se compilan en códigos de operación comprensible para la EVM.

![[209.B4_virtual_machine.png]]
_Imagen 3: Estructura básica de cómo funciona la EVM_

**La EVM utiliza estos códigos de operación (OP_CODES) para realizar tareas específicas.** Estas limitaciones llevan a la EVM a crear métodos de trabajo que le permitan realizar sus operaciones, entre ellas la más importante es la **memoria de contratos.** Dicha memoria sirve para almacenar información a la que la EVM puede acceder rápidamente. Por otra parte, para almacenar datos de manera indefinida y hacerlos accesibles para futuras ejecuciones de contratos, se puede usar el almacenamiento por contratos. Esta actúa esencialmente como una base de datos pública, desde la cual los valores se pueden leer externamente sin tener que enviar una transacción al contrato, es decir, sin comisiones.

**Los OP_CODES son una parte muy importante y esencial de la EVM.** Estos códigos de operación son los que definen las operaciones válidas que la EVM puede realizar. En EVM existe la capacidad de ejecutar hasta 256 OP_CODES distintos, aunque en la actualidad no existen esta cantidad de códigos definidos. La razón es que **el desarrollo de EVM no ha requerido de la creación de tales códigos y los desarrolladores son cuidadosos con incluir nuevos códigos debido a las limitaciones en sus números.**

**Un aspecto importante de los OP_CODES, es que este es un nivel intermedio de programación para la EVM.** El primer nivel vendría dado por Solidity y los lenguajes de programación de alto nivel similares a este. Un segundo nivel de profundidad serían los OP_CODES. Por último, tendríamos el bytecode resultado de compilar los OP_CODES en el equivalente a lenguaje máquina de la EVM, algo prácticamente imposible de entender y escribir por un ser humano.

Sin embargo, al ser Ethereum una Blockchain pública y ser un proyecto que aboga por la apertura y transparencia, el lenguaje bytecode de la EVM se puede descompilar. Es decir, podemos transformar el bytecode a OP_CODES y de allí llevarlo a un lenguaje cercano a Solidity. **Esto es importante, puesto que brinda a EVM la capacidad de mantener de forma abierta y clara el contenido de un Smart Contract.** Además de permitir reconocer la ABI de la que dispone. Un dato importante, puesto que se trata básicamente de cómo puede codificar llamadas de un contrato para el EVM y, al revés, cómo leer los datos de las transacciones que genera dicho contrato.

####  Evolución futura de la EVM
La red de Ethereum ha sido nombrada como la computadora global debido a que cada uno de los nodos conectados a la red ejecuta una instancia de la EVM.

Al mismo tiempo que todos realizan las instrucciones de forma idéntica con el fin de lograr y mantener un consenso sobre el estado del sistema.

**Esta particularidad de Ethereum hace que su cálculo sea más lento y costoso en comparación con un ordenador común.** **Pero le brinda mayores ventajas, como por ejemplo una alta defensa a las** [**fallas bizantinas,**](https://ciberseguridad.com/guias/nuevas-tecnologias/criptomoneda/tolerancia-fallas-bizantinas/) **una mayor protección e integridad de los datos y una mayor resistencia a la censura.**

Así, Ethereum funciona como una computadora mundial descentralizada de uso general en una red entre pares. **Los Smart Contract y las DApps desarrolladas en la EVM podría incluso asumir las funciones de Internet tal y como las conocemos.** **Además, podría permitirnos la creación de economías más estables,** ya que su funcionamiento puede ser garantizado y no está sujeto a interpretaciones humanas.

> Con la aplicación de elementos como la distribución de archivos, la ejecución de contratos inteligentes, las aplicaciones descentralizadas y muchos otros, se elimina la confianza en terceros, ya que, si no se cumplen los términos programados, simplemente el contrato no se ejecutará.

**Sin embargo, podemos comparar su nacimiento y desarrollo con la Internet de los años 90. Nadie tiene idea lo que traerá en el futuro. Pero sin duda alguna, la EVM evoluciona con el tiempo y le permitirá a la red convertirse en una mucho más sólida.** Un ejemplo de esa evolución la podemos ver en las distintas actualizaciones que se han dado a la misma. Por ejemplo: en los Hard Fork Byzantium y Constantinople, Istambul, London y Homestead, la EVM sufrió de varios cambios agregándose nuevos OP_CODES y mejorando ciertas prestaciones de la misma. En un futuro, con la llegada de EVM 2.0, la EVM evolucionará hasta que sea finalmente reemplazada por **eWASM (Ethereum Web Assembly)** el cual mejorará enormemente las capacidades de generación de dApps dentro de Ethereum 2.0.

####  Característica de las EVM
La Ethereum Virtual Machine es un software que posee muchas características o cualidades tanto positivas como negativas. Entre ellas podemos mencionar:
1. **La EVM está enfocada en proporcionar seguridad y ejecutar códigos no confiables** en computadoras de todo el mundo.
2. **Las aplicaciones descentralizadas y los contratos inteligentes desarrollados en la EVM son completamente descentralizados y distribuidos.** Por lo que no requiere de la participación de terceros. Ni pueden ser modificadas ni alteradas.
3. **La EVM permite el desarrollo de una mayor cantidad de aplicaciones,** y que estas puedan ejecutarse sobre una misma red Blockchain, sin afectar otras operaciones.
4. **Los contratos inteligentes diseñados en la EVM son invariables y pueden ejecutarse y hacerse cumplir por sí mismo, de una manera autónoma y automática.** Con lo que se elimina la burocracia, los altos costos y el tiempo de espera típicos en los contratos tradicionales.
5. **La EVM es sustancialmente menos eficiente que muchas otras máquinas virtuales convencionales.** Esto se debe a que principalmente su diseño se basó en la utilidad del momento y no en el alto rendimiento.
6. **Los cambios y mejoras experimentados por la EVM han sido pocos hasta ahora.** Por lo que no está optimizada en cuanto a la velocidad para distintas plataformas de hardware.
7. **El diseño de la EVM no está dirigido a la portabilidad,** lo que limita los espacios en los que dicha máquina virtual puede implementarse.

###  Solidity (Video)
![[210.B4_Solidity.mp4]]
[Solidity.mp4](https://app.web3mba.io?wvideo=o1yv9r7686)

El nombre de Solidity hace referencia a un lenguaje de alto nivel de tipo estático que permite programar smart contracts para la red Ethereum. Su sintaxis es muy similar a la de lenguajes conocidos como C++ o JavaScript. Solidity fue creado con el propósito de facilitar la escritura de smart contracts de forma sencilla para la red Ethereum. Se trata de un lenguaje diseñado para aprovechar al máximo la EVM, permitiendo la creación y desarrollo de smart contracts que puedan ser ejecutados de manera óptima en ella.

El programador puede desarrollar sus aplicaciones en un lenguaje fácil de utilizar, leer y mantener, para que, al finalizar, el motor de Solidity convierta ese código sencillo en el código máquina que la EVM puede entender. Este código máquina es prácticamente imposible de interpretar por una persona. En esencia, Solidity facilita el desarrollo de smart contracts sobre Ethereum. Aunque no es el único lenguaje, sí fue el primero y el más versátil, además de ser el que más contratos inteligentes tiene desarrollados en la actualidad.

La principal característica de Solidity es que es un lenguaje Turing completo. Un lenguaje Turing completo permite una gran diversidad de operaciones y, por lo tanto, la generación de aplicaciones para prácticamente cualquier tipo de problema. El hecho de que sea Turing completo también implica que se debe contar con un mecanismo de protección para evitar el mal uso. Este mecanismo es conocido como "gas" y sirve para prevenir que el sistema, que es la Ethereum Virtual Machine, pueda colapsar debido a la creación de bucles infinitos u otras acciones maliciosas.

El gas funciona como el gasto computacional que conlleva procesar una transacción o un smart contract dentro de la red. Podríamos hacer una pequeña analogía y compararlo con los kilovatios hora de la electricidad. Al final, nos permitirá tener una compensación de precio entre la fluctuación del precio de Ethereum y el costo que debemos pagar por realizar una transacción dentro de la Ethereum Virtual Machine.

Ethereum nació como una alternativa a la red de Bitcoin. Su creador, Vitalik Buterin, propuso en su momento incorporar un lenguaje de tipo Turing completo a la red de Bitcoin, ya que consideraba que el lenguaje con el que fue desarrollado Bitcoin era insuficiente para la evolución de la red. Sin embargo, al no recibir respuesta por parte de los desarrolladores, Buterin decidió crear y desarrollar su propio proyecto: Ethereum. Hoy en día, Bitcoin y Ethereum son las dos redes más valiosas y conocidas, ocupando el primer y segundo lugar, respectivamente.

No obstante, Bitcoin y Ethereum poseen grandes diferencias. Por ejemplo, Bitcoin, la moneda de la red Bitcoin, fue creada como medio de pago y como resguardo de valor, mientras que Ethereum fue desarrollada con la finalidad de ser mucho más flexible y programable, permitiendo evolucionar con nuevas capacidades a lo largo del tiempo. Esto es gracias a la EVM y a Solidity, las dos herramientas que permiten a los desarrolladores aprovechar al máximo Ethereum, facilitando la tarea de desarrollar aplicaciones distribuidas y otras funciones que hacen uso de los smart contracts.

El desarrollo de Ethereum comenzó como una idea en la mente de Gavin Wood. Esta idea fue materializada por Christian Rittwisner junto a un equipo de trabajo, y el resultado de este esfuerzo llegó a ser Solidity. Desde entonces, el desarrollo de Solidity ha mantenido su evolución y, en la actualidad, se encuentra en la versión 0.8.13, a fecha de 16 de marzo de 2022. Solidity es un lenguaje orientado a objetos, similar a C++ o C#. Fue diseñado específicamente para desarrollar aplicaciones para la red de Ethereum, por lo que solo corre en la blockchain de Ethereum o en otras derivadas compatibles, como Polygon.

Una ventaja de este lenguaje es que el código fuente de los programas realizados con él puede ser accedido públicamente desde la red blockchain. Incluso estando en bytecode, es posible compilarlo y obtener una muestra bastante clara de cómo era el código fuente original. Solidity soporta la herencia y la herencia múltiple, lo que le otorga una gran flexibilidad a la hora de programar elementos complejos. Este lenguaje también proporciona una serie de bibliotecas muy útiles que facilitan la programación de los smart contracts, haciendo que el código sea reutilizable y mucho más sencillo de mantener.

Como casi todo lenguaje de programación, Solidity puede aprovechar las ventajas de un entorno integrado de desarrollo (IDE). En Ethereum, el IDE oficial es conocido como Remix. Este facilita a los desarrolladores la creación de smart contracts, al mismo tiempo que permite acceder al estado y propiedades de estos contratos ya creados. Además, cuenta con poderosas herramientas de corrección y análisis de código para ayudar a los desarrolladores a depurar sus programas. Remix también puede ser ejecutado y utilizado de forma online a través de navegadores como Firefox o Chrome, o directamente en nuestro ordenador. Aunque este es el IDE oficial de Ethereum, también existen otros entornos compatibles con el lenguaje de Solidity.

###  ¿Qué es Solidity?
El nombre de Solidity hace referencia a un lenguaje de alto nivel de tipado estático con el que se pueden programar Smart Contracts para la red de Ethereum.

De sintaxis es muy similar a C++ o Javascript, Solidity fue creado con el propósito de permitir la escritura de Smart Contracts de forma sencilla para la red Ethereum.

Se trata de un lenguaje diseñado para sacar el máximo provecho a la Ethereum Virtual Machine, permitiendo la creación y desarrollo de Smart Contracts que puedan ser ejecutados de forma óptima en la EVM.

Para ello, el programador puede desarrollar sus aplicaciones en un lenguaje sencillo de utilizar, leer y mantener para que, al terminar, el motor de Solidity convierta ese código sencillo en el código máquina que la EVM entenderá. Un código máquina prácticamente imposible de entender por una persona.

En esencia, Solidity facilita el desarrollo de Smart Contracts sobre Ethereum y, aunque no es el único lenguaje, sí fue el primero, el más versátil y sobre el que más contratos inteligentes hay desarrollado.

  ![[211.B4_solidity.png]]

####  Un lenguaje Turing Complete
Gracias a Solidity y a su relación con la EVM, los desarrolladores pueden realizar programas que sean Turing Complete.

Esto se debe a que EVM posee la capacidad de ejecutar cualquier código que sea definido por un desarrollador dentro del marco de sus capacidades.

Esto representa una gran ventaja para la red Ethereum. Gracias a EVM y Solidity los desarrolladores pueden programar acciones que luego serán ejecutadas por la EVM de forma descentralizada en la red Ethereum. Pero esto también **implica que se debe disponer de un mecanismo de protección para evitar su mal uso. Este mecanismo es conocido como ==Gas== y sirve para evitar que el sistema pueda ser colapsado por la creación de bucles infinitos u otras acciones maliciosas. Este Gas funciona como el gasto computacional que conlleva procesar una transacción o un Smart Contract en la red.**

####  Importancia y desarrollo de Solidity
Su creador, Vitalik Buterin, propuso incorporar un lenguaje tipo Turing Complete a la red Bitcoin.

Consideraba que el lenguaje con el que fue desarrollado Bitcoin era insuficiente para la evolución de la red. 

Pero al no recibir ninguna respuesta por parte de los desarrolladores, Buterin decidió crear y desarrollar su propio proyecto: **Ethereum.**

> Hoy en día, Bitcoin y Ethereum son las redes más valiosas, conocidas y empleadas por la comunidad de las criptomonedas. 

Ocupando el primer y segundo lugar respectivamente. No obstante, Bitcoin y Ethereum poseen grandes diferencias. Por ejemplo, Bitcoin, la moneda de la red Bitcoin, fue creada como medio de pago y de resguardo de valor.  Mientras que **Ethereum, fue desarrollada con la finalidad de ser mucho más flexible y programable permitiéndole evolucionar con nuevas capacidades en el tiempo.**

Esto gracias a EVM y Solidity, las dos herramientas que permiten a los desarrolladores sacar el máximo provecho de Ethereum. Con Solidity, se facilita la tarea de desarrollar aplicaciones distribuidas (DApps) u otras funciones que hagan uso de los Smart Contracts.

El desarrollo de Ethereum comenzó como una idea en la mente de Gavin Wood en 2014. La idea fue materializada por Christian Reitwiessner junto a un equipo de trabajo. El resultado de este trabajo llevó a Solidity. Desde entonces, el desarrollo de Solidity ha mantenido su evolución y en la actualidad se encuentra en la versión 0.8.13 del lenguaje (16 de marzo de 2022).

####  Características de Solidity
1. Es un tipo de lenguaje orientado a objetos (OO) como C++ y C#.
2. **Fue diseñado específicamente para desarrollar aplicaciones para la red Ethereum.** Por lo que solo corre en la blockchain Ethereum o derivadas compatibles.
3. **Una ventaja que posee este lenguaje es que el código fuente de los programas que son realizados con él puede ser accedido públicamente desde la blockchain.** Incluso estando en bytecode, es posible descompilarlo y obtener una muestra bastante clara del código fuente original.
4. **Solidity soporta la herencia y la herencia múltiple,** dotándolo de una gran flexibilidad a la hora de programar elementos complejos.
5. **Este lenguaje también proporciona una serie de bibliotecas muy útiles** que facilitan la programación de los Smart Contracts, haciendo que el código sea reutilizable y más sencillo de mantener.

####  Entornos de desarrollos disponibles
Como casi todo lenguaje de programación, Solidity puede explotar las ventajas de un entorno integrado de desarrollo o IDE.

En Ethereum, el IDE oficial es conocido como Remix. 

Este facilita a los desarrolladores la creación de Smart Contract, a la vez que permite tener acceso al estado y propiedades de los Smart Contract ya creados. Además, cuenta con poderosas herramientas de corrección y análisis de código para ayudar a los desarrolladores a depurar sus programas.

Remix también puede ser ejecutado y usado de forma online a través de Firefox o Chrome o directamente en nuestro ordenador. Y aunque este es el IDE oficial de Ethereum, también existen otros entornos compatibles con el lenguaje Solidity. 

**Atom es una herramienta editable que se puede emplear para personalizar cualquier cosa. Podemos encontrar un paquete conocido como Etheratom que emplea la biblioteca web3.js para interactuar con un nodo de Ethereum.**

Otro IDE que podemos encontrar es el plugin Visual Studio Code, creado por Microsoft. Este permite la creación y desarrollo de Smart Contract a través de un compilador de Solidity. También permite la creación de aplicaciones para Microsoft y aplicaciones webs modernas y servicios en la nube que usen su servicio Azure.

###  Otros lenguajes de programación para Smart Contracts
Los Smart Contracts pueden ser escritos en distintos lenguajes de programación.

Siempre y cuando exista el compilador y librerías capaces de traducir y servir de interfaz con las distintas capacidades Smart Contracts de la Blockchain que usemos.

Esto significa que es posible usar cualquier lenguaje de programación para crearlos, pero los desarrolladores de la Blockchain deben crear el set de herramientas básico para tal fin.

En tal sentido, algunos de los lenguajes de programación que podemos usar para crear Smart Contracts son los siguientes.

1. Bitcoin Script
2. Miniscript
3. Vyper
4. Cairo
5. Haskell
6. C++

####  1 | Bitcoin Script
El lenguaje de programación por defecto es Bitcoin Script. Este es un lenguaje de programación diseñado para Bitcoin y es el responsable de permitir la programación de transacciones dentro de la red, para hacer que Bitcoin cumpla con la premisa de “dinero digital programable”.

Si bien, Bitcoin Script es un lenguaje de programación bastante limitado debido a que no es Turing Completo y que funciona mediante un esquema de tipo pila. 

> Esto hace que Bitcoin Script no solo sea complejo de programar, sino también limitado en las características y funciones que presenta. 

**De hecho, Bitcoin Script está limitado a solo 256 tipos de instrucciones distintas, conocidas como OP_CODES,** muchas de las cuales aún no han sido definidas porque Satoshi Nakamoto las dejó en blanco. El fin de esto era mejorar sus capacidades en el futuro, pensando en las necesidades que pudiera tener la red en los años por venir. 

![[212.B4_bitcoin_script.png]]

El lenguaje Script de Bitcoin posee varias características y cualidades, entre las que podemos mencionar:
1. **Es simple** y requiere de un procesamiento mínimo.
2. **Su funcionalidad es limitada,** lo que aporta mayor seguridad al sistema.
3. **Al ser un lenguaje Turing Incomplete no posee bucles, por lo que se asegura que el programa deja de repetirse y termina.** Así, se evita la posibilidad de que ocurran errores y códigos maliciosos a la red Bitcoin.
4. Su simplicidad le permite ser **implementado en una amplia gama de dispositivos.**
5. No hay un estado anterior o posterior a la ejecución del script. **Toda la información necesaria para ejecutar el script debe estar contenida en él.**
6. **Está basado en una pila y puede usar dos tipos: Una principal y otra alternativa.** Donde esta última se emplea para el almacenamiento de datos de cálculos de pasos intermedios de una forma muy parecida a la tecla memoria en las calculadoras.
7. **El lenguaje de script de Bitcoin es bastante pequeño.** Solo puede contener 256 instrucciones, ya que cada instrucción está expresada en un byte.

> El propósito de la creación de un lenguaje script en Bitcoin, es el de proporcionar una serie de parámetros fáciles y flexibles para poder posibilitar una transacción.

**Cuando Satoshi Nakamoto desarrolló Bitcoin deshabilitó varias funciones, entre ellas la multiplicación.** Por lo que el script se mantiene simple en términos de programación. Entonces, este lenguaje de programación es lo que determina si una operación puede realizarse o no. Es decir, si dicha operación está autorizada para la transferencia de fondos.

En pocas palabras, **la creación del Bitcoin Script es lo que otorga la naturaleza programable de Bitcoin.** Es lo que nos permite, por ejemplo, enviar una transacción que la misma se valide solo si determinadas condiciones se cumplen. E**sta propiedad es algo único de Bitcoin y las criptomonedas, algo que el dinero digital actual no puede alcanzar**, y mucho menos el arcaico dinero físico. **Es la evolución del dinero** llegado a un punto en que incluso este puede actuar de forma independiente y descentralizada, atendiendo simplemente a la programación incrustada en él.

Por otra parte, el script de Bitcoin también evita la creación de errores en el sistema y el uso innecesario de transacciones muy complejas. De hecho, el script hace que las transacciones sean relativamente fáciles de calcular. Además, los bucles infinitos requieren muchísima más potencia de cálculo y ralentizan las redes, como se mencionó al principio.

Un ejemplo de Bitcoin Script sería el siguiente:

#####  OP_DUP
OP_HASH160
OP_PUSHBYTES_20 0706a504a6b9af3bc99a6554f4d5e167a107b40d
OP_EQUALVERIFY
OP_CHECKSIG

ScriptPubKey (HEX)76a9140706a504a6b9af3bc99a6554f4d5e167a107b40d88ac

Este sencillo script conocido como P2PKH, sencillamente hace una verificación de la PubKey (en hexadecimal) para saber si es correcto el parámetro OP_PUSHBYTE_20. Para ello hace una duplicación pubKey, aplica un OP_HASH160 (corresponde a un hash SHA-256 y luego un RIPEMD-160), realiza un PUSH de los primeros 20 bytes del parámetro (0706a504a6b9af3bc99a6554f4d5e167a107b40d) y verifica si son correctos. Si es cierto, entonces chequea la firma digital y permite el uso de Bitcoin. 

En este caso falta la sección ScriptSig, pero ello no impide la verificación que la transacción está usando el estándar SegWit de Bitcoin. En todo caso, puedes verificar esta operación en la siguiente imagen:

![[212.B4_verifiicacion.png]]   

####  2 | Miniscript
Miniscript es un lenguaje de programación que facilita la generación de Smart Contracts para Bitcoin.

**Permite que el software analice automáticamente un script, incluyendo la determinación de los datos de los testigos que deben generarse para gastar los Bitcoin protegidos por ese Script.**

La representación estructurada de los scripts de Bitcoin proporcionada por Miniscript permite a los monederos ser mucho más dinámicos con los scripts que utilizan. Para apoyar ese dinamismo, los Miniscripts pueden ser creados usando un lenguaje de políticas de fácil escritura. Las políticas son componibles, permitiendo que cualquier sub-expresión válida sea reemplazada por otra sub-expresión válida (dentro de ciertos límites impuestos por el sistema Bitcoin).

Inicialmente, el lenguaje fue diseñado para ser parecido a JavaScript, sin embargo, el desarrollo del proyecto dejo ese desarrollo y lo traslado a Rust, el cual sigue en desarrollo y ya se encuentra en proceso de ser integrado a Bitcoin Core, con varias propuestas para agregar soporte oficial a este lenguaje. 

![[212.B4_miniscript.png]]

De esa forma, Miniscript se transformaría en un crate de Rust, que permitiría usar Rust para realizar Smart Contracts para Bitcoin, todo un adelanto que permitirá a Bitcoin disfrutar de potentes Smart Contracts Turing Completo dentro de su estructura. 

####  3 | Vyper
Vyper es un lenguaje de programación basado en Python dirigido a crear Smart Contracts para la máquina virtual de Ethereum (EVM). 

**Al estar basado en Python, este lenguaje disfruta de una enorme facilidad para desarrollar dApps para quienes están acostumbrados a este lenguaje, y al mismo tiempo, se alimenta de las potentes herramientas de depuración que están creadas para él.**

Entre sus principales objetivos tenemos: 
1. **Ofrecer una mejor seguridad,** ya que debería ser posible y natural construir contratos inteligentes seguros en Vyper.
2. **Simplicidad del lenguaje y del compilador:** El lenguaje y la implementación del compilador deben esforzarse por ser simples.
3. **Mejorar la auditoría del código.** El código de Vyper debe ser lo más legible posible. Además, debe ser lo más difícil posible escribir código engañoso. La simplicidad para el lector es más importante que la simplicidad para el escritor, y la simplicidad para los lectores con poca experiencia previa con Vyper (y poca experiencia previa con la programación en general) es particularmente importante.
4. **Permite una mejor comprobación de límites y desbordamiento,** especialmente en los accesos a arrays y en la aritmética.
5. **Soporte para enteros con signo y números decimales de punto fijo.** 
6. **Decidibilidad:** Es posible calcular un límite superior preciso para el consumo de gas de cualquier llamada a una función de Vyper.
7. **Tipificación fuerte,** para evitar los problemas de seguridad que el tipado dinámico puede traer. 
8. **Código del compilador pequeño y comprensible.** 
9. **Soporte limitado para funciones puras:** Cualquier cosa marcada como constante no puede cambiar el estado, lo que ayuda a mejorar la seguridad.

Vyper puede ser usado en Ethereum o en cualquier red EVM compatible como Polygon, BNB Chain, u otras redes derivadas de la EVM y sus primitivas criptográficas.

####  4 | Cairo
Es un lenguaje para escribir programas demostrables.La ejecución de un programa Cairo produce una traza que puede ser enviada a un prover sin confianza, que genera una prueba STARK para la validez de la declaración o el cálculo representado por el programa Cairo. 

La prueba puede entonces ser verificada utilizando un verificador (que puede o no estar en la cadena).

Cairo no es un lenguaje de Blockchain y, por tanto, no puede utilizarse para escribir contratos inteligentes (aunque puede llegar a serlo, más adelante). Sin embargo, Cairo es especialmente útil para crear funciones donde el uso de criptografía ZKP es esencial para mantener la seguridad y privacidad, de allí que se haya ganado un espacio en el desarrollo de dApps pensadas en proteger la privacidad, especialmente en plataformas de identidad soberana, DEX sobre zk-Rollups o cualquier aplicativo que use criptografía ZKP. 

####  5 | Haskell
Haskell en un lenguaje de programación muy usada en el mundo científico, y es el lenguaje elegido por Cardano.

**Haskell destaca por ser un lenguaje de programación funcional, que es muy adecuado para código de alta seguridad y programas que requieren un alto grado de verificación formal.**

Esto permite a los programadores puedan tener un mayor grado de certeza de que el código que han implementado es correcto, lo que sin duda ayuda a mantener la seguridad de los Smart Contracts y de las plataformas que dependen de ellos. 

**En Cardano, Haskell permite que los contratos inteligentes de Plutus y Marlowe pueden ser cuidadosamente implementados en un código preciso y formalmente verificado que ofrece un alto nivel de seguridad desde el principio.** Plutus y Marlowe se ofrecen como un conjunto de bibliotecas para Haskell, aprovechando la documentación existente de Haskell, los juegos de herramientas y una comunidad altamente profesional para proporcionar una base a partir de la cual construir contratos inteligentes seguros y de calidad empresarial.

Tanto el código off-chain como on-chain de Cardano está escrito en Haskell, lo que permite a Cardano heredar el rico cuerpo de investigación que ya existe dentro del ecosistema de Haskell, en lugar de reinventar la rueda con un lenguaje de contratos inteligentes totalmente nuevo y no probado. Básicamente, Haskell es un lenguaje que ha sido probado, que es seguro y que puede ser perfectamente utilizado para crear Smart Contracts Turing Completo que pueden ser verificados formalmente en todo momento. 

####  6 | C++
El lenguaje de programación C++ es un viejo conocido en el mundo de la programación. Es usado como lenguaje de programación para Smart Contracts en EOS. 

De esta manera, los desarrolladores pueden crear contratos inteligentes en EOSIO utilizando el lenguaje de programación C++. 

El kit de herramientas de desarrollo de contratos de EOSIO o EOSIO.CDT proporciona las bibliotecas y herramientas necesarias para construir un contrato inteligente. Consulte el manual de EOSIO.CDT para obtener más detalles sobre cómo empezar con EOSIO.CDT.

Para desplegar el contrato inteligente en la cadena de bloques, primero hay que utilizar la herramienta eosio-cpp para compilar el contrato inteligente. La compilación crea un archivo Web Assembly (WASM) y un archivo de interfaz binaria de aplicación (ABI) correspondiente.

El archivo Web Assembly o .wasm es el código binario que el motor WASM de la Blockchain ejecuta. El motor de ensamblaje web o motor WASM está alojado en el demonio de nodeos y ejecuta el código del contrato inteligente. La interfaz binaria de la aplicación o archivo .abi define cómo los datos son transferidos hacia y desde el motor WASM.

De esta manera, se puede usar el lenguaje de programación C++ y su capacidad Turing Completa, para crear Smart Contracts en EOS.


## U3. Práctica 1
###  Programación de Smart Contracts en Solidity I (Video)
![[213.B4_Programación_de_Smart_Contracts_en_Solidity_I.mp4]]
[Programacion de Smart Contracts en Solidity I](https://app.web3mba.io?wvideo=6l3v25oa8m)

Primero, vamos a entrar en doc.soliditylang.org, que contiene información sobre el lenguaje Solidity. Como veréis, al ingresar, nos lleva a la última versión, que es la 0.8.17 en el momento de grabar este vídeo. Esta documentación contiene todo lo que necesitáis saber sobre cómo funciona el lenguaje, qué tipos de datos hay, sus operadores, etc. Os recomiendo que, dado que en este curso solo vamos a hacer una pequeña introducción, si queréis profundizar en el tema, exploréis la documentación, que está muy bien redactada.

La siguiente página que creo que es muy interesante, de cara a ver las cosas de un modo más práctico y no tan teórico, es "Solidity by Example". En esta web encontraremos un montón de ejemplos de Solidity utilizando aspectos concretos, como, por ejemplo, variables, constantes, structs, etc. Al principio son cosas muy básicas, pero si hacéis scroll, encontraréis ejemplos cada vez más avanzados. Sin más, vamos a pasar a desarrollar nuestros propios smart contracts. Vamos a entrar en Remix.

Remix, para quien no lo conozca, es un entorno de desarrollo de Solidity que nos permite desarrollar, compilar e incluso desplegar tanto en redes virtuales como en redes de prueba o en mainnet. Por ahora, vamos a hacer cosas muy sencillas simplemente dentro del navegador, sin realizar ningún despliegue real. Esta es la página de inicio; como veis, aquí tenemos distintos apartados. Este es el del "file explorer", donde desarrollaremos nuestros contratos y demás. Si hacéis clic en la carpeta de "contracts", veréis que ya hay una serie de contratos de ejemplo que nos ofrece Remix. Ahora los veremos en más detalle.

Si nos dirigimos al símbolo de "Solidity Compiler", desde aquí podremos compilar los distintos smart contracts que hayamos desarrollado. En este caso, podríamos compilar automáticamente el smart contract "storage" que hemos abierto. Luego lo veremos también en más detalle. En este último panel, tenemos el de despliegue y realización de transacciones. Aquí podemos seleccionar el entorno en el que vamos a hacer el despliegue. Los que indican "vm" son en máquinas virtuales; esto sucederá solo a nivel de este navegador, pero podemos utilizar otros proveedores, como Hardhat, Ganache, una wallet, etc., para desplegar e interactuar con estos smart contracts en otras redes.

Este smart contract se llama "Storage.sol". La extensión "sol" es del lenguaje Solidity. Cada vez que hagáis un smart contract, mi recomendación es utilizar el mismo nombre que el contrato. Lo primero que vemos aquí es la licencia; realmente este no es un campo necesario, pero es recomendable. Si no lo indicáis en el contrato, el compilador de Solidity os lanzará un warning; en este caso, se está utilizando GPL3. Luego, lo siguiente que se indica es la versión de Solidity a la que apunta este smart contract, es decir, con qué versión de Solidity se va a poder compilar este contrato. En este caso, está utilizando una versión compatible con las versiones menores que la 0.9.

Entonces se pone "pragma solidity" y a continuación la versión. "uint256" significa que es un entero, un "integer"; "u" es "unsigned", es decir, no tiene signo, por lo que todos serían números positivos y de 256 bits. Esta es una propiedad del contrato. Luego aquí tenemos dos funciones: una función que es "store", que lo que hace es guardar un nuevo valor, actualizando la propiedad "number" pasándole un parámetro "num". Aquí lo que hacemos es definir la función, el nombre de la función, el parámetro que recibe, indicando primero el tipo y luego el nombre del parámetro, y luego un modificador de la función, indicando cuál es su visibilidad. En este caso es "public", por lo que esta función es accesible por cualquiera, incluso desde el propio contrato o desde contratos externos.

El cuerpo de la función simplemente realiza una asignación. La variable "number", que es esta propiedad que hemos mencionado, se iguala a "num", que es el parámetro que está recibiendo. Esta es una función que modifica el estado del smart contract, por lo que requeriría una transacción que modifique el estado y, por tanto, requiere un coste de gas. Luego tenemos esta otra función que se llama "retrieve". Esta función, como veis, no recibe ningún parámetro, también es pública, pero es "view". "View" significa que es una función que no modifica el estado de la blockchain ni del smart contract. Por lo tanto, no es necesario realizar una transacción para ejecutarla.

Esto se podría hacer desde la consola, por ejemplo, accediendo a esta función, que se ejecutaría automáticamente sin necesidad de ninguna transacción. Esta función nos devuelve... Aquí dice "returns", lo que significa que nos devuelve, y entre paréntesis nos indica el tipo que tiene que devolver. En este caso, nos devuelve la propiedad "number". Como veis, este smart contract es muy sencillo; simplemente modifica y permite visualizar una propiedad. Vamos a crear una carpeta dentro de "contracts", la llamaremos "mba". Dentro de esta carpeta, vamos a crear un nuevo archivo que llamaremos "simplecontract.sol".

Lo primero, como hemos visto antes, es establecer la licencia. Vamos a copiar esta de aquí, por ejemplo. Hay múltiples tipos de licencia, como podéis ver en la documentación de Solidity. Podéis poner "unlicense" si queréis, pero en este caso vamos a utilizar "MIT", que es una licencia muy conocida y recomendada por la documentación. El siguiente paso es establecer la versión. Para ello, como hemos visto antes, utilizamos la palabra clave "pragma", seguida de "solidity", que es el lenguaje. En el smart contract de ejemplo "storage" que hemos visto antes, se indicaba que la versión tenía que ser superior a una e inferior a otra. Nosotros lo que vamos a hacer es ponerle "0.8.17", lo que significa que el compilador que vamos a permitir que compile este smart contract tiene que ser 0.8.17 o superior, pero inferior a 0.9.

Ahora, lo siguiente es crear el contrato. Utilizamos la palabra "contract", seguido del nombre del contrato, que será "simplecontract", abrimos la llave y ya está. Con esto ya tendríamos la primera parte de nuestro contrato. De la misma manera que antes, vamos a crear aquí una variable que será de tipo "uint256", la llamaremos "number". Solo que si hacemos esto, la visibilidad de este parámetro no está indicada, así que lo que vamos a hacer es que sea pública. Además de números, también podemos utilizar otros tipos de datos; por ejemplo, vamos a utilizar "address", que es una dirección de Ethereum, como "0x...". También la vamos a declarar como pública y la llamaremos "myAddress".

Luego, vamos a utilizar un constructor. Los smart contracts pueden tener o no tener constructor; en este caso, sí que lo vamos a crear. ¿Para qué sirve un constructor? Para inicializar una serie de datos o realizar una serie de operaciones en el momento de creación del smart contract. En este caso, simplemente ponemos "constructor", abrimos paréntesis y le pasamos una serie de parámetros; puede que reciba parámetros o puede que no. Por ejemplo, si no queremos que reciba parámetros, podríamos decir "number = 42". Entonces, cuando creásemos el smart contract, automáticamente la propiedad "number" tendría el valor 42. O podemos establecer nosotros el parámetro, lo ponemos aquí, "uint256 _number", y entonces aquí "number = _number".

¿Por qué lo pongo con barra baja? Esto es algo que se suele hacer para que los parámetros vayan precedidos por una barra baja, lo que permite diferenciarlos fácilmente en el cuerpo de una función del resto de propiedades o variables temporales. Además, también nos permite, en casos como este, utilizar variables que representan lo mismo; este parámetro será el valor de "number", así que sabemos que si tiene barra baja, es el que le estamos estableciendo desde cero. Aquí vemos que nos ha salido una alerta. Esto nos indica que el compilador al que estamos apuntando, que es al menos 0.8.17, no se corresponde con el compilador que está definido actualmente.

Entonces, podemos ir a la pestaña de "compilador" y, como veis, está preseleccionado el 0.8.7. Abrimos el desplegable y seleccionamos el que queramos, en este caso el 0.8.17, que como hemos comentado, es el último. Muy bien, pues ya tenemos un smart contract muy simple creado. De manera que tenemos aquí estos botones que nos permiten copiar el ABI y el bytecode. El bytecode es el código compilado del smart contract y el ABI es la interfaz, es decir, contiene todos los elementos del smart contract. El ABI nos indica que hay una propiedad pública que es un "uint256", que es "number", y que hay una propiedad pública de tipo "address", que es "myAddress". También nos dice que el constructor recibe ciertos parámetros y contiene las firmas de todas las funciones.

Esto nos indica qué funciones hay, qué reciben, qué devuelven, etcétera, pero no contienen funcionalidad alguna; simplemente nos dice de qué manera se puede interactuar con este smart contract, mientras que el bytecode, como digo, es todo el código del smart contract compilado. Necesitamos ambas cosas para poder desplegar el smart contract, pero luego, para interactuar con él, necesitamos el ABI, que es la interfaz, y la dirección en la que se ha desplegado. Una vez que ya lo tenemos compilado y funciona correctamente, vamos a proceder a hacer el despliegue.

Tenemos aquí el smart contract y aquí lo podríamos desplegar, pero nos pide todos los parámetros que tengamos en el constructor. Actualmente, solo tenemos "number". Si ponemos aquí 36, por ejemplo, esto realmente lo único que hace es desplegarlo y se verá un poco más en detalle. Así también nos serviría. Le daríamos a "desplegar". De acuerdo, pues entonces aquí nos sale un tick que indica que ha ido todo bien; se ha desplegado. Aquí vemos la información. En resumen, esto nos ha desplegado un nuevo smart contract que aparece en "deployed smart contracts", y nos indica también en qué dirección se ha desplegado este contrato.

Aquí tenemos dos botones que se corresponden con las funciones con las que podemos interactuar, que son "number" y "myAddress". Entonces, le damos a "myAddress", que nos dice que nos devuelve "0x000000" porque no hemos establecido ningún valor para esta propiedad, así que es el valor por defecto, que son ceros. El "number", ¿cuál será? Pues el que le hayamos indicado como parámetro en el constructor, que nos devolverá 36. Aquí está. Como veis, esto pone que son "calls". Cuando pone "call", significa que realmente no está realizando ninguna transacción, a diferencia de lo que hicimos antes al desplegar el contrato, que aquí sí que hubo una transacción. Esto, como solo es una consulta de información, porque al final son funciones de tipo "view", no requieren de ninguna transacción.

Muy bien, pues con esto ya tenemos un contrato muy sencillo y vamos a pasar a ampliarlo un poco. ¿Qué podemos hacer? Podemos añadir un setter a estas propiedades, a ambas. Lo recomendable, tal como indica la documentación o como veréis en la mayoría de contratos, es seguir un orden de qué cosas se ponen en qué orden. Por ejemplo, primero se ponen las propiedades del contrato, el constructor iría después y luego las funciones. Hay otra serie de elementos que ya veremos, como los structs, los eventos, los modifiers, etc. La idea es esa. En este caso, que solo tenemos propiedades, constructor y ahora funciones, se hace en este orden.

Vale, pues entonces, como hemos visto, utilizamos la palabra "function". Vamos a poner el nombre de la función, "setNumber" en este caso. Los parámetros que va a recibir serán "uint256 _number_", como hemos dicho, es una buena práctica que los parámetros empiecen siempre con barra baja. Vamos a poner "public" porque esta función va a ser pública, ya que queremos que podamos interactuar con ella desde fuera. Abrimos las llaves. No he puesto un "return" porque esto no devuelve nada; solo vamos a modificar la función. Haremos exactamente lo mismo que estamos haciendo aquí. Podemos copiarlo y pegarlo para facilitar un poco.

Muy bien, entonces al final esto simplemente es un "set"; solo estamos modificando este valor y podemos hacer lo mismo para el "address". Vamos a poner "setMyAddress"; aquí el parámetro que recibe es de tipo "address" y lo vamos a llamar "_myAddress_". Realmente, el nombre del parámetro, como digo, es simplemente una manera de hacerlo, pero aquí podríamos llamarlo "ADDR" si queremos. Como he dicho, es mejor que empiece con barra baja. Pero bueno, "myAddress", también de tipo público. Y aquí lo mismo, "myAddress" pasa a ser lo que haya almacenado en "_myAddress_;"

Esta diferencia con otros lenguajes como Python es que siempre todas las sentencias deben acabar en punto y coma, como en JavaScript, aunque JavaScript es menos estricto. Vale, entonces hemos añadido estas nuevas funciones. Así que lo que vamos a hacer es ir de nuevo al compilador de Solidity, compilar de nuevo y luego ir a la pestaña de despliegue. Entonces, este smart contract que teníamos previamente lo vamos a desechar y vamos a desplegar de nuevo. Esta vez vamos a ponerle un 12, por ejemplo, para que sea distinto y le damos a "deploy". Entonces ya se nos ha desplegado aquí el smart contract. Como veis, antes teníamos solo estos dos botones de "number" y "myAddress", y ahora tenemos otros dos en naranja que son las funciones.

Estas sí que implican transacciones y, como veis, estas reciben parámetros, a diferencia de las otras. Entonces, si comprobamos, el "number" va a ser 12, "myAddress" seguirá siendo "0x0000" y vamos a establecer un nuevo número, por ejemplo, 17. Ahora, como veis, sí que ha enviado una transacción, del mismo modo que cuando se desplegó el smart contract. Aquí podréis consultar la información de la transacción, el hash de la transacción, desde qué dirección ha ido, a qué dirección ha ido, que en este caso es a la dirección del smart contract, que es esta de aquí, y el gas que ha consumido, etcétera.

Entonces, una vez que hemos cambiado el número, esta transacción ha ido correctamente. Si volvemos a consultar el número, ha cambiado y ahora pone 17. Muy bien, ahora también podemos cambiar el "address". Vamos a coger, por ejemplo, el propio "address" del smart contract. Remix nos permite muchas veces, cada vez que hay un "address" o un hash, poner el botón de copiar para facilitarlo todo. Entonces ya lo hemos copiado y lo vamos a pegar aquí. Le damos al botón y esto nos ha hecho una transacción. Entonces ya ha cambiado el "address" de la variable "myAddress". Cuando le damos aquí, ha cambiado; ahora es esta nueva información.

Esto está pidiendo un "address", así que no podríamos poner otra cosa; no podemos poner aquí el string "hola". Si lo hacemos, va a fallar. Como veis, aquí dice que la transacción a esta función ha fallado y nos indica que es un "invalid address"; se esperaba un argumento de tipo "address", pero el valor es "hola", así que no es válido. Como no es válido, no se ha podido realizar y si vamos a "myAddress", nos sigue devolviendo el valor que habíamos indicado inicialmente. Vale, pues vamos a seguir ampliando nuestro smart contract para añadirle más funcionalidad.

Vamos a añadir una función que sea de tipo "view". Como lo que hemos visto antes era simplemente un getter, aquí vamos a ponerle un poco más de funcionalidad. Vamos a crear una función que se llame "isThisNumberLarger". Vamos a pasarle un parámetro que será "number". Va a ser una función de tipo público y de tipo "view" porque no va a modificar el estado del smart contract. Además, nos va a devolver un valor de tipo booleano. Entonces, ¿qué va a hacer esto? Nos va a decir si nuestra propiedad "number" es mayor que el parámetro que le hemos pasado.

Además, también vamos a explorar otro tipo de funciones. Hemos hablado de las funciones que son de tipo "view" y ahora vamos a hablar de las que son de tipo "pure". Vamos a crear una función "sum". Recibirá dos parámetros, que llamaremos "number1" y "number2". También será de tipo público. En lugar de "view", será "pure" y lo que nos devuelve es un "uint256". Esta función simplemente devolverá la suma de "number1" más "number2". ¿Por qué es de tipo "pure" y no "view"? Porque las funciones de tipo "view" no modifican el estado del smart contract, pero sí leen el estado del mismo.

Es decir, aquí estamos accediendo a la propiedad "number", mientras que en esta función de suma, le estamos pasando dos parámetros y nos está devolviendo la suma de ellos. No importa lo que contenga el smart contract, ya que no lo vamos a consultar. Entonces, esta función... ¡Uy! Perdón, esto no lo he puesto correctamente. Esta función, al no leer el estado del smart contract, se puede clasificar con este tipo más restrictivo, lo que además ahorra gas. En Solidity, es muy importante hacer las cosas de la manera más económica posible, ya que esto supone un ahorro de dinero real cuando está desplegado en redes públicas, especialmente en mainnet, que es bastante caro.

Entonces, es muy importante intentar ahorrar el máximo posible. Muy bien, pues vamos a ir de nuevo aquí a la compilación. Como tenemos "auto compile", esto no sería necesario, pero simplemente lo hacemos para comprobarlo. Vamos a desechar el smart contract que teníamos desplegado y vamos a desplegar este nuevo. Vamos a poner aquí un parámetro que será 10, por ejemplo. Desplegamos y ya lo tenemos aquí desplegado. Aquí tenemos lo mismo de antes; "myAddress" es "0x0000", el "number" es 10, que es lo que hemos puesto, todo eso es lo mismo de antes.

Vamos a probar las cosas nuevas que son "isThisNumberLarger" y "sum". Como es 10, si le pongo aquí un valor de 8, este me devolverá "false". Si le pongo un valor de 13, nos devolverá "true". "bool" es otro tipo de dato, igual que hemos visto ya con "uint256" y "address"; esto es un valor booleano que solo puede tomar los valores "true" o "false". Ahora vamos a probar la función de suma. Aquí sí que tenemos, como son varios parámetros, los suyos que hagamos aquí el despliegue. Entonces aquí podemos poner los parámetros de cada uno de ellos; vamos a poner 5 y 3, hacemos el "call" y nos devuelve 8.

De nuevo, los que tienen el cuadradito azul significan que no modifican el estado; son "calls", así que no hay que realizar transacciones, mientras que estos sí requieren transacciones. Entonces ya hemos visto varias cosas: hemos visto las propiedades, la visibilidad pública, pero todavía no hemos visto ninguna de tipo privada, así que más adelante lo veremos. Hemos visto los modificadores de "view" y "pure", así que ahora vamos a ver algo nuevo: los eventos. Los eventos son algo muy importante en Solidity y son bastante interesantes.

Los eventos son sucesos que nosotros marcamos o se emiten en el smart contract en algún momento de su funcionalidad para que puedan ser leídos off-chain, es decir, desde fuera de la blockchain, por ejemplo, aplicaciones o servicios que estén escuchando la blockchain y estén atentos a que suceda algo. Por ejemplo, cuando se realiza una transferencia de un token ERC20, se emite un evento "Transfer". Esto se hace para que se esté escuchando y, cuando se detecte que se ha producido una transferencia, se realice alguna acción en un backend, en un servidor, etc. Estos eventos son para ser detectados desde fuera; no es algo que desde un smart contract puedas detectar que se ha producido un evento en otro smart contract.

Los eventos los pondríamos debajo de las propiedades y antes del constructor. Este será un evento que se disparará cuando se modifique la propiedad "number". Aquí se le pasarán una serie de parámetros; ¿cuáles vamos a pasar? Pues "oldNumber" y otro parámetro que será "newNumber", acabando en punto y coma, como siempre. Entonces, ¿de qué nos servirá esto? Cada vez que se cambie el número, si estamos escuchando los eventos del smart contract, sabremos cuándo alguien ha cambiado ese número. Podremos ver de qué número ha cambiado a qué número. Esto lo podemos hacer, por ejemplo, aquí, cuando hacemos el "setNumber".

Entonces aquí utilizamos la palabra "emit", que es para emitir el evento, seguido del nombre del evento, que será "newNumberSet", y los parámetros que recibe. ¿Cuál será el viejo número? Pues aquí lo que actualmente es "number". ¿Cuál será el nuevo? El que estamos pasando por parámetro, "number" con barra baja. Muy bien, desechamos el smart contract anterior, desplegamos de nuevo y, como vemos, vale 5. Ahora vamos a ponerle un valor de 8, por ejemplo. "SetNumber" llamamos a la función y aquí se ha enviado una transacción. La consola de Remix nos permitirá comprobar el evento que se ha emitido.

Aquí dentro de "logs", observamos que hay una propiedad que dice "event" y nos indica el número del evento, que es "newNumberSet", y aquí los argumentos. Los argumentos del evento nos los muestra de dos maneras distintas: o bien por el orden, que es 0 y 1, o bien por el nombre de la propiedad, que son "oldNumber" y "newNumber", que en este caso ha pasado de 5 a 8. Esto es una manera bastante útil de poder observar los cambios que se han producido en el smart contract desde fuera.

Otra cosa interesante de Remix, que no he comentado, es que además de desplegar aquí, podemos cargar un smart contract que ya se haya desplegado previamente. Por ejemplo, si copiamos su dirección, lo descartamos y pegamos aquí la dirección, al darle, nos mostrará el smart contract que ya hemos desplegado anteriormente. Esto, en el entorno de una máquina virtual, no tiene mucho sentido, pero si estamos utilizando un proveedor distinto, por ejemplo, en una red de pruebas como Rinkeby, si queremos interactuar con un smart contract que ya existe y que hemos desplegado en otra sesión, simplemente podemos copiar su dirección y darle al botón.

Como vemos, aquí ya está; si le damos al "number", está en 8, que es el valor que le habíamos puesto anteriormente. Con esto ya hemos visto los eventos, pero también podemos decir que queremos emitir este evento en el constructor, porque en el constructor también estamos cambiando el número de 0, que es el valor inicial, al parámetro que le estamos pasando. Podríamos copiar esto aquí y entonces estaríamos emitiendo el evento y cambiando el número tanto en el constructor como en esta función. Sin embargo, lo que estamos haciendo es algo que a mí personalmente no me gusta: repetir código.

Todo lo que se puede hacer para evitar repetir código es mejor, porque facilita la legibilidad y el mantenimiento. Si tienes el mismo código repetido en varias funciones y luego, por alguna razón, lo cambias en una, pero no en otra, te encuentras con comportamientos inconsistentes. Cada vez que se repite código, en este caso son solo dos líneas, pero en otros casos puede ser más complejo. Entonces, ¿qué vamos a hacer? Vamos a extraer esta funcionalidad de emitir el evento y cambiar el valor de esa propiedad a otra función externa.

Vamos a crear una función y esta función será de tipo privado. ¿Qué implica eso? Que no podremos interactuar con ella desde fuera. Es decir, ¿veis aquí todas las funciones a las que podemos acceder? Esta función que vamos a crear no estará aquí, porque al ser de tipo privado, solo se podrá acceder desde el propio smart contract. Entonces, ¿para qué se utilizan este tipo de funciones? Por ejemplo, para lo que hemos hecho, cuando internamente el smart contract tiene que realizar algunas acciones que solo serán llamadas desde el propio smart contract, que no queremos que se llamen desde fuera.

Muchas veces, las funciones privadas se nombran con un guion bajo delante del nombre de la función. Esto permite visualizar rápidamente que esta función es privada, es algo interno del smart contract. Entonces, vamos a hacer lo mismo. "_setNumber_". Esta función hará exactamente lo mismo; recibirá el parámetro "number", solo que en lugar de ser "public", será "private". Hará exactamente lo mismo que hemos mencionado aquí: emitirá el evento y cambiará la propiedad. Entonces, donde estamos haciendo estas acciones, llamaremos a esta función privada: "_setNumber(number)_;".

El smart contract se ha compilado correctamente. Desechamos este, desplegamos de nuevo, poniéndole un 5, por ejemplo. Cuando vengamos aquí y veamos la transacción, esta es la transacción que ha desplegado el smart contract; vemos que se ha llamado al evento, pasando de 0 a 5. Si lo cambiásemos a 12, por ejemplo, generará una nueva transacción que lanzará otro evento de 5 a 12. Con esto hemos aprovechado para ver cómo funcionan las funciones privadas y cómo evitar repetir código, logrando un código más reutilizable.

###  Programación de Smart Contracts en Solidity II (Video)
![[214.B4_Programación_de_Smart_Contracts_en_Solidity_II.mp4]]
[Programacion de Smart Contracts en Solidity II](https://app.web3mba.io?wvideo=fa8on4840i)

En este nuevo vídeo, vamos a crear otro contrato para seguir explorando las posibilidades que nos ofrece el lenguaje Solidity. Vamos a desarrollar una especie de juego y comenzaremos creando un archivo que llamaremos "game.sol". Primero, estableceremos la licencia, que será MIT, y luego definiremos la versión de Solidity. Como dijimos en el vídeo anterior, utilizaremos "pragma" y la versión será la 0.8.17, es decir, desde la 0.8.17 hasta la 0.9.

El contrato se llamará "Game" y en este pequeño juego, cada usuario podrá crear un héroe, y los héroes podrán luchar entre ellos. Para ello, introduciremos un nuevo concepto llamado "struct". Un struct es como un tipo de dato, y lo llamaremos "Hero". Aquí detallaremos las propiedades que este tipo de dato tendrá. El héroe tendrá un nombre, un nivel, un nivel de ataque y un nivel de defensa. Como mencioné en otros vídeos, es una buena idea mantener un orden sobre qué va antes y qué va después. Los tipos de datos, en este caso los structs, deben ir antes de las propiedades. Esto definirá el tipo de dato "Hero" con todas sus propiedades, y ahora veremos cómo asociar a cada usuario con uno de estos héroes.

Para ello, introduciremos un nuevo tipo de dato que es el "mapping". El mapping es como un hashmap o un diccionario en otros lenguajes, que asocia una clave con un valor. En este caso, la clave será un "address", que será la dirección del usuario. Luego, el valor será un objeto de tipo "Hero". La variable será pública y la llamaremos "heroes". Ya tenemos el tipo de dato y esta propiedad que indica la asociación entre los usuarios y los héroes. Podríamos crear un constructor, pero en este caso lo omitiremos, ya que no es necesario que existan constructores en el contrato.

Lo que sí haremos es crear una función para poder crear el héroe. Entonces, ¿qué parámetros le pasaremos? Vamos a pasarle el nombre. En cuanto a los strings, cuando se pasan como parámetro, hay que usar la palabra clave "memory", porque es un string que está en memoria. Hay otros tipos de modificadores, pero para este caso, siempre será de tipo "memory". Así que indicamos el parámetro "name" y el resto les daremos un valor por defecto. Vamos a asociar en este mapping, en nuestra propiedad de "heroes", el address de la dirección que está enviando la transacción a un nuevo héroe.

Hay una serie de variables globales que se pueden acceder desde Solidity y que nos permiten obtener cierta información. Por ejemplo, desde cualquier smart contract, podemos saber cuál es la dirección que está enviando la transacción a este smart contract. En este caso, es "msg.sender". Esta variable siempre contendrá la dirección que está enviando la transacción y será la clave de nuestro par que vamos a crear aquí. Entonces, haremos que "heroes[msg.sender]" sea igual a un nuevo objeto "Hero". Esto se puede hacer de múltiples maneras. Una forma es poner "Hero()" y pasar directamente los valores de todas las propiedades, en este caso sería "name", el nivel será uno por defecto, y el ataque y la defensa serán 100.

Esta es una manera de hacerlo. Otra forma sería, en lugar de hacerlo así, indicar mediante clave y valor cómo será. Lo voy a poner... Comentamos esto. Por cierto, los comentarios en Solidity se hacen con doble barra "//". También se puede hacer con barra y asterisco ```"/* ... */"``` si queremos hacer un comentario de bloque. Otra opción que podríamos utilizar aquí sería lo mismo, "Hero()" y aquí introducimos el objeto, pero para eso introducimos unas llaves y aquí sí que iríamos poniendo cada uno de los parámetros: "name", "name", "level", 1, etc. Pero como son pocas cosas y es sencillo, lo dejaremos de esta manera.

Con esto ya crearíamos el héroe. Podemos ir compilando y ver qué pasa. Compilamos "game", nos vamos a la pestaña de despliegue, tenemos todo marcado como en los vídeos anteriores, y desplegamos. El despliegue ha sido exitoso y aquí tenemos las dos funciones: la propiedad pública "heroes" y la función "createHero". Esta recibe como parámetro un address y, como decimos clave-valor, si introducimos el address, nos devolverá la propiedad "Hero". Por ejemplo, si ponemos el address de la cuenta con la que hemos hecho el despliegue, lo pegamos aquí y nos devuelve el objeto vacío con todos los valores por defecto. Como veis, el string está vacío y tanto el nivel como el ataque y la defensa están a cero.

Ahora mismo podemos crear un héroe. Cuando lo llamemos, vamos a llamarlo "Pedro". Esto nos dice que ya ha enviado una transacción, que ha ido correctamente, y vemos el parámetro que hemos mandado. Si volvemos a llamar a esta función, aquí vemos que lo que nos ha devuelto es un objeto "Hero" con todas sus propiedades: "Héroe Pedro", nivel 1, ataque 100, defensa 100. Entonces, ¿qué podemos hacer para ampliar esto? ¿Qué pasa si llamo a la función "createHero" varias veces? Lo que sucederá es que se sobrescribirá. Si ahora me creo otro héroe que se llame "Antonio" y vuelvo a llamar a esto, me lo ha sobrescrito.

Con esto hay que tener cuidado; igual no queremos que este sea el comportamiento. Quizás alguien llama a esta función sin querer y tenía ya un héroe de nivel 200 y lo pierde. Así que aquí vamos a introducir un nuevo concepto que es muy importante: el "require". En Solidity, "require" comprueba que se cumple una condición y, si no se cumple, revierte la transacción. Es decir, anula la transacción. Cualquier cosa que se hubiese hecho previamente no se guardará. Si hubiésemos hecho cambios en el smart contract, da igual; esa transacción se cancela y no se lleva a cabo.

En este caso, lo que vamos a comprobar es que no existe ya un héroe para este address, para "msg.sender". Como el objeto "Hero" tiene toda esta información, el nombre, el nivel, etc., lo que podemos hacer es comprobar el nivel. Si el nivel es cero, sabemos que no existe un héroe, porque si se hubiese creado un héroe, sería por lo menos uno, ya que se crea con uno, o puede que sea más y luego suba el nivel si desarrollamos esa funcionalidad. Entonces, para eso vamos a hacer un "require".

Ponemos la condición booleana que en este caso será que "heroes[msg.sender].level" sea igual a 0. Es decir, tenemos que asegurarnos de que se cumple esta condición: no puede haber un héroe asociado a esta dirección. El "require" nos permite además poner un mensaje de error, de modo que si una transacción falla, podemos saber por qué ha fallado. En este caso, vamos a poner "You already have a hero". Entonces guardamos, borramos el smart contract que teníamos desplegado. Como lo tenemos en "autocompile", no hay que volver a darle. Desplegamos de nuevo.

Vamos a hacer lo mismo de antes. Creamos un héroe que se llama "Pedro". Y ahora creamos otro héroe que se llame "Antonio". Aquí, la transacción ha fallado, como podéis ver, sale una "X" y nos dice "revert", la transacción se ha revertido. Y aquí, "Reason provided by the contract", esto es el mensaje que le hemos puesto: "You already have a hero". Ahora hemos añadido esta restricción: no puedes crear otro héroe si ya tienes uno.

¿Qué es lo siguiente que vamos a hacer? Creo que podemos implementar una función de lucha, para que los héroes puedan enfrentarse entre sí. La función se llamará "fight". ¿Cómo vamos a hacer esto? Haremos que, al enviar una transacción llamando a "fight", se indique contra qué enemigo queremos enfrentarnos. Así que pondremos un "address enemy". Esto también será de tipo público. Aquí realizaremos la lucha. Vamos a pensar qué restricciones podemos poner a esta transacción.

Lo primero es que, si quiero luchar contra alguien, necesito tener un héroe. Así que aquí haremos lo mismo de antes. Vamos a hacer un "require" que verifique que "heroes[msg.sender].level" sea mayor que cero. Acordémonos de siempre poner la condición booleana y luego el mensaje. El mensaje será "You don't have a hero". Si no tienes un héroe, no puedes luchar. Muy bien.

¿Qué otra restricción podríamos poner? Que el enemigo al que nos estamos enfrentando también debe tener un héroe. Así que vamos a copiar y pegar. La propiedad "heroes[enemy].level" tiene que ser mayor que cero. Si el nivel es 0, significa que el objeto está vacío. Si el nivel es mayor que 0, significa que ya hay un objeto ahí. Entonces queremos que el enemigo tenga un héroe; si no, no podemos luchar. El mensaje de error será "Enemy doesn't have a hero".

Vale, ya tenemos dos restricciones que parecen bastante buenas. ¿Se nos ocurre alguna otra? A mí se me ocurre que no puedas luchar contra ti mismo. Si yo aquí en el address me pongo mi misma dirección, el héroe estaría luchando contra sí mismo y eso no es algo que queramos hacer. Así que hacemos "require(msg.sender != enemy)". Esta es la condición y el mensaje que pondremos será "You can't fight yourself".

Muy bien, pues ya hemos cubierto todas las condiciones que podemos poner. ¿Cómo va a ganar un jugador? Si su nivel de ataque es mayor o igual que la defensa del enemigo, eso tendría sentido. Entonces, "heroes[msg.sender]" es el objeto "Hero". Para acceder a cualquiera de sus propiedades, utilizamos el punto y la propiedad que queremos. En este caso, "attack". Si el ataque es mayor o igual que la defensa del enemigo, entonces habremos ganado el combate.

¿Qué pasa si ganamos el combate? Si ganamos, podemos hacer que suba de nivel. Aquí ahora mismo no tenemos nada. Vamos a poner aquí un "TODO". Ahora vamos a crear una función que nos suba de nivel. Esta función debe tener visibilidad. Si la hacemos pública, cualquiera podría subir el nivel de su héroe. No queremos eso, porque entonces el usuario llamaría constantemente a esta función y estaría muy OP. Así que lo que vamos a hacer es que sea una función privada. Como es privada, le pondremos la barra baja al inicio. Esto no es necesario, pero es una buena práctica. Al final, el estilo de programación depende de cada uno.

¿Qué pasa cuando un jugador sube de nivel? Vamos a hacer que su héroe suba algunas de sus propiedades. "heroes[msg.sender].level" será el nivel más uno. Así que sube uno en su nivel. ¿Qué más cosas vamos a subir? El nombre no va a cambiar, pero vamos a subir el ataque y la defensa. El ataque lo subiremos en 15, por ejemplo, y la defensa la subiremos en 10. Entonces ahora tenemos que llamar a la función simplemente, "levelUp". Como veis, no hace falta pasarle ningún parámetro.

Podríamos hacer que "levelUp" recibiese un parámetro con el address y entonces aquí, en lugar de "heroes[msg.sender]", sería "heroes[address]". Ojo, aquí, aunque estemos llamando a una función distinta, "msg.sender" sigue siendo la dirección que ha llamado la transacción. Es decir, aunque la llamada a esta función venga de otra función, "msg.sender" no cambia, porque quien ha iniciado la transacción es la dirección que manda la transacción. Ahora, si este contrato estuviese llamando a otro contrato, ahí sí que "msg.sender" cambiaría. Pero eso no aplica en este momento.

Ahora mismo, estamos haciendo como 6 puntos en DER. Otra opción sería indicarle aquí el address del héroe al que queremos subir. Son dos maneras distintas de hacerlo. Vale, pues con esto podemos ir probándolo. De nuevo, descartamos el contrato anterior y lo desplegamos de nuevo. ¿Por qué lo estamos desplegando de nuevo? Porque cada vez que hacemos un cambio, el contrato anterior sigue adelante con el código compilado y la interfaz que tenía antes. Por eso hay que volver a desplegarlo.

Esto es un tema que tiene Solidity. Si descubres un bug en tu smart contract, no puedes simplemente parchearlo y que siga funcionando. Toda la información que tuvieras almacenada se pierde. Es decir, si despliego este smart contract con esta nueva funcionalidad e intento acceder a cuál es mi héroe, estará vacío. Así que el héroe "Pedro" que creé antes ya no existe. Bueno, existe, pero en el contrato anterior. En este ya no existe; son dos contratos distintos. No podemos actualizar un contrato como tal, al menos no de esta manera. Así que cada vez que se hace un cambio, es un contrato nuevo.

Por eso hay que tener cuidado al utilizar smart contracts. Cuando despleguemos smart contracts, debemos estar muy seguros de que todo funciona, porque si no, hay que hacer todo desde cero y los datos que tengamos en el contrato anterior no se podrán migrar de manera sencilla a este. Vamos a crear un héroe. Comprobamos el nombre. Vale, "Pedro", ataque 100, defensa 100. Ahora necesitamos crear un enemigo. Aquí tenemos una serie de cuentas. La que estamos utilizando inicialmente es la de 5, B3, etc. Vamos a coger la segunda cuenta. Esta segunda cuenta no tiene un héroe. Comprobamos. No tiene un héroe, así que lo vamos a crear. Este se llamará "Antonio". Creamos un héroe.

Vale, ahora tenemos a "Antonio", que es nivel 1, de la cuenta A, B, etc. Y luego la de 5B tiene a "Pedro". Vamos a hacer que "Pedro" se enfrente a "Antonio". Para eso, ahora mismo estamos con la de 5B, que es "Antonio". Vamos a copiar la dirección de "Pedro". Entonces, estamos con 5B y vamos a luchar contra la A, B, lo que sea. "Fight". Vale, parece que ha ido todo correctamente. La transacción ha funcionado. Ahora volvemos a ver las características de este héroe.

Vale, "Pedro" ha subido al nivel 2. Ha subido al nivel 2 y ahora su ataque es 115 y su defensa es 110. Muy bien. ¿Qué pasa si intentamos...? Vamos a comprobar que los requisitos que hemos puesto funcionen bien. Intentemos utilizar a un héroe que aún no exista. Le damos a luchar. Ha fallado. No tienes un héroe. Entonces esta primera condición ya funciona bien. Vamos a intentar luchar contra nosotros mismos. Así que nos vamos a poner el de... Entonces, si estamos luchando contra AB8, vamos a ponernos el usuario AB8. "Luchar". Vale, nos sale "You can't fight yourself".

¿Qué pasa si intentamos luchar contra un address que no tiene un héroe? Copiamos esta dirección, la pegamos y vamos a luchar. Ah, disculpad, no, tengo que... No había cambiado, me había puesto con otro héroe, perdón, con otra dirección que no tenía un héroe. Me he vuelto a coger la primera. "Luchar". Enemigos en Javagirum. Vale, hemos comprobado ya todos los casos posibles. También hemos comprobado el caso exitoso, que es el que hemos hecho antes.

¿Qué más podemos hacer? Se me ocurre que podemos hacer una función de entrenamiento, de modo que podamos subir de nivel a un héroe sin necesidad de luchar contra otro. Por eso creamos la función "train". No le pasamos ningún parámetro. Será una función pública. Vamos a pensar qué "require" le podemos poner. Tiene sentido que tengas que tener un héroe. Si no tienes un héroe, no puedes entrenar. Si tienes un héroe, podrás entrenar, así que vamos a hacer que subas de nivel.

Y vosotros diréis, ¿qué diferencia hay entre poner "levelUp" como función pública? Al final, con llamar a "train" ya estás subiendo de nivel. Es como puede ser, ¿verdad? ¿Cómo podríamos hacer esto más restrictivo para que no puedas estar entrenando constantemente? Podemos ponerle un límite de tiempo. En Solidity, puedes acceder al momento actual. Igual que podemos acceder a "msg.sender", otra de las variables que existen es el timestamp del bloque en el que se ha minado esta transacción. Entonces, podemos utilizar eso para comprobar el tiempo. Podemos decir que solo se puede entrenar una vez al día, por ejemplo.

Así que vamos a añadir una propiedad nueva al héroe. También será un "uint256" y lo llamaremos "lastTraining". Este contendrá el timestamp de la última vez que se llamó a la función "train". El timestamp es un entero porque es un número de segundos. Es un número largo de segundos y, como no nos interesa exactamente qué significa ese número, sino solo la variación de ese número, si ha pasado suficiente tiempo desde la última vez.

Para eso, en "train" tendremos que añadir otro "require". Este "require" será que se pueda entrenar. Entonces, ¿cómo lo haremos? El timestamp, "block.timestamp", es la variable que hemos mencionado que se puede utilizar para acceder al momento actual, que es cuando estás enviando esa transacción. Esta tomará el valor del timestamp de ese momento. Entonces, tenemos que comprobar que el timestamp sea mayor.

Vamos a hacerlo de otra manera. Si le restamos el último momento en el que el héroe pudo entrenar, es decir, "heroes[msg.sender].lastTraining", la diferencia entre el momento actual y la última vez que entrenó tiene que ser mayor que lo que digamos. Solidity nos permite utilizar, si pusiéramos un número de segundos, por ejemplo, si quisiéramos poner una hora, serían 60 segundos por 60. Entonces esto sería una hora. O podríamos, si quisiéramos que fuese un día, multiplicar por 24. Pero Solidity nos permite ponerlo de una manera más sencilla: "1 days". Esto también funcionará de la misma manera.

Con esto estamos haciendo una comprobación de que ha pasado al menos un día desde la última vez que entrenó. Si no ha entrenado nunca el héroe, automáticamente "lastTraining" estará a 0. Entonces, el timestamp será un número bastante más alto, así que de primeras podrá entrenar. ¿Qué pasa aquí también? Al haber puesto esta nueva propiedad, nos está saliendo un mensaje de error. Porque claro, nos está diciendo que esto espera 5 argumentos, pero solo hemos pasado 4. Aquí hemos pasado el nombre, el nivel, el ataque, la defensa, pero no hemos puesto "lastTraining".

Vamos a poner ahora que sea 0. Así, de esta manera, podrá entrenar desde el primer momento. Muy bien, pues entonces ya estaría... No, realmente no, porque tenemos que actualizar el valor de "lastTraining". Si no lo actualizamos, estará siempre a cero y siempre podrá entrenar. Así que vamos a coger esta propiedad del héroe y la igualaremos al momento actual: "block.timestamp". También podríamos estar aquí poniendo eventos, por ejemplo, cuando suba de nivel podríamos poner un evento o cuando entrene, pero como eso ya lo hemos cubierto en vídeos anteriores, tampoco vamos a repetirnos demasiado.

Y ya tenemos listo nuestro vídeo de hoy. Espero que os haya gustado. Si es así, no olvidéis darle al botón de suscripción, al botón de "like" y compartir el vídeo con vuestros amigos. Y ya sabéis, si queréis ver más vídeos así, seguidme en Instagram, Facebook, Twitter, y también en Twitter. Nos vemos en el próximo vídeo. Como hemos dicho, lo tenemos en autocompilación. Descartamos los smart contracts anteriores y desplegamos. Se ha desplegado correctamente. Vamos a crear nuestro héroe. Se ha creado bien. Copiamos la dirección para ver su información. Nivel 1, ataque 100, defensa 100, "lastTraining" 0.

Vale, ahora vamos a entrenar. La transacción se ejecuta correctamente. Entonces, según esto, ya deberíamos haber subido de nivel. Vamos a comprobarlo. Se ha actualizado. Ha subido al nivel 2. Aquí, ataque 115, defensa 110. "LastTraining" es el timestamp del momento en que se ejecutó, que fue hace unos segundos. ¿Qué pasa si volvemos a darle a "train"? Ha fallado la transacción. Ah, claro, aquí nos dice que se ha revertido, pero no nos está dando información. ¿Por qué? Porque se me ha olvidado poner aquí el mensaje.

El mensaje, como digo, no es necesario, pero es bastante recomendable. Si ponemos aquí "You can only train once a day", solo puedes entrenar una vez al día. Bueno, pues vamos a destruir el contrato, desplegamos uno nuevo, creamos el héroe, observamos su información y entrenamos. Bien, volvemos a entrenar. Mal. "You can only train once a day". Esto ya funciona correctamente.

¿Qué más cosas podemos hacer? Cuando quiero ver mi héroe, que me esté devolviendo mi address todo el rato, si hemos dicho que lo podemos sacar de "msg.sender". Vamos a crear una función pública que se llame "getMyHero" que no reciba ningún parámetro. Entonces, esto lo que hará, como nos va a devolver el héroe, pondremos "returns (Hero)". Y aquí vamos a poner "return heroes[msg.sender]".

Ahora aquí nos dice, un momento, aquí pasa algo. ¿Qué es lo que pasa? Como he dicho antes, a veces hay que poner con algunos tipos de datos más complejos, con los tipos básicos, como booleano, int, etc., no hace falta. Pero con tipos más complejos, como es string o en este caso como es struct, hay que especificar un modificador de "memory", "calldata" o "storage". En este caso, le vamos a poner "memory". Entonces, "Hero memory". Guardamos. Esto es muy interesante; Remix nos avisa cuando algo se nos pasa.

Aquí lo que nos está diciendo es que esta función la podemos restringir a "view" y es cierto, porque esta función, como hemos dicho, será un "call", no será una transacción. Así que no requiere transacción, así que será "view". Vamos a probar. Desplegamos de nuevo. Vamos a "getMyHero". Nos devuelve aquí... Esto ahora nos lo pone de una manera un poquito más fea. Al final es lo mismo que si lo ponemos aquí. Lo que pasa es que aquí sí que nos devuelve cada uno de los valores.

Entonces, creamos un héroe. Si le damos aquí, nos saldrá "Pedro" y si le damos a "getMyHero", también nos vendrá "Pedro", nivel 1, ataque 100, "lastTraining" 0. Con lo cual, esto simplemente era un poco para facilitarlo. Al final, si esta información... esto simplemente es la manera de representarlo. Cuando estéis vosotros haciendo un servidor o recogiendo esa información para hacer algo, al final os da igual cómo aparezca, porque lo vais a gestionar como queráis.

¿Qué más cosas podemos hacer? Ya parece que está bastante completo, pero podemos hacer alguna otra cosa. Como he dicho en otros vídeos, no me gusta repetir código y si puedo evitarlo, lo evito. Así que, ¿qué código tenemos aquí repetido? Alguno que veáis. Yo veo uno claramente, que es el "require" de que no tengas un héroe. Esto lo tenemos que hacer cada vez que realizamos alguna acción que necesita un héroe. En este caso, es muy simple; solo tenemos "luchar" y "entrenar", así que tenemos este "require".

Podríamos extraerlo a una función que realice ese "require". Pero hay una funcionalidad de Solidity que está muy bien y que nos sirve precisamente para esto: los "modifiers". Los "modifiers" son como los decoradores que hay en otros lenguajes. Es algo que hace que se ejecute código antes o después de la ejecución de una función. Normalmente, se utilizan para hacer este tipo de comprobaciones. Ahora mismo solo tenemos "luchar" y "entrenar", pero imaginad que tenemos 10 funcionalidades distintas que puede hacer un héroe y en todas tenemos que hacer ese "require".

Utilizando este "modifier", de una manera muy sencilla, lo podríamos tener. Vamos a crearlo aquí, debajo del mapping, antes de las funciones. Hacemos un "modifier". Lo llamaremos "hasHero", es decir, que tiene un héroe. A los "modifiers" se les puede pasar un parámetro o se les puede omitir. En este caso, lo omitiremos porque no lo necesitamos. ¿Qué le vamos a poner aquí? El "require" que hemos mencionado para comprobar que tiene un héroe. Luego, lo que vamos a poner es "_;".

Esto es un poco raro, ¿qué es esto de " _ "? Pues como esto es un decorador, el guion bajo significa la función que estamos decorando. Este es el código que se ejecuta antes de la función y luego sigue haciendo lo que sea que haga la función. En este caso, vamos a ponerle ese decorador a estas funciones: la de "luchar" y la de "entrenar". Entonces, los "modifiers" los ponemos al final, después de "public", antes del cuerpo de la función. "hasHero". Y aquí también, "hasHero".

Entonces ya podemos quitar este "require". "requireHero". Vale. Vamos a comprobar que esto funciona. Desplegamos. Intento llamar a "entrenar". Ah, no funciona. "You don't have a hero". Eso es porque, como está funcionando en el sistema de "require", ha intentado ejecutar esto y no ha funcionado. Muy bien, pues yo creo que con esto tenemos ya un juego muy sencillo pero bastante completo.

Para hacer un repaso de las cosas nuevas que hemos visto en este vídeo, hemos visto los structs, cómo se crean, cómo se accede a sus propiedades, y hemos visto los mappings, que son asociaciones clave-valor, como si fuese un diccionario. Una cosa que no he comentado, pero que se puede hacer, es que se pueden encadenar distintos mappings. Puedo hacer un mapping cuya clave sea un número, por ejemplo, y cuyo valor sea otro mapping. Este mapping puede ser "address" y "bool", por ejemplo. Esto es algo que está permitido; podéis asociar tantos como queráis.

Los mappings son una de las estructuras de datos más importantes que hay en Solidity. Por ejemplo, para representar los balances de un token, se utiliza un mapping donde la clave es la dirección y el valor es un "uint256". Así es como se representan. Así que no dejéis de mirar el tema de los mappings, que es importante. ¿Qué más hemos visto aquí? Hemos repasado el tema de las funciones, la visibilidad, por ejemplo, esta función que es privada. También hemos revisado el tema de si es una función de tipo "view" o si es de transacción.

Hemos visto también los "modifiers", que son los decoradores. También hemos visto el tema de los "requires", que es muy importante, sobre todo en cuestiones de seguridad, porque habrá funciones que no pueden ser ejecutadas por cualquiera. Por ejemplo, si quiero hacer una transferencia de tokens, tenemos que comprobar que el dueño de los tokens es quien está llamando la transacción. Si no, cualquiera podría transferir tokens ajenos. Bueno, eso es todo por hoy. Gracias por ver el vídeo. Nos vemos en el próximo. Esta parte también es bastante importante. Así que, por ahora, ya está y ahora vamos a pasar a hacer más contratos y ver más funcionalidades de Solidity.

###  Programación de Smart Contracts en Solidity III (Video)
![[215.B4_Programación_de_Smart_Contracts_en_Solidity_III.mp4]]
[Programacion de Smart Contracts en Solidity III](https://app.web3mba.io?wvideo=wswph1psja)

En este nuevo vídeo, vamos a explorar otro concepto de Solidity: las interfaces. Las interfaces, básicamente, proporcionan una lista de funciones que los smart contracts que las implementen deben tener y deben implementar todas sus funciones. Las interfaces contienen simplemente el nombre de la función, los parámetros, lo que devuelven, etc., pero no contienen la funcionalidad, es decir, la implementación de esa función. No contienen un código ejecutable; son simplemente una guía de lo que deben tener los smart contracts que implementen esa interfaz.

Para ello, vamos a crear una interfaz de oráculo y una serie de oráculos que nos proporcionarán el precio de algunos tokens. Por ejemplo, vamos a hacer que nos den el precio de USDT y el precio de MATIC en la red mainnet de Ethereum. De acuerdo, primero vamos a crear una carpeta llamada "oracles" y dentro de esta carpeta, comenzaremos creando la interfaz "IOracle". Es recomendable que el nombre de la interfaz empiece por "I" para que sea fácil identificar que es una interfaz en lugar de un contrato normal. Para acelerar el proceso, vamos a copiar la licencia y la versión.

Normalmente, cuando hemos creado otros contratos, hemos puesto "contract" y el nombre del contrato, pero al ser esto una interfaz, hay que poner "interface" y el nombre de la interfaz, que es "IOracle". ¿Qué queremos que contenga? Queremos que incluya las funciones que tendrá la interfaz. En este caso, solo nos interesa una: obtener el precio. Así que la llamaremos "function getPrice". No recibe parámetros y lo que nos devolverá es el precio.

Hemos visto antes otros tipos de visibilidad, como "public" y "private". Aquí vamos a poner "external", porque las funciones de las interfaces deben ser externas. "External" significa que solo se puede llamar a la función desde fuera del contrato, es decir, desde otro contrato o desde una dirección, como una wallet, pero no desde el propio contrato. Todas las funciones de las interfaces son externas. En este caso, será una función "view" porque no modificará el estado de la blockchain; simplemente leerá y devolverá un tipo "uint256".

De acuerdo, esta sería nuestra interfaz. Como veis, es muy sencilla; únicamente contiene esta función. Ahora vamos a crear un oráculo que implemente esta interfaz. Creamos un nuevo archivo que llamaremos "StableOracle.sol". ¿Por qué "Stable"? Porque este será un oráculo que nos dará el precio de monedas estables, como USDT, USDC, DAI u otras similares. Para simplificar, lo que haremos es un contrato que nos devolverá siempre un valor fijo, que será 1. Normalmente, cuando se obtienen los precios de tokens, se suelen hacer relativos al dólar estadounidense (USD).

Entonces, aquí hacemos "contract StableOracle". Este será el contrato, pero queremos que implemente la interfaz. Para eso, tenemos que importarla en este contrato. Así que utilizamos la palabra "import". Debemos poner la ruta relativa donde está el contrato; al estar en la misma carpeta, será "./IOracle.sol". Ahora tenemos que decirle que este contrato es un "IOracle". ¿Qué implica eso? Estamos diciendo que este contrato debe implementar todas las funciones de esta interfaz. Si no lo hace, nos mostrará un error.

Vamos a hacerlo. La función debe llamarse igual, por supuesto. Tiene que recibir los mismos parámetros; en este caso, ninguno. Esto será una función "external view". Vamos a poner lo mismo. Aquí vamos a poner "override" porque estamos indicando que estamos sobrescribiendo la función de la interfaz. De esta manera, vemos que esta es una función de interfaz y devolverá lo mismo. Como esto será en stablecoin y lo haremos de manera sencilla, devolveremos 1, ya que representa 1 USD o 1 USDT.

Lo que sucede es que en Solidity no existen los decimales; lo que se hace es escalar, es decir, se multiplica y se añaden ceros en lugar de usar decimales. Normalmente, depende de la moneda, pero muchas veces es un estándar utilizar 18 decimales, que es lo que utiliza Solidity para el Ether, que son 10 elevado a 18 wei. Entonces, multiplicaremos esto por 10 elevado a 18, es decir, será un 1 seguido de 18 ceros. De manera simplificada, se puede poner como "1e18", que es 1 por 10 elevado a 18.

Aquí nos sale un warning que nos dice que esto no está leyendo nada de este smart contract, así que en lugar de "view", se puede poner "pure". Sin problema, lo ponemos como "pure". Con esto ya tenemos un oráculo que implementa esta interfaz. Ahora podemos crear otro oráculo que también implemente esta interfaz. Vamos a hacer uno para MATIC. Lo llamaremos "MaticOracle.sol". Para acelerar, vamos a copiar esto y pegarlo aquí. En lugar de "Stable", ahora será "Matic".

Como MATIC no es una stablecoin y tiene un valor que varía, vamos a poner una propiedad que será el precio, que es la que devolveremos cada vez. Entonces, creamos la propiedad "uint256 price", pero la pondremos como privada porque queremos que no se interactúe con este contrato directamente, sino que se haga a través de la interfaz "IOracle". Así que ya tenemos la función "getPrice".

Ahora aquí lo que podremos hacer es, en lugar de devolver 1e18, devolver la propiedad "price". Esto ya no será "view", ahora será "view" porque estamos leyendo algo del smart contract. Sin embargo, ahora mismo no le estamos asignando valor. Vamos a cambiar esto. Cuando despleguemos el smart contract, le pondremos en el constructor un parámetro "price" que será el que asignaremos a la propiedad "price". Esto es lo mismo que hemos hecho en otras ocasiones.

Cuando desplegamos el smart contract, le decimos que el MATIC vale tanto y se almacena esa variable. Cuando llamemos a "getPrice", será ese valor. Pero claro, MATIC es un token que cambia de precio, así que deberíamos tener aquí una función que nos permita cambiar ese valor. Vamos a hacer un "setPrice". Esto es muy parecido a lo que hemos hecho en vídeos anteriores. Establecemos el "price", esto será "public". No es "view" porque estamos cambiando el precio, así que esto será una transacción que modifica el estado.

Vale, pues ya tenemos dos contratos distintos, dos oráculos distintos, pero ambos implementan la misma interfaz "IOracle". Así que, como hemos dicho, nos da igual cómo esté implementado cada uno de estos smart contracts, porque nosotros solo utilizaremos esta interfaz. Vamos a llamar a "getPrice". Nos da igual cómo esté implementado, qué tiene por dentro, si llama a otros contratos; eso nos es indiferente.

Ahora vamos a crear otro smart contract que nos permita interactuar con estos. Vamos a crear uno que se llame "PriceChecker". Copiamos esto, el contrato se llamará "PriceChecker". Este contrato no le pondremos "is IOracle" porque no implementará "IOracle"; lo que hará es llamar a esos otros oráculos. En lugar de importar cada uno de ellos, podríamos hacer un "import MaticOracle.sol" e interactuar con "MaticOracle". Pero la gracia de esto es que basta con tener esta interfaz; podemos comunicarnos con cualquiera de ellos simplemente usando la interfaz y haciendo referencia al address de cada uno de esos contratos.

Vamos a hacerlo bastante genérico. Haremos un mapping, que es algo que ya hemos visto en el vídeo anterior, cuya clave será un address, que será el address del token cuyo precio queremos comprobar, y cuyo valor será un "IOracle", es decir, un objeto, un contrato que implementa la interfaz "IOracle". Lo pondremos como público y lo llamaremos "oracles". Básicamente, es un mapping que nos dice para cada token cuál es su oráculo.

¿Qué tenemos que hacer ahora? Haremos un setter para poder rellenar eso. Este recibirá el token al que queremos consultar el precio y el address del oráculo que nos dará esa información. Será público. Entonces, lo que hacemos, como hemos hecho en otros vídeos, es "oracles[token] = IOracle(oracle)". Con esto estamos instanciando un contrato que sigue esta interfaz con esta dirección. Entonces, esto es un objeto al que podremos llamar a todas sus funciones. Bueno, a todas, en este caso, es únicamente "getPrice".

Con esto ya no necesitamos nada más. Con acceder a "oracles[token]" ya tendremos acceso a esa función. Pero también queremos que nos diga el precio, así que vamos a crear una función que llamaremos "checkPrice". Aquí le diremos que reciba la dirección del token. Es decir, cuando le diga aquí la dirección del token USDT, por ejemplo, me devolverá 1, porque llamará internamente a través de la interfaz de "IOracle", llamará al "StableOracle" y me devolverá lo que sea que implemente esa función.

Vale, pues esto será "public view" y nos devolverá un "uint256". Entonces, esto nos devolverá lo que haya en "oracles[token]", que nos devolverá el objeto "IOracle", y de este llamaremos a su función "getPrice". Y ya está. Con esto ya tendríamos un contrato que podemos surtir de todos los oráculos que creemos, asociados a cada uno de los tokens, y podemos consultar los precios de cada uno de esos tokens.

Ahora vamos a desplegarlos, a compilarlos y a ver que todo funciona bien. Como está en "autocompile", aquí no habrá ningún problema. Vamos a empezar desplegando, por ejemplo, el "StableOracle", que es el primero que hemos hecho. La interfaz no se despliega; lo que desplegamos son cada uno de estos oráculos que implementan esa interfaz. Desplegamos el "StableOracle". Ha ido todo bien y aquí lo tenemos. De hecho, si le diésemos aquí a "getPrice", nos devolvería un 1 seguido de 18 ceros. Perfecto, lo mismo que esperábamos.

Ahora vamos a desplegar el de MATIC. Aquí nos pide un parámetro. Nos venimos aquí y decimos: "¿Cuánto vale ahora mismo un MATIC en USD?". Esto lo tenemos que transformar a... lo tenemos que escalar, es decir, multiplicar por 10 elevado a 18, para que tenga el mismo número de decimales que todos los demás oráculos. Así que lo que hacemos es pegar aquí el número, cambiamos la coma por un punto y decimos "por 10^18". Y entonces esto nos tiene que devolver el valor. Aquí está.

Vale, pues cogemos este número, que es 0.84 x 10^18, lo pegamos aquí y desplegamos el smart contract. Vale, ya tenemos aquí desplegados el "StableOracle" y el "MaticOracle". Lo mismo aquí, si le damos a "getPrice", nos devuelve ese valor. Podríamos actualizar el valor si luego cambiásemos, pero ahora no lo vamos a hacer. Por último, vamos a desplegar el "PriceChecker". Lo desplegamos y aquí lo tenemos.

Ahora mismo no tenemos ningún oráculo dentro de este mapping, así que lo que vamos a hacer es rellenarlo. Vamos a poner un oráculo para el USDT y otro oráculo para MATIC. ¿Cuál es el address del token? Yo lo tengo aquí ya abierto. En Etherscan, puedes buscar cualquier token. Aquí están los USDT, que son los más famosos. Aquí nos viene su dirección, que es la dirección del contrato. Al final, todos los tokens... Esto es un ERC20, es un smart contract que está desplegado. Copiamos su address y lo ponemos aquí en "setOracle". El token será este y el oráculo será el stable, así que como lo tenemos aquí desplegado, le damos al botón de copiar y lo pegamos.

Entonces estamos asociando la dirección de este token con la dirección de este oráculo. Llamamos a la transacción y se ha hecho correctamente. Ahora vamos a añadir, vamos a borrarlo para que no haya confusión. Ahora vamos a añadir el de MATIC. Vale, pues aquí lo mismo, tenemos aquí el token MATIC en la mainnet de Ethereum. Copiamos el address del token y ahora copiamos la dirección del oráculo de MATIC, que es este de aquí. Lo copiamos, lo pegamos y hacemos "Transact".

Muy bien, pues ya tenemos ambos oráculos. Si quisiésemos hacer una comprobación, copiamos aquí el address de MATIC y si le doy, me va a devolver 0.84, que es el oráculo de MATIC. Vale, pues entonces ya podemos consultar directamente los precios de cada uno de ellos. Vamos a consultar el de MATIC, que lo tenemos aquí a mano. Meto el address, estamos llamando a esta función de aquí, "checkPrice". Le vamos a meter el address del token de MATIC y a ver qué nos devuelve.

Vale, pues esto es lo que hemos puesto antes: 0.84 por 10^18. ¡Gracias por ver el vídeo! Y si queremos comprobar el precio del USDT, lo mismo. Vamos aquí a "checkPrice": 1 seguido de 18 ceros. Funciona perfectamente. Como veis, aquí estamos utilizando simplemente "IOracle" para interactuar con distintos smart contracts que están implementados de distinta manera. Cada uno tiene sus particularidades, pero la interfaz nos permite ser agnósticos a la implementación de ese smart contract. Lo único que nos interesa es la interfaz que presenta y la función "getPrice".

También podemos hacer ahora una modificación. Supongamos que el MATIC ha cambiado de precio. Vamos a simular que ha cambiado. Aquí tenemos este número, vamos a decir que en lugar de 0.84, sube a 0.87. Hacemos la transacción y copiamos de nuevo el número, la dirección de MATIC, "checkPrice", 0.87. Hemos cambiado el valor dentro del contrato del oráculo de MATIC y eso nos ha permitido que, cuando lo volvemos a consultar desde el contrato de "PriceChecker", obtenemos un valor distinto.

Y bueno, esto sería todo. Con esto hemos repasado un poco. Hemos visto cómo funcionan las interfaces. Hemos visto que son simplemente funciones sin cuerpo. Hemos visto cómo se importan contratos o interfaces de uno a otro. Hemos visto cómo hacer que un smart contract implemente una interfaz, poniéndole "is IOracle" y el nombre de la interfaz que hemos importado, y poniendo el cuerpo de la función, indicando que estamos haciendo un "override" de esa función. Luego, desde aquí, hemos visto cómo interactuar con distintos contratos a través de una interfaz unificada. ¡Gracias por ver el vídeo!

###  Programación de Smart Contracts en Solidity IV (Video)
![[216.B4_Programación_de_Smart_Contracts_en_Solidity_IV.mp4]]
[Programacion de Smart Contracts en Solidity IV](https://app.web3mba.io?wvideo=u1x4589guk)

En este vídeo vamos a hablar de OpenZeppelin. OpenZeppelin es una compañía que implementa una serie de contratos en Solidity, es decir, smart contracts. Muchas veces, implementa los estándares de una manera que está muy probada, auditada y es muy segura. Por lo tanto, en lugar de tener que implementar nosotros mismos smart contracts muy extendidos, como pueden ser el ERC20 o el ERC721, OpenZeppelin ya nos proporciona contratos que son muy seguros y fiables. Así que, en lugar de reinventar la rueda, es muy recomendable utilizar estos contratos que ya existen y que son tan confiables. Vamos a ver algunos ejemplos, los integraremos en Remix y observaremos cómo funcionan.

Nos unimos aquí a los contratos. Esta es la documentación de OpenZeppelin. Como podemos ver, tiene multitud de recursos, incluyendo temas de control de acceso, tokens, gobernanza y otras utilidades. Comenzaremos, por ejemplo, con el tema del control de accesos. También podemos revisar directamente el código fuente en GitHub, lo cual es bastante útil. Aquí accedemos a su repositorio de contratos. Esta es la última versión, pero se pueden seleccionar versiones anteriores si deseamos utilizar otros compiladores. Aquí podemos ver todas las versiones disponibles.

Vamos a ir a Remix y crearemos un contrato que utilice el control de acceso. Si habéis echado un vistazo a los smart contracts que vienen por defecto en Remix, notaréis que hay uno que se llama Owner. Este contrato permite utilizar un modificador que restringe quién puede acceder a ciertas funciones. Esto es similar a lo que hemos visto en un vídeo anterior, donde solo algunas direcciones pueden realizar ciertas acciones. En este caso, las funciones que tengan ese modificador OnlyOwner solo pueden ser utilizadas si la cuenta que lo envía es la que se ha establecido como owner.

OpenZeppelin ya nos proporciona una funcionalidad muy similar a esta, de modo que podemos simplemente utilizar su modificador en lugar de tener que implementarlo nosotros mismos. Así que, vamos a crear una carpeta que llamaremos OpenZeppelin y crearemos un contrato que llamaremos ContractWithOwner, por ejemplo. Vamos a copiar, como hacemos siempre, la licencia y la versión, y ahora importaremos el smart contract. Hay varias maneras de hacerlo. Si nos fijamos en la documentación, aquí nos explican cómo instalarlo, pero desde Remix no es necesario hacer ninguna instalación, ya que automáticamente detecta si estás utilizándolo y te instala el paquete directamente.

Entonces, se puede hacer de esta manera, con `@openzeppelin/contracts` y la ruta hacia el contrato que queramos, o incluso se puede hacer referencia directamente al smart contract desde GitHub. Si copiásemos esta URL de OpenZeppelin contracts, nos llevaría hasta allí. Pero, por ahora, nos quedaremos simplemente con el AccessControl. Vamos a copiar aquí lo que nos viene de ejemplo. En este caso, queremos el de Ownable. Aquí podéis comprobar que lo que viene es muy similar al ejemplo que se encuentra en Remix. Tenemos una propiedad privada que se llama Owner, y también tenemos una serie de eventos, etc. Lo importante es el modificador OnlyOwner, que comprueba que el owner del contrato es el mismo que el messageSender y, si no, nos lanza un error: "OwnableCaller is not the owner".

Así que, tenemos importado el smart contract de Ownable, y vamos a crear nuestro contrato, que hemos llamado ContractWithOwner. De una manera muy similar a como hicimos antes con las interfaces, para que un contrato implemente el nombre de la interfaz, este contrato lo que hará es heredar del contrato Ownable. Así que utilizamos `is` y el nombre del contrato que estamos heredando, `is Ownable`. Con esto, nuestro contrato es como si estuviese embebido dentro del contrato Ownable, lo que nos da acceso a todas las funciones y modificadores que esto permite.

Ahora que tenemos esto, vamos a probar a crear una propiedad uint256 que será pública y la llamaremos number, como hemos hecho en otras ocasiones. No creo que haga falta ni hacer un constructor, así que simplemente haremos la función de set. Esta función recibirá un parámetro llamado _number_, será pública y aquí asignaremos `number = _number`. Así que, esto es como lo hicimos inicialmente, de modo que cualquier dirección puede hacer esta modificación. Pero si ahora añadimos aquí el modificador OnlyOwner, que de nuevo es el que nos viene en el contrato Ownable que estamos heredando, ya no permitirá que cualquiera lo modifique, solo el owner.

¿Y quién es el owner por defecto? El address que despliega el contrato. Muy bien, vamos a hacer una prueba. Vamos a desplegar este contrato. Además de las funciones que hemos definido, que son el number, que es la propiedad pública, y el setNumber, que es la función para establecer esa propiedad, vemos que aparecen aquí algunas otras funciones o propiedades. Por ejemplo, esta owner, que también será una función pública que nos ofrece el contrato Ownable y que nos devuelve el address del owner. Como vemos, coincide con el address de la cuenta que ha desplegado el smart contract, y el number inicialmente es cero.

Podemos establecerlo, por ejemplo, en 15, y si le damos a number, nos aparecerá porque hemos podido cambiar ese número. Si ahora utilizásemos otra cuenta distinta, por ejemplo, la segunda de la lista que nos aparece aquí, e intentásemos cambiar ese número, por ejemplo, a 7, mandaríamos una transacción y nos daría un fallo. La transacción ha revertido, y el motivo que nos da es "OwnableCaller is not the owner", que es el mensaje que se muestra cuando el require falla, al comprobar que el owner no coincide con quien está enviando la transacción.

Entonces, ¿qué más opciones nos proporciona este contrato Ownable? Una opción es renunciar a la propiedad del contrato. Pero hay que tener cuidado con esto, porque una vez que renuncias a la propiedad, ya no puedes recuperarla, de modo que todas las funciones clave que están protegidas bajo el OnlyOwner ya no serían accesibles. Así que recomiendo tener mucho cuidado al hacer esto. Lo que sí se permite, y que en muchas ocasiones es bastante útil, es transferir la propiedad del contrato a otra cuenta. Por ejemplo, ahora estamos con esta cuenta, y no nos ha dejado cambiar el número, pero si cambiásemos la propiedad del contrato a otra cuenta, si lo hacemos desde la propia cuenta, no nos dejará, solo el owner puede hacerlo.

Entonces, si volvemos a enviar esa transacción con el owner, nos permitirá cambiarla, y ahora el que antes era owner ya no podrá hacer estos cambios porque ya no es el owner. Tendría que ser esta nueva cuenta quien realice ese cambio. Una vez que lo hace, ya sí que nos ha permitido cambiarlo y comprobamos que efectivamente ha cambiado este número. Este es uno de los ejemplos de smart contracts que facilita bastante el desarrollo con OpenZeppelin.

Ahora vamos a hacer otro ejemplo, vamos a crear un token ERC20. Si quisiéramos hacer un token ERC20 desde cero, deberíamos crear la propiedad de los balances, que sería un mapping, como hemos mencionado en otro vídeo, de cuánto balance tiene cada usuario. Tendríamos que implementar la función de minteo, de transferencia, y todas las que vienen definidas en el estándar. Pero como eso es algo muy habitual y ya está hecho mil veces, en lugar de hacerlo desde cero, vamos a importar el smart contract ERC20 que nos ofrece OpenZeppelin.

En la sección de contratos, tenemos un apartado que es tokens, donde encontramos distintos estándares. En este caso, nos centraremos en el ERC20. Vemos que está el ERC20 y también está el IERC20, que es la interfaz de utilización del ERC20. El que vamos a utilizar es el ERC20. Lo dejo aquí abierto para que luego consultemos alguna cosa, pero como veis, es básicamente la implementación del estándar de una manera muy segura y totalmente probada.

Así que vamos a crear un nuevo contrato y lo llamaremos MyToken.sol. Copiamos esto y la importación ya no será en AccessControl, sino que será en ERC20.sol. Entonces, aquí, igual que antes, declaramos el contrato, en este caso MyToken, que hereda de ERC20. Ahora, ¿qué tenemos que hacer aquí? Debemos definir el constructor, porque el contrato de OpenZeppelin requiere que se le indique el nombre y el símbolo del token. Por lo tanto, es necesario tener un constructor, ya que el contrato padre, que en este caso es el ERC20 de OpenZeppelin, requiere estos parámetros.

La manera de realizar el constructor es un poco diferente. Haremos el constructor, le pasaremos los parámetros que necesitamos, y luego debemos llamar a ERC20, que es el nombre del contrato padre, y entre paréntesis, pasaremos los parámetros que nos pide, que son el nombre del token, que será "MyToken", y el símbolo del token, que será "TKN". Este sería el constructor, así que, haciendo únicamente esto, ya tendríamos un smart contract de un token ERC20.

El problema es que ahora mismo no se ha minteado ningún token, es decir, sería un token con un total supply de 0. Así que hay que mintear algo, es decir, debemos generar una cantidad de tokens para alguien. Lo común aquí es dárselo al que ha desplegado el smart contract. Entonces, accederíamos a la función mint y diríamos para quién estamos minteando, que será el message.sender. ¿Y cuánto estamos minteando? Vamos a poner aquí un 1 seguido de un montón de ceros.

¿Por qué llamamos a mint? Estamos invocando una función que no estamos viendo, pero esta función es interna y nos ofrece el ERC20. Antes hemos hablado de las funciones públicas, privadas y externas, y ahora nos queda hablar de las funciones internas. Si buscamos mint, vemos que esta es una función interna. ¿Qué implica eso? Las funciones privadas solo se pueden acceder desde el mismo contrato, mientras que las funciones internas también se pueden acceder desde subcontratos, es decir, desde un smart contract que herede de este.

Y eso es justo lo que estamos haciendo. Desde el constructor del smart contract, llamamos a mint, indicando a qué cuenta y la cantidad, y esto, después de hacer ciertas comprobaciones, realizará la acción. Como vemos, está aumentando el total supply, emitiendo un evento, cambiando el balance y realizando una serie de acciones. Si hacemos esto, nuestro smart contract, nuestro token ERC20, tendrá esta cantidad de tokens, y nunca se podrá modificar la cantidad total porque no hay manera desde fuera de llamar a esta función. Al ser una función interna, no tendremos acceso a ella.

Vamos a hacer la demostración. Desplegamos el contrato anterior y desplegamos MyToken. Aquí ya vemos que hay un montón de información. Cuando no hemos dado ninguna función, todas estas son propias internas del ERC20 de OpenZeppelin. Entonces, ¿qué vemos aquí? El name, que es MyToken, el símbolo, que es TKN, y el totalSupply, que es la cantidad que hemos definido. TotalSupply indica cuántos tokens hay de este ERC20. ¿Hemos minteado todos estos? Eso es lo que hay. Los decimales, por defecto, son 18, que es muy común.

Podemos hacer una prueba de sobrescribir alguno de esos valores. También podemos comprobar el balance. Si vemos el balance del usuario que ha desplegado el smart contract, veremos lo que hemos minteado. Tiene sentido. Si cogiésemos otro, por ejemplo, este de aquí, nos dirá que es cero, por supuesto, porque no ha recibido ningún token. Aquí tenemos también las funciones de approve, transfer, etc. El allowance permite que otra cuenta use tus tokens de alguna manera, que pueda transferirlos o hacer lo que quiera con ellos.

Entonces, si estamos así, lo único que podemos hacer para que estos tokens cambien de mano es que el usuario los transfiera. Es la única manera. Vamos a probar a hacer la transferencia. Transferimos a esta otra cuenta que hemos puesto la mitad de los tokens. Si aquí hay esto que empieza por 1, 0, borramos 2, ponemos un 5, y hacemos la transacción. Se ha realizado la transferencia. De hecho, ahora, si lo vemos, vamos a notar que se ha generado un evento de transferencia. Aquí está: evento transfer desde esta cuenta hasta esta cuenta por el valor correspondiente.

Ahora, el balance que antes era 0, ahora será un 5 seguido de todos esos ceros. Como hemos mencionado, no hay manera de que se puedan mintear nuevos tokens. Es decir, nunca habrá más de estos tokens, ni menos, porque no se permite mintear ni quemar ninguno de esos tokens. Para modificar eso, deberíamos implementar una función de minteo. Aquí le pondríamos, digamos, que la forma de la función será muy similar a esto, que queremos mandárselo a una cuenta y una cantidad. Hacemos addressToMintAmount y lo pondremos de manera pública.

Aquí llamaremos a la función interna, que es esta de aquí. Entonces, lo que hacemos es mintear con la función que nos provee OpenZeppelin, mint, para la dirección y la cantidad. Como es una función interna, aquí no nos aparece, pero en cuanto damos una puerta de salida al exterior, que es una función pública, al desplegar el token de nuevo, veremos que ahora sí tenemos esta función de mint. El total supply sigue siendo el mismo, y si minteamos otra cantidad para quien sea, para la misma cuenta que lo ha desplegado, el total supply se duplicará.

Con esto, sí podemos aumentar la cantidad. ¿Qué más podríamos hacer? Antes de continuar, no es muy seguro tener una función de mint que sea pública, porque cualquiera podría venir y mintear tokens gratis para sí mismo. Entonces, ¿qué tenemos que hacer? Limitar quién puede mintear. Una manera clara de hacerlo es importar también el contrato Ownable de OpenZeppelin. Así, haremos que este smart contract, además de ser un ERC20, también sea Ownable. Solo el propietario de este smart contract podrá mintear.

Si volvemos, eliminamos este smart contract, lo desplegamos de nuevo y lo hacemos con la cuenta de arriba del todo, ahora solo el propietario, que aquí vemos de nuevo owner, será el único que podrá mintear. Si yo ahora quiero mintear con esta cuenta, puedo hacerlo. Pero si llega otra cuenta, por ejemplo, la última que hemos seleccionado antes, e intenta mintear para sí misma, se encontrará con que no puede. Esto combina lo que hemos visto del ERC20 con lo que hemos visto previamente del Ownable.

Estas son pequeñas piezas del rompecabezas que vamos uniendo, y sin apenas haber desarrollado nosotros prácticamente nada, ya estamos dando una funcionalidad más compleja. ¿Qué más podríamos hacer? De la misma manera que estamos minteando con el OnlyOwner, podríamos implementar una función para quemar tokens. La función de quemar tokens hace justo lo contrario, como podéis imaginar. También tenemos aquí una función interna dentro del ERC20 que permite quemar tokens de una cuenta específica.

Entonces, de manera sencilla, hacemos una copia y donde ponemos burn, ya está. Ahora, vamos a quemar un 10%. Le he quitado un 0 y de esta misma cuenta, porque hay que quitárselo a alguien que tenga los tokens, sino no podremos. La transacción ha ido correctamente y esto nos ha generado un evento. Como vemos, no hay un evento específico de quemar. Cuando se están quemando tokens, internamente se está haciendo una transferencia a un address que, al final, es lo mismo, porque nadie posee el wallet y, por lo tanto, nadie puede hacer nada con ello.

Así que, básicamente, esto es lo que hemos hecho. Si comprobamos el total supply, en lugar de 1,0 ahora hay un 9. Y aquí lo mismo, no podríamos quemar tokens desde otra cuenta que no tenga tokens. Por ejemplo, si intentamos quemar desde aquí, nos fallará. Primero, nos fallará porque estamos haciéndolo desde una cuenta que no es la 1, y si cambiamos al owner y lo intentamos de nuevo, nos fallará porque la cantidad que estamos intentando quemar excede el balance de esa cuenta. Lo mismo ocurre si intentamos hacer una transferencia; no puedes transferir más de lo que tienes, etc.

Este es un ejemplo sencillo de cómo modificar un ERC20. Os recomiendo que le echéis un vistazo a la implementación para ver cómo lo hace y demás. Otras opciones que se podrían cambiar, como he mencionado, son los decimales. En este caso, se podría sobrescribir esta función que es pública. Utilizando el override, igual que hemos hecho antes con las interfaces, en lugar de que los decimales sean 18, podríamos cambiarlos a 6, 12 o cualquier otro número que nos sea más manejable. Si no lo veis claro, de todos modos, id a la documentación. En la documentación se explica bastante bien los contratos y cómo hacer este tipo de modificaciones, por ejemplo, cómo modificar el tema de los decimales.

## U3. Práctica 2
###  Herramientas no-code para Smart Contracts (Video)
![[217.B4_Herramientas_no-code_para_Smart_Contracts.mp4]]
[Herramientas no-code para Smart Contracts](https://app.web3mba.io?wvideo=0loo3xj76e)

Una parte importante de toda la etapa de programación o desarrollo de una aplicación tiene que ver con las plataformas que nos permiten interactuar con la blockchain. En este caso, estudiaremos dos plataformas muy conocidas dentro de la comunidad: Infura y Alchemy. Presentemos cada una de ellas.

Infura es una plataforma dedicada a ofrecer a los desarrolladores de aplicaciones descentralizadas servicios que les permitan interconectar sus aplicaciones con los diferentes ecosistemas blockchain a los que esta plataforma tiene acceso. La idea es bastante sencilla: Infura se encarga de gestionar la conexión a todo lo que es la blockchain, es decir, a todos los nodos y a lo que estos pueden realizar dentro de la blockchain. Ofrecen una API sencilla a los desarrolladores para que puedan conectar sus aplicaciones a través de esta API y, de esta manera, tener acceso a las blockchains que Infura soporta.

Como pueden ver, es una web bastante conocida en el mundo del desarrollo web y de aplicaciones descentralizadas, porque, de hecho, parte de las grandes figuras del ecosistema, como Metamask, Uniswap o Brave, dependen de las infraestructuras de Infura o utilizan sus servicios para su funcionamiento. Entonces, ¿cómo podemos acceder a todos estos recursos de manera sencilla? La mejor manera es simplemente ir a su web, que es la que estamos viendo en pantalla, y tranquilamente podemos realizar un login, ya que los servicios básicos de esta web son completamente gratis. Hay servicios de pago, pero estos son para grandes aplicaciones que requieren un nivel de uso de recursos mucho más amplio, por lo que tendrían que aportar una cierta cantidad de dinero o pagar una determinada suscripción a los servicios de Infura.

Sin embargo, si eres un desarrollador que está empezando o que quiere desarrollar una aplicación sencilla, no te preocupes, porque Infura ofrece un plan gratuito que es el que empezaremos a ver aquí para que sepas cómo utilizarlo y cómo desplegar todo el potencial de esta plataforma. En este caso, ya tenemos aquí un login y simplemente vamos a proceder a loggearnos. Pero si esta es tu primera vez entrando a la plataforma, lo primero que debes hacer es registrarte. Aquí puedes crear una cuenta; simplemente debes poner tu correo electrónico, tu contraseña y aceptar los términos de uso. Luego, cuando tengas creada la cuenta, simplemente vas nuevamente a Login y aquí sí podemos acceder a la plataforma.

En este punto, ya podemos ver el dashboard de Infura. Podemos observar que se nos presenta información relevante. En este caso, la información más importante es el merge, ya que Infura tiene acceso a la red Ethereum. De hecho, fue creada con esa red en mente. Aquí podemos ver todos los productos que podemos desplegar. En este caso, tenemos la Web3 API, que es la API de Ethereum, la API de ETH2, IPFS y Filecoin. Estas son las cuatro redes que Infura soporta de forma oficial y completa en este momento. También podemos ver los roles que puedes crear dentro de cada uno de tus proyectos, que pueden ser dueño, administrador o contribuidor.

Ahora bien, ya tenemos aquí desplegada toda la parte del dashboard. Quiero crear una API que me permita interconectar mi aplicación en desarrollo con las capacidades que Infura me ofrece. Para eso, simplemente iremos a crear una nueva API o crear una nueva key y seleccionamos la red que queremos utilizar. En este caso, vamos a seleccionar la Web3 API. Podemos dar un nombre; en este caso, vamos a poner "Testing de Pruebas" y creamos. Automáticamente ya tenemos aquí nuestra primera API key, que es lo primero que nos aparece. También tenemos los endpoints de la red, que son las redes que podemos utilizar. En el lado de Ethereum, podemos utilizar la red mainnet o las redes de pruebas Ropsten, Kovan, Rinkeby, Goerli y Sepolia. Es decir, si queremos crear una aplicación descentralizada que funcione en la mainnet, debemos copiar este endpoint que está aquí, que, si nos damos cuenta, esta API Key es la misma que se repite aquí, para que nuestra aplicación descentralizada se conecte automáticamente a Infura y los datos que comparte tu aplicación con Infura se dirijan a la red main.

En caso de que queramos utilizar alguna otra red, simplemente seleccionamos y automáticamente la dirección cambia, en este caso, a rekenv-info.io. Eso significa que todo lo que hagamos con nuestra DApp irá dirigido a la red rekenv. Por supuesto, esto es simplemente para el caso de Ethereum. También podemos funcionar con otras redes. Por ejemplo, podemos utilizar las redes Polygon, Optimism, Arbitrum o Pallet. Si seleccionamos Polygon, podemos agregar la red Mainnet, pero también podemos agregar la red Moonbeam, que es la red de testnet.

¿Qué sucede en este punto? Que para ello, Infura nos pide un agregado, un addon sobre la plataforma. Si vamos allí, nos está pidiendo que seleccionemos un plan de pago, que en este caso puede ser el plan más sencillo, que es el de Developer, para poder agregar esta función con el respectivo pago que nos están solicitando. Sin embargo, en este caso simplemente nos vamos a manejar con Ethereum y vamos a volver atrás. Podemos ver aquí cómo tenemos estas cuatro opciones, pero estas son pagas. Debemos cancelar una pequeña suscripción para poder utilizarlas. También tenemos acceso a otras redes del tipo Web3, como serían Near, Aurora y la red Starnet. Sin embargo, Avalanche.js, Near, Stagnate y Aurora son redes que están disponibles, pero todas estas redes están en lo que se llama pruebas, es decir, se nos presta el servicio para este tipo de redes, pero debemos ser conscientes de que hay cosas que pueden ir bastante bien o otras que pueden ir bastante mal debido a que están en desarrollo dentro de la infraestructura de Infura.

Si pasamos a Settings, podemos ver que podemos cambiar el nombre de nuestro proyecto o borrarlo. También podemos elegir la parte de seguridad, viendo que al principio tenemos aquí nuestra API y nos dice claramente que mantengas tu API en secreto. Esto nunca debe ser legible para humanos en tu aplicación. ¿Por qué estas advertencias sobre la API? Bueno, la API es muy importante porque es la interfaz o el medio que te permite conectar tu aplicación con los servicios de Infura. Si alguien tiene tu API, esta persona tiene acceso a tu aplicación y a todo lo que ella hace. Por lo tanto, la API siempre debe ser bien protegida o, en este caso, ofuscada de alguna manera para que cualquier persona que pueda tener acceso a tu código o que esté incluida dentro de tu aplicación no pueda leerla directamente. Es decir, debes cuidarla como si fuera tu clave privada de criptomonedas, porque esta API es la llave secreta para acceder a todo tu sistema de interacción con Infura y tu aplicación.

Aquí también tenemos otros requerimientos, como sería un secret, en caso de que quieras agregar una clave adicional, o un sistema de JWT, que utiliza un sistema de claves públicas y privadas para agregar una seguridad extra a tu API. Finalmente, también tenemos la parte de Project Sharing, que nos permite compartir nuestro proyecto y colaborar con otras personas en su desarrollo. Simplemente nos pide que agreguemos un correo electrónico y seleccionemos el rol: administrador o contribuidor. ¿Por qué solo dos roles si mencioné tres al principio? La persona que crea el proyecto es el dueño. Este permiso no cambia en ningún momento. La persona que abrió el proyecto es la que será el dueño de ese proyecto todo el tiempo. Luego, simplemente nos quedarían los roles de administrador y contribuidor. Agregas el correo, seleccionas el rol y compartes el proyecto para que esta persona pueda colaborar contigo sin mayores dificultades en el desarrollo de tu aplicación descentralizada.

Como puedes ver, la parte administrativa que nos permite Infura es bastante sencilla, lo que sería la API y todo lo que nos permite conectarnos a sus servicios. También tenemos un apartado de stats, que nos indica cuántas veces estamos haciendo requests a Infura. Es decir, cada vez que hagamos una acción dentro de nuestra aplicación descentralizada, nos dirá cuántas veces hemos realizado una acción. También tenemos un reporte que nos dice cuántas veces hemos hecho una acción dentro de nuestra aplicación descentralizada. Esa acción o request se verá reflejada en este total, que es el volumen total de requests en las últimas 24 horas, y también nos indicará qué método se ha utilizado y cuántos de esos requests han ido a la red. Toda esa actividad se puede ver aquí, dentro de la parte de stats. También podemos ver las transacciones que se realizan. En este caso, está todo el proceso de cómo se realizan las transacciones, pero este es un servicio que se requiere directamente a Infura. Infura manejaría toda esta parte directamente, evitando que, en caso de que estés haciendo una transacción o una operación, esta simplemente se pierda. Con esta función, Infura agarra todas esas transacciones y las maneja de una forma más inteligente para evitar que la interacción de tu DApp no sea la correspondiente o no sea la mejor en este caso.

Finalmente, tenemos la sección de explorador, que es un explorador para la red IPFS, que nos permite crear proyectos y almacenar datos dentro de la misma. Por ejemplo, seleccionamos aquí "Testing". Ya tenemos nuestro proyecto. Nos indica que tenemos un total de 5GB de almacenamiento gratuito. No hay tamaño de archivos restringido y podemos bajar o subir 5GB de datos al mes. Este es nuestro plan básico. Si queremos aumentar nuestro plan, podemos comprar más espacio para seguir aumentando la capacidad de este sistema.

¿Para qué se utiliza el sistema de IPFS? Si nuestra aplicación descentralizada necesita almacenar información de las interacciones o de los usuarios, IPFS es una opción potente para almacenar toda esa información de forma descentralizada. De manera que cada usuario tenga su propio espacio de almacenamiento dentro de esta red descentralizada. Todos esos datos estarán unidos a la interacción de ese usuario, es decir, todos los usuarios pueden leer la información que ha subido al IPFS a través de tu aplicación descentralizada. Ninguno de los otros usuarios puede leerla porque para realizar esta acción, necesitas las claves privadas que se almacenan dentro del monedero de cada persona. Es la mejor forma de almacenar datos dentro de lo que sería una nube, porque mantiene privados los datos de cada uno de sus usuarios.

Así, como pueden ver, todas las opciones que Infura nos ofrece son bastante potentes y flexibles para generar aplicaciones descentralizadas. Simplemente quiero hacer una acotación y un hincapié en este punto. Vamos a la parte de aplicación. Fíjense que aquí está nuestra aplicación, "Crear 18". Vamos a manejar la key. Esta, como se puede ver, es la que está en la parte de abajo. Es nuestra API y ese es el dato que debemos tomar para llevarlo a nuestra aplicación descentralizada. Esto lo veremos un poco más adelante para que vean cómo podemos utilizar este dato dentro de nuestras aplicaciones y así interactuar con la blockchain de una forma más sencilla, utilizando códigos en Python o JavaScript, que son los dos lenguajes de programación más utilizados para generar aplicaciones descentralizadas.

¡Gracias! En sus pantallas tenemos a Alchemy. Alchemy, al igual que Infura, es un servicio de desarrollo para aplicaciones web 3 descentralizadas que nos permite crear APIs que facilitan la integración de nuestras aplicaciones con el universo blockchain de la web 3. ¿Qué diferencia hay entre Infura y Alchemy? El mercado de las aplicaciones descentralizadas es el mismo que el de las aplicaciones blockchain. La principal diferencia entre Alchemy e Infura es la capacidad o las opciones de redes que tenemos activas dentro de Alchemy. Alchemy soporta bloques como Ethereum, Solana, Optimism, Polygon, Arbitrum, Crypto.org, Starnet y Astar. Es decir, tenemos un mayor abanico de aplicaciones blockchain dentro de Alchemy que podemos utilizar para crear nuestras propias aplicaciones.

Al igual que Infura, podemos utilizar todo este poder a través de Web3 APIs, que fácilmente podemos crear al acceder a la plataforma. ¿Cómo podemos acceder a la plataforma? Simplemente vamos a la parte de Login y aquí tenemos la capacidad para registrarnos utilizando la cuenta de Google o simplemente suscribirnos con un correo electrónico y contraseña. En este caso, vamos a utilizar la suscripción por Google. Como pueden ver, la interfaz es bastante sencilla y distinta a lo que vimos anteriormente en Infura. Pero podemos ver que ya tenemos el dashboard y una aplicación de prueba creada. Como no hemos tenido ninguna interacción, simplemente nos aparece que no hay información que mostrar dentro del dashboard.

Ahora bien, si queremos crear una aplicación, es decir, si queremos crear nuestra propia API para utilizarla dentro de nuestra aplicación descentralizada, eso es bastante sencillo. Simplemente debemos ir aquí a "Create App" y ofrecer un nombre para la misma. En este caso, vamos a poner "Testing" también y haremos una descripción: "Testing de API". En este caso, la descripción es una aplicación de prueba para el desarrollo y vamos a elegir la cadena. Nos da opciones para elegir las cadenas Polygon, Solana, Astar, en este caso Astar Mainnet, o podemos elegir Polygon, Polygon Mumbai, o seleccionar Solana y Solana con las dos redes que tiene. Empezamos seleccionando Ethereum y elegimos la red Goerli. Creamos la aplicación y ya estamos dentro del dashboard de nuestra aplicación recién creada utilizando la red Goerli, tal como podemos ver aquí desplegado.

Ahora bien, ¿dónde está nuestra API? ¿Cuál es nuestra API en este caso? Simplemente vamos aquí, vemos detalles y empezamos a ver toda la información. En este caso, tenemos las unidades de computación, que han sido 0 porque el proyecto es nuevo. También tenemos la respuesta media, el éxito, la capacidad, el uso de las redes, la cantidad de requests que se han realizado, el éxito de esas requests, el total de requests en las últimas 24 horas y las requests que han sido marcadas como inválidas. Si queremos ver la key, vamos aquí a "View Key" y allí está nuestra API Key para interactuar con los servicios de Alchemy y todo el poder de esta red dentro de Ethereum.

Fíjense que aquí está nuestra API Key, nuestro endpoint, utilizando el protocolo HTTPS, y el endpoint utilizando WebSockets. Aquí están las capacidades de cómo podemos utilizar el SDK o las herramientas de desarrollo de Alchemy, utilizando lenguajes de programación como JavaScript, una consola o simplemente podemos utilizar Python. En este caso, podemos utilizar Python con V3 para hacer la conexión y podemos ver que hay diferentes partes de uso, es decir, códigos de uso para utilizar todo el potencial de esta aplicación. También podemos utilizar Go, que es el lenguaje de Google, un lenguaje bastante potente. Como pueden ver, hay varias opciones de lenguaje que podemos utilizar para realizar todas estas acciones. Simplemente debemos tener cuidado de copiar esta API y colocarla en los programas de prueba o en nuestra aplicación para utilizar todo este potencial.

Podemos tener el TH de prueba, agregar un wallet y la parte de seguridad. En este caso, la parte de seguridad es prácticamente la misma situación que hemos visto anteriormente. Podemos permitir direcciones de uso que estén permitidas para la aplicación, dominios que estén permitidos o direcciones IP. Esto podría verse como una especie de muro de fuego que nos permite controlar qué direcciones pueden interactuar con tu aplicación. También podemos agregar un monedero que nos dirige a recargar la parte de Metamask y también podemos agregar lo que serían ETH de pruebas. Fíjense que aquí ya estamos en la red Goerli. Vamos a hacer aquí la conexión al Faucet para probar. Fíjense que ya estamos conectados como José y tenemos un Faucet para Goerli. Simplemente copiamos la dirección de nuestro monedero, que ya está configurado para Goerli, y lo enviamos. Automáticamente nos enviará la totalidad de 0.25 Goerli ETH a nuestro monedero.

En este caso, podemos llegar a mandarlo a la red Mumbai. Vamos a hacer aquí para requerir lo que serían tokens de prueba, copiamos la dirección. En este caso, ya tengo aquí la red Mumbai activa. Vamos a esperar un momento a que la operación se haga efectiva. Y aquí está. Ya se hizo efectiva la operación. Ya tenemos 1.5 MATIC en la red Mumbai, que es la red de prueba de Polygon. ¿Y de qué nos sirve esto? ¿Para qué hemos realizado esta operación dentro de un Faucet? Las interacciones que se realizan en redes como Mumbai y Goerli, que son redes testnet, si bien no necesitan dinero real, sí requieren tokens de esas redes para funcionar. Recordemos que estas redes funcionan tal cual como lo haría la red Mainnet de cada una de estas redes. En este caso, Ethereum Mainnet y Goerli funcionan de la misma manera. Necesitamos pagar las comisiones de esas redes que, aunque lo hacemos con Goerli ETH, este token no tiene valor económico, pero necesitamos pagarlas para que las acciones se puedan realizar. Esto del Faucet nos ayuda a tener dinero en nuestros monederos que, aunque sea de la red testnet, podemos utilizar para hacer las diferentes interacciones con estas redes.

Ahora bien, cerremos aquí un momento y volvamos a Alchemy. Ya podemos ver aquí todo lo que es el dashboard de Alchemy. Podemos saber qué nos ofrecen estas cuatro opciones: seguridad, cómo agregar un monedero, cómo agregar tokens de prueba para nuestro monedero y la que es para hacer las interacciones con nuestras aplicaciones. Aquí en las aplicaciones, en el explorador, tenemos toda la actividad que se ha realizado dentro de nuestra aplicación descentralizada. Aquí tenemos el compositor. El compositor es simplemente una utilidad que nos permite crear requests especializados. Podemos utilizar las diferentes cadenas que Alchemy nos ofrece de soporte, las diferentes redes y los diferentes métodos que nos permiten acceder a la información dentro de las capacidades de respuesta del request de Alchemy.

En este caso, podemos pedir el bloque o la chain ID de una cadena, en este caso la red Ethereum en la red Goerli, y mandamos nuestros requests. Aquí está el request enviado, pero la respuesta que recibimos es un error porque el origen dashboard.alchemy.com no está permitido. Esto tiene que ver con la parte de seguridad que acabamos de ver. Simplemente permitimos el origen, en este caso dashboard.alchemy.com, y ya con ello podemos empezar a hacer los requests. También tenemos acceso a lo que sería la main pool, un observador de la main pool, y notificaciones por las diferentes actividades que podemos estar realizando con nuestra aplicación descentralizada. En este caso, podemos revisar la actividad de NFT, la actividad de direcciones, las notificaciones de transacciones que hayan sido dropeadas o las que hayan sido minadas.

Finalmente, también tenemos otras opciones que Alchemy nos ofrece, que son APIs avanzadas para transferencias, generación de metadata para los tokens, balance de tokens, allowance, lo que es Alchemy Web3, Smart Web Sockets, Trace API, Debug API y NFT API. Importantes estas dos últimas, que son APIs de desarrollo bastante potentes, que nos permiten mejorar el debugging de las aplicaciones descentralizadas que estemos creando. Esto es muy importante porque un aspecto que ningún desarrollador debe dejar de lado es el debugging y el reconocimiento de errores y cómo solucionarlos dentro de las capacidades de desarrollo de la aplicación. Esto con el fin de mantener las aplicaciones seguras y evitar que hackers o actores maliciosos puedan traspasar la seguridad de nuestras aplicaciones y obtener ganancias de forma maliciosa.

Como pueden ver, esto es Alchemy. Es bastante sencillo crear una cuenta aquí y empezar a utilizar su potencial.

## U4. Samrt Contracts sobre Bitcoin
###  Smart Contracts en Bitcoin Script (Video)
![[218.B4_Smart_Contracts_en_Bitcoin_Script.mp4]]
[Smart Contracts sobre Bitcoin](https://app.web3mba.io?wvideo=4umxj53x1u)

Los contratos inteligentes, o smart contracts, pueden ser escritos en diferentes lenguajes de programación, siempre y cuando existan compiladores y bibliotecas capaces de traducir y servir de interfaz con las distintas capacidades de los contratos inteligentes en la blockchain que utilicemos. Esto significa que es posible usar cualquier lenguaje de programación para crearlos, pero los desarrolladores de la blockchain deben crear el conjunto de herramientas básico para tal fin. En este sentido, algunos de los lenguajes de programación que podemos utilizar para crear contratos inteligentes son los siguientes.

En Bitcoin, el lenguaje de programación por defecto es Bitcoin Script. Este lenguaje está diseñado específicamente para Bitcoin y es responsable de permitir la programación de transacciones dentro de la propia red, haciendo que Bitcoin cumpla con la premisa de ser un dinero digital programable. Sin embargo, Bitcoin Script es un lenguaje bastante limitado, ya que no es Turing completo y funciona mediante un esquema de tipo pila. Esto hace que Bitcoin Script no solo sea complejo de programar, sino también limitado en las características y funciones que presenta. De hecho, Bitcoin Script está restringido a solo 256 tipos de instrucciones distintas, conocidas como opcodes, muchas de las cuales aún no han sido definidas porque Satoshi Nakamoto las dejó en blanco con el fin de mejorar sus capacidades en el futuro, pensando en las necesidades que pudiera tener la red en los años venideros.

El lenguaje Script de Bitcoin posee varias características y cualidades. Entre ellas, podemos mencionar que es simple y requiere un procesamiento mínimo, que su funcionamiento es limitado, lo cual aporta mayor seguridad al sistema, y que al no ser un lenguaje Turing completo, no posee bucles, lo que asegura que el programa deje de repetirse y termine. De esta manera, evitamos la posibilidad de que ocurran errores y códigos maliciosos en la red de Bitcoin. Otra característica es que su simplicidad le permite ser implementado en una amplia gama de dispositivos. Además, no hay un estado anterior o posterior a la ejecución del script; toda la información necesaria para ejecutar el script debe estar contenida en el propio script.

El lenguaje está basado en una pila y puede usar dos tipos: una pila principal y otra pila alternativa, donde esta última se emplea para el almacenamiento de datos, cálculos y pasos intermedios, de una forma muy parecida a la tecla de memoria en las calculadoras. El lenguaje de script de Bitcoin es bastante pequeño, ya que solo puede contener 256 instrucciones, y cada instrucción está expresada en un byte. El propósito de crear un lenguaje script en Bitcoin es proporcionar una serie de parámetros fáciles y flexibles para posibilitar una transacción. Así, cuando Satoshi Nakamoto desarrolló Bitcoin, deshabilitó varias funciones, entre ellas la multiplicación, lo que mantiene el script simple en términos de programación.

Este lenguaje de programación determina si una operación puede realizarse o no, es decir, si dicha operación está autorizada para la transferencia de fondos. En pocas palabras, la creación de Bitcoin Script es lo que otorga la naturaleza programable de Bitcoin. Esto nos permite, por ejemplo, enviar una transacción que se valide automáticamente si se cumplen determinadas condiciones. Esta propiedad es única de Bitcoin y las criptomonedas, algo que el dinero actual no puede alcanzar, y mucho menos el arcaico dinero físico. Es la evolución del dinero, llegando a un punto en que incluso puede actuar de forma independiente y descentralizada, atendiendo simplemente a la programación incrustada en él.

Por otra parte, el script de Bitcoin también evita la creación de errores en el sistema y el uso innecesario de transacciones muy complejas. De hecho, el script hace que las transacciones sean relativamente fáciles de calcular. Además, los bucles infinitos requieren mucha más potencia de cálculo y pueden sobrecargar las redes, como se mencionó al principio. Miniscript es un lenguaje de programación que facilita la generación de contratos inteligentes para Bitcoin. Permite que el software analice automáticamente un script, incluyendo la determinación de los datos de los testigos que deben generarse para gastar los bitcoins protegidos por ese script. La representación estructurada de los scripts de Bitcoin proporcionada por Miniscript permite a los monederos ser mucho más dinámicos con los scripts que utilizan.

Para apoyar este dinamismo, los Miniscripts pueden ser creados usando un lenguaje de políticas de fácil escritura. Las políticas son componibles, permitiendo que cualquier subexpresión válida sea reemplazada por otra subexpresión válida, dentro de ciertos límites impuestos por el sistema de Bitcoin. Inicialmente, el lenguaje fue diseñado para ser parecido a JavaScript; sin embargo, el desarrollo del proyecto se trasladó a Rust, el cual sigue en desarrollo y ya se encuentra en proceso de ser integrado en Bitcoin Core.

Vyper es un lenguaje de programación basado en Python, dirigido a crear contratos inteligentes para la máquina virtual de Ethereum. Al estar basado en Python, este lenguaje ofrece una enorme facilidad para desarrollar aplicaciones distribuidas para quienes están acostumbrados a este lenguaje, y al mismo tiempo, se beneficia de las potentes herramientas de depuración que ya existen para él. Entre los principales objetivos de Vyper se encuentran ofrecer una mejor seguridad, ya que debe ser posible y natural tener contratos inteligentes seguros en este lenguaje. También se busca la simplicidad del lenguaje y del compilador, así como mejorar la auditoría del código. El código de Vyper debe ser lo más legible posible y, además, debe ser difícil escribir código engañoso en él. La simplicidad para el lector es más importante que la simplicidad para el escritor, y es particularmente relevante para aquellos con poca experiencia previa en Vyper y en programación en general.

Además, Vyper permite una mejor comprobación de límites y desbordamientos, especialmente en los accesos a arrays y en la aritmética. Vyper puede ser utilizado en Ethereum o en cualquier red compatible con la Ethereum Virtual Machine, como Polygon, BNB Chain u otras redes derivadas de la EVM y sus primitivas criptográficas. Haskell es un lenguaje de programación muy utilizado en el mundo científico y es el lenguaje elegido por Cardano. Haskell destaca por ser un lenguaje de programación funcional, muy adecuado para código de alta seguridad y programas que requieren un alto grado de verificación formal. Esto permite a los programadores tener un mayor grado de certeza de que el código que han implementado es correcto, lo que, sin duda, ayuda a mantener la seguridad de los contratos inteligentes y de las plataformas que dependen de ellos.

En Cardano, Haskell permite que los contratos inteligentes de Plutus y Marlowe sean implementados cuidadosamente en un código preciso y formalmente verificado, que ofrece un alto nivel de seguridad desde el principio. Plutus y Marlowe se ofrecen como un conjunto de bibliotecas, aprovechando la documentación existente de Haskell, los juegos de herramientas y una comunidad altamente profesional para proporcionar una base a partir de la cual construir contratos inteligentes seguros y de calidad empresarial. Tanto el código off-chain como on-chain de Cardano está escrito en Haskell, lo que permite a Cardano heredar el rico cuerpo de investigación ya existente dentro del ecosistema de Haskell, en lugar de reinventar la rueda con un lenguaje de contratos inteligentes totalmente nuevo y no probado.

Básicamente, Haskell es un lenguaje que ha sido probado, que es seguro y que puede ser utilizado para crear contratos inteligentes Turing completos, que pueden ser verificados formalmente en cualquier momento. Como hemos podido ver a lo largo del tema, los contratos inteligentes pueden desarrollarse de diferentes maneras. Podemos desarrollarlos en Solidity, en Vyper, o incluso en lenguajes que no hemos visto en este curso, como el LLL. Estos lenguajes, al final, nos permitirán desarrollar nuestros contratos inteligentes basados en toda la potencia que nos ofrece la blockchain de Ethereum y, gracias a ellos, crear ese bytecode, subirlo a la blockchain y ejecutarlo de forma descentralizada en nuestras aplicaciones. A partir de aquí, lo que nos queda es seguir investigando y profundizando en todo el mundo de los contratos inteligentes y sus lenguajes de programación.

###  Bitcoin Script, el primer lenguaje de Smart Contracts del mundo
Es un lenguaje de programación simple empleado en Bitcoin para el procesamiento de las transacciones.

Este lenguaje está basado en una serie de estructuras lineales, conocidas como pila (_stack_), que contienen datos existentes que son procesados usando el esquema LIFO (_Last In – Firt Ou_t).

Así, cada instrucción en este lenguaje se ejecuta consecutivamente una después de la otra.

Como ya hemos mencionado, este lenguaje no es Turing Completo debido a que su funcionalidad es limitada y no puede realizar bucles. No obstante, esta limitación es intencional porque así se evita la entrada en un bucle infinito y se comentan errores irrecuperables dentro de los mismos. Esto evita que las partes maliciosas del programa pueden tener la libertad de crear operaciones complicadas para consumir los recursos de la red y servir de base para la generación de ataques de denegación de servicios (DoS). 

La intención y objetivo tras la creación de Bitcoin Script, es la de permitir escribir programas y que los ordenadores ejecuten los mismos de forma descentralizada. Así, Bitcoin puede comunicar nuestros deseos por medio de códigos de programación u operacionales que son conocidas como OP CODES. Entre esas funciones están la manipulación de memoria, matemáticas, bucles, llamadas a funciones, entre muchas otras.

> Por ello, Bitcoin Script es en esencia un conjunto de instrucciones programadas que se registran con cada transacción realizada. Estas instrucciones describen cómo los usuarios pueden obtener accesos a los bitcoins disponibles en la red y hacer uso de ellos.

####  ScriptSig & scriptPubKey:  Las dos secciones de los Bitcoin Scripts
En la red Bitcoin, cada Bitcoin Script se divide en dos tipos de scripts, los scriptSig y scriptPubKey.

- **ScriptSig es el script de desbloqueo,** que requiere de una clave pública y una firma digital. De hecho, luego de detectar varios problemas en las primeras versiones del software de Bitcoin, se incluyeron las verificaciones de las firmas. Por lo que el sistema solo acepta realizar transacciones si las firmas y su verificación cumplen con una serie de reglas establecidas que garantizan un comportamiento adecuado en la red.
- **ScriptPubKey, es el script de bloqueo,** que contiene un hash de clave pública, también denominada dirección de Bitcoin. Algunos scripts de Bitcoin requieren de multifirmas, es decir, de la autorización de varios usuarios para realizar la transacción. En este caso, el script es más complicado debido a que se trata de una operación mucho más grande que la estándar entre iguales. De hecho, la programación como tal de las transacciones de Bitcoin es almacenada en esta parte del script.

![[219.B4_scripts.png]]

#####  Objetivo de su creación
El propósito de la creación de un lenguaje script en Bitcoin, es el de proporcionar una serie de parámetros fáciles y flexibles para poder posibilitar una transacción. 

**Cuando Satoshi Nakamoto desarrolló Bitcoin, deshabilitó varias funciones, entre ellas la multiplicación. Por lo que el script se mantiene simple en términos de programación.** 

Entonces, este lenguaje de programación es lo que determina es si una operación puede realizarse o no. Es decir, si dicha operación está autorizada para la transferencia de fondos.

En pocas palabras, la creación del Bitcoin Script es lo que otorga la naturaleza programable de Bitcoin. Es lo que nos permite, por ejemplo, enviar una transacción que la misma se valide solo si determinadas condiciones se cumplen. Esta propiedad es algo único de Bitcoin y las criptomonedas, algo que el dinero digital actual no puede alcanzar, y mucho menos el arcaico dinero físico. Es la evolución del dinero llegado a un punto en que incluso este puede actuar de forma independiente y descentralizada atendiendo simplemente a la programación incrustada en él.

Por otra parte, el script de Bitcoin también evita la creación de errores en el sistema y el uso innecesario de transacciones muy complejas. De hecho, el script hace que las transacciones sean relativamente fáciles de calcular. Además, los bucles infinitos requieren muchísima más potencia de cálculo y ralentizan las redes, como se mencionó al principio.

####  Ejemplo de Bitcoin Script.
Vamos a ver un pequeño Bitcoin Script muy usado en la actualidad para las transacciones en Bitcoin.

Explicaremos su comportamiento y funcionamiento, así como las distintas partes del mismo, para luego ir profundizando en sus propiedades.

#####  Bitcoin Script: Transacciones en Bitcoin usando el script P2PKH
**Los Bitcoin Script están presentes en todas las acciones de Bitcoin. La verdad es que cada operación en Bitcoin es llevada a cabo por un script específico que delimita lo que se va a realizar. Fuera de lo que dice dicho script nada puede pasar.**

Por ejemplo, si queremos hacer una transacción un script para ello sería el siguiente:

|Secciones|Contenido del Bitcoin Script|
|---|---|
|scriptPubKey|OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG|   |
|scriptSig|Signature|   |
|scirptSig|Pubkey|   |

**Todo el contenido anterior es una simple transacción en Bitcoin del tipo P2PKH (_Pay to Public Key Hash_).** Este tipo de script es un script estándar y de hecho es la forma más usada para enviar bitcoins. A primera vista se muestra como algo muy críptico y difícil de entender. La verdad es que detrás de tal complejidad, se esconde un sencillo sistema que explicaremos ahora.

######  Explicando a fondo la transacción
El anterior Bitcoin Script está delimitado en dos partes: 
1. scriptPubKey
2. scriptSig.

En el primero, están las acciones a realizarse, mientras que el segundo contiene la firma y clave pública para verificar la autenticidad de tales acciones. De tal forma se asegura que solo quien tiene acceso a los fondos pueda realizar alguna operación con los mismos. Por otro lado, están los OP_CODES que en la operación son los siguientes:
1. **OP_DUP:** Duplica el elemento de la pila superior.
2. **OP_HASH160:** La entrada se codifica dos veces: primero con SHA-256 y luego con RIPEMD-160.
3. **OP_EQUALVERIFY:** Verifica que los datos introducidos sean correctos y válidos.
4. **OP_CHECKSIG:** Las salidas, entradas y el script de toda la transacción se resumen en un hash. La firma utilizada debe ser una firma válida para este hash y debe estar junto a la clave pública.

Ahora bien, lo que pasa durante la ejecución del script es lo siguiente:
1. **En primer lugar,** la clave pública original del dueño (que está en el scriptSig) de los fondos se duplica.
2. **La clave pública duplicada pasa luego a un proceso de hashing.** En este proceso se le aplica primero un hash SHA-256 y al resultado luego se le aplica un hash RIPEMD-160.
3. **El resultado se compara con el hash de la clave pública que está en el scriptPubKey** para asegurarse de que sea EQUALVERIFY (es decir, sea la misma clave y sea verificada como válida).
4. **Si coincide, el script continúa ejecutándose y se realiza el CHECKSIG** para verificar la firma con la clave pública.
5. **De esta forma se lleva a cabo todo lo indicado en el script de forma segura y programada.** Si deseas conocer más a fondo cómo funciona Bitcoin Script, puedes visitar nuestro servicio Bit2Me TV, donde podrás ver algunos vídeos explicando mucho más sobre este interesante lenguaje.

#####  Bitcoin Script Escrow
El ejemplo de P2PKH es bastante sencillo y es básico, pero Bitcoin Script nos permite crear cosas mucho más avanzadas, como un Escrow. 

**Un ==escrow== es un elemento básico en un Exchange descentralizado, básicamente es un baúl de seguridad, donde las partes colocan sus criptomonedas y secretos para realizar un intercambio seguro y descentralizado.** Plataformas como LocalBitcoin o Bisq usan este tipo de scripts para su funcionamiento y en Bitcoin Script es posible crearlas de la siguiente forma: 
```
OP_DUP OP_1 OP_EQUAL
OP_IF
  OP_DROP
  <AnaHashedPublicKey>
  <JuanHashedSecret>
OP_ELSE
  OP_DUP OP_2 OP_EQUAL
  OP_IF
    OP_DROP
    <AnaHashedPublicKey>
    <HashedDisputeReleaseSecret>
  OP_ELSE
    OP_DUP OP_3 OP_EQUAL
    OP_IF
      OP_DROP
      <JuanHashedPublicKey>
      <AnaHashedSecret>
    OP_ELSE
      OP_4 OP_EQUALVERIFY
      <JuanHashedPublicKey>
      <HashedDisputeRevertSecret>
    OP_ENDIF
  OP_ENDIF
OP_ENDIF
OP_ROT
OP_HASH160
OP_EQUALVERIFY
OP_OVER
OP_HASH160
OP_EQUALVERIFY
OP_CHECKSIG
```

**El script tiene un funcionamiento bastante sencillo:**
Ana y Juan deciden realizar un intercambio, y para ello preparan los siguientes elementos:
1. **Ana prepara su Hash PubKey** (su dirección de criptomoneda) y la pública (comprador)
2. **Juan prepara su Hash PubKey** (su dirección de criptomoneda) y la pública (vendedor)

El segundo paso es generar los secretos que permitirán a cada una de las partes saber que efectivamente se han realizado las operaciones correspondientes para el intercambio. Tanto Ana como Juan crean estos secretos y realizan un Hash de los mismos, sin embargo, estos solo se harán públicos bajo ciertas condiciones:
1. **Si Juan realiza la operación y libera el pago, este ya no podrá tomar para sí los fondos.** En este punto, Juan hace público el secreto que le permitirá a Ana confirmar la operación (generalmente la TXID de una operación enlazada con la operación de escrow que se mantiene en la mempool de Bitcoin). Si Ana confirma la operación, ella está obligada a realizar su operación con el fin de obtener las criptomonedas. En caso contrario, se aplica la función de reintegro, porque Ana no ha cumplido su parte y se le amonesta. 
2. **Si Ana decide que no quiere completar la operación, simplemente cancela la operación, y la esta se reintegra a Juan devolviéndole sus fondos.** En este punto, Ana no recibe amonestación, ya que solo ha cancelado la operación y los fondos nunca estuvieron en peligro.
3. **Si el resultado de la operación no ha sido satisfactorio ni para Ana ni para Juan. Pueden pedir a un tercero neutral que intervenga y decida sobre el mejor curso para los fondos, sin embargo, el tercero solo es un mediador y no puede tomar los fondos para sí mismo en ningún momento.** Esto es posible gracias a un segundo Bitcoin script que paga las comisiones y es capaz de finalizar la operación, solo si OP_4 es activada (la opción que Juan como vendedor puede activar para generar la intervención de un tercero para la mediación).  

El segundo Bitcoin Script que habilita el pago de las comisiones es:
```
OP_DUP OP_3 OP_EQUAL
OP_IF
  OP_DROP
  OP_HASH160
  <AnaHashedSecret>
  OP_EQUALVERIFY
  OP_DUP
  OP_HASH160
  <JuanHashedPublicKey>
  OP_EQUALVERIFY
  OP_CHECKSIG
OP_ELSE
  OP_DUP OP_4 OP_EQUAL
  OP_IF
    OP_DROP
    OP_HASH160
    <HashedDisputeRevertSecret>
    OP_EQUALVERIFY
    OP_DUP
    OP_HASH160
    <JuanHashedPublicKey>
    OP_EQUALVERIFY
    OP_CHECKSIG
  OP_ELSE
    OP_DUP
    OP_HASH160
    <MediatorSwapHashedPublicKey>
    OP_EQUALVERIFY
    OP_CHECKSIG
  OP_ENDIF
OP_ENDIF
```

Así tenemos que:
```
OP_IF
  OP_DROP
  OP_HASH160
  <AnaHashedSecret>
  OP_EQUALVERIFY
  OP_DUP
  OP_HASH160
  <JuanHashedPublicKey>
  OP_EQUALVERIFY
  OP_CHECKSIG
```

Esta primera parte, aplica cuando ambas partes están de acuerdo con la operación y ambas firman la operación para que sea transmitida a la red y se complete el intercambio deseado. 
```
OP_ELSE
  OP_DUP OP_4 OP_EQUAL
  OP_IF
    OP_DROP
    OP_HASH160
    <HashedDisputeRevertSecret>
    OP_EQUALVERIFY
    OP_DUP
    OP_HASH160
    <JuanHashedPublicKey>
    OP_EQUALVERIFY
    OP_CHECKSIG
  OP_ELSE
    OP_DUP
    OP_HASH160
    <MediatorSwapHashedPublicKey>
    OP_EQUALVERIFY
    OP_CHECKSIG
  OP_ENDIF
OP_ENDIF
```

**En caso contrario, se aplica la reversión de la operación que le devuelve los fondos a Juan, o se aplica la mediación para que esta revise el caso y decide completar la operación si todo es correcto, o bien una parte intenta hacerle trampa a la otra.** 

Tal como se puede ver, el proceso de creación de Smart Contracts usando Bitcoin Script es procedimental, algo complejo pero posible de realizar sin mayores complicaciones, y esto es solo una parte de su potencial, porque el lenguaje va mejorando a medida que la red Bitcoin evoluciona y se desarrolla.

###  Funcionamiento de Bitcoin Script
Imagina que apilas 3 libros: 
1. Libro A (arriba), 
2. Libro B (en medio) 
3. Libro C (abajo). 

Con Bitcoin Script: 
- El Libro A tendría que ser el primero en salir de la pila (_popped_). 
- El Libro B, sería el siguiente. 
- El Libro C sería el último, para poner cualquier cosa en la parte inferior de la pila (_pushed_). 

El mismo concepto se aplica virtualmente a las operaciones en una secuencia con Script.

![[220.B4_pila.png]]

####  Capacidades de Bitcoin Script
Uno de los puntos más relevantes del funcionamiento de Bitcoin Script es su notación y sus capacidades de complejidad programática.

El primer punto es fácil de ver, porque Bitcoin Script usa la conocida Notación Polaca Inversa (RPN) o notación postfija. La RPN es un método para colocar la función de la operación al final de una frase. 

**Por ejemplo, la suma de 5 y 6 en Bitcoin Script debe escribirse como "5 6 +" en lugar de "5 + 6".** **En el caso de que queramos multiplicar tendríamos que escribirla “5 6 *”. Este tipo de notación facilita la creación de stacks manipulables para realizar las distintas operaciones a la que Bitcoin Script debe darnos acceso.** 

El otro punto, la complejidad algorítmica, tiene que ver con un concepto muy conocido en los lenguajes de programación, la conocida capacidad Turing. En este punto existen dos capacidades Turing que son:
1. Turing Completo.
2. Turing Incompleto.

**Un lenguaje del tipo Turing Completo, nos dice que el lenguaje es capaz de generar bucles infinitos y nos ofrece las capacidades para generar algoritmos tan complejos como para recrear cualquier sistema informático, sin importar que tan complejo puedan ser.** Básicamente, un lenguaje Turing Completo te permite crear cualquier cosa que puedas imaginar y escribir en un algoritmo completo dentro de ese lenguaje de programación. 

**Por su parte, un lenguaje Turing Incompleto significa que el lenguaje no permite bucles infinitos. Esto tiene tanto ventajas como desventajas. Una de las ventajas de utilizar un lenguaje Turing incompleto es la imposibilidad de ejecutar algoritmos malformados, independientemente de si son ataques maliciosos intencionados o errores de programación no intencionados.** De esta manera, se evita el problema de la detención, permitiendo leer el script y ejecutar sus acciones. Si las instrucciones son correctas, el script se ejecuta de forma correcta, y si las instrucciones son incorrectas, el script solo emite un error y se continúa con el sistema, evitando caer en bucles infinitos que detengan al sistema.

Otros blockchains desarrollados desde Bitcoin han optado principalmente por ser Turing Completo, o al menos tener un alto grado de Turing Completo. Aunque esto potencialmente pone en juego el problema de la interrupción, también proporciona un mejor soporte para la compleja lógica requerida para el desarrollo de contratos inteligentes. Un caso en este sentido es Ethereum, cuyo lenguaje Solidity y su EVM son del tipo Turing Completo, lo que permite desarrollar Smart contracts extremadamente potentes. 

####  Ejemplo de una transacción de Bitcoin
Los Bitcoin Script están presentes en todas las acciones de Bitcoin. Cada operación en Bitcoin es llevada a cabo por un script específico que delimita lo que se va a realizar. Fuera de lo que dice dicho script, nada puede pasar.

Por ejemplo, si queremos hacer una transacción un script para ello sería el siguiente:
- scriptPubKey | OP_DUP OP_HASH160
- scriptSig (Signature)
- scriptSig (Pub Key)

Lo que hemos visto hasta ahora es una transacción en Bitcoin del tipo P2PKH (Pay to Public Key Hash). Este tipo de script es un script estándar y de hecho es la forma más usada para enviar bitcoins. A primera vista se muestra como algo muy críptico y difícil de entender. La verdad es que detrás de tal complejidad, se esconde un sencillo sistema que explicaremos ahora.

#####  Explicando a fondo la transacción
**El anterior Bitcoin Script está delimitado en dos partes: ScriptPubKey y scriptSig. En el primero, están las acciones a realizarse, mientras que el segundo contiene la firma y clave pública para verificar la autenticidad de tales acciones.** De tal forma se asegura que solo quien tiene acceso a los fondos pueda realizar alguna operación con los mismos. Por otro lado, están los OP_CODES que en la operación son los siguientes:
1. OP_DUP: Duplica el elemento de la pila superior.
2. OP_HASH160: La entrada se codifica dos veces: Primero con SHA-256 y luego con RIPEMD-160.
3. OP_EQUALVERIFY: Verifica que los datos introducidos sean correctos y válidos.
4. OP_CHECKSIG: Las salidas, entradas y el script de toda la transacción se resumen en un hash. La firma utilizada debe ser una firma válida para este hash y debe estar junto a la clave pública.

Ahora bien, lo que pasa durante la ejecución del script es lo siguiente:
1. En primer lugar, la clave pública original del dueño (que está en el scriptSig) de los fondos se duplica.
2. La clave pública duplicada pasa luego a un proceso de hashing. En este proceso se le aplica primer un hash SHA-256 y al resultado luego se le aplica un hash RIPEMD-160.
3. El resultado se compara con el hash de la clave pública que está en el scriptPubKey para asegurarse de que sea EQUALVERIFY (es decir, sea la misma clave y sea verificada como válida).
4. Si coincide, el script continúa ejecutándose y se realiza el CHECKSIG para verificar la firma con la clave pública.
5. De esta forma se lleva a cabo todo lo indicado en el script de forma segura y programada. Si deseas conocer más a fondo cómo funciona Bitcoin Script, puedes visitar nuestro servicio Bit2Me TV, donde podrás ver algunos vídeos explicando mucho más sobre este interesante lenguaje.

###  OP_CODES
También conocidos como "Códigos de Operación"

Son las instrucciones e indicaciones que se utilizan en informática para la programación de equipos de computación y máquinas virtuales.

**Estos códigos indican las operaciones o funciones que deben ser realizadas y ejecutadas por el hardware o software.**

En el caso de los hardware, la forma de los OP_CODE estará definida según el tipo de arquitectura del conjunto de operaciones (ISA) del ordenador. Es decir, según las instrucciones que posea el dispositivo para la interpretación y ejecución de los códigos de operación. En caso del software, los OP_CODE están creados con un tipo de ISA, o arquitectura de operaciones, diseñada especialmente para ser interpretada por la máquina virtual o el interpretador de bytes.

**Los códigos de operación permiten que un programa de computación pueda emitir una orden al computador y que este la intérprete y la ejecute.**

####  ¿Cómo funciona un OP_CODE?
Para que las máquinas, equipos y ordenadores puedan recibir y ejecutar una orden específica, es necesario emitir instrucciones en un lenguaje que puedan entender.

Por ello, estas instrucciones son escritas en un lenguaje de programación que contiene códigos de operación o es traducido en última instancia a una serie de códigos de operación.

**Estos códigos están escritos en un idioma que generalmente conocemos, como el inglés, y luego son traducidos por un programa compilador o traductor para que las máquinas lo entiendan en su lenguaje binario.** Es decir, las instrucciones mnemónicas escritas en nuestro lenguaje para la interpretación de nosotros los humanos, tienen su equivalente en lenguaje binario para que las máquinas puedan interpretarlas fácilmente. Y así poder actuar sobre la instrucción recibida y ejecutarla de forma correcta.

#####  Ejemplo de un OP_CODE
Un buen ejemplo de OP_CODE lo podemos ver en la siguiente imagen:

![[221.B4_op_code.png]]

En ella podemos ver algunos OP_CODES pertenecientes a las instrucciones capaces de ejecutar un procesador o CPU de computadora (específicamente los x86 de Intel). Como podrás ver es algo críptico de leer y difícilmente se puede programar usando el mismo (aunque algunos desarrollos se hacen en este tipo de lenguaje debido a su velocidad).

La situación en el mundo cripto no es muy distinta y en Bitcoin, por ejemplo, podemos ver algo como esto:

![[221.B4_op_codes.png]]

1. **Signature:** Firma digital del dueño de la dirección Bitcoin
2. **Public Key:** Clave pública, suministrada por el dueño de la dirección, donde están los fondos BTC.
3. **OP_DUP:** Duplica la clave pública donde están los fondos Bitcoin.
4. **OP_HASH160:** Realiza un Hash SHA-256 y RIPEMD-160 a la clave pública suministrada por el dueño de la dirección
5. **Hash160 (Public Key):** Hash RIPEMD-160 a la clave pública donde están los fondos BTC.
6. **OP_EQUALVERIFY:** Se verifica la clave suministrada y la almacenada en el script son iguales.
7. **OP_CHECKSIG:** Se verifica la firma digital, si es VERDAD, se liberan los fondos.

Ciertamente, es igual de críptico, pero esta sencilla sentencia es equivalente a una transacción en Bitcoin. Si quieres saber más de la misma, puedes leer nuestro artículo dedicado a Bitcoin Script donde explicamos a profundidad que hacen exactamente estas instrucciones.

####  Bitcoin Script:  Tipos de códigos de operación
Los OP_CODES para el Bitcoin Script pueden clasificarse según la función e indicaciones que vayan a ejecutar en el sistema.

Estos códigos pueden ser utilizados para eliminar, añadir, mover o girar elementos en la pila. Analizar y realizar operaciones aritméticas, validar o invalidar transacciones, entre muchas otras más funciones.

A continuación, presentaremos un listado de los códigos de operación clasificados según su tipo y funciones. No obstante, es importante señalar que esta lista no es concluyente ni radical, puesto que existen muchos códigos de operación en el script de Bitcoin y aquí solo se mencionan algunos de ellos.

#####  Códigos de inserción
- **OP_0 = 0x00 y OP_FALSE = OP_0:**  
    Ambos códigos empujan o agregan un elemento o una matriz vacía de bytes a la pila. Ninguno de los dos debe ser confundido con NO_OP
- **OP_PUSHDATA1 = 0x4c, OP_PUSHDATA2 = 0x4d y OP_PUSHDATA4 = 0x4e:**  
    En el primer código, el siguiente byte contiene el número de bytes que se insertarán en la pila. En el segundo código los siguientes 2 bytes contienen el número de bytes que se insertarán en la pila, mientras que en el tercero son los siguientes 4 bytes los que contienen el número de bytes que se añadirán a la pila. En estos códigos el proceso de añadir los bytes se realizará en ==formato endian.==
- **OP_NEGATIVE = 0x4f y OP_TRUE = OP_1:**  
    En este caso, el número negativo -1 se empuja a la pila, mientras que en OP_TRUE el número positivo 1 se empuja a la pila.

#####  Códigos de control
- **OP_NOP = 0x61:**  
    Este código no ejecuta ninguna operación, pero se utiliza en los casos en los que haya que rellenar algún espacio dentro del programa.
- **OP_IF = 0x63 y OP_NOTIF = 0x64:**  
    Ambos códigos se utilizan para ejecutar las declaraciones. En el primer código, se ejecutan si el valor de la pila superior no es FALSE; en el segundo código, se ejecutan si los valores de la pila superior si es FALSE. Así en ambos casos, el valor de la pila superior se elimina.
- **OP_ELSE = 0x67:**  
    Se utiliza para afirmar o negar las declaraciones. En caso de haberse ejecutado los dos códigos anteriores (OP_IF y OP_NOTIF) las declaraciones se niegan. En caso de no haberse ejecutado, las declaraciones se afirman.
- **OP_ENDIF = 0x68:**  
    Se utiliza para terminar un bloque, ya que, sin esto, las transacciones no serían válidas. Un código OP_ENDIF sin un código OP_IF anterior tampoco será válido.
- **OP_RETURN = 0x6a:**  
    Se utiliza para marcar una salida de transacción como no válida.

#####  Códigos de aplicaciones y operaciones de pila
- **OP_TOALTSTACK = 0x6b y OP_FROMALTSTACK = 0x6c:**  
    El primer código se emplea para mover la entrada en la parte superior de la pila alternativa y eliminarla de la pila principal. El segundo código ejecuta el proceso contrario; mueve la entrada hacia la parte superior de la pila principal y la elimina de la pila alternativa.
- **OP_DROP = 0x75 y OP_DUP = 0x76:**  
    Se utilizan para eliminar un elemento de la pila superior y para duplicar un elemento de la pila superior, respectivamente.

#####  Códigos de operaciones de empalmes
- **OP_SIZE = 0x82:**  
    Este código empuja la longitud de la cadena del elemento superior de la pila, sin reventarlo.

Los códigos OP_SUBSTR = 0x7f, OP_LEFT = 0X80 y OP_RIGHT = 0x81 han sido deshabilitados. Se utilizaban para:
1. Devolver una sección en una cadena.
2. Mantener solo los caracteres restantes de un punto específico en una cadena, y
3. Mantener solo los caracteres restantes al lado derecho de un punto específico en una cadena, respectivamente.

#####  Códigos para operaciones numéricas
- **OP_1ADD = 0x8b y OP_1SUB = 0x8c:**  
    Se utilizan para añadir (sumar) o eliminar (restar) 1 a la entrada respectivamente.
- **OP_2MUL = 0x8d y OP_1DIV = 0x8e:**  
    Se utilizaban para multiplicar o dividir por 2 la entrada respectivamente, pero ambos fueron deshabilitados.
- **OP_ABS = 0x90 y OP_NEGATE = 0x8f:**  
    Se utilizan para invertir el signo de la entrada, es decir, para hacer positiva o negativa la entrada respectivamente.
- **OP_MIN = 0xa3 y OP_MAX = 0xa4:**  
    Estos códigos se utilizan para devolver el menor valor de a y b, o en su caso para devolver el mayor valor de a y b respectivamente.

#####  Códigos para codificación y cifrado
- **OP_RIPEMD160 = 0xa6:**   
    Se emplea para codificar la entrada con el algoritmo RIPEMD-160, con la finalidad de obtener hashes más cortos, pero igualmente seguros para la creación de direcciones.
- **OP_SHA1 = 0xa7:**  
    Se emplea para codificar la entrada con el algoritmo SHA-1, el cual se utiliza para calcular y obtener un valor de comprobación única para todas las entradas no mayor a 264 – 1 bit.
- **OP_SHA256 = 0xa8:**  
    Se emplea para codificar la entrada con el algoritmo SHA-256.
- **OP_HASH160 = 0xa9:**  
    Se utiliza para codificar la entrada 2 veces. La primera codificación a través del algoritmo SHA-256 y la segunda con el algoritmo RIPEMD-160
- **OP_HASH256 = 0xaa:**  
    Se utiliza para codificar la entrada 2 veces a través del algoritmo SHA-256.
- **OP_CHECKMULTISIG = 0xae:**   
    Se emplea para realizar una comparación entre la primera firma con cada clave pública hasta encontrar una coincidencia ECDSA. Luego repite el proceso con la segunda firma y las claves públicas posteriores y así sucesivamente hasta que todas las firmas hayan sido verificadas.

#####  Códigos para bloqueo de tiempo
- **OP_CHECKLOCKTIMEVERIFY = 0xb1:**   
    Este código marca como no válida la entrada si el elemento superior de la pila es mayor que el campo establecido como nLockTime, que representa la condición que se debe cumplir. En la aplicación de este código hay varias implicaciones que también hacen que la entrada sea inválida. Por ejemplo, si la pila está vacía o su elemento superior es negativo, entre otros.
- **OP_CHECKSEQUENCEVERIFY = 0xb2:**  
    También se usa para marcar la entrada como no válida si el tiempo de bloqueo es diferente o mayor al valor del elemento superior de la pila.

**Cada uno de estos OP_CODE realiza una función bien definida, y el arreglo conjunto de estos OP_CODE es lo que permite al Bitcoin funciona tal como lo hace. Sin embargo, los OP_CODE no son únicos de Bitcoin. Ethereum, por ejemplo, también tiene su propio registro de OP_CODE que le permite introducir instrucciones a su Ethereum Virtual Machine, y de allí realizar todas las operaciones de esta blockchain.** Eso va desde las transacciones más simples hasta operaciones complejas de smart contracts de esa plataforma. Lo mismo pasa con el resto de criptomonedas que tienen también sus OP_CODES o herramientas análogas para su funcionamiento.

De allí la importancia de los mismos, no solo conocerlos, sino desarrollarlos para ampliar las funcionalidades de las criptomonedas y los ecosistemas que estas contienen.

###  Smart Contracts usando Bitcoin Script
Un ejemplo sencillo de Smart Contract en Bitcoin Scipt es el conocido HTLC (Hash Time Locked Contract). 

Nos permite realizar operaciones en Bitcoin que nos permiten realizar operaciones de Atomic Swaps y con ello operaciones de Cross-Chain. 

El script básico de HTLC se puede definir según el siguiente formato RFC:
```
OP_IF
    OP_SIZE 32 OP_EQUALVERIFY
    OP_SHA256 <secret_hash> OP_EQUALVERIFY
    OP_DUP OP_HASH160 <redeem_identity>
OP_ELSE
    <expiry> OP_CHECKLOCKTIMEVERIFY OP_DROP
    OP_DUP OP_HASH160 <refund_identity>
OP_ENDIF
OP_EQUALVERIFY
OP_CHECKSIG
```

Este script se puede analizar de la siguiente forma dentro de un esquema Cross-Chain:
1. Alice crea un secreto de más de 32 bytes usando el hash SHA-256. Este secreto permitirá mantener la seguridad de la operación de cross-chain que se realizará con Bob y finalmente genera instrucciones para que la operación sea asignada a la dirección que Bob ha publicado para la realización del intercambio. 
    - OP_SIZE 32 OP_EQUALVERIFY
    - OP_SHA256 <secret_hash>  OP_EQUALVERIFY
    - OP_DUP OP_HASH160 <redeem_identity>
2. Alice envía la solicitud de intercambio (ETH->BTC) y en ese punto envía el hash secreto a Bob.
3. A partir del hash del secreto, Bob no puede saber el secreto real, por lo que, para saberlo, debe aceptar la solicitud y cumplir con su parte del intercambio.

![[222.B4_transfer.png]]

## U4. Práctica
###  Programación de Smart Contracts en Bitcoin Script (Video)
![[223.B4_Programación_Smart_Contracts_en_Bitcoin_Script.mp4]]
[Programacion Smart Contracts en Bitcoin Script](https://app.web3mba.io?wvideo=j18970hyft)

Saludos, en este video les explicaremos uno de los pilares fundamentales que permiten que Bitcoin pueda ser lo que llamamos dinero digital programable. Esto es posible gracias a Bitcoin Script, un sistema de scripting que le permite a Bitcoin programar de forma interna las operaciones que se realizan dentro de su red blockchain o la red de nodos que forman parte de esta red conocida como Bitcoin.

Bitcoin Script es un lenguaje de programación bastante sencillo; es muy pequeño en sus aspectos y en lo que puedes hacer con él, pero tiene una funcionalidad muy relevante: permitir a los programadores de la red Bitcoin y a los usuarios transferir valor de forma completamente digital y programable entre los diferentes pares que están dentro de la red. No solamente eso, Bitcoin Script es lo que se encarga de hacer posible que mis transferencias, o las transferencias que hagamos dentro de la red, lleguen desde el punto A al punto B de forma segura y que solo las personas que están en medio de esa transacción sean las autorizadas para poder utilizar este valor que se está transmitiendo.

¿Cómo hace posible esto Bitcoin Script? Pues bien, Bitcoin Script utiliza el poder de la criptografía junto con el de la programación para habilitar a los usuarios de la red en el uso de las diferentes transacciones que se realizan. Por ejemplo, si yo, como usuario, transmito dinero utilizando mis entradas de Bitcoin a una persona, estoy utilizando mis entradas y para eso genero un script específico que me permite desbloquearlas y enviarlas a esa segunda persona. Esta persona, entonces, tendrá la habilidad de utilizar sus propios scripts y realizar los pagos consecuentes que vaya a hacer después de recibir este dinero. Por supuesto, todo esto que estoy diciendo pasa completamente desapercibido porque se realiza de forma transparente al usuario. La idea de Bitcoin Script es que los programadores de Bitcoin puedan habilitar opciones de transacciones digitales completamente nuevas para la red y que esto sea completamente transparente para los usuarios, porque lo único que importa en este punto es que puedan realizar sus operaciones sin mayores inconvenientes.

Ahora bien, Bitcoin Script es normalmente conocido como un lenguaje del tipo stack o de pila. Es decir, las operaciones que se realizan con Bitcoin Script se apilan unas sobre otras y luego se ejecutan para tener una entrada de datos y una salida de la misma. Esto facilita la generación de nodos que puedan interpretar toda esta información de forma bastante universal y que todos los nodos tengan un consenso sobre si una transacción es válida o no. Para ello, Bitcoin Script se vale de una serie de instrucciones que se conocen como opcodes o códigos de operación. En la página oficial de Bitcoin, podemos ver cuáles son estos opcodes. Los opcodes simplemente nos permiten introducir datos dentro de Bitcoin Script para que sean validados o ejecutados por los diferentes nodos.

Este es un punto muy importante que quiero enfatizar: al igual que en Ethereum, donde programamos algo en Solidity y la Ethereum Virtual Machine procesa esa información, en Bitcoin ocurre algo similar, pero a un nivel mucho más sencillo. En Bitcoin no tenemos una máquina virtual como tal, sino un ejecutor que se encarga de tomar el Bitcoin Script, realizar las ejecuciones o las operaciones que está pidiendo y tener la certeza de si la operación es válida para incluirla dentro de los bloques.

Ahora bien, ¿qué operaciones podemos hacer o qué rango de operaciones tenemos disponibles dentro de Bitcoin Script? Aquí, en la página, podemos ver la anotación que tenemos disponible. Varios de estos códigos han sido desactivados por los desarrolladores de Bitcoin debido a problemas de seguridad. La idea es mantener Bitcoin Script lo más sencillo y seguro posible. Entre esas anotaciones y operaciones que podemos realizar, podemos encontrar los siguientes opcodes y las diferentes capacidades que pueden realizar. Por ejemplo, en la parte de constantes, podemos definir constantes con palabras como OP_0 o OP_FALSE, que nos permiten identificar un arreglo de datos vacíos dentro del stack que se está ejecutando en Bitcoin Script. Recordemos que esto significa que se llevará al stack un dato vacío que no tiene ningún valor para que sea identificado y analizado por el ejecutor de Bitcoin Script dentro de los nodos.

También tenemos operaciones especiales como OP_PUSH_DATA, que simplemente nos indican que debemos añadir una determinada cantidad de datos a la pila, dependiendo de una entrada que le estemos otorgando. También tenemos OP_ENGAGE, que lleva el número menos uno al stack, o hacer OP_1_TRUE, OP_1 o OP_TRUE, que serían operaciones del tipo lógico dentro del stack. Además, tenemos códigos de operaciones que nos permiten hacer control de flujo. Esto es importante porque recordemos que Bitcoin Script no solo es un lenguaje de script, es un lenguaje de programación limitado en sus funciones, pero que aún así tiene la capacidad de controlar el flujo. Es decir, la capacidad de decidir si se hace una iteración o no, dependiendo de determinadas condiciones. Para ello, tenemos códigos como OP_NOP, que no hace nada, OP_IF, que ejecuta una determinada condición si se cumple, OP_NOT_IF, que es lo contrario, y OP_ELSE, que es otra opción de control de flujo bastante utilizada. También tenemos OP_ENDIF, que se utiliza para finalizar una operación en caso de que sea inválida, OP_VERIFY, que es la verificación de una operación, y OP_RETURN, que simplemente nos ayuda a marcar nuestra situación como inválida y se utiliza en muchas operaciones como base para realizar las Coinbase. OP_RETURN es una de las operaciones más utilizadas en este sentido porque nos permite añadir información que no debe ser analizada directamente, sino que es marcada como inválida o que se puede agregar a la blockchain sin ningún tipo de procesamiento por parte de la máquina de consenso dentro de Bitcoin.

También tenemos el control del stack, que incluye varias operaciones, como la duplicación del stack, la apertura del stack y la eliminación de una instrucción. Para eliminar una instrucción se utiliza el opcode OP_DROP, para duplicar se utiliza el opcode OP_DUP, y así sucesivamente tenemos una serie de operaciones que nos permiten manejar diferentes operaciones que podríamos utilizar dentro de las capacidades de Bitcoin Script. Un apunte importante: siendo Bitcoin dinero programable, está la capacidad de realizar operaciones aritméticas. Sumar, restar y multiplicar son operaciones posibles utilizando Bitcoin Script. Para ello, contamos con varios opcodes que son los que vemos aquí ahora en pantalla, como el opcode para sumar, sustraer, multiplicar y dividir. Es muy importante mencionar que los opcodes de multiplicación y división están desactivados debido a un problema que se descubrió dentro de Bitcoin, que permitía a ciertos usuarios manipular estos opcodes para realizar operaciones mal formadas que fueran validadas por el nodo y que al final pudieran permitirles obtener ingresos de forma maliciosa. Estos opcodes fueron desactivados por el equipo y desde entonces se han mantenido así.

Fíjense que no son los únicos. Hay varios opcodes, por ejemplo, los de lógica y de splice, que también están desactivados por razones de seguridad. También vemos que tenemos opcodes para multiplicación, división, módulo y otras operaciones aritméticas, como verificar si un número es igual a otro, si es menor o igual, o si es mayor. Este tipo de operaciones también se pueden realizar con el sistema de Bitcoin Script.

En un principio, también mencioné que con Bitcoin Script se pueden hacer operaciones de tipo criptográfico. Esto tiene sentido porque la manera en que verificamos operaciones dentro de Bitcoin utiliza la criptografía. Para ello, Bitcoin Script tiene las siguientes funciones o códigos de operación disponibles: RIPEMD-160, que utiliza el hash RIPEMD-160 dentro de una operación, SHA-1, SHA-256, que es el SHA-256 que hemos visto en otros videos, OP_HASH160, que aplica SHA-256 y RIPEMD-160 para generar diferentes hashes especiales para Bitcoin, como la dirección de una cuenta de Bitcoin. También está OP_CODESEPARATOR, que es una operación que realmente no hace nada, sino que realiza un chequeo de firmas. OP_CHECKSIG, que verifica si una firma pública añadida dentro de Bitcoin Script es correcta, dependiendo de los datos que le hayamos otorgado. CHECKSIGVERIFY, que es la verificación de esa firma, y OP_CHECKMULTISIG, que nos permite crear monederos de múltiples firmas. Esta es la operación que hace posible esa capacidad.

También tenemos operaciones de lock time o de bloqueo por tiempo, como OP_CHECKLOCKTIMEVERIFY, o CLTV, que es una transacción especial que nos permite bloquear determinadas cantidades de criptomonedas, en este caso Bitcoin, por un tiempo determinado hasta que se verifiquen o se cumplan ciertas condiciones. También tenemos, en un sentido similar, OP_CHECKSEQUENCEVERIFY, o CSV, que tiene funciones parecidas a CLTV, pero que en este caso, en vez de utilizar un lock time, utiliza un sistema de secuencias, tal como lo ejemplifica el BIP 0060, que es el que se encarga de este tipo de operaciones.

Ahora bien, ya que conocemos un poco las operaciones que están dentro de Bitcoin Script y sus diferentes opcodes, recomiendo leer y reconocer bien esta página si quieres entrar en el mundo de la programación de Bitcoin directamente con Bitcoin Script. Sin embargo, no es la única manera de hacerlo. Puedes utilizar wrappers como Python o BTC, que te permiten programar operaciones con Python, pero que luego son traducidas a los opcodes necesarios para generar transacciones que puedan ser entendidas por la red Bitcoin. En todo caso, esta lista de operaciones que están aquí de opcodes nos dice algo muy claro sobre Bitcoin Script: podemos programar operaciones de distintas índoles con él. Esto elimina un poco la idea de que Bitcoin Script no tiene la capacidad de programar smart contracts.

Bitcoin Script tiene la capacidad de programar smart contracts. De hecho, cada vez que haces una transacción en Bitcoin, las operaciones de distintas índoles se pueden programar en el mismo sistema. Esto es lo que nos permite programar una transacción en Bitcoin Script. Esta transacción es posible por un pequeño smart contract dentro de esa operación, porque Bitcoin Script es un lenguaje de tipo smart contract. La diferencia entre los smart contracts de Ethereum y los de Bitcoin es que los smart contracts de Bitcoin no son Turing completos. ¿Qué significa esto? Que no podemos crear estructuras extremadamente complejas en comparación con lo que podemos hacer con Solidity. Por ejemplo, no podríamos crear un oráculo blockchain, como Chainlink, sobre Bitcoin, porque no hay capacidad para este tipo de operaciones. Sin embargo, los desarrolladores de Bitcoin entienden que estas limitaciones deben ser superadas y para eso se han creado diferentes sistemas, como Miniscript y los wrappers que he comentado para Python o para otros lenguajes de programación.

Estos wrappers y extensiones buscan llevar a Bitcoin a más lugares para que su uso sea potenciado. Más allá de esto, para ver cómo funciona Bitcoin Script en realidad, vamos a ver unos pequeños ejemplos que les mostraré en pantalla para que vean cómo es la programación de un Bitcoin Script y hasta dónde se puede llevar este potencial. Vamos a reducir un poco esta pantalla aquí y vamos a nuestra consola. En este caso, ya tenemos algunos ejemplos preparados. Voy a mostrar el ejemplo número uno. En este caso, tenemos un comando llamado btcd, que contiene una serie de datos que iré demostrando. Este primer dato que ustedes ven aquí es nuestra firma de Bitcoin. Luego viene la firma hashada y aquí están nuestras operaciones. Voy a poner esto aquí de manera que podamos revisarlo poco a poco.

Esta línea que estoy recorriendo en pantalla es una dirección de Bitcoin. Pueden verificarla directamente en un mempool. Aquí están nuestras operaciones completas. Muy bien. Aquí lo que vemos es lo siguiente: estas dos líneas pertenecen a nuestro script de verificación. Nuestro script de verificación contiene la información de nuestra llave pública y la firma correspondiente para movilizar una determinada cantidad de criptomonedas que estén dentro de una dirección. En este caso, la dirección que estamos viendo es la dirección 12AB8. Esto le dice a Bitcoin Script que tenemos esta dirección, esta firma y estos scripts. Vamos a tomar estos scripts, los vas a ejecutar dentro de un nodo y vas a verificar si todo es correcto. Si todo es correcto, esta persona puede movilizar el dinero que está en esa dirección y enviarlo a quien lo está enviando.

Entonces, el primer cuerpo que tenemos aquí, estas dos primeras líneas, sería nuestro script de verificación. Luego viene nuestro script como tal. Aquí lo primero que hacemos es duplicar la pila, que tomará esta información y la duplicará. Luego, haremos un hash 160, es decir, realizaremos un hash RIPEMD-160 y doble SHA-256. Después, tomaremos esta dirección y verificaremos si son iguales, y luego verificaremos las firmas. Para ejecutar esto y verlo más gráficamente, vamos a salir un momento aquí. Vamos a limpiar la pantalla. Haremos lo siguiente: bash ejemplo 01. Vamos a ejecutar un depurador llamado btcdep, que podemos buscar aquí. Vamos a buscar rápidamente antes de mostrarles dónde pueden encontrar este depurador. Aquí está: este es el Bitcoin Script Debugger, un depurador oficial de Bitcoin que pueden utilizar con completa confianza. Es bastante sencillo de compilar para que se pueda agregar su funcionamiento.

Ahora que sabemos dónde conseguir la herramienta BTCDEP, que es la que vamos a utilizar, vamos a ejecutar un pequeño script con un ejemplo de transacción que ya hemos modificado, que es el ejemplo que estábamos viendo en pantalla. Vamos a limpiar la pantalla nuevamente. Haremos bash ejemplo 01. Aquí tenemos a BTCDEP ejecutando nuestro script. En este caso, el script que había mostrado en pantalla ya está cargado. Aquí podemos ver el script en forma de pila y vamos a ir ejecutando paso a paso cada una de estas operaciones. El primer paso es tomar y duplicar todo el stack superior. Ya está. PushStack se ha duplicado. Ya tenemos el primer paso aquí. Seguimos al segundo paso. La pila se sigue reduciendo y vamos haciendo la ejecución continua de este script. Lo siguiente que hacemos es duplicar nuevamente la línea anterior y aquí tenemos el script ya duplicado. Fíjense que tenemos nuestras firmas ya duplicadas.

Bien, vamos a hacer entonces el siguiente paso, que es aplicar el OP_HASH160. ¿Qué va a pasar aquí? Lo que sucederá es que tomaremos la firma pública, que en este caso es la 044, y la transformaremos en una dirección de Bitcoin, que debería ser igual a la dirección 12AB8 que estamos viendo aquí abajo. Vamos a ejecutar el siguiente paso y deberíamos obtener la dirección. Efectivamente, en el lado del script tenemos nuestra dirección, 12AB8, y en el lado del stack ejecutándose dentro de BTCDEP, tenemos la misma dirección. La firma que estamos tomando de esta operación es correcta y nos está generando la dirección que necesitamos para hacer la verificación. Ahora, el siguiente paso es enviar la firma que nos está dando el script. Y ahí está. Ahora, estas dos firmas que están aquí las vamos a verificar con OP_EQUALVERIFY. Ejecutamos el siguiente paso y efectivamente, las operaciones son correctas. El script nos está diciendo que las direcciones son idénticas y, por ser idénticas, nos da la capacidad para seguir con la operación. Finalmente, lo que quedaría es verificar si la firma es correcta y pertenece a quien dice pertenecer. Aplicando el siguiente paso, podemos ver que efectivamente sí, la firma es completamente idéntica y pertenece a quien dice pertenecer. Finalizamos y con ello hemos terminado la ejecución de un primer Bitcoin Script.

Este proceso que acabo de explicar aquí de forma gráfica con BTCDEP es el mismo que se realiza una y otra vez con cada una de las operaciones que se llevan a cabo dentro de Bitcoin. Cada vez que un minero genera un bloque e incluye 1,000 o 1,200 transacciones dentro de ese bloque, estos bloques llegan a los nodos, que realizan estas operaciones una y otra vez hasta que terminan con las 1,200 operaciones y verifican que todo esté correcto. Luego de verificar que todo esté correcto, simplemente ingresan el bloque que ha enviado el dinero al listado de la blockchain y con ello se da el visto bueno a ese bloque, se valida y se genera consenso en la red. Todo este proceso se repite constantemente dentro de Bitcoin y en monedas que funcionan con el esquema de Bitcoin. Por ejemplo, puede ser Dash, que tiene un sistema muy parecido a Bitcoin Script. Puede ser Zcash, que también tiene un sistema bastante similar. Monero también tiene un sistema muy parecido, con adaptaciones para sus Bulletproof y su máquina virtual, porque ellos sí tienen una máquina virtual a nivel de ejecución. Pero las bases son estas que acabamos de ver en este ejemplo.

Si salimos aquí, podemos cerrar y ya con eso hemos terminado con un primer ejemplo. Vamos a ver un segundo ejemplo que he preparado. En este caso, ejemplo 02. Vamos a ejecutarlo aquí. Aquí cambia un poco la cuestión. Aquí vemos operaciones nuevas y vamos a explicar un poco de qué van estas operaciones nuevas. Vamos a dividir un poco el script para hacerlo más legible y luego les explicaré poco a poco cómo es cada una de estas operaciones. En este caso, ya tenemos los OP_DUP, OP_PUSH, PUSHBYTE, y tenemos aquí un tema de dirección y el hash.

Lo que ven en pantalla es una transacción del tipo SetTweet, como las que vemos normalmente en la actualidad dentro de la red, porque prácticamente la mayoría de las transacciones que se hacen son del tipo SetTweet o P2SH, que son muy parecidas también. En este caso, el script cambia un poco. El script empieza primero con un PUSHBYTE de 72 y un PUSHBYTE de 65. Al final, me da una clave pública. Luego nos pide que hagamos una duplicación del stack, que hagamos un hash 160 y luego hagamos un PUSHBYTE 20. Es decir, tomaremos los últimos 20 bytes y haremos un PUSH para verificar si esto es idéntico a lo que tenemos dentro del stack. Así funciona SetTweet. Aquí, como se puede ver, nos hace falta la formación de las claves, porque SetTweet divide esta información en dos partes. Las claves van por un lado, en lo que llamamos el witness o testigo, y la información de la transacción como tal va por el otro, que es lo que vamos a verificar en este punto.

Entonces, vamos a ejecutar este ejemplo y aquí tenemos nuestro stack cargado. Tenemos aquí unas advertencias que serían debido a que el BTC no está completamente sincronizado con los operadores de código de Bitcoin Script. Pero podemos simplemente obviar esto y seguir adelante. Vamos a hacer el primer paso y ahí cargamos la primera parte del stack. El segundo paso ya está descargado, seguimos cargando el siguiente paso. Aquí empiezan las operaciones de manipulación, de información y de verificación. Lo primero que vamos a hacer es una duplicación. Efectivamente, ya podemos ver la duplicación hecha. Aquí está. Luego viene la realización del hash 160 y aquí está nuestro hash 160 de la anterior operación. Seguimos con el siguiente paso, que es hacer el PUSHBYTE y finalmente cargamos la información de la firma y hacemos la verificación. Efectivamente, la firma es correcta. Hemos conseguido que la información sea correcta y que nos valide la operación. Esto significa que la operación SetTweet que acabamos de ver es correcta. Dentro del script que va a esta operación SetTweet, todas las operaciones están correctas.

Como puedes ver, es bastante sencillo utilizar BTCDEP para programar este tipo de cuestiones. Pueden ser directamente transacciones que hayas sacado de las operaciones de la mempool o de las operaciones dentro de Bitcoin. Por ejemplo, aquí podemos ver una transacción. Si vamos a los detalles, podemos ver toda la información necesaria para tal cuestión. Aquí está el script. Simplemente tomaríamos esta información, la colocaríamos dentro de BTCDEP y con ello podríamos verificar si efectivamente este script, tal como está escrito, que en este caso es una operación SetTweet y de tipo multifirma, tal como aparece aquí en la pantalla, ya con esto podríamos llegar a incluirlo dentro de BTCDEP y verificar si efectivamente la operación es correcta. O podemos ir paso a paso, como sería lo ideal.

En este caso, por ejemplo, si quiero hacer algo muy sencillo, como sería una suma, podríamos escribirlo así: BTCDEP OP_1, OP_2, OP_ADD. Y aquí ya tendríamos nuestro primer stack. Tendríamos el número 1, el número 2 y el OP_ADD. Simplemente pasamos paso a paso y tenemos nuestra operación de suma. La capacidad de BTC y de Bitcoin Script para permitirnos programar es muy amplia, aunque no llega a los niveles de Solidity o de otros lenguajes de programación de smart contracts Turing completos. Bitcoin Script nos permite hacer muchas cosas increíbles a nivel de programación descentralizada.

Quiero mostrarles parte de ese poder. Vamos aquí a un proyecto que utiliza Bitcoin Script para realizar un mercado de intercambio, un DEX, un exchange descentralizado. Este es Bisq. Bisq es un exchange descentralizado que funciona dentro de Bitcoin. De hecho, cuando instalas Bisq, realmente estás instalando un nodo de Bitcoin que funciona de forma completamente descentralizada. No tiene ningún intermediario, no funciona con un servidor web como otros servicios descentralizados, como en el caso de Uniswap. No necesitas ningún intermediario, como Infura en el caso de Uniswap y su wallet MetaMask. Absolutamente nada. Simplemente descargas este software, instalas tu propio nodo, instalas todos los servicios que necesitas y te conectas directamente a un exchange descentralizado en el que puedes intercambiar cualquier tipo de moneda.

Este es un ejemplo del potencial que existe detrás de Bitcoin Script. No solo es para programar operaciones sencillas. También puedes utilizarlo para programar aplicaciones como estas, que son mucho más complejas, que se apoyan en otras tecnologías para complementarse y realizar operaciones o aplicaciones, en este caso, para crear aplicaciones que sean completamente descentralizadas y que no tienen nada que envidiar a otras plataformas como Ethereum, Polkadot o cualquier otro tipo de plataforma web 3 como la conocemos normalmente. Pero también, y extrañamente, entra en lo que sería la web 3. La web 3 y el corazón de este MBA es demostrar que el mundo tal como lo conocemos ahora puede descentralizarse. Estos son ejemplos muy claros del poder de la descentralización que nos permite el Bitcoin Script. Espero que les haya gustado este video y nos veremos en otra ocasión.

## U5. DLC en Bitcoin
###  DLC (Video)
![[224.B4_DLC.mp4]]
[DLC](https://app.web3mba.io?wvideo=vgugowyhqq)

Hablemos ahora de los DLC. Los Discrete Block Contracts (DLC) son una propuesta que busca convertir a Bitcoin en una blockchain con medios propios y nativos para crear oráculos blockchain, algo que hasta ahora era imposible de realizar. Últimamente, gran parte del desarrollo de Bitcoin se ha centrado en ofrecer mejoras a su privacidad y en su capacidad para ejecutar scripts más potentes. Mejoras como Taproot y Graftroot apuntan precisamente a esto. Sin embargo, los DLC tienen un objetivo un poco más específico: están diseñados para conectar la blockchain de Bitcoin con el mundo exterior. Es decir, los DLC buscan establecer puentes de comunicación que lleven información del mundo real a la blockchain. Esto permite que, una vez allí, esa información sea procesada por smart contracts dentro de Bitcoin o cualquier otra blockchain que implemente los DLC.

En este sentido, es comprensible que conectar la blockchain al mundo real no sea una tarea sencilla. Sin embargo, es una funcionalidad muy apreciada por los desarrolladores de aplicaciones descentralizadas. De hecho, las finanzas descentralizadas (DeFi) necesitan este tipo de funciones para poder ejecutarse correctamente. De ahí que en Ethereum los oráculos sean algo muy común, ya que son los encargados de llevar información del mundo real a los protocolos DeFi o a las DApps que se ejecutan sobre la red y requieren estos datos. En este caso, Chainlink es uno de los proyectos más conocidos de oráculos sobre Ethereum. Pero Bitcoin, al igual que muchas otras criptomonedas derivadas, enfrenta un desafío diferente, dado que Bitcoin Script está limitado en funciones. Este tipo de funcionalidades son casi imposibles de implementar sobre Bitcoin de forma nativa. En su lugar, es necesario crear todo un protocolo de segunda capa, como RSK o Stacks, para agregar estas capacidades.

La propuesta del creador de los DLC pretende cambiar esta situación y permitir que Bitcoin pueda implementar oráculos de forma nativa en su blockchain. Las posibilidades son innumerables, comenzando porque Bitcoin finalmente podría tener un conjunto de aplicaciones descentralizadas propias. Esto ampliaría enormemente su funcionalidad y masificaría aún más su uso. Por otro lado, podría generar problemas si no se resuelven los desafíos de escalabilidad que ya enfrenta Bitcoin. Ciertamente, la función de los DLC es interesante, pero se presenta un grave problema en el horizonte: la escalabilidad. Este problema podría no ser del todo insuperable, ya que el creador de los DLC mencionó que podrían ejecutarse sobre Lightning Network. ¿Cuál sería el resultado? Las operaciones de los DLC podrían realizarse por miles en un canal de Lightning Network dedicado a esta tarea. Una vez que se alcance el límite del canal, simplemente se cierra, se emite el bloque en la blockchain de Bitcoin y se cierran las cuentas para todas las partes involucradas. De esta forma, se posibilita que los DLC realicen miles e incluso cientos de miles de operaciones sin que ello tenga un impacto indeseado sobre la blockchain de Bitcoin.

Sin embargo, por otro lado, ya no sería nativo. Incluso es posible llevar los DLC a sistemas compatibles con Lightning Network, como es el caso de Lumino Network de RSK, donde podría potenciar enormemente la funcionalidad de este protocolo de segunda capa de Bitcoin. No solo eso, el sistema podría también trasladarse a otras redes o protocolos de segunda capa que cumplan con las funciones HTLC y firmas NOR. Actualmente, los DLC sobre Bitcoin son una construcción cada vez más cercana. Parte de la tecnología de los DLC depende de la activación de Taproot y Mast, dos tecnologías que han sido activadas recientemente en Bitcoin. Sin embargo, para el completo funcionamiento del protocolo DLC es necesario habilitar algunas funciones adicionales que permitan su desarrollo integral sobre Bitcoin y sobre Lightning Network.

No obstante, en la comunidad de Bitcoin muchas cosas han cambiado. Si bien en sus inicios se pensaba que Bitcoin no necesitaría grandes desarrollos para smart contracts avanzados, esta idea ha ido cambiando radicalmente en los últimos años. La creación de Taproot y la implementación de Schnorr abrieron las puertas a ello. Además, se busca mantener la descentralización de Bitcoin para este tipo de construcciones, dejando de lado la necesidad de proyectos externos como RSK o Stacks para estas operaciones. Así, los desarrolladores de Bitcoin buscan construir todo lo que necesitan para smart contracts avanzados en Bitcoin de forma nativa, aprovechando la mayor red descentralizada del mundo cripto, que cuenta ya con más de 20,000 nodos core y un número superior a 30,000 nodos de Lightning Network.

Dicho esto, la implementación de DLC llevará a Bitcoin a un nuevo nivel, ya que sus smart contracts nativos podrán ejecutarse no solo sobre la Layer 1 de Bitcoin, sino también sobre Lightning Network, lo que haría que las comisiones y la velocidad de estas operaciones sean cientos de veces superiores a las de cualquier red blockchain activa actualmente, incluso superior a Ethereum 2.0 y sus shards. Pero, ¿significaría esto que no podemos hacer uso de los DLC actualmente? Para nada. Podemos usar esta tecnología como Tech Preview junto a otras capacidades de la red Bitcoin en su testnet y explorar el potencial de los DLC aplicados sobre esta red. Así podríamos vislumbrar el potencial de esta tecnología, aunque aún solo sea posible sobre la testnet.

Desde hace años, contemplamos el problema de escalabilidad de Bitcoin y su conexión con el mundo externo. Los oráculos y los DLC abren un nuevo universo para todo tipo de funcionalidades, lo que permitiría la aplicación, por ejemplo, de smart contracts sobre Bitcoin, algo que, a pesar de no haberse visto en el pasado, hoy sí es una realidad y una necesidad. Para implementar efectivamente los DLC sobre Bitcoin, aún deben transcurrir ciertas innovaciones tecnológicas y mejoras. Sin embargo, la comunidad ya está en ello y se puede probar la tecnología de los DLC sobre la testnet de Bitcoin para realizar pruebas y seguir mejorando esta red, con la esperanza de que pronto sea una realidad.

###  ¿Qué son los DLCs?
Los Discrete Log Contracts o DLC, son una propuesta que busca convertir a Bitcoin en una Blockchain con medios propios y nativos para crear oráculos Blockchain, algo que de momento es imposible de realizar. 

La idea detrás de los DLC proviene de la mente de Tadge Dryja del MIT, quien es un conocido desarrollador de Bitcoin y que ha estado detrás de ideas como Lightning Network (LN) y UTreeXO.

####  Discrete Log Contracts (DLC) : Smart Contracts para Bitcoin
Últimamente mucho del desarrollo de Bitcoin está centrado en ofrecer mejoras a su privacidad y a su capacidad de ejecutar scripts más potentes.

Mejoras como Taproot y Graftroot apuntan precisamente a esto, y entre ellas llegan los Discrete Log Contracts (DLC). Sin embargo, los DLCs tienen un objetivo un poco más específico. 

Y es que estos están diseñados para conectar la Blockchain de Bitcoin con el mundo fuera de la Blockchain. Es decir, los DLC buscan establecer puentes de comunicación que lleven información del mundo real a la Blockchain. Para que una vez allí esa información sea procesada por Smart Contracts dentro de Bitcoin, o cualquier otra Blockchain que implemente los DLCs.

En tal sentido, es comprensible que conectar la Blockchain al mundo real es una funcionalidad muy apreciada por los desarrolladores de aplicaciones descentralizadas. De hecho, las finanzas descentralizadas o DeFi necesitan de este tipo de funciones para poder funcionar de forma correcta. De allí el hecho de que en Ethereum los oráculos sean algo común, porque son estos los que llevan información del mundo real a los protocolos DeFi (o DApps) que se ejecutan en Ethereum y necesitan de estos datos. En ese caso, Chainlink es uno de los proyectos más conocidos de oráculos sobre Ethereum.

> Pero Bitcoin, así como muchas criptomonedas derivadas, son otra historia. Dado que Bitcoin Script está limitado en funciones, este tipo de funciones son casi imposible de implementar sobre Bitcoin de forma nativa. En su lugar, se hace necesario crear todo un protocolo de segunda capa (como el de RSK o Stacks) para agregar estas funcionalidades.

Pues bien, la propuesta de Tadge Dryja quiere cambiar esto y permitir que Bitcoin pueda implementar oráculos de forma nativa en su Blockchain. Las posibilidades de esto son muchas, empezando porque Bitcoin finalmente podría tener un conjunto de aplicaciones descentralizadas DeFi propias. Algo que ampliaría de sobre manera su funcionalidad y masificaría aún más su uso. Por otro lado, generaría problemas si no se solventan los problemas de escalabilidad que sufre Bitcoin.

####  Lightning Network y los DLCs
La función de los Discrete Log Contracts (DLC) es interesante, pero se presenta un grave problema en el horizonte: la escalabilidad.

Pues bien, esto podría no ser un problema del todo, ya que Tadge Dryja ha creado los DLC para que puedan ser ejecutados sobre Lightning Network. 

¿Resultado? Las operaciones de DLC pueden realizarse por miles en un canal de Lightning Network dedicado a esta tarea. Y una vez se llegue al límite del canal, simplemente este se cierra, se emite el bloque en la Blockchain de Bitcoin, y se cierran las cuentas para todas las partes involucradas.

**De esta manera, sería posible que los DLC puedan realizar miles e incluso cientos de miles de operaciones sin que ello tenga un impacto indeseado sobre la Blockchain de Bitcoin. Aunque es cierto, no sería nativo ya.**

**Incluso, es posible llevar los DLC a sistemas compatibles con Lightning Network, como es el caso de la Lumino** Network de RSK, en donde podría potenciar enormemente la funcionalidad de este protocolo de segunda capa de Bitcoin. No solo eso, el sistema podría trasladarse a otras redes o protocolos de segunda capa que cumplan con las funciones HTLC y firmas Schnorr.

####  Discrete Log Contracts (DLC), estado actual
Parte de la tecnología de DLC depende de la activación de Taproot y MAST, dos tecnologías que han sido activadas recientemente sobre Bitcoin.

Sin embargo, para el completo funcionamiento del protocolo DLC es necesario habilitar algunas funciones adicionales que permitirán su completo desarrollo sobre Bitcoin y Lightning Network.

![[225.B4_dlcs.png]]

**Sin embargo, en la comunidad Bitcoin muchas cosas han cambiado. Si bien, en sus inicios se pensaba que Bitcoin no necesitaría de grandes desarrollos para Smart Contracts avanzados, esta idea ha cambiado radicalmente en los últimos años. La creación de Taproot y la implementación de Schnorr abrieron las puertas para ello, eso además de la idea de mantener la descentralización de Bitcoin para este tipo de construcciones, dejando de lado la necesidad de proyectos externos (como RSK o Stacks) para este tipo de operaciones.**

De esta manera, los desarrolladores de Bitcoin buscan construir todo lo que necesitan para Smart Contracts avanzados en Bitcoin, de forma nativa, aprovechando la mayor red descentralizada del mundo crypto (Bitcoin cuenta con más de 20 mil nodos Core, y un número superior a 30 mil nodos LN). **Dicho esto, la implementación de DLC llevará a un nuevo nivel a Bitcoin, porque sus Smart Contracts nativos podrán ejecutarse no solo sobre la Layer1 de Bitcoin, sino también sobre Lightning Network,** con lo que las comisiones y velocidad de estas operaciones sería cientos de veces superior a la de cualquier red Blockchain que se encuentre activa actualmente, incluso superior a Ethereum 2.0 y sus shards. 

¿Significa todo esto que no podemos hacer uso de los DLC actualmente? Para nada, podemos usar dicha tecnología como “tech preview” junto a todas las capacidades de la red Bitcoin testnet y el poder de los DLC aplicados sobre esta red, para ver el potencial de esta tecnología.


###  Funcionamiento de un DLC
En el whitepaper presentado por Tadge Dryja, este especifica claramente el funcionamiento básico de los DLC. 

En primer lugar, debes saber que un DLC es un contrato que tiene valor monetario.

Cuando un DLC es creado, actúan tres entidades. Dos de ellas son las partes que están realizando el intercambio, y una tercera parte es el ==oráculo.== **Este último es quien dará a conocer los datos necesarios para llevar a cabo la negociación.** Dependiendo de los datos otorgados por el oráculo, se realiza una distribución de fondos atendiendo a las condiciones estipuladas por el contrato.

**Pero es gracias a la estructura de la Blockchain, que las partes que actúan en una DLC jamás se conocen como tal. Es más, ni siquiera el oráculo es capaz de obtener dichos datos.** Esto garantiza que las operaciones son privadas y seguras, y al mismo tiempo, que dichas operaciones sean descentralizadas. No solo eso, el uso de firmas Schnorr resulta vital en este funcionamiento, y a la vez el uso de tecnologías como **Taproot y Graftroot**, pues son estas las que amplifican la funcionalidad final de los DLC. Dicho de otra manera, los DLC son una tecnología complementaria a estas otras tecnologías ya mencionadas.

Ahora bien, esto es solo una vista superficial de cómo funciona un DLC, así que ahondemos un poco más sobre esta tecnología. En especial, sobre su apartado “discreto” y lo que permite estas características: las firmas Schnorr.

####  Firmas Schnor:  La discreción de los DLC
El funcionamiento de los DLC recae especialmente en las firmas Schnorr.

Estas firmas son el método elegido para crear las firmas digitales necesarias para que un contrato multipartita pueda ser ejecutado de forma confiable. 

**Recordemos que las firmas Schnorr son capaces de ejecutar una forma de criptografía conocida como firmas con umbral (threshold signature).**

Ello significa que, varias partes pueden participar en la firma digital de un contrato o transacción de criptomonedas. Todo ello sin que ninguna de las partes sepa cuál es la firma de cada una de las partes, ni los datos secretos asociados a dicha firma. De hecho, es la firma de todas las partes la que al final garantiza una firma única y uniforme para el contrato o transacción.

Imagina esto de la siguiente manera:
- **Dos personas crearán un contrato a futuro de Bitcoin.**   
    Ambas partes han decidido crear este contrato y confiar en un oráculo para determinar si en el plazo de tiempo definido en el oráculo se cumplen las condiciones que favorezcan a una u otra de las partes involucradas. 
- **En este punto, establecidas las condiciones, se comienza con la creación del DLC.** Así, cada una de las partes crea su propia firma Schnorr, incluyendo al oráculo.
- **Una vez se han creado las firmas y firmado el script o Smart Contract,** este se envía a Blockchain a la espera de que se cumplan las condiciones. 
- **Las condiciones son monitoreadas constantemente por el oráculo,** que al término de la operación es consultado por la información necesaria para el cumplimiento del Smart Contract. 
- **Esta información es entregada por el oráculo, junto con su firma Schnorr** y una vez se verifica la autenticidad de la información, el DLC activa las condiciones del contrato dada la información recibida. 
- **De esta forma, el Smart Contract creada por las partes en su momento** enviará los fondos de acuerdo a lo estipulado, y todo ello sin ninguna intermediación.

**En este ejemplo, las firmas Schnorr son vitales porque estas son las que demuestran de forma clara que la información es correcta (en el caso del oráculo) y de que las partes (ganadora o perdedora) han recibido la información y que están de acuerdo con la misma.** 

De hecho, si una de las partes intentara reclamar el dinero sin autorización del oráculo, el dinero podría ir directamente a su contraparte, desmotivando así acciones maliciosas.

**Adicionalmente, el hecho de usar firmas Schnorr y de poder unirse con contratos como los impulsados por Taproot y Graftroot solucionan un problema común con los smart contact: la privacidad.** Y es que, estas creaciones están pensadas en proteger la misma de la mejor manera posible en todo momento.

Básicamente, el funcionamiento de DLC depende de la siguiente estructura:

![[226.B4_estructura.png]]

En esta imagen podemos ver las UTXOs, que pueden ser manejadas por Alicia y Bob, las cuales son emparejadas on-chain en una operación multifirma (2-de-2). 

Sin embargo, esta operación solo se aplicará una vez se cumplan ciertas condiciones off-chain que serán analizadas por los oráculos DLCs. 

En nuestra imagen, vemos que hay 4 condiciones off-chain, siendo las tres primeras las realizaciones de las operaciones programadas por los Smart Contracts DLC y la última, una cláusula de devolución en caso de que no se cumplan ninguna de las condiciones programada, permitiendo que Alice y Bob recuperen su dinero. 

**En toda esta estructura hay un punto importante:** **las condiciones del Smart Contract y la transacción no son reveladas sino hasta el final de la operación, momento en el que el resultado queda grabado en la Blockchain de Bitcoin.** Esto significa que las condiciones del Smart Contract son privadas, y solo son conocidas por Alice y Bob, nadie más puede revisarlas, salvo aquellas que son cumplidas y quedan grabadas en la Blockchain. 

####  Oráculos en DLC
Un oráculo en Blockchain, no es más que una entidad que firma mensajes como reacción a eventos del mundo real.

Antes de que se produzca el evento, el oráculo anuncia un nonce público que se utilizará para producir posteriormente una firma. 

La clave pública utilizada para la firma también debe conocerse de antemano, pero no es necesario que sea única para cada evento. Una vez que se ha producido el evento, un oráculo libera un mensaje firmado sobre el resultado del evento utilizando el [nonce](https://es.cointelegraph.com/explained/what-is-the-nonce-a-vital-number-in-bitcoin) (y la clave pública) anunciados previamente.

En tal sentido, una característica importante de DLC es que las firmas del oráculo pueden utilizarse sin una petición explícita de los participantes en el contrato. Esta característica es la razón de la parte de "registro discreto" del nombre, ya que el protocolo, dependiendo de su implementación e instanciación, permite a las partes ocultar rastros de sus contratos al oráculo.

Lo anterior se puede ver gráficamente en la siguiente imagen:

![[226.B4_participante.png]]

  ![[226.B4_fuera_de_la_cadena.png]]

En este caso, podemos ver la “vista de participante” es decir, la vista que tendría toda aquella persona que participe en el Smart Contract DLC. Son ellos los únicos que podrán ver la información de las operaciones, viendo el DLC, el resultado del oráculo y toda la información almacenada en el mismo. Sin embargo, quienes estén fuera del sistema no podrán ver nada de esto, para ellos, la transacción será simplemente una transacción de Bitcoin o LN dentro de la red, la cual pueden verificar en todo momento sin problemas y sin revelar datos del sistema. 

![[226.B4_vista_ajena.png]]  

####  Ejecución de confianza mínima
Una segunda característica de los DLC es que las dos partes implicadas en el contrato no necesitan confiar la una en la otra.

La configuración y ejecución del contrato es tal que se garantiza que siempre podrán cerrar el contrato unilateralmente. 

**Con el uso de firmas adaptadas, es imposible que una parte se comporte mal y la interacción entre las partes solo es necesaria durante la fase de configuración.** Las partes también están protegidas contra oráculos defectuosos que no produzcan una firma en la ocurrencia del evento a través de un mecanismo de reembolso.

La versión actual de la especificación no ofrece protección contra la colusión de una parte con un oráculo. Sin embargo, estos mecanismos ya están previstos (a través de pruebas criptográficas contra-fraudes) a los fines de brindar mayor seguridad a esta implementación.

###  Ejemplos de DLC
Una de las formas en la que podemos probar el poder los de DLCs sobre Bitcoin, es usando la implementación realizada por Suredbits, con su software Bitcoin-S y Krystal Bull. 

![[227.B4_ejemplo_1.png]]

En este caso, descargaremos la versión 1.4.0 de Krystal Bull desde su web oficial de [GitHub](https://github.com/bitcoin-s/krystal-bull).

![[227.B4_ejemplo_2.png]]

Una vez descargado el software, podemos instalarlo y comenzar con el proceso de creación de nuestro primer DLC. En este caso, solo debemos hacer clic en “Create New Oracle” y comenzar con este proceso:

![[227.B4_ejemplo_3.png]]

Este proceso nos permite crear el monedero que manejará el oráculo y los DLCs asociados al mismo, como tal el proceso se da por medio de un monedero HD, en el que veremos la información de la seed.

![[227.B4_ejemplo_4.png]]

En este caso, nuestro oráculo tendrá el nombre de “BTC Price” y colocaremos nuestra clave para su manejo. Una vez terminado este proceso de configuración, podemos ver nuestro oráculo, la clave pública y dirección asociada al mismo.

![[227.B4_ejemplo_5.png]]

**Ahora ¿Cómo configurar este oráculo?** Pues bien, teniendo en cuenta que deseamos controlar el precio de Bitcoin, y que este dato es del tipo “numérico”, debemos crear un Evento Numérico para su control. Así, al presionar “Create Numeric Event” comenzamos a indicar los datos del precio de BTC que deseamos vigilar.

Así especificamos que nuestro oráculo tendrá:
1. Un precio de 45.000 USD por cada BTC
2. Vigilará la unidad BTC/USD

![[227.B4_ejemplo_6.png]]

Y creamos el evento. Al crearlo podremos verlo en el dashboard de nuestro Krystal Bull. Si queremos ver nuestro oráculo dentro de la red, todo lo que debemos hacer es hacer clic en “Send to Oracle Explorer” y allí podremos ver el oráculo en funcionamiento ([enlace al oráculo creado](https://oracle.suredbits.com/announcement/9b528c1bc206bfff6fbc443e1db93ca1e97895940d35ed363cc422fc452b58e5)). 

![[227.B4_ejemplo_7.png]]

![[227.B4_ejemplo_8.png]]

Toda la información que podemos ver en la captura anterior es nuestro oráculo DLC ya habilitado en la red. De hecho, en la imagen superior está desplegada en hexadecimal y abajo, la podrás ver en formato JSON, de forma más legible. 

![[227.B4_ejemplo_9.png]]

**En este momento, nuestro DLC ya ha sido creado, tenemos un oráculo que está atento al precio del BTC pero necesitamos alimentarlo con el precio para que funcione, después de todo el oráculo es simplemente un vigía de la realidad off-chain, uno que toma los datos de esa realidad y los traslada a la Blockchain y sus Smart Contracts.** Para lograr esto, es posible usar cualquier tipo de API que te permita obtener la información que buscas (incluyendo otras plataformas de oráculos blockchains) e inyectar dicha información. En este punto, el desarrollador tiene completo control y todo lo que necesita es acceso a dicha API y un nodo de Bitcoin para lograrlo. 

**Para este ejemplo, haremos algo más sencillo, lo haremos de forma manual, pero el resultado final será el mismo:** nuestro Smart Contract mostrará el resultado que hemos configurado. **Este proceso se llama “Attestation”** y lo podemos completar agregando el dato esperado por el Smart contrat (el precio de BTC), en este caso introducimos el valor actual de BTC en mercado:

![[227.B4_ejemplo_10.png]]

Para ello abrimos nuestro evento (o lo que es lo mismo interactuamos con el DLC) y agregamos el dato de Attestation, firmamos el evento y lo enviamos al explorador de oráculos, para ver los resultados:

![[227.B4_ejemplo_11.png]]

Con ello en el explorador quedará evidencia del oráculo y podemos observar el mismo de forma totalmente descentralizada. 

![[227.B4_ejemplo_12.png]]

####  Posibles usos previsibles con este ejemplo
**Ahora bien, una de las preguntas que seguramente te harás con este ejemplo es ¿Qué utilidad puede tener esto? Pues bien, imagina un exchange descentralizado (DEX) y piensa ¿Cómo saben estos exchanges el precio de un activo en todo momento? La respuesta, es que los DEX piden a oráculos como el que mostramos arriba información sobre el token o criptomoneda que vigilan.** 

Por supuesto, esto es un proceso que se realiza de forma automática y continua, pero eso es algo posible usando los DLCs, ya que para automatizar todo lo que hemos realizado paso a paso, solo faltaría programar un script o API que realice estas operaciones de forma continua, siendo que esta tarea es sencilla, en comparación con programar el Smart Contract que controla y permite ese proceso.

De hecho, en Suredbits han hecho esto, puesto que tienen un bot funcionando que maneja el precio de Bitcoin de forma diaria, una forma muy clara de demostrar el potencial de la tecnología. 

![[227.B4_ejemplo_14.png]]

Por supuesto, si podemos hacer algo como esto, es posible crear cualquier tipo de estructura, y eso es a lo que apuntan los DLCs, permitir la creación de Smart Contracts avanzados sobre Bitcoin y Lightning Network, aprovechando todo el potencial de ambas redes. 

¿Quieres una dApp DeFi en Bitcoin? DLC permite crearla. ¿Quieres una aplicación de mensajería o red social sobre Bitcoin? Los DLCs son una respuesta a ello. ¿Una Stablecoin o token sobre BTC? Eso también los DLC lo hacen posible. 

Si deseas saber más sobre Bitcoin-S y los DLCs, puedes revisar la [documentación oficial](https://bitcoin-s.org/docs/wallet/dlc) del proyecto.

## U6. DeFi
###  ¿Qué es DeFi? (Video)
![[228.B4_Qué_es_DeFi.mp4]]
[Que es DeFi](https://app.web3mba.io?wvideo=8f3ek5356e)

¿Qué es DeFi? DeFi, o Decentralized Finance (finanzas descentralizadas en español), es el término que se utiliza para definir una gran tendencia que ha surgido en torno a la tecnología blockchain en los últimos años. DeFi busca desarrollar pequeñas piezas de servicios financieros tradicionales, pero con un grado adicional de transparencia y descentralización. Estas pequeñas piezas, como si fueran bloques de Lego, son combinables entre sí con el fin de crear un ecosistema de soluciones que, en conjunto, ofrezcan una alternativa mejorada a los sistemas financieros tradicionales. Esta es la idea que ha impulsado la creación del término DeFi y que ha llevado su evolución hasta el punto actual. De hecho, en la actualidad es imposible pasar por alto el gran impacto que DeFi tiene en el mundo cripto. Por esta razón, abrimos un espacio para conocer qué es DeFi y cómo esta idea está cambiando el panorama financiero global.

Imagina un mundo donde cualquier persona pudiera crear productos financieros transparentes con los que cualquiera, en cualquier parte del globo, pudiera interactuar. No importa dónde te encuentres, si tienes un banco o no, si posees un monedero cripto, puedes utilizar un servicio financiero ofrecido por un protocolo DeFi. Además, debido a que sus funcionalidades son comunes entre ellos, como mencioné antes, son como piezas de Lego que puedes conectar entre sí. DeFi busca transformar las estructuras de finanzas centralizadas que tenemos actualmente en estructuras descentralizadas sin necesidad de terceros de confianza, ejecutando todo esto sobre smart contracts o contratos inteligentes dentro de una blockchain, donde quede reflejado de forma transparente un registro escrito e inalterable de cada acción realizada. Todo lo que ocurre dentro de esos smart contracts queda registrado en la blockchain, que, como sabemos, es algo que siempre se puede observar.

El impacto de algo como esto es enorme. Llevamos apenas unos años y la creatividad de la comunidad mundial está dando forma a versiones alternativas de casi todos los productos financieros existentes. Y no solo eso, sino que también se están creando instrumentos financieros nunca antes imaginados, como las bolsas descentralizadas, que más adelante cubriremos. Imagina que necesitas obtener un crédito para emprender un negocio, pero no tienes acceso a activos reales o ahorros en moneda fiat que te sirvan como colateral. Es más, quizás ni siquiera puedes usar un banco porque eres una de esas miles de millones de personas que no están bancarizadas. Gracias a DeFi, puedes solicitar ese préstamo en dólar digital (USDT, USDC, BUSD) utilizando capital cripto, es decir, criptomonedas como Bitcoin u otros dólares digitales. Este préstamo será controlado y aprobado no por un humano o un banco tradicional, sino por un smart contract en la blockchain que decidas utilizar.

Si te preocupa tu capacidad técnica, porque quizás no la tengas, no todo el mundo ha nacido con conocimientos en desarrollo tecnológico. Si te preocupa tu habilidad para analizar y verificar la fiabilidad del servicio DeFi que estás utilizando, puedes confiar en el análisis que miles de personas llevan a cabo continuamente sobre estos protocolos. El hecho de que todos los contratos y las operaciones que se realizan en ellos sean públicos implica que cualquiera puede cuestionarlos y, de hecho, estará incentivado a hacerlo, ya que también está en juego su dinero. En el futuro, dado el impacto de esta tecnología, no será raro que en las escuelas se enseñe a los niños a leer smart contracts. Gracias a DeFi, no necesitas estar bancarizado; no necesitas llevar decenas de papeles, hacer filas en bancos para entregar esos documentos y esperar semanas, incluso meses, a que te den una respuesta. En su lugar, desde la comodidad de tu sofá con tu smartphone, podrás realizar este proceso. Esto puede parecer irrelevante en algunos países, pero en otros es de una utilidad similar a la que permitió el acceso a Internet.

Las DeFi, no obstante, pueden ser mucho más. Pueden ser el vehículo para la economía y las finanzas de un mundo cada vez más presente que, con la ayuda de la tecnología blockchain, puede comenzar a descentralizarse. Serán el medio que abra las puertas a inversiones internacionales sin tanta burocracia, costos y tiempo, y con mayores niveles de confianza y transparencia. En definitiva, un vehículo para que las personas no bancarizadas puedan acceder a servicios sin las restricciones de los bancos, teniendo las mismas condiciones para evolucionar en su desarrollo personal.

¿Cuál es el origen de DeFi? Si piensas que las DeFi tienen su origen en el nacimiento de Bitcoin, tienes razón; Bitcoin es definitivamente la primera plataforma DeFi del mundo, pero el origen de la idea es mucho más antiguo. Nick Szabo, supongo que lo conoces, es una figura que muchos asocian con Satoshi Nakamoto, aunque nunca lo sabremos con certeza. Szabo apuntaba, tal vez sin saberlo, al nacimiento de las DeFi cuando presentó su idea de los smart contracts en 1995. Como ves, estas ideas han estado circulando durante muchos años, pero no es algo reciente; simplemente ahora tenemos la capacidad técnica para llevarlas a cabo. En 1995, Nick Szabo ya planteaba estos smart contracts, una idea sin duda adelantada a su época. Sin embargo, no fue hasta la llegada de Ethereum en 2014 y su desarrollo en 2016 que se vivió un cambio radical en esta idea. Ethereum y sus smart contracts permitieron a los desarrolladores crear cualquier cosa que pudieran imaginar sobre una blockchain. Lo que comenzó como un experimento, algo que simplemente se iba a probar, ahora se está transformando en un movimiento por sí mismo, un ecosistema financiero descentralizado que opera de manera autónoma, generando miles de millones de dólares cada mes desde todas partes del mundo.

Muchos desarrollos apuntan a que soluciones similares también podrán ofrecerse en las soluciones de segunda capa de Bitcoin. Este ecosistema DeFi, entre 2018 y 2019, mantuvo un desarrollo constante, y durante los primeros meses de 2020, el crecimiento fue aún más impresionante, alcanzando su punto culminante en 2021, del cual hablaremos más adelante. Este crecimiento ha sido totalmente sin precedentes. Incluso ha llegado a un punto en el que los límites entre los sistemas descentralizados (es decir, estos sistemas DeFi) y los sistemas centralizados de la banca tradicional comienzan a difuminarse. Ya no sabes cuándo estás en un sistema DeFi o en un sistema centralizado tradicional. Todo esto es gracias al trabajo de miles de personas anónimas que ahora nos permiten contar con mercados de liquidez, sistemas de préstamos y exchanges descentralizados.

Ahora que ya conocemos el concepto de DeFi, sus orígenes y las diferencias entre diferentes modelos financieros digitales, veamos cuáles son las características específicas de las DeFi. Primero, funcionan en base a la tecnología blockchain y a los smart contracts. En segundo lugar, pueden ser extremadamente seguras. Esto no significa que siempre lo sean, pero tienen el potencial de serlo gracias a que utilizan técnicas criptográficas avanzadas para asegurar que la plataforma, el acceso y el uso de las mismas sean realizados solo por personas autorizadas. Tercero, pueden contar con altos niveles de descentralización. De nuevo, esto depende de cómo se implemente, pero pueden alcanzar ese nivel de descentralización, es decir, tienen la capacidad de operar sin que una cadena burocrática se imponga sobre las funciones de la plataforma. Claro, esto no es así con todos los sistemas y protocolos disponibles, pero la posibilidad está presente.

En cuarto lugar, encontramos que no requieren confianza en terceros. Este es un punto muy importante, ya que significa que la interacción en una plataforma es directa entre el usuario y la plataforma. Los terceros de confianza son innecesarios porque esa tarea será realizada por la blockchain, que llevará el registro de todo. En quinto lugar, son transparentes. Es otra gran característica de las DeFi, ya que puedes observar todo lo que ocurre dentro de la blockchain y verificar exactamente esos smart contracts. Como mencioné, se construyen utilizando software libre y cada línea de código puede ser auditada por cualquier persona. Además, las movilizaciones de recursos, es decir, cuando el dinero pasa de un smart contract a otro, también son auditable, porque todo ello tiene su lugar dentro de la blockchain.

El acceso a una plataforma DeFi no tiene fronteras. Puedes estar en cualquier país del mundo y acceder a sus servicios sin inconvenientes. De hecho, esto es algo que hemos visto increíblemente en los últimos meses, sobre todo en 2021, cuando vimos a personas en Filipinas participando en un juego que quizás hayas oído hablar, Axie Infinity. En Filipinas, un país que claramente no está entre los más desarrollados del planeta, encontraron en DeFi y en la posibilidad de participar en estos juegos dentro de la blockchain una oportunidad que les permitió salir adelante y conseguir un ingreso extra en un momento tan delicado como fue la pandemia. Así que todos estos sistemas permiten la entrada y la participación de cualquier persona en cualquier lugar del mundo, y la posibilidad de acceder a ellos es tan simple como tener un teléfono móvil y un monedero.

Hablemos ahora de los pros y los contras de esta tecnología. Por supuesto, como toda tecnología, tiene sus aspectos positivos y negativos. Entre los pros, encontramos que habilita el acceso a servicios financieros para millones de personas que, como mencioné, pueden no estar bancarizadas. Quiero detenerme un momento aquí en la importancia de estar bancarizado, ya que no todo el mundo tiene esta capacidad. Tú probablemente puedes ir al banco y decir: "Hola, soy Antonio. Vengo a hablar de mi cuenta". Eso no ocurre en muchos lugares donde la gente no tiene estas oportunidades. Gracias a DeFi, esto es posible, y representa una oportunidad de oro para llevar desarrollo y libertad financiera a quienes, por diversas razones, no han podido disfrutar de estos servicios.

Dentro de los pros también encontramos que permite que la financiación internacional de empresas y proyectos sea mucho más sencilla. Las plataformas DeFi pueden ajustarse a las necesidades del público para llevar desarrollo e inversiones donde se necesitan. Y dichas inversiones pueden provenir de cualquier lugar del mundo. Solo hay que ver la cantidad de dinero que ha aflorado gracias a la creación de estos sistemas. Sí, mucho de ello es riqueza virtual, pero también se ha generado mucha riqueza tangible. Además, las DeFi crean un nuevo punto de diversificación económica y desarrollo. De hecho, pueden significar un importante punto de desarrollo económico a mediano plazo debido al enorme potencial de criptomonedas como Bitcoin.

Habiendo cubierto estos pros, y créeme, hay muchos más, veamos algunos de los contras. La seguridad, en primer lugar, sigue siendo un aspecto a mejorar dentro de las plataformas DeFi. Si bien la blockchain ha demostrado ser una tecnología muy segura, aún quedan muchas cosas por pulir, especialmente en lo que respecta a la seguridad y auditoría de los smart contracts. Un fallo en un smart contract puede significar un colapso en la plataforma, como demostró el caso de DAO en los inicios de Ethereum y otros experimentos fallidos que hemos visto en los últimos años.

En segundo lugar, otro de los contras es que los protocolos de actuación ante la volatilidad de las criptomonedas no siempre están bien ajustados. Muchas plataformas DeFi han creado mecanismos de funcionamiento que garantizan su estabilidad económica frente a la volatilidad de las criptomonedas. Sin embargo, no pueden realmente garantizarla, y vemos que muchos de estos mecanismos a veces resultan insuficientes o simplemente no protegen al ecosistema frente a las fuertes fluctuaciones que se observan en este mercado. Una situación triste que ocurrió recientemente es la de Luna y UST, cuya fluctuación y acciones de corrección han demostrado que la descentralización y protocolos de actuación mal ajustados pueden ser una debilidad para estas plataformas si no se manejan correctamente.

Finanzas descentralizadas y fintech. Creo que es útil dedicar un momento a analizar ambas, porque seguro que has oído hablar de fintech, pero ¿en qué se diferencian de las finanzas descentralizadas que estamos cubriendo? Tenemos en nuestras manos tres modelos de finanzas que, hasta cierto punto, tienen un mismo objetivo: ofrecernos herramientas financieras potentes para ayudarnos a manejar de manera más sencilla nuestras finanzas y carteras de inversión. Estamos hablando, claro, de las finanzas tradicionales, ese banco del que he estado hablando, las nuevas fintech, que son empresas que tienen aplicaciones sobre las finanzas tradicionales, y en tercer lugar, las DeFi.

Las finanzas tradicionales ya las conocemos: el modelo centralizado de toda la vida, altamente dependiente de los bancos, enrevesado a veces, complejo muchas otras y, a menudo, inalcanzable para una gran parte de la población mundial. Hablamos de un modelo que ya vemos como en su ocaso, no solo por su incapacidad de innovar, sino porque los mismos que lo sostienen han comenzado a entender que esas herramientas ya no funcionan en el mundo actual. De los intentos de renovar y mejorar ese viejo sistema surge nuestro segundo modelo: las FinTech, o tecnologías financieras. Aquí hablamos de un intento de crear un sistema de finanzas digitales que permita alcanzar a una mayor cantidad de población, que sea rápido, eficiente, barato, global y, sobre todo, más sencillo de manejar que la banca tradicional.

Desde la década de los 90 y principios del nuevo milenio, las fintech se elevaban como el pináculo de la tecnología financiera y parecían marcar el próximo salto evolutivo de las finanzas globales. Sin embargo, esto quedó en un segundo plano con la creación de Bitcoin, la llegada de Ethereum y los primeros sistemas DeFi. La posibilidad de construir finanzas descentralizadas más universales, totalmente sin fronteras, cambió definitivamente las reglas del juego. No solo por su funcionamiento, sino también por las posibilidades que ofrecen las finanzas descentralizadas.

Podemos compilar ahora una pequeña lista que nos ayudará a diferenciar entre estos tres modelos. Una fintech es un ente centralizado, construido sobre un software y con entornos controlados y censurables. Esta palabra es importante. Por otro lado, una DeFi despliega su software sobre una blockchain descentralizada. Los contratos de una fintech son contratos que siguen el constructo legal típico que todos conocemos, mientras que en DeFi estos contratos son establecidos de igual manera para todos. El corazón de una DeFi y sus servicios son los smart contracts en blockchains que podemos ver, auditar y verificar libremente. Las decisiones de aprobación de una fintech están atadas a una cadena burocrática más larga o más corta, lo que significa que, como usuarios, podemos estar esperando una respuesta a nuestras solicitudes durante meses, días, semanas o incluso horas. Pero en DeFi, todo ocurre dentro de la cadena, de forma inmediata entre tú y la plataforma. En la mayoría de los casos, la cadena ni siquiera tiene que tener constancia de lo que está pasando. El contrato está en la cadena, se ejecuta y ya está. La aprobación se realiza de forma automática si cumples o excedes los requisitos que la plataforma exige para acceder a sus servicios.

Una fintech, por seguir con las diferencias, utiliza bancos y toda la estructura de finanzas tradicionales para hacerte llegar los recursos que solicitas. Como mencioné, una fintech es básicamente una aplicación sobre las finanzas tradicionales. Esto significa que necesitas ser alguien bancarizado y tener un registro en el sistema para participar con ciertas garantías. También significa que ese dinero puede ser censurado o limitado si así lo desean. En DeFi, esto no es algo de lo que debas preocuparte. No necesitas tener cuenta bancaria; solo necesitas un monedero de criptomonedas donde puedas recibir e interactuar con tus fondos. Ante esta visión, queda claro que una fintech es simplemente un ente financiero tradicional, pero digitalizado. Algunos proyectos fintech bien reconocidos a nivel mundial son Revolut o PayPal, por si necesitas ejemplos. Pero ya sabemos todos cuáles son y ahora entendemos en qué se diferencian de las DeFi.

Hablemos de los potenciales casos de uso de DeFi. Porque hemos estado hablando de DeFi un buen rato, ya sabemos lo que son, su origen y las diferencias con otros tipos de tecnologías. Hablemos realmente de para qué se usa esto, porque probablemente has vivido sin usar DeFi toda tu vida. ¿En qué medida podrías usarlo? En primer lugar, las DeFi nos sirven como un puente financiero entre la riqueza de los tenedores de criptomonedas y un mundo lleno de servicios financieros que pueden emplearse haciendo uso específicamente de esa riqueza acumulada en los diferentes monederos. Dicho esto, entre los casos de uso más típicos podemos mencionar los siguientes.

Sistemas de lending descentralizados, o préstamos descentralizados, son uno de los principales casos de uso de las DeFi en la actualidad, y uno de mis favoritos. El sistema es sencillo. Si una persona desea un préstamo y quiere usar sus criptomonedas como colateral, puede hacerlo sin problemas. El sistema funciona de manera muy similar a las fintechs o finanzas tradicionales. La diferencia principal es que no tienes que registrarte en ningún sitio, ni siquiera presentarte. Todo lo que necesitas es un monedero con criptomonedas. Te conectas al sistema a través de tu monedero y este sistema comprueba inmediatamente si tienes alguno de los activos que acepta como colateral. Un par de firmas con tu monedero es todo lo que te separa de obtener un crédito, normalmente en dólar digital (USDT, USDC), que recibirás de inmediato. Tu colateral seguirá accesible para ser retirado en cualquier momento, a cambio, claro, de devolver el préstamo. Una importante ventaja aquí del sistema DeFi es que los tipos de interés los define el mercado y no un banco central, lo que permite condiciones totalmente distintas a las que ofrecen los servicios financieros tradicionales.

Esto es algo que puedes hacer hoy mismo si quieres. Si tienes dinero en un monedero, puedes ir a un protocolo DeFi, verás que te piden un colateral. Si tienes el token que te piden, imagina que te piden ETH como colateral, el sistema verá que tienes ETH y te dirá: "Con este ETH que tienes, puedes pedir hasta esta cantidad de dólares como préstamo". Depositas ese ETH y te llevas el préstamo. Luego, para devolverlo, simplemente envías USDT o el USD que hayas recibido al protocolo y este te devuelve tu colateral. Este sistema es realmente interesante.

Pero vayamos al siguiente caso: los mercados descentralizados. Este es otro caso de uso de las DeFi que, si el anterior me gustaba, este me encanta. Creaciones como los exchanges descentralizados, conocidos como DEX o DEXs, son como los pools de inversiones o derivados financieros. Todos estos sistemas de staking son posibles gracias a DeFi. Es necesario hacer especial mención a los mercados descentralizados, porque esta parte es muy diferente a lo que vemos en los mercados tradicionales. Si entiendes lo que son los mercados de lending y comprendes los mercados descentralizados, puedes entender rápidamente cómo funciona DeFi.

Imagina que tienes una bolsa. Todos sabemos lo que es la bolsa. En la bolsa hay precios, por ejemplo, de Coca-Cola. La acción de Coca-Cola se mueve, la gente compra y vende. Esto se hace a través de un libro de órdenes. ¿Qué es el libro de órdenes? Es algo que existe en los mercados tradicionales. Tienes órdenes de venta, gente que está vendiendo Coca-Cola a diferentes precios, y órdenes de compra, gente que está comprando Coca-Cola a diferentes precios. Ahí tienes ese libro de órdenes, donde puedes ver la profundidad de las órdenes por ambos lados. Donde se cruzan, ese es el precio que ves en la bolsa o, si compras el periódico al día siguiente, el precio de cierre fue el último que se cruzó entre venta y compra.

Esto es posible en los mercados tradicionales, pero no en los mercados descentralizados. Los mercados descentralizados tuvieron que encontrar una solución a este problema. No puedes tener un libro de órdenes en DeFi, porque eso significaría que tienes que firmar y pagar por poner tu orden en ese libro. Nadie va a pagar por poner su orden en el libro para ver si en algún momento se ejecuta. Por eso se inventaron los mercados descentralizados. Todos los precios que ves en los tokens en las bolsas descentralizadas, que son la base de DeFi, se crean de la siguiente manera: hay un pool, una piscina de liquidez, donde hay un token contra otro. Igual que Coca-Cola cotiza contra el dólar, puedes imaginar que hay acciones de Coca-Cola y dólares en una piscina. En función de cuántos dólares y cuántas acciones de Coca-Cola hay, tendrás un precio u otro. Si tienes 10 dólares y 10 acciones de Coca-Cola, el precio de una acción de Coca-Cola será un dólar. Pero si quieres comprar una acción de Coca-Cola, tendrás que depositar un dólar. Entonces habrá 11 dólares y 9 acciones de Coca-Cola porque te has llevado una. Eso cambia el precio porque ya la cantidad de uno y de otro cambia. Así es como funcionan los mercados descentralizados.

También tenemos sistemas de pagos. Las características de estas plataformas les permiten ser un puente de confianza para procesar pagos de distintas blockchains utilizando una infraestructura externa y autónoma. De hecho, pagar con dólar digital empieza a ser una realidad muy extendida, ya que un pago internacional con dólar digital se liquida en minutos, mientras que uno a través de los medios tradicionales tarda desde varias horas, en el mejor de los casos, a varios días, que suele ser lo normal. Finalmente, también encontramos servicios bancarios y de seguros. El hecho de que todos los protocolos estén conectados entre sí, como mencioné con los bloques de Lego, permite a las blockchains crear servicios bancarios de todo tipo por terceros que no necesitan la aprobación o el consentimiento de otros sistemas. Esto nos brinda la oportunidad de acceder a un nivel de innovación jamás visto antes y una capacidad de interacción que hace posibles servicios financieros y bancarios que serían imposibles con las finanzas tradicionales. Uno de los casos más interesantes es el de sistemas que ofrecen servicios de seguros o inversiones totalmente ajenos a los sistemas bancarios tradicionales.

En este punto, es claro que el potencial de las DeFi para ofrecer servicios y soluciones es muy variado, tan variado como la inventiva de las personas que desarrollan dichos sistemas. Dediquemos ahora un momento a los riesgos, porque hemos estado hablando de las ventajas y características un buen rato. Detengámonos un momento a hablar de los riesgos a tener en cuenta al acceder al mundo DeFi. En DeFi, todo tiene sus imperfecciones, como cualquier otro sistema que se está trabajando e innovando. Existen riesgos que provienen de que todavía no está todo ajustado. Hay cosas que aún necesitan mejoras. De hecho, es importante conocer los riesgos antes de entrar de lleno en este mundo. Si no lo haces, es posible que aprendas a base de errores, que, francamente, así es como hemos aprendido todos, así que tampoco pasa nada.

Entre estos riesgos, podemos mencionar los siguientes. Los contratos y plataformas pueden ser complejos de entender, y usar DeFi no es algo que cualquiera pueda hacer, por mucho que a veces te pueda parecer lo contrario. Si entras a una aplicación descentralizada e intentas realizar una operación, seguramente verás que hay conceptos que para una persona común pueden parecer extraños, como staking o pooling. Además, los contratos de DeFi y las explicaciones en la web de la aplicación, así como los smart contracts de dichas aplicaciones, pueden parecer escritos en una lengua perdida que nadie entiende, lo que puede conllevar riesgos. Si no entiendes bien, puedes estar haciendo algo que realmente no deseas hacer. Por esto, creo que es importante que seas consciente de que DeFi, aunque ofrece enormes posibilidades, también presenta riesgos. Es fundamental saber en qué estás participando e invirtiendo. Para llegar a ese nivel de comprensión, lo único que necesitas es dedicar un poco de tiempo a probar y entender qué hace la plataforma, comprender exactamente cómo funciona y cuáles son las herramientas que tienes a tu disposición. De esta manera, podrás evitar situaciones desafortunadas, como la pérdida de tu inversión. Aunque, como mencioné, al principio, perder un poco de dinero probando es algo común.

### ¿Qué es DeFi?
DeFi o Decentralized Finance (Finanzas Descentralizadas, en español) es el nombre que está definiendo una gran tendencia que se está dando entorno a la tecnología Blockchain en los últimos años.

DeFi busca desarrollar pequeñas piezas financieras tradicionales, pero con un grado extra de transparencia y descentralización. 

Estas pequeñas piezas, como si fueran piezas de Lego, son combinables entre sí con el fin de desarrollar todo un ecosistema de pequeñas soluciones que en su conjunto formen una gran solución para las finanzas. De este modo, se podrá invalidar la necesidad de instituciones financieras centralizadas y opacas que ya no aportan valor.

Esa es la idea que ha impulsado la creación del término “DeFi”, y la que ha llevado su evolución hasta el punto actual. De hecho, en la actualidad es imposible pasar por alto el altísimo impacto que DeFi tiene en el mundo cripto. Por esa razón, abrimos un espacio para conocer que es DeFi y como esta idea está cambiando el mundo financiero global.

####  DeFi, la idea que está cambiando el mundo financiero
Imagina un mundo donde cualquier persona pudiera crear productos financieros transparentes, justos y eficientes, haciendo que los bancos, las grandes financieras, prestamistas y empresas de seguros pasen a un segundo plano. O mejor aún, se vuelvan completamente innecesarias y desaparezcan. 

**Pero también un mundo donde cualquier persona pueda interactuar con esos productos de forma libre.**

**Pues bien, esto es lo que es DeFi. Es decir, quiere convertir las estructuras de finanzas centralizadas que tenemos ahora, en estructuras descentralizadas, sin terceros de confianza, ejecutada sobre Smart Contracts o contratos inteligentes, dentro de una Blockchain donde quede reflejado de forma transparente un registro escrito e inalterable de cada acción realizada.**

El impacto de una tendencia como esta es gigantesco. Apenas estamos en sus primeros años y ya la creatividad de la comunidad mundial está dando forma a versiones alternativas de casi todos los productos financieros ya existentes.

**Imagina que tienes la necesidad de obtener un crédito para emprender. En lugar de ir a un banco, puedes ir a una plataforma DeFi y solicitar un préstamo.** Dicho préstamo tiene unas condiciones (salvando los tecnicismos) bastante claras y transparentes. Todo esto gracias a que dicho préstamo va a ser controlado por un Smart Contract público e inmutable.

**No solo eso, todas las acciones que se realicen en las plataformas quedan visibles y grabadas de forma inmutable también en la Blockchain.** Tal vez usted no tiene el conocimiento para verificar la fiabilidad del servicio DeFi, pero debido a su característica de transparencia, miles de ojos podrán analizarlo y cuestionarlo, alertando de su mal funcionamiento si así fuera. Y en el futuro, dado el impacto de esta tecnología, seguro que en la escuela se enseña a los niños a leer Smart Contracts transparentes.

> Gracias a DeFi, no necesitará estar bancarizado, no necesitará llevar decenas de papeles, hacer filas para entregarlos y esperar semanas para una respuesta. En su lugar, desde la comodidad de su sofá, con su smartphone podrá hacer todo el proceso recibiendo el dinero en su poder.

**No obstante, las DeFi pueden ser mucho más, pueden ser el vehículo para la economía y las finanzas de ese mundo cada vez más presente que con la ayuda de la tecnología Blockchain comience a descentralizarse.** El vehículo que abra las puertas a inversiones internacionales sin tanta burocracia, costes y tiempo y con mayores niveles de confianza y transparencia. **Un vehículo para que las personas no bancarizadas puedan acceder a servicios sin las dictaduras de los bancos, teniendo iguales condiciones de evolucionar personalmente en su desarrollo.**

####  Origen del DeFi
Si eres de los que piensan que las DeFi tienen su origen con el nacimiento del Bitcoin, estás en lo cierto. Bitcoin es definitivamente la primera plataforma DeFi del mundo. Pero el origen de la idea es mucho más antiguo.

Nick Szabo apuntaba, tal vez sin saberlo, al nacimiento de las DeFi cuando presentó su idea de los Smart Contracts en el año de 1995. Eso es 13 años antes de la creación del Bitcoin, una idea sin duda adelantada a su época. 

**Sin embargo, no fue hasta la llegada de Ethereum en 2014, lo que supuso un cambio radical a esta idea.** Ethereum y sus Smart Contracts permitían a los desarrolladores crear cualquier cosa que pudieran imaginar sobre una Blockchain. Y justamente eso lo que empezó con un experimento ahora se está transformando en un movimiento por sí mismo, en un ecosistema financiero descentralizado que opera miles de millones de dólares cada mes. 

**Un ecosistema que durante los años 2018 y 2019 mantuvo un desarrollo constante, y durante los primeros meses de 2020 ha tenido un crecimiento sin precedente. Incluso ha llegado al punto que ha revalorizado los proyectos Blockchain al permitir crear puentes entre las finanzas tradicionales y las criptomonedas.** 

Gracias a ese trabajo ahora podemos contar con mercados de liquidez, sistemas de préstamos y exchanges descentralizados (DEX), siendo todo esto solo el comienzo. 

####  Características de las DeFi
Ahora que, ya que conocemos el concepto, sus orígenes y la diferencias entre modelos financieros digitales, conozcamos cuales son las características de las DeFi. 

1. **Funcionan en base a la tecnología Blockchain y de los Smart Contracts.**
2. **Son muy seguras.** Esto gracias a que usan técnicas criptográficas potentes para asegurar que la plataforma, el acceso y uso de las mismas pueda ser realizado solo por personas autorizadas.
3. **Cuentan con altos niveles de descentralización.** El mayor potencial de las DeFi es su alto nivel de descentralización. Es decir, tienen la capacidad de actuar sin necesidad que una cadena burocrática se imponga por encima de las funciones de la plataforma.
4. **Sin confianza en terceros.** Esto significa que la actuación en una plataforma es directa entre el usuario y la plataforma en sí. Los terceros de confianza son innecesarios porque esa tarea será realizada por la Blockchain. Es esta estructura la que llevará el registro de todo de forma segura e inmutable. 
5. **Transparentes.** Otra gran característica de las DeFi es su transparencia. Al ser construidas sobre software libre cada línea de código de las plataformas es auditable. Además las movilizaciones de recursos son auditables, porque todas ellas tienen lugar sobre la Blockchain. 
6. **Sin fronteras.** El acceso a una plataforma DeFi no tiene fronteras. Puedes estar en cualquier país del mundo y acceder a sus servicios sin inconvenientes.  

####  Pros y Contras
Como toda tecnología tiene sus pros y contras, y por esa razón examinaremos algunos de ellos. 

#####  Pros
1. **Habilita el acceso a servicios financieros a millones de personas que no están bancarizadas.** Esto es sin duda una oportunidad de oro para llevar desarrollo y libertad financiera a quienes por distintas razones no han podido gozar de estos servicios. 
2. **Permite que la financiación internacional de empresas y proyectos sea mucho más sencilla.** Las plataformas DeFi pueden ajustarse a las necesidades de un público objetivo con el fin de llevar desarrollo e inversiones allí donde se necesitan. Y dichas inversiones pueden provenir de cualquier lugar del mundo de forma segura. 
3. **Crea un nuevo punto de diversificación económica y desarrollo.** De hecho, las DeFi pueden significar un importante punto de desarrollo económico en el mediano plazo debido al enorme potencial económico de criptomonedas como Bitcoin.

#####  Contras
1. **La seguridad aún sigue siendo un punto a pulir dentro de las plataformas DeFi.** Si bien, la Blockchain ha demostrado ser una tecnología muy segura, aún quedan muchas cosas por mejorar, en especial, con el nivel de seguridad y auditoría de seguridad de los Smart Contracts. Un fallo en un Smart Contract significa un fallo en la plataforma, tal como lo demostró The DAO.
2. **Protocolos de actuación ante la volatilidad de las criptomonedas.** Muchas plataformas DeFi han creado mecanismos de funcionamiento que garantizan su estabilidad económica frente la volatilidad de las criptomonedas. Sin embargo, muchas veces estos mecanismos parecen insuficientes. O simplemente no protegen del todo al ecosistema frente a las fuertes fluctuaciones. Una situación que lleva a pérdidas millonarias. Un caso de este tipo es MakerDAO y DAI, cuyas fluctuaciones y acciones de corrección han dejado ver que la descentralización y protocolos de actuación mal ajustados muchas veces pueden ser una debilidad para estas plataformas, si no se manejan de forma correcta.

####  DeFi y FinTech ¿Cuáles son sus diferencias?
Tenemos  tres modelos de finanzas que hasta cierto punto tienen un mismo objetivo en común: Ofrecernos herramientas financieras potentes para ayudarnos a fortalecer nuestras finanzas y portafolios.

**Sin embargo, la forma en cómo logran esto es completamente distinta para cada uno de esos modelos. Sí, estamos hablando de las finanzas tradicionales, las nuevas FinTech y por supuesto del DeFi.** 

Las finanzas tradicionales ya las conocemos, el modelo centralizado, altamente dependiente de los bancos, enrevesado, complejo e inalcanzable para la gran mayoría de la población mundial. Hablamos de un modelo que vemos ya como entra en su ocaso, no solamente por su incapacidad de innovar, sino porque los mismos que los sostienen han empezado a entender que esas herramientas ya no funcionan en el mundo actual.

**De los intentos de renovar y mejorar ese viejo sistema, sale nuestro segundo modelo, las FinTech (Financial Technologies – Tecnologías Financieras). Hablamos de un intento de crear un sistema de finanzas digitales que permita alcanzar a mayor cantidad de población que sea rápido, eficiente, barato, global y sobre todo más sencillo de manejar.** Desde la década de los 90 e inicios del nuevo milenio, las FinTech se elevaban como el pináculo de la tecnología financiera y parecían que serían el próximo salto evolutivo de las finanzas globales. 

**Sin embargo, eso quedó atrás con la salida del Bitcoin, la llegada de Ethereum y los primeros sistemas DeFi.** El hecho de poder construir finanzas descentralizadas, más seguras, más universales, sin fronteras, definitivamente cambió las reglas del juego, no solo por su funcionamiento sino también por las posibilidades de las DeFi.  

Así podemos compilar Una pequeña lista nos podrá ayudar a diferenciarlas: 
1. **Una FinTech es un ente centralizado, construido sobre software y con entornos controlados y censurables.** Por otro lado, una DeFi, trabaja despliega su software sobre una Blockchain descentralizada.
2. **Los contratos de una FinTech son contratos que siguen el constructo legal que todos conocemos.** Mientras que en DeFi esos contratos son establecidos iguales para todos, el corazón de una DeFi y sus servicios son los Smart Contracts en Blockchain que podemos ver y auditar libremente. 
3. **Las decisiones de aprobación de una FinTech están atadas a una cadena burocrática, larga o corta, eso significa tiempo que como usuarios perdemos esperando una respuesta a nuestras solicitudes.** Por otro lado, en una DeFi la cadena se reduce entre tú y la persona que te dará el crédito. En ocasiones, la cadena ni siquiera existe, porque la aprobación se realiza de forma automática si cumples o excedes los requisitos que la plataforma pide para acceder a sus servicios.
4. **Una FinTech usa bancos y toda la estructura de finanzas tradicionales para hacerte llegar los recursos que pides.** Eso significa que sí o sí, necesitas ser alguien bancarizado y con registro en el sistema para participar con ciertas garantías. También significa que ese dinero puede ser censurado o limitado si así lo desean. En DeFi, esto no es algo que deba preocuparte. No necesitas tener cuenta bancaria, solo una wallet de criptomonedas donde recibir tus fondos y el resto tienes libertad.

**Ante esta visión queda bastante claro que una FinTech es un ente financiero digitalizado.** Algunos proyectos FinTech bien reconocidos a nivel mundial son Coinbase, Revolut o Paypal, por nombrar solo algunos.

![](https://files.cdn.thinkific.com/file_uploads/636320/images/90e/07b/d5d/defi_vs_finhtech-01.png)

####  Potenciales casos de uso del DeFi
¿De qué nos sirven las DeFi en la actualidad? ¿Cuáles son sus usos? En primer lugar: las DeFi nos sirven de puente financiero entre la riqueza de los tenedores de criptomonedas y un mundo de servicios financieros que pueden otorgarse haciendo uso de esa riqueza para generar -a su vez- más riqueza con ella. 

Dicho esto, entre los potenciales casos de uso de DeFi podemos mencionar:
1. **Sistemas de lending descentralizados:** Es uno de los principales casos de uso de las DeFi en la actualidad. El sistema es sencillo: **si una persona desea un préstamo y quiere usar de colateral o garantía sus criptomonedas puede hacerlo sin problemas.** El sistema funciona de forma muy similar a las FinTechs o finanzas tradicionales. **Pero DeFi suele ofrecer mejores condiciones de interés y generalmente los préstamos suelen aprobarse casi de forma instantánea.** Atrás quedan las horas en el banco, el enviar documentos digitales y esperar días para una respuesta, con DeFi basta interactuar con la DApp, realizar el depósito de garantía exigido y tendrás en tu poder el dinero que has requerido en préstamo y todo en unos minutos. 
2. **Mercados descentralizados:** Otro caso de uso de las DeFi son los mercados descentralizados. Creaciones como los exchanges descentralizados (DEX), los pools de inversiones, derivados financieros, sistemas de stakings, mercados de predicción, y más son posibles gracias al DeFi. 
3. **Sistemas de pagos:** Otro uso que se le da a las DeFi es el de sistemas de pagos. Las características de estas plataformas les permite ser un puente de confianza para procesar pagos de distintas Blockchain haciendo uso de una infraestructura externa, descentralizada y autónoma. 
4. **Servicios bancarios y de seguro:** Otro uso de las DeFi es la de ofrecer servicios del tipo “bancario” sin ser exactamente un banco. Por ejemplo, hay protocolos DeFi que permiten a sus usuarios realizar una determinada inversión. Pero al cabo de un tiempo, puedes recibir dicha inversión con un margen de ganancia, y todo gracias a los intereses que la misma ha generado. Pero no solo eso, sino que también hay sistemas que permiten la emisión de monedas estables (stablecoins), así como sistemas de identificación digital y de seguros financieros. 

En este punto es claro que el potencial de las DeFi para ofrecer servicios y soluciones es variado, tan variado como la inventiva de las personas que desarrollen dichos sistemas. 

####  Riesgos a tener en cuenta en el mundo DeFi
En DeFi no todo es perfecto. Existen riesgos que es bueno conocer antes de entrar de lleno en este mundo. Entre ellos podemos mencionar:

#####  Contratos y plataformas complejas de entender y usar
**El DeFi no es para todo el mundo,** por mucho que quieran hacer ver lo contrario. Si entras a una DApp DeFi e intentas realizar una operación, seguramente verás que en medio de todo eso hay conceptos que para una persona promedio pueden parecer extraños. No solo eso, los contratos de DeFi y explicaciones de la web de la aplicación, así como el Smart Contract de dichas aplicaciones, puede parecer una lengua perdida del mundo para la mayoría de las personas. 

Dicho esto, es bueno que seas consciente de que, si bien DeFi ofrece enormes posibilidades, debes en primer lugar saber en qué estás participando e invirtiendo, y eso pasa por aprender y comprender qué es lo que hace la plataforma, como lo hace y qué herramientas tienes a disposición. Todo ello con el fin de evitar situaciones penosas como la pérdida de tu inversión.

#####  Una descentralización incompleta
Las aplicaciones DeFi si bien se ejecutan en una Blockchain como Bitcoin, Ethereum, EOS o TRON, esto no significa que las mismas sean plenamente descentralizadas. 

Generalmente, los protocolos y aplicaciones DeFi tienen algún punto de centralización que les permite tener un determinado grado de control para situaciones en las que se amerite intervención inmediata. Un ejemplo de esto es MakerDAO y su stablecoin DAI. 

**Si bien MakerDAO funciona como una entidad descentralizada, las figuras detrás del desarrollo del protocolo tienen lo que podría llamarse un “Botón de Pánico” llamado “Emergency Shutdown”.** **Esta funcionalidad del protocolo permite cerrar todo el funcionamiento de MakerDAO y DAI para evitar que los inversores sufran pérdidas graves por algún problema en la colateralización del protocolo.** Puedes imaginar que, así como hay funciones como estas en MakerDAO, el resto de proyectos también tendrá una función parecida e incluso mayor. 

Pero, ¿Por qué esto es un riesgo? Si lo piensas un poco, funciones como estas pueden ser aprovechadas por actores maliciosos dentro y fuera del protocolo para causar daño dentro del mismo. También es un riesgo porque muchos DeFi se venden como una panacea de descentralización, cuando la realidad es muy distinta. Un problema que se agrava si añadimos la aparición de protocolos DeFi que no son más que una estafa de libreto. 

**En pocas palabras, conoce bien el proyecto donde participas, conoce sus funciones, pero sobre todo conoce la comunidad que lo mantiene. Una comunidad transparente no ocultará nada,** como el caso de MakerDAO que hicieron pública la información sobre “Emergency Shutdown” y las razones para su creación. Si sospechas de algo como eso, mantente alerta, en especial con proyectos nuevos y poco conocidos. 

#####  La seguridad no es infalible
Es cierto que la seguridad en Blockchain es excelente, también es cierto que esta no es infalible. 

El mejor ejemplo de esto lo vemos en los varios proyectos DeFi que han sufrido de problemas de seguridad relacionados con sus Smart Contracts y que han supuesto robos millonarios a sus plataformas. **Plataformas como dForce, Uniswap, Balancer, Bancor, bZx y  Synthetix, son solo algunas de las víctimas de los hacks más sonados en este sector.** 

El problema es más grave aún, porque la seguridad de los Smart Contracts depende de dos factores. En primer lugar, depende de la buena codificación y construcción de los mismos por parte de los desarrolladores del protocolo DeFi. Así un buen proyecto, codifica, revisa y audita sus Smart Contracts de forma constante. De esa forma, si detecta un error lo corrige rápidamente sin dilaciones. 

En segundo lugar, la seguridad también depende de la buena programación de las funciones que hacen posible su funcionamiento directo en la Blockchain. Por ejemplo, un problema de seguridad en una función de la EVM que afecte a estos Smart Contracts, y automáticamente la seguridad de los mismos está en peligro. **El problema con este último punto es que la seguridad ya no depende tanto del desarrollador del protocolo DeFi. En su lugar, depende de los desarrolladores Blockchain, y en caso de que no pueda ser mitigado correctamente, se tendrá un grave problema de seguridad.** 

Sí, suena a cuento de terror. Y que una tecnología que se asume ultra segura pueda tener estos problemas, sorprende. Sin embargo, son problemas reales, de hecho, la función DELEGATECALL de EVM, fue la causa de un ataque que se dio a las wallets de Parity en 2017. 

#####  El peligro de las estafas
Si has estado suficiente tiempo en el mundo cripto, seguramente recordarás el Boom de las ICO de 2017 y 2018. 

Y también sabrás lo que ello significó para muchos: pérdidas millonarias y estafas por doquier. En este punto, **las DeFi están comenzando a pasar por el mismo proceso. De hecho, hay cientos de proyectos que se disfrazan de DeFi para estafar a quienes caen en la trampa de hacer dinero fácil y rápido.**

De hecho, en medio del boom DeFi, que está de moda, no es raro ver como las plataformas buscan la forma fácil de desarrollar sus ideas. **Un ejemplo de esto lo vemos en dForce, quienes simplemente copiaron el protocolo de Compound (versión 1) para lanzar su plataforma.** **Como resultado, la plataforma dForce cayó víctima de un problema de seguridad que no detectaron y tuvieron grandes pérdidas.**

Como esta situación muchas más pueden darse: copiar un Smart Contract, cambiar algunas cosas y lanzar un servicio con el único fin de estafar a quienes caigan en la trampa. Es algo que sucede más a menudo de lo que piensas y una de las razones por la que debes estar muy atento cuando entras al mundo DeFi.

####  Plataformas DeFi en la actualidad
En la actualidad, el desarrollo de las plataformas DeFi es gigantesco. Bitcoin y Ethereum recogen las más grandes e importantes. Solo entre estos dos proyectos ya el 70% de la capitalización de las criptomonedas es controlado, eso son casi 200 mil millones de dólares.

Eso ha atraído a muchas empresas a empezar a explorar la creación de herramientas, DeFi, algunas con más éxito que otras, pero entre ellas podemos mencionar:
1. **Bisq:** Un protocolo de intercambio P2P construido especialmente para Bitcoin y completamente descentralizado.
2. **RSK:** Un protocolo y conjunto de servicios identificados como RIF OS, una plataforma de desarrollo completa que incluye Smart Contracts, identidad digital, almacenamiento descentralizado, pagos instantáneos, puentes cross-chains, sistema de pago integrado, comunicaciones descentralizadas y generación de mercados descentralizados.
3. **0x:** un protocolo para la construcción de intercambios descentralizados P2P que funciona sobre Ethereum. 
4. **Bancor:** Un sistema de intercambio de tokens construido sobre Ethereum.
5. **Compound:** Un protocolo de pool de inversiones con opciones de lending, yield farming, liqidity mining que ha tomado gran relevancia durante 2020 hasta el punto de desplazar por dos semanas a MakerDAO como la DeFi de mayor valor.
6. **Kyber:** Un protocolo de swap para integrar funcionalidades de intercambio en aplicaciones con operaciones cross-chain.
7. **MakerDAO y DAI, una DAO:** Una stablecoin diseñada para facilitar la creación de aplicaciones financieras construida sobre Ethereum.
8. **Augur:** Un protocolo para la creación de mercados de predicción.
9. **Curve:** Un DEX de stablecoins.

**Esta es una pequeña lista de algunas de las aplicaciones DeFi más importantes que existen en la actualidad.** Nombrarlas todas sería una tarea titánica debido a la diversidad de herramientas que existen en la actualidad. Pero las acá mencionadas se han ganado un sitial de honor debido a su seriedad, compromiso y desarrollo activo. Ante esto no queda duda que las DeFi y sus distintas aplicaciones serán cada vez más importantes en el futuro. Después de todo, apenas estamos explorando estas herramientas y reconociendo su alcance.

###  CeFi vs DeFi (Video)
![[230.B4_CeFi_vs_DeFi.mp4]]
[CeFi vs DeFi](https://app.web3mba.io?wvideo=x9t8x7c9qq)

Vamos a comparar ambos modelos. Las CeFi pueden parecer un poco similares a las finanzas tradicionales, ya que son finanzas centralizadas, pero veremos las diferencias entre ambos. Como mencionamos anteriormente, las finanzas descentralizadas, o DeFi, han crecido de forma explosiva en los últimos cinco años dentro del ecosistema blockchain. Esta realidad la conocemos gracias a los avances en blockchain y su capacidad para programar datos, así como a la posibilidad de crear servicios descentralizados, en contraposición a lo que las finanzas centralizadas nos permiten. Este es el punto en el que se diferencian.

Por eso, creo que es importante dedicar un momento a entender cuáles son las diferencias entre CeFi y DeFi. Escucharéis mucho sobre CeFi, así que prestad atención, esta parte es importante. ¿Qué es CeFi? En primer lugar, CeFi, o finanzas centralizadas, son aquellas aplicaciones o servicios financieros en los que los usuarios confían en personas para que administren los fondos y ofrezcan los servicios de manera adecuada. Estas son empresas centralizadas que garantizan el éxito de sus productos y el bienestar de sus clientes. Aunque estas compañías pueden utilizar algún tipo de dinero digital, aquí es donde se habla de CeFi y se diferencia de las finanzas tradicionales. Sin embargo, hay muy poca innovación en términos de estructura, que es uno de los elementos clave, como hemos visto en las DeFi.

Un buen ejemplo de CeFi serían los neobancos o fintechs dentro del mundo cripto, como BlockFi o Nexo. En contraposición, las DeFi son empresas o proyectos donde no existe un garante, ya que el servicio se ejecuta de forma descentralizada y todo lo que garantiza la seguridad es la plataforma desarrollada sobre la blockchain. En todo caso, los usuarios conocen esta realidad y la aceptan, lo que les permite realizar transacciones sin depender de una única autoridad centralizada, como podría ser una corporación. A raíz de esto, los usuarios pueden elegir entre un amplio abanico de servicios aquel que mejor se ajuste a sus necesidades. Un buen ejemplo de estos servicios descentralizados podría ser Aave, en el ámbito del lending descentralizado, o Uniswap, la principal bolsa descentralizada.

Sigamos diferenciando CeFi y DeFi. Existen tres aspectos esenciales para distinguir entre ambas, y estos elementos son, primero, la arquitectura. En este punto, CeFi tiene una arquitectura del servicio que está centralizada y depende de una serie limitada de elementos para su funcionamiento. Mientras que en DeFi, esta arquitectura es descentralizada y depende de un esquema de consenso. El funcionamiento, en todo caso, se mantiene y depende de estas estructuras. Por ejemplo, un neobanco presta servicios gracias a los servidores donde se aloja el servicio. La caída de esos servidores o el cierre de los mismos puede dejar al usuario sin acceso. En DeFi, aunque el sistema de control de la red puede verse afectado, la información no se perdería, ya que siempre habría nodos con una copia de la blockchain, con toda la información hasta ese momento. Además, si una web se cae, el protocolo sigue siendo accesible directamente desde la blockchain. Esta es una de las fortalezas de desarrollar un proyecto sobre la blockchain.

En segundo lugar, hablemos de la lógica. La lógica del servicio es la que permite que su funcionamiento sea sostenible. En un proyecto CeFi, la lógica del negocio permanece como un secreto empresarial, siendo conocida solo por las partes autorizadas. Mientras que en DeFi, esta lógica se desarrolla de forma pública y abierta, generalmente como desarrollos de software libre, lo que las hace totalmente transparentes. En CeFi, como mencioné, la lógica depende de las aplicaciones que se ejecutan en el servidor del servicio. En cambio, en DeFi, esta lógica depende de los smart contracts y la red blockchain sobre la que se ejecutan, contratos que son accesibles para cualquier persona.

Y en tercer lugar, hablemos de la gobernanza, como último punto en discordia. Aquí encontramos que se produce una separación de poderes por parte de la sociedad a la hora de ofrecer el servicio o decidir cuál es el servicio. En CeFi, la gobernanza es ejercida por sus directivos, que suelen ser un grupo muy reducido de personas, todas ellas con intereses en mantener el control. Pero en DeFi, la gobernanza puede extenderse no solo a los creadores, sino también a los usuarios del sistema. Por ejemplo, en CeFi, las decisiones sobre el funcionamiento dependen de sus inversores, mientras que en DeFi, esas decisiones pueden estar en manos de los propios usuarios. Incluso en los casos en los que la gobernanza es realmente abierta, lo común es que se puedan proponer cambios o mejoras para que el resto de la comunidad vote sobre su implementación.

Bien, hablemos de los usos para ambos, usos para DeFi y usos para CeFi. Tanto las DeFi como las CeFi pueden aplicarse a cualquier tipo de servicio financiero tradicional y relacionado con criptomonedas, como el comercio al contado, el comercio de derivados, préstamos, entre otros. Lo que hemos comentado anteriormente en cuanto a casos de uso que se aplican a las DeFi también podría aplicarse a las CeFi, con las diferencias ya mencionadas. Las conversiones entre criptomonedas y monedas fiat también están disponibles en ambos ecosistemas. Además, ambas plataformas, DeFi y CeFi, pueden brindar servicios entre cadenas, aunque los mecanismos aquí varían. En general, ambas tendencias tienen usos similares, pero el enfoque es muy distinto.

Un aspecto específico de DeFi es la tokenización de activos. Por poner un ejemplo, Synthetix aloja un ecosistema DeFi donde los usuarios pueden crear los llamados activos sintéticos, que son tokens ERC20 o RC20 que representan activos en el mundo real. Los usuarios pueden eventualmente liquidar esos activos sintéticos y comerciarlos en un exchange dedicado. Los activos sintéticos tienen un gran potencial y beneficios que pueden permitir en el futuro. Este tipo de activos, como mencioné, nacen gracias a la descentralización y la capacidad de los sistemas DeFi de innovar, algo que es mucho más lento y complicado de comprender en los sistemas CeFi.

###  CeFi vs DeFi, comparativa entre ambos modelos
Las finanzas descentralizadas (DeFi) han crecido de forma explosiva en los últimos cinco años dentro el ecosistema Blockchain.

Esto ya es una realidad, gracias a la tecnología Blockchain. Su capacidad de programación y la posibilidad de crear servicios descentralizados, en contraposición a los que las finanzas centralizadas (CeFi) nos permiten.

En este punto nos podemos preguntar ¿Qué es CeFi y cuáles son las diferencias entre CeFi y DeFi?

####  ¿Qué es CeFi?
CeFi o finanzas centralizadas, son aquellas aplicaciones o servicios financieros en los que los usuarios confían en las personas para que administren los fondos y lleven los servicios de manera correcta. 

Estas son empresas centralizadas que son los garantes del éxito de sus productos y del bienestar de sus clientes. Aunque estas compañías pueden estar utilizando un nuevo tipo de dinero digital, hay muy poca innovación en términos de estructura, que es uno de los elementos clave de las DeFi. **Un buen ejemplo de CeFi, serían los neobancos o fintechs como Celsius, BlockFi o Nexo.**

> Las DeFi son empresas o proyectos donde no existe un garante, ya que el servicio se ejecuta de forma descentralizada y todo lo que garantiza la seguridad es la plataforma desarrollada sobre Blockchain. 

En todo caso, los usuarios conocen esta realidad y la aceptan, con lo que pueden realizar transacciones sin depender de una única autoridad centralizada, como una corporación. El resultado de esto es que los usuarios tienen libertades mayores a la hora de decidir qué hacer con sus activos digitales. **Un buen ejemplo de estos servicios son AAVE o Uniswap, cuyo funcionamiento es descentralizado.**

####  Diferenciando CeFi y DeFi
Encontramos que existen tres aspectos esenciales para diferenciar entre CeFi y DeFi, y estos elementos son:
1. **Arquitectura.**  
    **En este punto, CeFi tiene una arquitectura del servicio que está centralizada y depende de una serie limitada de elementos para su funcionamiento. Mientras que en DeFi, esta arquitectura es descentralizada y depende de un esquema de consenso.** El funcionamiento en todo caso se mantiene y depende de estas estructuras. Por ejemplo, un neobanco presta servicios gracias a los servidores donde se aloja el servicio, la caída de esos servidores deja al banco sin acceso. Sin embargo, en DeFi esto no es un problema, la red es tan amplia que la caída de uno o varios nodos no tiene ningún impacto. El sistema seguirá funcionando sin contratiempos. 
2. **Lógica.**  
    La lógica del servicio es la que permite que su funcionamiento sea sostenible. En proyecto CeFi, la lógica de negocio permanece como un secreto empresarial siendo conocido solo por las partes autorizadas para ello. Mientras que e**n DeFi, esta lógica se desarrolló de forma pública y abierta** (generalmente siendo desarrollos software libre) lo que les hace transparentes. En CeFi, la lógica depende de aplicaciones que son ejecutadas en el servidor del servicio, mientras que en DeFi, esta lógica depende de los smarts contracts y la red Blockchain sobre la que se ejecutan dichos smart contracts.
3. **Gobernanza.**  
    En este punto es donde se produce una separación de poderes del servicio. En CeFi, la gobernanza es ejercida por sus directivos, un grupo muy reducido de personas, todas ellas con intereses en mantener el mismo. Pero **en DeFi, la gobernanza se extiende no solo a los creadores sino también a los usuarios del sistema.** Por ejemplo, en CeFi las decisiones sobre el funcionamiento del mismo depende de sus inversores, pero en DeFi, esas decisiones se toman en general por consenso de todos los participantes interesados en formar parte de la gobernanza del protocolo, dejando que cada participante tenga poder de voto para decidir.

####  DeFi vs CeFi: Usos
Tanto las DeFi como las CeFi pueden aplicarse a cualquier tipo de servicio financiero tradicional y relacionado con criptomonedas, como comercio al contado, comercio de derivados, préstamos y más.

**Las conversiones entre criptomonedas y monedas fíat también están disponibles en ambos ecosistemas. Además, las dos plataformas, CeFi y DeFi, pueden brindar servicios entre cadenas, aunque los mecanismos varían.**

En general, las dos tendencias tienen usos similares, pero el enfoque es muy distinto. Un aspecto específico para DeFi es la tokenización de activos. Por ejemplo, Synthetix aloja un ecosistema DeFi donde los usuarios pueden crear los llamados activos sintéticos, que son tokens ERC-20 que representan activos en el mundo real. Los usuarios pueden eventualmente liquidar esos activos sintéticos y comerciarlos en un exchange dedicado. Los activos sintéticos tienen un gran potencial, capaz de hacer el comercio de derivados más flexible, accesible y transparente.

###  El futuro del DeFi (Video)
![[232.B4_Futuro_del_DeFi.mp4]]
[Futuro del DeFi](https://app.web3mba.io?wvideo=2xvmh40ctu)

En esta sección vamos a hablar un poco sobre el futuro, pero realmente no deberías hacerme demasiado caso. DeFi se mueve a una velocidad vertiginosa y lo que voy a comentar ahora son cosas que estamos observando y el posible futuro que veremos en los próximos meses y años. Sin embargo, realmente nadie vio venir lo que se convirtió en DeFi. Nadie esperaba sistemas como SushiSwap, por ejemplo. ¿Quién iba a pensar que se crearía una bolsa descentralizada que sería especialmente épica en dimensiones y cuya estética sería la del sushi? Nadie podía imaginar esto. Lo mismo ocurre con PancakeSwap; ¿quién iba a imaginar un pancake como la imagen de una bolsa? Por lo tanto, no sabemos hacia dónde va a evolucionar esto, ni hacia dónde nos llevará DeFi. El futuro es algo que la comunidad de personas de cualquier parte del planeta va a crear. Lo que funcione, se seguirá haciendo, y lo que no, se dejará de hacer. Pero, bueno, hablemos un poco de lo que podría ser el futuro.

Las finanzas descentralizadas se han transformado en una de las grandes innovaciones de la industria blockchain y de las empresas que forman parte de este ecosistema. Esta tecnología no solo plantea una alternativa a las instituciones financieras tradicionales, sino que también revoluciona toda la industria financiera, habilitando servicios que de otra manera no serían posibles. Esta evolución es especialmente visible en redes como Ethereum, Polygon, Avalanche, Solana e incluso en las segundas capas de estos servicios. En todos ellos, la evolución ha sido enorme. De hecho, en DeFi Llama, por ejemplo, podemos ver en este gráfico cómo ha sido el crecimiento en TBL, que significa Total Value Locked, es decir, la cantidad de dinero depositada en estos sistemas.

Recordemos un momento los sistemas de lending descentralizado. Estos sistemas, que funcionan como bancos cripto, permiten que las personas depositen dinero, y gran parte de este dinero se almacena allí. Otro lugar donde se deposita mucho dinero es en las pools que crean los mercados, esos mercados descentralizados que mencionaba antes, en los cuales hay dos activos: un dólar digital, normalmente, y un token que puede ser Ethereum o cualquier otro. Bien, pues ese TBL, como vemos en el gráfico, fue de 253.000 millones de dólares en noviembre de 2021, y la tendencia ha sido claramente alcista. De hecho, observamos que desde 2019 a 2021, la línea es prácticamente vertical.

Podemos ver de cerca la evolución de los distintos proyectos DeFi observando en esta otra gráfica los 10 proyectos más grandes del ecosistema y su participación en el mismo. La mayoría de ellos son proyectos que son parcialmente descentralizados y que han formado parte de este ecosistema desde 2017, algunos también desde 2019. En estos 10, podemos ver lo que hoy se encuentra entre los principales proyectos dentro de DeFi. Estos datos, tanto el TBL como los principales proyectos, nos dejan claro otro punto: DeFi era una serie de plataformas separadas, pero a medida que la interoperabilidad entre cadenas se va manifestando, y esos bloques de Lego se van conectando, lo que encontramos es que las diferentes plataformas DeFi se han ido integrando.

En esta nueva era, la estrategia del yield farming agregado y cross-chain, es decir, entre diferentes cadenas, ha sido fundamental, permitiendo que los ecosistemas interactúen financieramente, trasladando valor entre unas cadenas y otras e incrementando su potencial de crecimiento. Hablemos del auge de las DeFi 2.0. La llegada de las DeFi 2.0 revolucionó rápidamente la industria a lo largo de 2021. Esta versión mejorada del concepto DeFi actual ha abordado las principales debilidades existentes, al tiempo que aprovecha sus fortalezas para presentar a los usuarios nuevas y emocionantes alternativas en el camino hacia la tan ansiada independencia financiera.

A diferencia de la versión anterior de DApps o aplicaciones descentralizadas, que estaba orientada a los usuarios, DeFi 2.0 está más dirigida a un enfoque B2B, Business to Business. Los protocolos DeFi 2.0 aprovechan el hecho de que la primera generación de DApps impulsó con éxito a la industria al crear una base de usuarios inicial y proporcionan un feedback de valor incalculable que los futuros desarrolladores pueden utilizar para construir la próxima ola de DApps, con el objetivo de asegurar la supervivencia a largo plazo del sector. Es en este punto cuando las DeFi comenzaron a desarrollar mecanismos de gobernanza avanzados, comercio delegado y listados en CoinGecko y CoinMarketCap. Estas plataformas no solo han impulsado el mundo hacia DeFi 2.0, sino que también han marcado el camino para la revolución DeFi 3.0.

Hablemos un momento de DeFi 3.0. Actualmente, este modelo de DeFi, esta nueva versión, representa la próxima evolución de DeFi que está en construcción. En este punto, DeFi busca convertirse en un espacio de servicios. Básicamente, busca que el concepto de DeFi transforme su ecosistema en un servicio. Por ejemplo, el Farming as a Service. La idea es transformar a las DeFi en un servicio accesible y personalizable a las necesidades de sus usuarios. Esto significa que el usuario no tiene que encontrar el protocolo y participar directamente, sino que habrá un servicio que le permita hacer esto con las garantías que ofrece un tercero.

A través de su enfoque DeFi 3.0, varios proyectos están creando las bases para el éxito de todo el ecosistema. Su intención es establecer un ecosistema que revolucione los sistemas financieros tradicionales, manteniendo el objetivo inicial de las DeFi. Con la ayuda de los contratos inteligentes, se busca permitir que los usuarios tengan un control absoluto sobre los servicios financieros, con la seguridad que brindan esas terceras partes, y también se permitirá el comercio en el ámbito de las finanzas descentralizadas. En resumen, se están simplificando las inversiones estratégicas al agregar las recompensas a los titulares de tokens a través de recompras y otros mecanismos financieros. Su objetivo final sería otorgar al titular del token los derechos de propiedad y el control sobre todas las decisiones de inversión relacionadas con el proyecto en cuestión.

La idea sería lo que hemos estado hablando sobre la evolución hacia DeFi 2.0, pero esta vez ofrecida por un tercero que simplifica toda la operativa. Por si, como decía al principio, no eres una persona que se sienta cómoda trabajando con este tipo de ecosistemas descentralizados. Así que, en definitiva, tú decidirás si te diriges directamente a lo que pueden ser estas DeFi 3.0, que esperamos que sean la nueva evolución de DeFi, donde un tercero simplifica el proceso por ti, o si te sientes más aventurero y prefieres explorar DeFi 2.0, donde tendrás que involucrarte más y probar los sistemas por ti mismo.

Mi recomendación aquí sería, bueno, la de ir directamente a DeFi 2.0, probar un poco, dedicar algo de tiempo y, sí, posiblemente un poco de dinero, pero muy poco, simplemente para ver cómo funciona y así adquirir ese conocimiento de primera mano. Pero si ves que todo esto te supera, podemos esperar a ver qué nos traen las DeFi 3.0. Sin embargo, como he mencionado antes, no sabemos si las DeFi 3.0 acabarán siendo así. El futuro ya se verá.

###  El Futuro del DeFi
Las finanzas descentralizadas (DeFi) se han transformado en una de las grandes innovaciones de la industria Blockchain y las empresas que forman parte dentro del mismo. 

Esta tecnología no solo plantea una alternativa a las instituciones financieras tradicionales, sino también revolucionar toda la industria financiera habilitando servicios que de otra manera no podrían ser posibles.

Esta evolución es especialmente visible en redes como Ethereum, Polygon, Avalanche y Solana, donde la evolución de las DeFi ha sido enorme. De hecho, en DeFiLlama podemos seguir muy de cerca esa evolución, detectando que, en noviembre de 2021, el mercado tuvo un TVL de 253 mil millones de dólares, y la gráfica muestra el crecimiento enorme que ha tenido el sector desde el año 2019.

![[233.B4_crecimiento.png]]

De hecho, podemos ver muy de cerca la evolución de los distintos proyectos DeFi, teniendo que los 10 proyectos más grandes del ecosistema y su participación en el mismo. La mayoría de ellos son proyectos DeFi totalmente descentralizados y que han estado formando parte del ecosistema desde 2017, siendo algunos del 2019, durante el boom DeFi. 

![[233.B4_boom.png]]

**Estos datos nos dejan claro otro punto: DeFi en un principio era una serie de plataformas separadas, pero a medida que la interoperabilidad entre cadenas (gracias a los _bridges cross-chain_) fue aumentando, las plataformas DeFi se fueron integrando.** En esta nueva era, la estrategia del Yield Farming agregado y Cross-Chain fue fundamental, permitiendo que los ecosistemas pudieran interactuar financieramente trasladando valor entre las cadenas e incrementando su potencial de crecimiento. Este es el inicio de las DeFi 2.0

####  El auge de las DeFi 2.0
La llegada de las DeFi 2.0 ha conquistado rápidamente las industrias.

Esta versión mejorada del concepto DeFi actual ha abordado las principales debilidades existentes al tiempo que aprovecha las fortalezas para presentar a los usuarios alternativas nuevas y emocionantes en el camino hacia la independencia financiera.

**A diferencia de la versión anterior de dApps, que estaba orientada a los usuarios, DeFi 2.0 está más orientada a un enfoque B2B (_Business-to-Business_).**

Los protocolos DeFi 2.0 aprovechan el hecho de que la primera generación de dApps impulsó con éxito la industria al crear una base de usuarios inicial y proporcionar primitivas críticas de DeFi que los futuros fabricantes ahora pueden utilizar para construir la próxima ola de dApps. Y el objetivo de esto es asegurar la supervivencia a largo plazo del sector.

Es durante este punto, cuando las DeFi comenzaron a desarrollar mecanismos de gobernanza avanzados, comercio delegado y listados de CG y CMC, la plataforma no solo ha impulsado el mundo DeFi 2.0, sino que también ha marcado el camino para la revolución DeFi 3.0.

####  DeFi 3.0: El nuevo futuro de las DeFi
Las DeFi 3.0 son la próxima evolución de las DeFi en construcción. 

En este punto, DeFi busca convertirse en un espacio de servicios. 

Básicamente, busca el concepto de DeFi transforme su ecosistema en un Servicio (por ejemplo: Farming-as-a-Services / FaaS). La idea es transformar a las DeFi en un servicio accesible y personalizable a las necesidades de sus usuarios.

**A través de su enfoque DeFi 3.0, el proyecto está creando las bases para el éxito de todo el ecosistema. La intención del proyecto es establecer completamente un ecosistema para interrumpir los sistemas financieros tradicionales.** Con la ayuda de los contratos inteligentes, el proyecto quiere permitir que los usuarios tengan un control absoluto sobre la funcionalidad principal y el comercio en el ámbito de DeFi.

En resumen, están simplificando las inversiones estratégicas al agregar las recompensas a los titulares de sus tokens a través de recompras y reflejos. Su objetivo final sería otorgar al titular de la ficha los derechos de propiedad y el control sobre todas las decisiones de inversión relacionadas con el proyecto.


## U7. Metamask
###  Metamask (Video)
![[234.B4_Metamask.mp4]]
[Metamask](https://app.web3mba.io?wvideo=f53d91fctk)

Metamask es el puente que permite a los usuarios interactuar con Web3. Web3 abarca todas estas aplicaciones descentralizadas que forman parte de las redes blockchain. Metamask es un tipo de wallet HD, es decir, "hierarchical deterministic". Este tipo de wallets permite al usuario generar varios tipos de wallets, distintas e ilimitadas, y acceder a ellas a través de una única contraseña. Esta contraseña es una cadena de caracteres alfanuméricos que resulta ilegible para el ser humano. Para facilitar su uso, se emplean códigos mnemotécnicos, que transforman esta cadena de caracteres en palabras que sí son legibles. Comúnmente, se conoce a Metamask como una wallet, pero en realidad es un llavero.

Para entenderlo mejor, imagina un llavero que tenemos con las llaves de casa, por ejemplo, donde tendríamos la llave del patio, la llave de la puerta principal o incluso la llave del garaje. Todas estas llaves, que representan las wallets, están unidas por una anilla, que es lo que las convierte en un llavero. Y eso es, en esencia, Metamask: un llavero de cuentas que puedes generar dentro de la aplicación. Esta aplicación está disponible en formato de extensión para navegadores, inicialmente en Chrome y más tarde en Firefox, Opera, Brave y Edge. El desarrollo de Metamask estuvo a cargo de dos desarrolladores, Aaron Davis y Dan Finlay, quienes sentaron las primeras bases del proyecto en 2016. La idea detrás de Metamask era sencilla y revolucionaria: permitir a los usuarios utilizar su navegador web para interactuar de manera fácil, rápida y segura con sus dApps.

Para ello, Metamask utiliza la interfaz y API web de Ethereum, web3.js. Esta librería oficial de Ethereum es fundamental para las posibilidades que ofrece Metamask. Gracias a ella, se puede crear un proxy o puente de comunicación entre las dApps, Metamask y los usuarios. El trabajo resultó ser un gran reto técnico, especialmente en lo que respecta a mantener la seguridad necesaria para sus usuarios. Sin embargo, Metamask logró su objetivo y el 14 de julio de 2016 se presentó su primera versión. En ese momento, la extensión estuvo disponible para el navegador Chrome y sus derivados. Posteriormente, se lanzó la versión para Firefox, permitiendo el uso de la extensión en ese navegador. Desde entonces, Metamask se ha convertido en la forma más fácil de acceder a las dApps a través de una interfaz amigable, sin necesidad de configurar nada.

¿Cómo funciona Metamask? Su funcionamiento se basa en el uso de Web3.js, una librería que forma parte del desarrollo oficial de Ethereum. Web3.js fue creada para permitir la creación de aplicaciones web que puedan interactuar con la blockchain de Ethereum. Gracias a esta librería, páginas web y extensiones pueden aprovechar el poder de Ethereum y sus características. Técnicamente, lo que hace Metamask una vez que lo tienes instalado como extensión en el navegador es inyectar un código en cada página web que visitas. Este código actúa como una sonda que pregunta: "¿Hay alguien que me entienda? ¿Hay alguien que sepa quién soy?".

Cuando accedes a una web que es una dApp, esta ya está interactuando con el smart contract que actúa como servidor de la aplicación. En ese momento, la web responde a la sonda lanzada por Metamask y le dice: "Sí, yo te entiendo, vamos a interactuar". Así se establece la conexión entre la web a la que has accedido y la wallet de Metamask, permitiéndote utilizar la aplicación, ya sea para enviar transacciones o realizar otras interacciones que tenga el smart contract. Como mencionamos antes, las wallets HD son una de las aplicaciones más accesibles en el mundo. Además de permitir la conexión a la web, también facilitan el acceso a través de dispositivos móviles.

Es importante destacar que esta cadena alfanumérica se transforma en palabras legibles mediante códigos mnemotécnicos, y estos códigos son la clave para desencriptar el almacenamiento de información que contiene todas las wallets que hayas creado. A menudo, en foros de internet, hay usuarios que cambian de una wallet a otra en diferentes ordenadores o después de haber eliminado la extensión. Al recuperar su cuenta de Metamask con su passphrase, que es esta cadena de palabras legibles, descubren que tienen todos sus fondos disponibles. Esto genera la confusión de que, si han transferido los fondos, estaban teóricamente en su ordenador y ahora están disponibles en otro, lo que sugiere que se han sincronizado con algún servidor externo.

Sin embargo, esto no es cierto. Cuando un usuario cambia de wallet de un navegador a otro o a otro ordenador, la passphrase que utiliza para recuperar la cuenta es todo el almacenamiento de información que contiene todas las wallets, es decir, el llavero mencionado anteriormente. Una vez que introduces esa passphrase, que es el contenido del llavero, se te pedirá la clave para desencriptar esa passphrase. Por eso, siempre tendrás todos los datos localmente y podrás moverlos de un dispositivo a otro sin necesidad de que estén sincronizados con un servidor centralizado.

Metamask se puede utilizar principalmente para dos tipos de operaciones: transacciones de Ethereum entre dos wallets y las interacciones con los smart contracts o dApps, que son la parte visible de esos smart contracts. Cuando accedes a Metamask para realizar una transacción de wallet a wallet, como en el primer caso, Metamask tiene por defecto sus proveedores seleccionados, que son Infura y Etherscan. Estos son los nodos con los que se conectará Metamask para realizar las transacciones que intentas hacer desde la extensión. Al mismo tiempo, en la segunda opción, cuando interactúas con una web y esta envía órdenes a la extensión de Metamask para que firmes esas transacciones, si la web no tiene preferencias de nodos, Metamask utilizará sus proveedores por defecto. Sin embargo, la web puede sobrescribir esos proveedores por defecto redirigiendo las operaciones que firmes desde tu wallet hacia otros nodos, otras redes de nodos, entre los que también se encuentran Infura y Etherscan, que son los más utilizados, además de otras redes.

###  Metamask
MetaMask es una extensión o plugin para navegadores web que permite a los usuarios interactuar fácilmente con las dApps de la Blockchain de Ethereum.

Esto es posible, porque MetaMask hace de puente entre las dApps y los navegadores web facilitando el uso y disfrute de las mismas.

Gracias a esto, los usuarios son capaces de utilizar de forma sencilla dichas aplicaciones distribuidas y todo de forma integrada desde su navegador favorito. Con soporte para Firefox, Chrome, Opera y Brave, MetaMask ha acercado el mundo de las dApps al público en general.

El desarrollo de MetaMask estuvo a cargo de dos desarrolladores, Aaron Davis y Dan Finlay. Fueron ellos quienes sentaron las primeras bases del desarrollo de MetaMask en el año 2016. **La idea detrás del proyecto era sencilla y revolucionaria. MetaMask permitiría a los usuarios usar su navegador web para interactuar fácilmente con sus dApps favoritas, de forma rápida y segura.**

Para ello, MetaMask usaría la interfaz y API web de Ethereum, web3.js. Esta librería oficial de Ethereum sería la base fundamental del mundo de posibilidades ofrecidas por MetaMask. Gracias a ella sería posible crear un proxy o puente comunicacional entre las dApps, MetaMask y los usuarios.

![[235.B4_puente.png]]  

**El trabajo resultó ser todo un reto técnico, en especial por el tema de mantener la seguridad necesaria para sus usuarios. Sin embargo, MetaMask logró su cometido y el 14 de julio de 2016 se presentó su primera versión.** En este punto, la extensión estuvo disponible para el navegador Chrome y derivados. Más tarde se presentaría su versión para Firefox, permitiendo el uso de dicha extensión en ese navegador.

Desde entonces MetaMask se ha transformado en la forma más fácil de acceder a las dApps a través de una interfaz fácil de usar. Todo ello sin necesidad de configurar absolutamente nada.

####  ¿Cómo funciona MetaMask?
El funcionamiento de MetaMask es gracias al uso de web3.js, una librería que forma parte del desarrollo oficial de Ethereum. web3.js fue creada con el fin de permitir la creación de aplicaciones web que pudieran interactuar con la Blockchain de Ethereum.

Gracias a ella, páginas web y extensiones pueden aprovechar el poder de Ethereum y sus características.

**En tal sentido, MetaMask fue creada para ser un monedero del tipo HD para Ethereum y una herramienta para interactuar con dApps.** Para lograr ambos cometidos, MetaMask establece un canal de comunicaciones entre la extensión y la dApp en cuestión. Una vez que la aplicación reconoce que MetaMask está presente, se habilita y puede ser utilizada por el usuario.

> Habilitada la dApp, el usuario puede realizar todas y cada una de las acciones o eventos que permite la misma. Desde la compra o venta de tokens, hasta el acceso a recursos o cualquier servicio que preste la misma. 

Todas y cada una de estas acciones tiene un costo, uno que debe ser cancelado en Ethereum o en el token indicado para el mismo. En cualquiera de los casos, MetaMask cuenta con las herramientas necesarias para manejar dicha interacción.

**Es decir, MetaMask no solo genera un monedero de criptomonedas, sino que controla cada interacción del usuario con la dApp, y realiza las operaciones necesarias para que dichas operaciones se lleven a cabo.** Todo ello se lleva a cabo en un medio de comunicación seguro y con el uso de criptografía fuerte. MetaMask posee la capacidad de generar sus propias claves asimétricas, guardarlas localmente y gestionar su acceso. Incluso, MetaMask tiene la capacidad de usar nodos de Ethereum (del tipo Geth, por ejemplo) personales para garantizar mayor seguridad y privacidad en el uso, incluso es posible usar monedero hardware wallets para garantizar una mayor seguridad a nuestros fondos en dicho monedero. 

![[235.B3_web3js.png]]

####  ¿Cómo instalar MetaMask?
La instalación de MetaMask no implica mayores dificultades. Al ser una extensión para navegadores popular y probada, la misma se encuentra disponible en la tienda o repositorio de extensiones.

**Basta con acceder a la tienda de tu navegador y descargarla para usarla en tu navegador web de preferencia.**

En el caso de Chrome, podrás encontrarla aquí. En caso de que tengas un navegador derivado de Chrome como Opera, Brave o Vivaldi, dicha extensión funcionará perfectamente. Si en su lugar, utilizas Firefox, la extensión podrás encontrarla en este enlace. También puedes acceder a la extensión desde el sitio web oficial de MetaMask. Esta detectará tu navegador y te dirigirá al enlace correcto para la instalación de la extensión

En este caso, te advertimos de que tengas mucho cuidado con las extensiones que instales en tu navegador. Recuerda que existen muchos casos de suplantación de identidad (phishing) entre las extensiones por lo que se debe verificar muy bien lo que se instala. Para ello lo mejor es usar los medios oficiales y atender a las actualizaciones ofrecidas por la propia plataforma. Estas comprobaciones le permitirán disfrutar al máximo de tu experiencia con MetaMask.

####  Ventajas y desventajas de MetaMask
#####  Ventajas
1. **Creada con la librería web3.js lo que garantiza que podrás usar todo el poder de Ethereum.**
2. **Completamente software libre,** por lo que puede auditar su código y disfrutar de actualizaciones y parches de seguridad muy rápidamente.
3. **Capacidad de almacenar claves privadas** de forma local asegurando al máximo tus activos criptográficos.
4. **Permite la creación de monederos por medio de HD.** Esto ayuda a que los usuarios puedan realizar copias de seguridad de sus cuentas a través de las semillas.
5. **Permite el uso de varias cuentas y redes Ethereum** gracias a la creación de perfiles de uso.
6. Tiene un modo privado que **ofrece un alto nivel de seguridad** a los datos de sus cuentas, gracias al uso del EIP 1102.
7. **Permite mantener cualquier token ERC-20 en el mismo monedero.** De hecho, permite almacenar varios tokens ERC-20 al mismo tiempo.
8. **Tiene un alto nivel de integración con sitios** como Coinbase, ShapeShift o MyEherWallet para poder recargar el monedero de MetaMask.
9. **Permite el uso de nodos Ethereum remotos o locales**, permitiendo un alto nivel de seguridad en ambos casos.
10. Ofrece a nuestro navegador la capacidad de **interactuar con la mayoría de DApps.**
11. **Cuenta con protecciones internas** que bloquean casos de phishing u otros vectores de ataques que pongan en peligro sus fondos.

#####  Desventajas
1. **El hecho de que sea una extensión para navegadores significa que estos pueden rastrear toda la actividad de MetaMask.** Este es un caso especialmente cierto para Chrome, pues Google realiza una fuerte minería de datos de todos los usuarios de su navegador.
2. Pese a todas las protecciones de MetaMask, esta sigue siendo un monedero online con todas sus desventajas. **Una vulnerabilidad en la extensión o el navegador puede poner en peligro todos sus fondos.**
3. **MetaMask está limitado solo a interactuar con los Smart Contracts y Dapps que señalan.** No puede hacer mucho más como, por ejemplo, rehacer o escribir un nuevo Smart Contract.
4. **El hecho de depender de redes externas para su funcionamiento, agrega un punto de fallo en el esquema de seguridad.** La extensión puede ser segura, pero si los nodos no solo son, esto puede significar la pérdida o robo de información y fondos de los usuarios.

###  Instalación y configuración inicial de MetaMask
Se trata de una extensión para navegadores popular y probada. La misma se encuentra disponible en la tienda o repositorio de extensiones. 

De esta forma, basta con acceder a la tienda de tu navegador y descargarla para usarla en tu navegador web de preferencia.

En el caso de Chrome, podrás encontrarla aquí. En caso de que tengas un navegador derivado de Chrome como Opera, Brave o Vivaldi, dicha extensión funcionará perfectamente. Si en su lugar, utilizas Firefox, la extensión podrás encontrarla en este enlace. También puedes acceder a la extensión desde el sitio web oficial de MetaMask. Esta detectará tu navegador y te dirigirá al enlace correcto para la instalación de la extensión

En todo caso, ten mucho cuidado con las extensiones que instales en tu navegador. Recuerda que existen muchos casos de suplantación de identidad (phishing) entre las extensiones por lo que se debe verificar muy bien lo que se instala. Para ello lo mejor es usar los medios oficiales y atender a las actualizaciones ofrecidas por la propia plataforma. Estas comprobaciones le permitirán disfrutar al máximo de tu experiencia con MetaMask.

####  Proceso detallado de instalación y configuración
Dependiendo del navegador que utilices (Chrome, Edge o Firefox) es muy probable que con el paso anterior hayas instalado la extensión de MetaMask en el mismo. 

Ahora bien, aquí te guiaremos paso a paso en el proceso para que tengas tu MetaMask funcional al 100%. Este tutorial lo realizaremos sobre Firefox, pero es exactamente igual para el resto de navegadores.

#####  01| Comenzar con el setup del monedero
Realizada la instalación del monedero MetaMask verás una pantalla de bienvenida en la que debes hacer clic en “Empezar”.

![[236.B4_comenzar.png]]

#####  02|Crear un monedero
El siguiente paso te dará dos opciones:
1. **Importar un monedero:** En este caso, MetaMask te pedirá que uses Seed Phrase (o clave de respaldo) para recuperar un viejo monedero MetaMask que hayas tenido en posesión. Este proceso te restaura ese monedero y debes tener la Seed Phrase y la clave de ese monedero a la mano.
2. **Crear un monedero:** Para crear un nuevo monedero desde 0. Para este ejemplo elegiremos este paso.

![[236.B4_crear.png]]

#####  03|Aceptar las condiciones de uso de Metamask
En este punto MetaMask te hace saber que recolectan algunos datos que le son útiles para mejorar su monedero. Igualmente, te hacen saber que esos datos son anónimos y que no serán utilizados para rastrear tu actividad y mucho menos venderlos a terceros. En este punto, tienes la opción de “No aceptar” o “Aceptar”, en ambos casos, podrás configurar el monedero sin problemas.

#####  04|Crear la contraseña del monedero
Comienza lo realmente importante en la creación de nuestro monedero. Esta clave es la que permitirá que puedas desbloquear el monedero para su uso y de igual forma, es usada como entropía a la hora de crear el monedero. Todo esto significa que esta clave deber ser muy segura, por lo que te recomendamos usar claves alfanuméricas (con números y letras), con símbolos, mayúsculas y minúsculas, y con una extensión que no puede ser menor de 8 caracteres.

Un buen ejemplo de una clave con este tipo de opciones sería:
#*L45!Crypt0!50n!L1b3rt4d*#

En este caso hemos usado todas las opciones anteriores junto con una técnica de mnemotecnia para tener siempre presente nuestra clave segura en todo momento.

![[236.-B4_contraseña.png]]

#####  05|Respaldar la Seed Phrase
Creada nuestra contraseña, MetaMask comienza a generar nuestra Seed Phrase la cual debemos copiar de forma muy cuidadosa en un papel o cualquier medio seguro. Recuerda en todo caso lo siguiente:

La Seed Phrase y la contraseña del monedero son tu dinero, si las pierdes no podrás recuperarla, así que asegúrate de guardarlas en un lugar muy seguro.

![[236.B4_frase.png]]

Esta Seed Phrase deberás copiarla y luego MetaMask te pedirá que la confirmes para saber que ha sido copiada de forma correcta. Al confirmar la Seed Phrase entonces ya tendrás configurada tu MetaMask y podrás usarla sin inconvenientes con los ETH o tokens que desees.

Respaldando la seed con ello terminaría la configuración del monedero MetaMask.

![[236.b4_finalizacion.png]]

###  Tips de Seguridad para MetaMask
La seguridad del monedero es lo más importante para mantener tus criptomonedas seguras. Si eres un usuario de MetaMask, estos son algunos Tips para mantener la seguridad:
1. **Usa una clave segura para tu monedero,** no dejes el mismo sin esta, con el fin de que puedas garantizar que solo pueda ser accedido usando la clave correcta. 
2. **Usa el monedero MetaMask en un navegador distinto al navegador de uso diario.** Es decir, usa un navegador Web distinto para navegar y otro navegador para usarlo con las dApps y usar el monedero. 
3. **Si eres un usuario Windows o GNU/Linux, mantén tu monedero en una cuenta local distinta a la cuenta que normalmente usarías para las tareas diarias.** Este punto te ayudará a separar el acceso al monedero, de ser posible en una cuenta sin permisos administrativos y protegida con clave segura. Esto evitará que alguien pueda acceder a la cuenta y al monedero. 
4. **Si tienes un monedero hardware, usa el mismo para que controle clave privada de tu monedero MetaMask.** Esta medida de seguridad hará que puedas usar el monedero MetaMask como un monedero de visualización, pero si quieres realizar operaciones deberás usar el monedero hardware para la firma correspondiente.
5. **MetaMask es un monedero no-custodio y puedes configurar su acceso a la red usando tus propios nodos en lugar de los nodos de Infura/ConsenSys.** Si usas tus propios nodos, podrás usar MetaMask sin temor a que se te vete el acceso a la red Ethereum, y adicional, mantendrás tu acceso de forma más privada (ConsenSys/Infura mantienen un registro completo de todas tus operaciones).
6. **No olvides respaldar de forma segura tu seed phrase,** mantener el acceso a la misma asegura que puedas recuperar tu cuenta y el saldo en ella en cualquier momento. 
7. **Mantén el monedero limpio de “Sitios Conectados”.** Cada vez que MetaMask se conecta a una dApp, se genera una cierta apertura de permisos en el monedero, una práctica recomendable en este punto es, borrar esos permisos una vez termines de usar la dApp, así evitarás que cualquier actividad maliciosa pueda usar esos permisos para acceder al monedero.
8. **Mantén tu navegador libre de cookies o cualquier información temporal,** para ello, borra los temporales de tu navegador en cada sesión. 
9. **Agrega y usa los marcadores del navegador para ir directamente a los sitios de interés,** esto en lugar de acceder por los buscadores o enlaces que estén en sitios de terceros.


## U7. Práctica 
###  Iniciación a Metamask (Video)
![[238.B4_Iniciación_a_Metamask.mp4]]
[Iniciacion a Metamask](https://app.web3mba.io?wvideo=y38ekvssmy)

Uno de los monederos más útiles dentro del mundo cripto es, sin duda, MetaMask. MetaMask es un monedero que puede ser utilizado dentro de la red de Ethereum y redes compatibles con la Ethereum Virtual Machine. En este caso, es fácil instalarlo en cualquier sistema, ya que es una aplicación web; es decir, podemos instalarla en nuestros navegadores sin mayores inconvenientes. A continuación, haremos un ejemplo de cómo instalarlo en el navegador web Firefox.

La dirección de la página oficial de MetaMask es metamask.io. Desde aquí podemos descargar nuestra wallet MetaMask a través de un botón que nos lleva directamente a la página de addons o plugins de Firefox. Simplemente agregamos la extensión y esperamos un momento a que se complete la descarga para poder empezar a utilizar este monedero.

Ahora que tenemos instalada la extensión en nuestro navegador, comenzamos con el proceso de configuración. Simplemente debemos hacer clic en "Empezar" y seguir con el proceso. Lo primero que debemos elegir es si ya tenemos una frase secreta de recuperación o si vamos a establecer una nueva configuración. En este caso, vamos a crear una nueva cartera porque comenzaremos el proceso desde cero. Sin embargo, si ya tienes o has tenido una cartera MetaMask creada, puedes utilizar el proceso de importación para recuperar el contenido de esa antigua wallet. En este caso, comenzaremos una nueva.

Aquí debemos aceptar y configurar una clave segura. Una vez establecida la clave, simplemente debemos aceptar los términos de uso y comenzar con la creación de nuestra wallet. Lo siguiente es copiar la frase secreta de recuperación, o lo que sería lo mismo, la seed phrase, que consiste en las siguientes palabras. Una vez confirmada, simplemente hacemos clic y ya tenemos nuestra MetaMask creada. Automáticamente, MetaMask nos permite conectarnos a la red principal de Ethereum, lo que significa que podemos utilizar y enviar Ethereum o cualquier tipo de token compatible con esta red.

Sin embargo, también tenemos la opción de utilizarla con las redes de prueba de Ethereum, como Ropsten, Kovan, Rinkeby o un nodo interno que sería, en este caso, localhost:8545. Anteriormente, mencionamos que MetaMask es compatible con cualquier red que tenga retrocompatibilidad con la Ethereum Virtual Machine. Esto significa que podemos utilizar MetaMask con redes como Polygon, Binance Smart Chain o cualquier otra red que sea compatible con la EVM.

¿Cómo podemos agregar estas redes fácilmente a MetaMask y controlarlas todas desde este monedero? Para eso, hay una web muy conocida llamada Chainlist que nos permite añadir este tipo de redes adicionales a nuestro monedero MetaMask. Estamos en Chainlist y vamos a conectar nuestro monedero para empezar a agregar las redes disponibles. Conectamos nuestro monedero y rápidamente podemos ver la solicitud de conexión. Al conectar, automáticamente tenemos la opción de agregar las redes disponibles en Chainlist.

Fíjense que la primera red que aparece es Ethereum Mainnet, seguida de Binance Smart Chain, Avalanche, Polygon, Cronos, Phantom, Arbitrum y Optimism. Todas estas redes son compatibles con la EVM y, por lo tanto, pueden ser utilizadas directamente con MetaMask. Para agregar una de estas redes, en este caso, vamos a agregar la red Polygon. Simplemente debemos ir a Polygon y seleccionar "Agregar a MetaMask". Rápidamente se nos presenta la siguiente interfaz que nos indica que la red que vamos a agregar se llama Polygon Mainnet. La dirección URL de la red que nos permitirá conectar nuestro monedero con la red Polygon es PolygonRPC.com, y el identificador de la cadena es el número 137. Si hacemos clic en "Agregar red", automáticamente podemos ver que tenemos Polygon Mainnet agregado a nuestra wallet MetaMask.

Si estamos en Polygon, podemos ir a lo que se llama Polygon Bridge y rápidamente conectarlo a nuestra MetaMask, permitiéndonos interactuar con la misma, ya que estamos utilizando la red Polygon dentro de nuestro navegador. Chainlist, en este caso, es simplemente una recopilación de diferentes redes y puntos de conexión que nos permiten utilizar nuestra MetaMask con las diversas redes disponibles. Por ejemplo, podemos conectar Optimism, que es una L2 muy utilizada dentro de Ethereum. Simplemente lo agregamos y aquí están todos los datos para conectarnos a la red Optimism, que es bastante interesante dentro del ecosistema.

Si queremos agregar otras redes, simplemente debemos buscarlas en el listado de Chainlist y agregarlas a nuestro funcionamiento dentro de MetaMask. Como pueden ver, MetaMask es bastante potente y tiene sus pros y contras. En primer lugar, debemos tener mucho cuidado con las redes que estamos agregando a MetaMask, ya que recordemos que esto tiene acceso completo a nuestro monedero. Es decir, debemos ser cautelosos con las diferentes aplicaciones y webs que utilizamos para asegurarnos de que la red que estamos utilizando es la correcta y que el servicio es confiable, evitando así que nuestro monedero sea hackeado.

Chainlist, por ejemplo, es una aplicación muy conocida y su dirección es chainlist.org, facilitándonos el acceso a las diferentes redes. Sin embargo, siempre deben verificar dos veces las direcciones y asegurarse de que las aplicaciones descentralizadas sean lo suficientemente confiables para realizar este tipo de interacciones sin problemas.

Agregar direcciones o redes adicionales a MetaMask utilizando Chainlist también se puede hacer de forma manual. Simplemente debemos ir a configuración y, en la sección de redes, podemos agregar las redes que deseemos utilizando todos los datos manualmente. Si quieren conectarse a una red específica compatible con MetaMask, simplemente deben buscar los datos en las páginas web de los proyectos y agregarlos tal como aparecen aquí, para que puedan interactuar con estas redes sin inconvenientes. Esto hace que MetaMask sea un monedero muy potente y completamente adaptable a las necesidades del usuario.

Otra situación importante es hacer los respaldos correspondientes a las configuraciones, o más precisamente, a la frase de recuperación. Si no han copiado correctamente la clave de recuperación en el proceso inicial de configuración de MetaMask, pueden ir a la sección de seguridad y privacidad y hacer clic allí. Simplemente ingresan su clave y automáticamente podrán ver la frase secreta o seed de este monedero para que puedan recuperarlo. Esto es importante porque más adelante realizaremos un proceso de reconfiguración de nuestra MetaMask junto a un software de desarrollo llamado Ganache, que utilizaremos para hacer una configuración especial dentro de nuestro nodo Ganache y utilizarlo como monedero para interacciones con las DApps que estemos aplicando o desarrollando.

Como pueden ver, es bastante sencillo manejar este tipo de monederos, así que espero que les haya gustado este vídeo y que repliquen lo aprendido en sus hogares.

## U8. Servicios Sociales Descentralizados
###  Servicios Sociales Descentralizados (Video)
![[239.B4_Servicios_Sociales_Descentralizados.mp4]]
[Servcios Sociales Descentralizados](https://app.web3mba.io?wvideo=suj5w682gp)

Los NFT y el metaverso son los temas en auge en el ecosistema de las criptomonedas en este momento, pero es posible que el próximo gran auge sean las redes sociales descentralizadas. Esto se debe a que existe un considerable número de usuarios que sienten una desconfianza total hacia las redes sociales tradicionales, debido al excesivo control y, sobre todo, a la manipulación de la información. Además, empresas como Facebook, Twitter y LinkedIn, entre otras, ingresan enormes sumas de dinero utilizando los datos de los usuarios, como tú y como yo, como moneda de cambio para obtener rentabilidad. Gracias a la blockchain, la solución a este problema ya es una realidad y pasa por el desarrollo de redes sociales descentralizadas. Estas redes son libres y de código completamente abierto, lo que garantiza que cualquier persona pueda tener acceso a ellas en cualquier lugar del mundo. Asimismo, evita que cualquier entidad o empresa pueda utilizar o manipular la red y los datos a su favor, y, por supuesto, previene algo tan importante como la censura del contenido.

El funcionamiento de las redes sociales descentralizadas se basa en un sistema llamado Peer-to-Peer, es decir, un sistema de persona a persona, en el que cada nodo forma parte de una red y se puede acceder a ella de forma completamente autónoma. Además, este software puede ser construido de forma comunitaria entre todos los miembros de la comunidad y es completamente de libre acceso. Por tanto, las reglas y el funcionamiento de la red serían totalmente transparentes para todos los usuarios. Estamos en pleno proceso de evolución de la Web 2 hacia la Web 3.0, que es una web inteligente capaz de interpretar e interconectar una mayor cantidad de estratos de forma descentralizada y, lo más importante, sin intermediarios.

Te contaré una historia que ocurrió el año pasado. Julian York, un activista de la libertad de expresión, fue expulsado temporalmente de Facebook por compartir imágenes parcialmente desnudas en Twitter. Las fotos eran parte de una campaña alemana de concientización sobre el cáncer de mama en la que se veían claramente los pechos de una mujer. Facebook marcó la publicación como una violación de sus normas comunitarias, que prohíben estrictamente la publicación de la mayoría de estos tipos de desnudos en esa plataforma. Aunque la suspensión duró solo 24 horas, tuvo un gran impacto en el desarrollo del trabajo de York. ¿Y esto por qué? Simplemente porque, sin acceso a Facebook, York no pudo completar su trabajo ni publicar comentarios en otros sitios de noticias que utilizaban la herramienta de comentarios de Facebook para participar. Sin las credenciales de Facebook, York no podía acceder a otras aplicaciones en las que se utilizaba Facebook como método de inicio de sesión. Entonces, está claro que las redes sociales descentralizadas son una evolución directa hacia la libertad, hacia el control propio de tu contenido y de tus datos, y hacia una monetización independiente que nos llevará a la liberación de las finanzas descentralizadas.

Por un lado, su gobernanza sería abierta y todos podrían participar en la misma. Por otro lado, las acciones que involucren a personas externas a la plataforma serían muy difíciles de realizar. Para esto, la opción de detenerlo y hacer frente quedaría totalmente en manos de la comunidad. En una red descentralizada, el elemento negativo, es decir, la persona que crea ese ataque, sería completamente minimizado, porque la comunidad votaría para disminuir o negar la participación de esa organización o individuo. Dicho esto, podemos definir a las redes sociales descentralizadas como aquellas que operan en servidores o nodos que se ejecutan de forma completamente independiente. Esto quiere decir que estas redes sociales no están en manos de ninguna empresa, sino que sus usuarios son quienes toman las decisiones sobre su funcionamiento, actualizaciones y la forma de operar de estas redes.

Su principal característica es el uso de la blockchain y los sistemas de contratos inteligentes, conocidos como smart contracts. Estas plataformas descentralizadas se caracterizan por los siguientes elementos clave, y es importante que los tengas muy en cuenta porque utilizan la tecnología blockchain. La principal característica de la tecnología blockchain es la transparencia. Gracias a la red de datos abiertos, cualquier persona en la red puede ver los datos casi en tiempo real. De alguna manera, la blockchain devuelve la confianza en la privacidad a las redes sociales gracias a su naturaleza criptográfica. Por otra parte, la posibilidad de que haya un robo de datos es prácticamente cero. El control estaría, por tanto, en manos de los usuarios. A diferencia de las plataformas tradicionales, las redes sociales descentralizadas fomentan la independencia sin una autoridad central. La propiedad sobre los datos personales, el control sobre el contenido o la censura recaen solo sobre el usuario. Esto significa que ningún individuo o empresa puede dictar las reglas a otros usuarios o grupos de usuarios. Además, protege la privacidad y aumenta la seguridad.

Las preocupaciones de los usuarios sobre el control de sus datos personales han llevado al establecimiento del Reglamento General de Protección de Datos en la Unión Europea. Sin embargo, esta legislación considera a las empresas de redes sociales como procesadoras de datos, por lo que todavía mantienen el control sobre absolutamente todos nuestros datos. En estas redes sociales descentralizadas, los usuarios pueden crear cuentas sin tener que vincularse a ninguna identidad, como un correo electrónico o un número de teléfono. Esto no es necesario para tener un perfil en las redes sociales descentralizadas. Además, suelen basarse en la criptografía de clave pública para la seguridad de las cuentas, lo cual es fundamental, ya que utilizaríamos una clave encriptada en lugar de depender de una sola organización central que proteja tu clave o todos tus datos. Esto fomenta la libertad de expresión y la resistencia a la censura.

En las redes sociales tradicionales, las entidades son las que establecen las reglas de participación de todos los usuarios. En cambio, en las redes descentralizadas, las reglas las define el propio usuario o, en algunos casos, la comunidad. Es decir, ninguna autoridad puede modificar o eliminar el contenido creado por los usuarios, ni puede hacer nada que no esté autorizado por el usuario en sí. Esta característica ha generado mucho debate. Por un lado, están quienes piensan que prohibir los mensajes violentos en las redes sociales ayuda a proteger a los usuarios, mientras que otros consideran que la prohibición va en contra de los ideales de la libertad de expresión. Los usuarios pueden bloquear a estas personas, grupos o contenidos, pero no pueden evitar que participen en las diferentes redes. Así que vaticino que aún queda mucho por debatir en este sentido.

Por otro lado, tenemos la neutralidad económica, que significa fundamentalmente que los usuarios cambian a las redes sociales descentralizadas porque buscan liberarse de todo lo que implica la publicidad invasiva. En las redes sociales descentralizadas, además, buscamos nuevas formas de monetización. Queremos generar ingresos a través de nuestro contenido para mantener redes solventes. Por ejemplo, pagando con criptomonedas, los usuarios pueden crear, curar o consumir contenido en estas diferentes redes sociales descentralizadas. De esta manera, se incentiva a los creadores a centrarse en la calidad y a los usuarios a interactuar en la plataforma con estos contenidos.

Uno de los ejemplos claros de estos cambios en redes sociales es OneClick. OneClick es una red social que ha ido evolucionando con el tiempo, aunque tiene una vida muy corta desde su nacimiento. Actualmente se definen como el Amazon de los NFT. Esta plataforma permite crear y comprar cualquier tipo de NFT. Además, es bastante intuitiva y muy similar al Marketplace de OpenSea. No es una red social en sí, pero es importante que la conozcas. Es un proyecto de red social descentralizada que presenta una cadena de bloques especializada en alojar aplicaciones de redes sociales descentralizadas. Esto significa que cualquier persona o desarrollador puede crear una red social y alojarla en esta red. Además, es importante que sepas de su existencia porque es una red vertical, es decir, única y exclusivamente creada para desarrollar redes sociales. Esta red ofrece formas novedosas para que los creadores de contenido generen flujos de ingresos y también puedan interactuar con su audiencia.

Otra plataforma es Meme. En Meme se pueden publicar videos, blogs, imágenes, establecer estados y enviar mensajes, chatear por video de forma segura, en grupos o directamente con amigos. Es una red bastante versátil y avanzada. En esta plataforma se utiliza un sistema de recompensa con tokens, que permite a todos los usuarios ganar y gastar esos tokens. Esto se utiliza para impulsar las publicaciones, obtener una cuenta de usuario premium que cuesta unos cinco tokens al mes y acceder a infinidad de funcionalidades dentro de la plataforma.

Por otro lado, tenemos la red Pixify. Pixify es una alternativa a Instagram. En ella puedes controlar tus datos y tu privacidad, permitiendo que los usuarios vean solo las imágenes que tú deseas que vean. Todo esto se logra sin ver ningún tipo de anuncio. Obtiene los mismos conceptos básicos de la plataforma de compartir fotos, pero no tiene un algoritmo que impulse una línea de tiempo. Es decir, en el feed solo verás las publicaciones en orden cronológico, sin recopilar información de la experiencia de usuario personalizada dentro de la plataforma.

No es un secreto que las plataformas de blogging y noticias centralizadas están censuradas constantemente por instituciones y empresas, lo que coacciona la libertad de expresión y censura el contenido digital. Contar con plataformas descentralizadas permite una información colaborativa, sin censura y respetando la autoría del contenido publicado. Otra red social es Mastodon. Mastodon es una plataforma gratuita de código abierto que funciona como una especie de microblogging, muy similar a Twitter. De hecho, el día que Elon Musk anunció que quería comprar Twitter, se unieron a esta plataforma más de 30,000 nuevos usuarios. Parece increíble, ¿verdad? Una persona que se une a Mastodon se incorpora a una instancia específica que puede interoperar con otras instancias, permitiendo que los usuarios interactúen en diferentes nodos.

Mirror es otra plataforma de escritura descentralizada, diseñada para ayudar a los creadores a conectarse con un público objetivo de manera directa e innovadora. Esa es una de las principales atracciones de las redes sociales descentralizadas. Además, en ella es fácil convertir todos los artículos que se publican en NFTs. DLive es una plataforma de transmisión de video en directo que empodera a creadores y espectadores a través de un revolucionario sistema de recompensas. Aquí, los streamers pueden quedarse con el 80% de los ingresos de las suscripciones, mientras que los espectadores también reciben tokens por ver e interactuar con ese contenido. En general, DLive intenta ser única en ofrecer diferentes formas para que las personas sean recompensadas. Tanto los espectadores como los creadores de contenido tienen la oportunidad de ganar.

Sin lugar a dudas, estamos en el momento perfecto para comenzar a utilizar todas estas plataformas, monetizar tu contenido y proteger todos tus datos. ¿Cuál será la plataforma que destaque por encima del resto? Eso aún está por descubrir. Así que, pruébalas todas y elige cuál te gusta más.

###  La desconfianza en las Redes Sociales Centralizadas
Uno de los mayores problemas de nuestra sociedad actual la podemos ver en las redes sociales centralizadas como Facebook, Instagram, TikTok, Twitter y Snapchat.

Las redes sociales centralizadas rastrean, almacenan y venden nuestros datos para obtener ganancias, y al mismo tiempo, crear perfiles completos de nuestra actividad en Internet para bombardearnos de publicidad y seguir rastreándonos.

Aunque una distopía de ciencia-ficción, es la realidad que nos toca vivir todo el tiempo que nos conectamos a estas redes sociales y, de seguir así, el problema solo seguirá aumentando.

Las grandes compañías de Internet se han hecho con los primeros puestos de las empresas más valoradas del mundo gracias a la venta de datos. Una vez que agregas tu correo y contraseña y empiezas a hacer uso de dichos servicios, todos tus datos quedan en sus manos para venderlos. Incluso bajo la RGPD, las empresas buscan cualquier resquicio posible para sacar datos y darles uso comercial a los datos. Básicamente, las redes sociales “si algo es gratis, entonces el producto eres tú”, se ha desvelado con más relevancia últimamente.

> Cuando un usuario publica información en las redes sociales, es consciente de que se está dirigiendo al mundo, pero, al mismo tiempo, debe saber que también lo está haciendo al conjunto de corporaciones que le están escuchando y toman sus datos para usarlos para sus propios intereses.

Por ejemplo: 
- Twitter durante este 2021 ha generado un total de 571,8 millones de dólares procedentes de licencias de datos. 
- Esto es el 11% de todos los ingresos que la empresa tuvo durante 2021. 
- De hecho, los ingresos por la venta de datos no solo se han incrementado, sino que, al mismo tiempo, han impulsado de forma sustancial su negocio de publicidad, el cual depende de esta venta de datos. 
- Un negocio win-win para la empresa, pero loss-loss para sus usuarios que ven invadida su privacidad a niveles nunca vistos.

Twitter es, en este punto, la punta del Iceberg en comparación con los gigantes de Meta, Facebook e Instagram. **Tras el escándalo de Cambridge Analytica, sabemos que Facebook no solo vende datos, sino que dichos datos se usan activamente para manipular la opinión pública, convirtiendo este negocio en un arma de manipulación social.** 

El alcance es enorme porque en las redes sociales de Meta hay más de 2,5 mil millones de usuarios y, eso es, más de un cuarto de la población mundial actual (estimada en 8 mil millones para 2021). 

En este contexto, las redes sociales se han visto rodeadas de un halo de desconfianza que hace que la opinión pública se aboque y les ataque. Por un lado, las fake news se sirven a la orden del día en ella, por el otro la creciente polarización, se unen a algoritmos que incentivan la polémica y las luchas internas dentro de la red, junto con censura selectiva, dejan claro un punto: las redes sociales centralizadas no son confiables, porque el poder que tienen es tal, que pueden transformar a sociedades enteras en simples peones. 

![[239.B4_centralizadas.png]]

###  Redes Sociales Descentralizadas
Frente a la creciente desconfianza de las redes sociales centralizadas, la solución a ese problema pasa por la construcción de redes sociales descentralizadas, libres y de código abierto.

Estos tres puntos garantizarían que cualquiera pudiera tener acceso, que nadie podría usar y manipular la red a su favor y, por supuesto, evitaría la censura. 

1. Estas redes funcionarían bajo el concepto de redes Peer-To-Peer (P2P). 
2. Cada nodo forma parte de la red y puede acceder a ella de forma totalmente autónoma. 
3. Su software sería una construcción comunitaria y de libre acceso
4. Las reglas y funcionamiento de la red serían transparentes para todos.

**Esto no es una utopía, es una realidad que incluso se ha podido ver hasta cierto punto en medios centralizados, pero que están construidos por grandes comunidades, con reglas y desarrollos libres.** Por ejemplo, el mayor servidor IRC del mundo del software libre era el conocido Freenode, un lugar donde grandes proyectos de software libre tenían un lugar para reunirse y conversar, de forma libre y comunitaria. IRC es un servicio híbrido, es decir, depende de servidores para comunicar a las partes, pero una vez conectados, las partes pueden establecer comunicación P2P off-the-record. 

> Los servidores de Freenode eran ampliamente conocidos y usados, hasta que su administración (en manos de Andrew Lee, CEO del VPN PIA y Freenode) traicionó los principios que regían el ecosistema y comenzó con una serie masiva de despidos y dropping de privilegios en el servidor. 

La comunidad reaccionó rápidamente con renuncias y abandonos masivos, construyendo la red Libera Chat, lo que ha convertido a Freenode en una sombra y una mancha en la comunidad. Si, IRC es un servicio centralizado, pero la existencia de reglas claras, una comunidad respetuosa de las mismas y un software libre disponible para todos, daban la seguridad necesaria para que cualquiera pudiera expresar sus ideas en dicha comunidad, y si alguien buscaba imponer su posición por sobre todos los demás, este tipo de cosas son las que terminan sucediendo. 

**Frente a esto, las redes sociales descentralizadas son una evolución directa y la respuesta apropiada. Por un lado, su gobernanza sería abierta y todos pueden participar en la misma, por la otra, eventos en los que una persona intente a la fuerza tomar el poder serían muy difícil de realizar, y de hacerlo, la opción de detenerlo y hacer frente a dicho elemento queda en manos de la misma comunidad atacada.** Esto evitaría que una red conocida simplemente tenga que “abandonarse y autodestruirse”, porque un elemento busca controlarla. En una red descentralizada, sería el elemento negativo el que terminaría minimizado, porque la comunidad votaría por minimizar su participación e incluso negar su participación, si dado el caso, muestra total irrespeto por las reglas de la comunidad. 

Podemos definir a las redes sociales descentralizadas de la siguiente manera:
- Son aquellas que operan en servidores que se ejecutan de forma independiente. 
- Son redes sociales que no están en manos de ninguna empresa, sino que son sus usuarios los que toman las decisiones.
- Su principal característica es el uso de Blockchain y de sistemas de contratos inteligentes. De esta manera, los usuarios tienen más control y autonomía. 
- El usuario puede configurar su red social y determinar cómo funciona y qué pueden decir los usuarios.  
 
![[239.B4_descentralizadas.png]]

####  ¿Cómo funcionan?
Las redes sociales descentralizadas se caracterizan por los siguientes elementos claves:

#####  Tecnología Blockchain
La principal característica del Blockchain es la transparencia. 

Gracias a la red de datos abierta, cualquier persona en una red puede ver los datos casi en tiempo real.  De alguna manera, el Blockchain devuelve la confianza en la privacidad de las redes sociales gracias a su naturaleza criptográfica. Por otra parte, la probabilidad de que haya un robo de datos es casi cero.

#####  Control en manos del usuario
A diferencia de las plataformas tradicionales, las redes sociales descentralizadas fomentan la independencia sin una autoridad central.  

La propiedad sobre los datos personales, el control sobre el contenido o la censura, recae en el usuario. Es decir, ningún individuo o empresa puede dictar las reglas de otros usuarios o grupos. 

#####  La privacidad y seguridad
Las preocupaciones de los usuarios sobre el control de sus datos personales han llevado al establecimiento del Reglamento General de Protección de Datos (RGPD) en Europa. 

Sin embargo, esta legislación considera a las empresas de redes sociales como las “procesadoras de datos” por lo que todavía siguen teniendo control sobre los datos.

En las redes sociales descentralizadas, los usuarios pueden crear cuentas sin tener que vincularse con identidades, como una dirección de correo electrónico o un número de teléfono. 

Además, las redes sociales descentralizadas suelen basarse en la criptografía de clave pública para la seguridad de la cuenta, en lugar de depender de una sola organización para proteger los datos de los usuarios.

#####  Libertad de expresión y resistencia a la censura
En las redes sociales tradicionales, las entidades son las que establecen las reglas de participación de los usuarios. En cambio, en las descentralizadas, las reglas las pone el propio usuario.

Es decir, ninguna autoridad puede modificar o eliminar el contenido creado por los usuarios.

Esta característica ha creado mucho debate. Por una parte, están los que piensan que prohibir los mensajes violentos ayuda a proteger a los usuarios de las redes sociales, mientras otros consideran que las prohibiciones van en contra de los ideales de la libertad de expresión. Si bien los usuarios pueden bloquear estos grupos, no pueden evitar que participen en la red.

#####  Neutralidad Económica
La neutralidad económica es esencial para muchos que recurren a las redes sociales descentralizadas, quienes buscan liberarse de la publicidad invasiva.

Las redes descentralizadas buscan nuevas formas de monetización para mantenerse solventes. Por ejemplo, pagando con criptomonedas a sus usuarios por crear o curar contenido. De esta manera, se incentiva a los creadores de contenido a centrarse en la calidad.

###  Proyectos de redes sociales descentralizadas
Alguno de los proyectos de redes sociales descentralizadas más importantes que existen en la actualidad son:

####  Lbry
LBRY es uno de los protocolos más desarrollados dentro del ecosistema de las redes sociales descentralizadas y su objetivo es sencillo: Ser un espacio para la publicación de contenido audiovisual seguro y libre de censura. 

LBRY es un protocolo construido sobre Blockchain, que busca crear una enorme red de nodos descentralizados con los que puedes interactuar libremente. Como resultado, tienes una red llena de creadores de contenido que suben sus vídeos y mantienen el funcionamiento de la red en todo momento, porque nadie tiene el control del contenido ni del ancho de banda que está disponible para su funcionamiento. 

LBRY se puede dividir en dos partes: 
1. **Una Blockchain** para mantener a sus nodos unidos y debidamente monetizados. 
2. **Un sistema de almacenamiento y distribución de contenido** para que todos puedan subir y descargar aquel contenido que sea de su interés.

La monetización es posible por el token nativo LBC (LBRT Credits), el cual es usado para subir contenido y mantener el mismo dentro de la red por el tiempo que desees, porque al final, todo el contenido siempre está bajo tu absoluto control. 

Acceder a ese contenido es posible gracias a un protocolo P2P muy parecido a IPFS, ya que usa la tecnología DHT (que es usada en IPFS y BitTorrent) y un derivado del protocolo Kademlia. Es este sistema el que permite almacenar los datos de forma descentralizada y acceder a ellos cuando se desee. Como resultado, LBRY tiene en su haber una gran cantidad de datos, cuenta con un protocolo propio (conocido como LBRY Protocol – lbry://) y una comunidad que va creciendo rápidamente. 

Otras opciones como LBRY son PeakD y Dtube, cuyas tecnologías son bastante parecida y tienen un mismo fin: permitirnos el acceso a streaming de calidad desde cualquier parte del mundo, sin censura y respetando nuestra privacidad. 

####  Hive
Hive es una Blockchain nacida de la controversia dentro de la comunidad Steemit. 

Después de que Justin Sun, CEO de TRON, tomó el control de la startup Steem, parte de la comunidad alrededor de esa red decidió separarse e iniciar la red Hive. 

Desde entonces, Hive ha sido una red rápida, escalable y robusta para construir redes sociales Web 3.0. Su principal servicio en este sentido es Hive Blog, un espacio de microblogging donde tienes la libertad de crear contenido y monetizarlo por medio de visitas, lecturas y tips que recibas de la comunidad. Todo ello es mantenido por la criptomoneda nativa, el token Hive el cual es esencial para la economía de todos los servicios que la red Hive presta y mantiene accesibles para todos. 

####  Aether
Aether es una red social del tipo P2P que busca construir comunidades y espacios muy parecidas a Reddit.

Por medio de su potente aplicación, Aether te permite acceder a un universo de publicaciones que están relacionadas con tus intereses y selección personal de contenido, poniéndote en contacto con estos espacios para que puedas participar y retroalimentar a los mismos.

## Xperts 1 | Fran Villalba
###  Internxt (Video)
![[240.B4_Internxt.mp4]]
[Internxt](https://app.web3mba.io?wvideo=v7y1qwi2x9)

Internext es una empresa de almacenamiento en la nube que busca garantizar la seguridad y la privacidad que las grandes tecnológicas no logran ofrecer. Se trata de una startup impulsada por Wira, la aceleradora de Telefónica; Angels, la sociedad de inversión de Juan Roch; la escuela de negocios SADE de The Venture City; y el antiguo director de tecnología de Coinbase. Aunque actualmente cuentan con más de 300,000 usuarios activos, desde Internext se distancian del mercado masivo, enfocándose únicamente en el usuario que prioriza ante todo la privacidad. Sus productos estrella son DRIVE y WIRE, y próximamente lanzarán SEND, un servicio de envío de archivos mediante enlaces de caducidad programable e independiente de nuestro alojamiento personal. Entre sus planes futuros también se encuentra ofrecer una VPN y un servidor de correo electrónico dentro de un abanico de funcionalidades de suscripción única, siempre con la defensa de la confidencialidad de nuestros datos como bandera.

Básicamente, en Internext detectamos un problema: el internet que conocemos estaba monopolizado por gigantes tecnológicos cuyo fin era extraer datos del usuario, siendo este último el producto. Así, decidí crear una especie de internet alternativo, centrado en el usuario y en proteger su privacidad. Es decir, que al usar internet no tengas que venderte al mal diablo, sino que puedas acceder a servicios alternativos a los que ofrecen Google, Facebook, Microsoft, Amazon y otros, sin perder tu derecho a la privacidad y sin tener que compartir tus documentos o correos privados con terceros, evitando que puedan ser hackeados. Para ello, hemos desarrollado servicios alternativos a los que existían en ese momento, como una alternativa a Google Drive, que es nuestro Internet Drive, y una alternativa a Google Fotos, que es Internetx Fotos. También lanzaremos una alternativa a WeTransfer, que será Internet Exchange. La idea es crear un conjunto de servicios similares a G Suite, ya que el internet se compone de una serie de servicios. Cuando usas internet, ¿qué utilizas? O Google o Facebook. Nuestra propuesta son alternativas a estos servicios, enfocadas en la privacidad.

En términos prácticos, la diferencia es clara: Google, Apple y otras grandes empresas son más susceptibles a ser hackeadas. Por ejemplo, iCloud fue hackeado hace unos años, y fotos de Jennifer Lawrence y otras actrices se filtraron por internet. La idea es evitar que eso suceda, y en Internext nuestro enfoque está en que no ocurra. En esencia, un cloud no es más que servidores ubicados fuera de donde tú estás. Si quiero acceder a una página web o a un archivo que no está en mi móvil, me conecto a un servidor que está en otra ubicación, y este me envía la información que deseo ver. Al final, el cloud son servidores en alguna parte que te envían información. Hasta ahora, lo que sucedía es que Google, Amazon y otras grandes empresas operan centros de datos, como Dropbox, donde almacenan información. Esto es relativamente fácil de hackear porque es centralizado. Además, estas empresas tienen la clave de desencriptación de tus archivos, lo que las convierte en un blanco claro para ataques.

Un cloud descentralizado comparte el concepto de cloud, pero la diferencia es que, en lugar de almacenar un archivo en el centro de datos de Dropbox, donde ellos tienen la clave de desencriptación, en Internext los archivos se encriptan, no guardamos la clave de desencriptación y se fragmentan. Lo que hacemos es distribuir esos fragmentos alrededor del mundo en diferentes servidores. Si un atacante intenta hackear uno de tus archivos, como una foto personal, le sería prácticamente imposible, ya que al atacar un servidor solo encontraría fragmentos encriptados de archivos que no sirven para nada. Esta es la idea: la descentralización aplicada a nuestro caso de uso garantiza un mayor nivel de privacidad y seguridad. Por parte de la empresa, en el caso de Internext, no podemos acceder a esa información porque, además de estar distribuida, no tenemos la clave de desencriptación.

Es importante que la gente sepa que si quiere hacer algo en el mundo blockchain y descentralizado, habrá muchos obstáculos técnicos que no tendría si desarrollara un juego en un servidor convencional. Al principio, permitíamos que cualquier persona almacenara archivos, pero el problema que encontramos fue que era muy lento. Si cualquiera podía almacenar archivos, había personas con conexiones Wi-Fi lentas o que apagaban sus ordenadores, lo que requería mantener muchas copias de los ficheros. La ventaja de la descentralización, que es más económica porque utiliza espacio no ocupado por centros de datos, se perdía porque había que mantener muchas réplicas de los archivos. Así, nos encontramos en un momento en el que era más caro, más lento y menos fiable, ya que a veces perdíamos archivos si se apagaban varios ordenadores. Aunque intentamos evitarlo con un sistema de matrices similar al que utilizan los DVDs, que permite seguir escuchando música aunque el disco esté rayado.

A nivel de limitaciones, enfrentamos problemas de velocidad, fiabilidad y costes. Para solucionarlo, adoptamos un enfoque similar al de Bitcoin y Ethereum. Aunque Bitcoin es descentralizado, la realidad es que no conozco a ningún particular que esté minando Bitcoin en su ordenador. En nuestra infraestructura descentralizada, cada vez más profesionales almacenan datos, personas que realmente quieren dedicarse a esto y que se comprometen a pagar por sus servidores y mantener una conexión a internet adecuada para solventar estos problemas. Lo principal es que en el equipo fundador de la startup, si vas a hacer un proyecto tecnológico, especialmente en la industria blockchain, es fundamental contar con personas capacitadas que puedan llevar a cabo el proyecto. El tiempo de desarrollo, como mencionabas, será seguramente largo si deseas crear algo tecnológico, lo que implica muchos costes. Por lo tanto, deberás contratar a gente en algún momento. Si puedes evitar contratar desde el principio, aumentarás la probabilidad de sobrevivir, ya que tendrás menos costes a corto plazo, especialmente al inicio, cuando no cuentas con muchos fondos.

Internext se desarrolló de esta manera. Yo soy el fundador, pero me formé en programación, blockchain y negocios. Comencé por mi cuenta, pero después de unos años empezamos a contratar. Fueron varios años de desarrollo desde que surgió la idea de Internext en mi último año de carrera, entre 2017 y 2018, hasta que realmente lanzamos el producto al mercado en 2020-2021. Nuestro primer producto, DRIVE, lleva en el mercado poco más de un año y medio. Al principio, muy poca gente creía que realmente podríamos hacerlo. Era una idea ambiciosa, y yo era muy joven, recién graduado. El primer MVP, considerando todos los obstáculos técnicos que enfrentamos, era bastante lento; a veces, al intentar descargar un archivo, no funcionaba y tenías que volver a intentarlo. La experiencia de usuario también necesitaba mejoras, y aunque era ilusionante, había mucho trabajo por hacer. Hemos estado trabajando durante años para desarrollar un proyecto serio. Diría que el Internext que conocemos hoy comenzó a desarrollarse en 2020-2021, cuando logramos tener un MVP razonable y empezamos a escalar y profesionalizarlo, creando nuevos productos.

Cuando comenzamos Internext, el contexto era diferente. Hubo muchos problemas con Ethereum, que se volvió muy caro y relativamente lento en comparación con otras blockchains. Nuestro modelo es un poco híbrido: tenemos nuestra propia infraestructura y también nos apoyamos en la red de Ethereum, tanto para la infraestructura como para los pagos. Contratar a un desarrollador de blockchain o integrarlo en tu equipo fundador es lo mejor. O, si prefieres, puedes aprender Solidity, el lenguaje de programación utilizado en la red de Ethereum, o aprender otro lenguaje según lo que desees hacer. Go también está muy de moda ahora. En el espacio blockchain, estamos viendo que muchas personas han detectado la oportunidad de hacer dinero, lo que ha generado mucho humo. Muchos intentan aplicar blockchain a cosas que no tienen sentido, buscando cómo inventar una criptomoneda para enriquecerse rápidamente. Creo que la reflexión debe ser al revés: primero, identifica un problema real que deseas solucionar, como en mi caso, la privacidad, y luego busca las tecnologías adecuadas. En nuestro caso, no solo utilizamos blockchain; empleamos una variedad de lenguajes de programación y herramientas para resolver el problema.

Lo que estamos viendo ahora es que muchas soluciones se están aplicando a problemas que no existen en el ecosistema. Creo que, al final, solo quedarán unos pocos proyectos que realmente tengan un negocio sostenible detrás. No se puede mantener el hype indefinidamente; es necesario contar con un negocio real que genere ingresos y que ofrezca soluciones a problemas reales. En el ecosistema de Web3 y más allá, fuera del hype de términos como Web3 y Metaverso, lo que realmente quedará son proyectos que solucionen problemas reales y cuenten con un buen equipo detrás. Estoy convencido de que el 99% de lo que existe ahora, al igual que ocurrió en 2018, desaparecerá, y espero que esta vez no regrese.

Actualmente, estamos ayudando a 300,000 personas a resolver problemas de privacidad. La idea es alcanzar un millón de usuarios este año y, a partir de ahí, llegar a tres o cuatro millones el año siguiente. Nuestro objetivo es seguir mejorando la parte de DRIVE, especialmente en el sector B2B y Enterprise. Este producto es muy interesante en sectores como la salud y la educación, donde es crucial proteger datos de pacientes o de niños en escuelas. También es relevante para el sector institucional, para prevenir problemas como el espionaje. En definitiva, es un producto muy atractivo en el ámbito B2B Enterprise, donde vamos a centrar gran parte de nuestros esfuerzos el próximo año, y ya estamos comenzando a hacerlo este año. Además, continuaremos creando ese G Suite, no solo con DRIVE, FOTOS y SEND, sino también desarrollando nuevos servicios.

## Xperts 2 | Pablo Rodrigo
###  Trazable (Video)
![[241.B4_Trazable.mp4]]
[Trazable](https://app.web3mba.io?wvideo=7l0evnyvbo)

Trazable es una empresa que implementa la tecnología blockchain con el propósito de ofrecer garantías de seguridad, transparencia y confianza a la industria alimentaria. Desde el inicio del proyecto, tienen claro que la digitalización ha llegado para quedarse. Su modelo de negocio y su propuesta de valor se centran en formar parte de esta transformación, dotando a los departamentos de calidad de las empresas de las herramientas digitales necesarias para trazar la cadena de producción, distribución y compra de los alimentos. En marzo, lanzaron su propio token, el cual integra la cadena de bloques como una solución eficiente para analizar y automatizar la logística en el suministro. Su adaptabilidad al modelo tradicional ha supuesto la modernización y el acercamiento de esta nueva tecnología tanto a clientes como a inversores.

Trazable es un software de gestión de calidad que nace con la idea de lograr que las empresas de la industria alimentaria tengan trazabilidad desde el campo hasta la mesa, algo que antes no tenían, ya que solo contaban con información sobre su proceso productivo. Al conocer las necesidades de estas empresas, nos damos cuenta de que requieren una etapa previa: digitalizar sus procesos actuales. Muchos de ellos aún utilizan papel, lo que genera ineficiencias que pueden impactar en la seguridad alimentaria y en la confianza del consumidor. Por ello, hemos desarrollado una solución que les ayuda a digitalizarse, a tener un mayor control de la calidad y de la seguridad alimentaria, y, lo más importante, a conectarse con el resto de actores de la cadena y certificar toda esa información en blockchain para que el consumidor final pueda participar en la historia de los productos. En términos simples, se trata de la capacidad que tiene una empresa de saber de dónde provienen las materias primas o los componentes que utiliza en su producto, y a dónde envía ese producto. Esto es clave en la industria en general, porque cuando surge un problema, es fundamental saber qué ha ocurrido y ser capaz de rastrear, como se conoce en la industria, desde aguas abajo a aguas arriba, o viceversa, para identificar el problema y su impacto.

El primer inconveniente es la ineficiencia que genera tener toda la información en papel y archivada en carpetas. Cuando se necesita realizar ejercicios de trazabilidad, se pierde mucho tiempo, o a veces, el operario que debía registrar la información no está presente y se pierde ese papel. Esto puede parecer sencillo, pero en una empresa que produce grandes cantidades de alimentos, con lotes y lotes de productos, es fácil olvidar detalles. Tener un entorno digital es el primer desafío que hemos identificado. El siguiente reto es que, si se desea tener un control total de la trazabilidad, es necesario compartir información, lo cual a menudo es complicado en la industria. ¿Quién gestionará los datos? ¿Puedo entrar en conflictos de intereses con proveedores o clientes? Además, estamos hablando de cadenas que son globales, donde hay empresas que no se conocen entre sí. Entonces, ¿cómo se gestionará esa confianza o esa información? Este es otro problema importante.

Como puedes imaginar, comenzamos con una idea: lograr que las empresas tengan trazabilidad desde el campo hasta la mesa, y eso había que validarlo con las empresas. Fue un proceso largo de diálogo con empresas alimentarias y directores de calidad. En 2018, coincidimos con Embutidos Martínez, que vio sentido en nuestra propuesta. Recordamos con cariño ese primer caso de éxito, ya que fue un choque entre la idea que teníamos y la realidad. Pensábamos que todo iba a estar digitalizado y que sería sencillo conectar blockchain y trazabilidad, pero nos encontramos con directores de calidad y operarios que tenían dificultades incluso para manejar un Excel. Aprendimos que era necesario un paso previo, y aunque logramos sacar adelante ese caso de éxito, nos dio una lección sobre dónde estábamos.

Creo que la labor de Trazable a corto plazo es evangelizar, estar presentes y hablar sobre la importancia de la digitalización y los sistemas de gestión de calidad, que muchas empresas aún no tienen. Utilizan Excel, correos electrónicos, se comunican con los proveedores por teléfono y tienen sistemas ERP y de laboratorio, pero no cuentan con un software específico para calidad. Existen, pero no se utilizan. Esta labor de evangelización es algo que nos corresponde, junto con todas las ventajas que esto conlleva. Afortunadamente, la administración está tomando medidas y apoyándonos, ya que los principales distribuidores también están impulsando esta digitalización. Comienzan a exigirla porque ven que es un valor que los clientes demandan cada vez más. Estamos en un momento de cambio, y observamos que es una tendencia importante a nivel de mercancía.

A priori, lo que hemos explicado puede parecer complicado. Decir que hay que integrarse y trabajar con el equipo de IT puede asustar, pero es todo lo contrario. El proceso de hacer entender y romper esas barreras mentales sobre por qué hay que cambiar la forma de hacer las cosas es más largo que el proceso de incorporación. Al final, el proceso es registrarse. Una vez que aceptas y ves el valor de la herramienta, te registras, obtienes tu usuario y contraseña, y accedes a un SaaS que funciona en línea y está en la nube, como HubSpot o Salesforce, pero es una herramienta de calidad. Desde allí, puedes conectarte con el ERP o utilizar módulos como la gestión de incidencias, el gestor documental y todos los controles que debe realizar la empresa, como no conformidades y limpieza. Puedes hacerlo de manera sencilla, creando registros o carpetas del gestor documental con solo unos clics y comenzando a usarlo en tu día a día.

Desde Trazable, estamos siempre disponibles y contamos con un equipo de producto que te ayuda a entender la herramienta. También tenemos un Help Center en línea donde puedes acceder a tutoriales de cada etapa. El proceso de uso es muy sencillo. Cambia la percepción de la empresa sobre el retorno que pueden obtener en términos de tiempo, ahorro de costes o incluso incremento de ventas al utilizarlo. En la actualidad, estamos en una etapa anterior a la ingesta automática de datos, que se relaciona más con los sistemas MES que cubren la producción o el ERP. En nuestro caso, abarcamos todos los controles operativos de producción, limpieza y puntos críticos. La realidad es que el 90% de los clientes con los que trabajamos utilizan hojas impresas donde los operarios registran la fecha, la hora o un valor de la máquina. Ese Excel luego se archiva, o un técnico de calidad introduce selectivamente esos datos en un Excel para tener información y poder hacer predicciones. Nosotros transformamos eso en una tablet, donde ya se introducen los valores y se realiza un análisis, evitando problemas e inconsistencias, y generando estadísticas automáticas en ese momento. Lo más importante es que tienes tu información digital, que puede ser explotable y conectarse con el resto de eslabones de la cadena, hacia el consumidor, que es quien tiene el poder de compra.

Hasta ahora, no estábamos prestando atención al consumidor. La empresa podía ofrecer información, pero hoy en día, ¿qué quiere el consumidor? Ya no solo le importa si el producto es más barato o más caro, sino que lo más importante es el sabor. En el ámbito alimentario, esto es fundamental. Luego, la calidad y la seguridad alimentaria son prioritarias, seguidas del precio y el origen, que cada vez cobra más relevancia. La sostenibilidad también está ganando fuerza como un tema importante. La gente quiere saber más y alinearse con el propósito de las empresas, pero hasta ahora no contaba con un canal de comunicación. Independientemente de sus esfuerzos por buscar y obtener esos datos, no había un canal donde pudiera ver la información y conocer la historia de ese producto. Por ello, decidimos conectar esos puntos que teníamos.

Una de las soluciones que vimos con sentido fue trabajar en el espacio de blockchain a través del token. Esto cubría nuestra necesidad de tener un eje central que ayudara a generar un entorno de confianza entre los actores, depositando esa confianza en la tecnología y fomentando la colaboración. El token de Trazable nos sirve como un elemento diferenciador en otros proyectos y, a corto plazo, como una forma de capitalización para hacer crecer el proyecto y llevarlo al siguiente nivel. Hasta el momento de la ICO, habíamos conseguido medio millón de euros en financiación, parte de la cual provino de inversores. Conocíamos las diferentes etapas del proceso. La financiación con inversores es como casarse con alguien y meter a personas en el proyecto, por lo que la confianza es crucial. La ICO, en cambio, es una vía alternativa que surge de la tecnología y busca añadir actores clave, como los consumidores, para conectarlos con las empresas. Así, cerramos el círculo de manera perfecta, alineando la financiación con el objetivo a medio y largo plazo que queremos alcanzar.

Ahora, la situación es complicada, pero depende de si tiene sentido para ellos, ya que, como saben, el token requiere tiempo y dedicación para mantenerlo. Si se hace únicamente por conseguir financiación, no tiene sentido, porque eso desviará el enfoque, que es lo más importante en un proyecto. Donde estamos ahora es el resultado de todos los aciertos y errores que hemos cometido. No repetiría todos los errores que hicimos. De hecho, comenzamos Trazable enfocados en la industria del lujo y luego pivotamos hacia la alimentación. La idea inicial era introducir la tecnología en el sector del lujo para certificar productos y combatir las falsificaciones. En ese momento, mi socio Lucas y yo no teníamos recursos y queríamos probar rápidamente. La industria del lujo se mueve más lentamente, con empresas más grandes y deslocalizadas, por lo que nos resultó más fácil testear en la industria alimentaria.

En ese proceso, conocimos a una empresa de productos cárnicos, específicamente de jamones y aceites de lujo, que estaba interesada en combatir las falsificaciones, pero también en aportar valor al consumidor. Así comenzamos a explorar la industria alimentaria, identificando problemas de seguridad alimentaria y otros desafíos que nos llevaron a concluir que, en un entorno como el de España, con una industria muy grande y empresas de todos los tamaños, era mucho más fácil realizar pruebas. Así fue como conocimos a Embutidos Martínez, nuestro primer caso de éxito, y avanzamos con Trazable.

Funcionamos con cuatro pilares: crecimiento, producto, tecnología y ventas o negocio, donde todo se retroalimenta. El eje central es el producto, donde el cliente es lo más importante. Trabajamos mucho con empresas y pruebas, y recibimos muchos insumos de ventas o crecimiento que se validan en historias de usuario. Luego, la tecnología se adapta para que el producto evolucione en la dirección que nuestros clientes necesitan. En 2023 o 2024, nuestro objetivo es convertirnos en el software de referencia en gestión de calidad. Así como piensas en un CRM y mencionas Salesforce o HubSpot, queremos que Atrazable sea el referente en software de gestión de calidad. Además, planeamos introducir la utilidad del token dentro de nuestra solución de software y conectar a la red, finalizando la conexión entre usuarios y empresas dentro del producto que ofrecemos.

Estamos testeando aquí porque en muchas industrias somos referentes, también a nivel europeo y mundial en varios sectores. Nuestro objetivo es probar y, si es posible, lanzar este año en otros mercados, ya que somos una solución global. Las cadenas de suministro son complejas, y tenemos clientes que cuentan con proveedores en todo el mundo, así como algunos en Latinoamérica, y queremos expandirnos a otros mercados.

## Xperts 3 | Miguel Peco
###  Blocknitive (Video)
![[242.B4_Blocknitive.mp4]]
[Blocknitive](https://app.web3mba.io?wvideo=r91dtd38c5)

Blocknative nace a partir de la consultora Eman Gitti, al detectarse la necesidad de aplicar una tecnología tan disruptiva como la blockchain a soluciones concretas de procesos complejos. Su misión se centra en poner el foco en la innovación y la digitalización, aplicándolas a la resolución de problemas mediante tecnología descentralizada y cognitiva. Funciona mediante software colaborativo de código abierto, como Hyperledger, ofreciendo así soluciones adaptables gracias a la aplicación de una arquitectura modular flexible. Además, cuenta con alianzas clave con empresas relevantes del sector tecnológico como Oracle e IBM. Este proyecto contiene en su ADN el respeto por la privacidad y la seguridad a la hora de agilizar la transformación digital de un mercado en constante evolución.

Blocknative es una startup que surge en 2018 como un spin-off de una consultora con más de 17 años en el mercado, presente en España, México y Estados Unidos. Al observar el éxito de las nuevas tecnologías, crearon un hub digital de inteligencia artificial, Big Data y Blockchain, y decidieron que Blockchain podría tener un negocio aparte, dando lugar a la creación de Blocknative, apoyada en el contexto de la nueva GDPR. Así, desarrollaron un producto único en Europa que ayuda a solventar la trazabilidad del uso de datos, cumpliendo con la GDPR, normativa que comenzó a aplicarse el 25 de mayo de 2018. Nos gusta combinar datos y procesos con blockchain, siempre desde un punto de vista B2B. Lo que más me enamora de esta tecnología es su capacidad de ser transversal. Esto es algo que escucho frecuentemente de los clientes, quienes preguntan: "¿Pero en qué sector?" La respuesta es: en todos, porque, como hemos mencionado, estamos en datos y procesos, y todas las empresas tienen ambos.

Lo que hemos hecho es desarrollar una plataforma con distintos módulos para solucionar casos de uso de negocio. Uno de ellos es la trazabilidad del consentimiento. Por ejemplo, en un caso de uso que tenemos, se trata de la interoperabilidad entre empresas del grupo, que pueden crear una base común. Al ser distintas sociedades, deben cumplir la GDPR de manera diferente, pero nosotros colocamos nuestra capa por encima de la base de datos, y la herramienta actúa como un regulador que permite o no el uso de los datos. Otro caso de uso muy interesante que estamos comenzando a explorar, especialmente para un operador de telecomunicaciones o un ayuntamiento, es proporcionar visibilidad a los clientes sobre la trazabilidad de sus datos. Es decir, permitir que el cliente visualice qué consentimientos ha otorgado, qué finalidades ha firmado, qué se ha hecho con sus datos y a quién se han entregado, incluso en relación con una tercera empresa.

Desde el punto de vista de los procesos, tenemos casos de uso muy variados. Por ejemplo, trabajamos en la certificación de energías renovables, que luego tokenizamos, con la idea de emitir un pequeño certificado para un marketplace. También abordamos la trazabilidad digital de productos, como en el caso de un router que se instala en casa. Las telecomunicaciones enfrentan el problema de no tener trazabilidad sobre esos routers, lo que lleva a que cobren a los clientes sin saber dónde están. Por ello, tenemos dos casos de uso que permiten trazar de forma inequívoca la identidad digital del router desde su creación, pasando por el almacén de la telco, hasta llegar al cliente y ser instalado. Durante todo ese proceso, pueden ocurrir dos cosas: que el cliente se dé de baja voluntariamente o que se produzca una baja no voluntaria. En ambos casos, se puede certificar que el router ha regresado a la tienda, o incluso renovarlo por un tiempo determinado, manteniendo siempre el control de su identidad.

Dependiendo del caso de uso, siempre explicamos que blockchain no es la solución para todo. Debe tener una utilidad específica y un caso de uso que nos ayude a desarrollarla. Puede tener una vertiente muy B2B, que ayuda a reducir costos y mejorar la eficiencia del back office, ya que blockchain es, en esencia, una tecnología de backend. Es cierto que, dependiendo del caso de uso, se puede combinar con otras tecnologías, como la inteligencia artificial generativa y Big Data, para mejorar la fidelización de los clientes y la experiencia del usuario, lo que a su vez genera negocio. Sin embargo, repito, esto dependerá del caso de uso y puede aportar de diferentes maneras.

Nuestro producto está disponible en formato SaaS y en la nube. Actualmente, estamos enfocados en Latinoamérica, principalmente en México, y atendiendo a ciertos clientes que prefieren no utilizar SaaS, optando por soluciones en sus propias nubes, por lo que vendemos con licencia. No obstante, también ofrecemos la opción SaaS. Ambos productos cuentan con una experiencia de cliente muy sencilla. Hemos logrado el éxito en dos aspectos: primero, centrarnos en los procesos, que son lo que realmente aporta valor a los negocios; y segundo, eliminar la complejidad del blockchain para los clientes mediante un caso de uso, ofreciendo una solución que puedan utilizar sin necesidad de entender que están utilizando blockchain. Puedo enseñarte cómo funciona sin mencionar la palabra blockchain, y tú estarás aprovechando todos los beneficios que esta tecnología ofrece. Luego, si preguntas cómo se ha hecho, te diré que es en blockchain. Creo que ese es uno de nuestros mayores logros.

Podemos tener una prueba de concepto lista en menos de un mes, a menos que se complique con integraciones o sistemas de información. Si se trata de un caso de uso sencillo, incluso podríamos tenerlo funcionando en dos semanas. Nuestro enfoque principal es la trazabilidad. Además, contamos con otros productos paralelos, como nuestra propia plataforma de NFTs, que permite a los usuarios diseñar, crear y gestionar sus propios NFTs, incluyendo la posibilidad de establecer royalties. También tenemos una alianza con Block Impulse, una plataforma ICO que ayuda a las empresas a crear nuevos proyectos y generar su token. No solo les asistimos en el diseño de la plataforma, sino que también les ayudamos a crear su token, lo cual es un proceso complejo que incluye la elaboración del white paper, la estructura económica y legal, y la parte de marketing. Si desean profundizar en la parte de marketing, les recomendamos contratar a un experto en esa área.

¿Qué es blockchain? Para mí, como lo explico a mi entorno que no tiene conocimientos en el tema, es como un Excel en el que múltiples participantes pueden interactuar, quedando registrada la trazabilidad de las acciones de manera inmutable y visible para todos. Entonces, ¿cuándo tiene sentido utilizar blockchain? Como mencioné, cuando hay más de un participante. Si se va a utilizar para una empresa, ¿puede ser útil? Sí. ¿Realmente aportará valor? Depende. Habrá casos en los que sí. Si necesitas realizar una certificación específica, entonces sí, pero en realidad no estarías utilizando blockchain. La tecnología blockchain tiene la ventaja de permitir muchas aplicaciones, pero actualmente solo estamos utilizando alrededor del 20% de su potencial. Por lo tanto, es necesario educar a las empresas para que comiencen con un pequeño pilar y, una vez que tengan la base, puedan incorporar smart contracts para automatizar procesos.

No soy un experto en finanzas o en el mundo de las DeFi, pero creo que hay un gran potencial en ese ámbito. Desde mi perspectiva, blockchain es tan transversal que puede aplicarse a todos los sectores. Sin embargo, es cierto que las empresas que adoptan esta tecnología suelen ser aquellas con capacidad de inversión e innovación, que están dispuestas a ser pioneras en su implementación para mejorar la eficiencia. Otros sectores que considero muy interesantes son las telecomunicaciones y los seguros, que siempre están presentes de una forma u otra. En el caso de la banca, aunque hay menos ejemplos, hemos trabajado en proyectos relacionados con importaciones y exportaciones, donde hay muchos participantes y un gran volumen de documentación que certificar. Si todos suben la documentación correspondiente a una plataforma y se va certificando, se genera seguridad y se reduce la carga de conciliación de papeleo.

El retail también tiene un gran potencial para cambiar con blockchain. Un caso interesante que hemos explorado en México es la logística inversa de medicamentos, que involucra al laboratorio, distribuidor y cliente final, incluso cuando el medicamento regresa. Algunos medicamentos no pueden ser redistribuidos, mientras que otros pueden volver al mercado, dependiendo de su fecha de caducidad. Certificar toda esta documentación es crucial. Una de las preguntas que nos hicieron las farmacias fue: "¿Qué gano yo con esto?" La respuesta es que, a corto plazo, no ganarás nada, pero el éxito radica en que el distribuidor y el laboratorio te incentiven a compartir y colaborar en este ecosistema, ya que ellos también obtendrán beneficios. Actualmente, se estima que en México se pierden 66 millones de dólares al año debido a la falta de trazabilidad. Si logramos reducir esa pérdida a 10 millones, incentivando a las farmacias, eso sería un éxito, ya que habríamos recuperado 54 millones.

Blockchain es una tecnología más y un concepto de digitalización. No se puede digitalizar de 0 a 100; debe hacerse de manera gradual. Es cierto que en el mundo de Hyperledger Fabric, donde se desarrollan procesos de negocio, puedes optar por soluciones de código abierto que son muy económicas, o contratar a IBM, que es uno de los líderes en esta tecnología, aunque a un costo más elevado. En la fase inicial, puede parecer que estás haciendo una inversión costosa en tecnología. Sin embargo, si logras cambiar la mentalidad y buscar casos de uso que se automaticen, considero que, según ciertos cálculos, blockchain puede ser una tecnología más económica que otras en el mercado y, sobre todo, escalable. Creo que blockchain tiene mucho sentido porque ayuda a garantizar la integridad de los datos y su uso, promoviendo un ecosistema colaborativo. Es fundamental que todos los datos estén ligados a un consentimiento, y eso es crucial; romper esa cadena puede generar problemas significativos.

## Xperts 4 | Lucas Salinas
###  Trazable (Video)
![[243.B4_Trazable.mp4]]
[Trazable](https://app.web3mba.io?wvideo=x6th69298c)

Empezamos en la incubadora de Demium. Yo acabé allí por accidente, mientras que Pablo creo que sí fue premeditado al entrar. Nos conocimos un viernes en un evento de captación de talento, donde se reúnen mentes que quieren emprender o que buscan algo diferente. Ese viernes nos conocimos y, el lunes, nos tocó trabajar juntos en el mismo equipo, un poco por suerte. Ese lunes comentamos que íbamos a trabajar juntos durante los próximos meses, aunque en ese momento no te planteas que tienes delante a la persona que verás todas las mañanas durante los próximos cinco años de tu vida.

Gran parte del desarrollo de Trazable ha implicado mucha investigación, lo que nos ha permitido experimentar con redes como Ethereum, Bitcoin y redes privadas como Hyperledger, en colaboración con proyectos lanzados junto a IBM o Intel, entre otros. También hemos trabajado con blockchains de distintos tipos: públicas, permissionadas, privadas y sin permissionar. Cuando comenzamos Trazable, a finales de 2017, la carrera ya no se centraba tanto en cuál era la blockchain más eficiente, sino en empezar a explotar la capa de aplicación. Esto es parte de la razón por la que Trazable decidió asentarse en ese ámbito y trabajar en llevar esta tecnología a la industria, que aún no la tenía tan comúnmente adoptada. En ese momento, las decisiones sobre qué blockchain utilizar solían basarse en lo que era viable a nivel de negocio y en cómo defender un modelo de negocio. En nuestro caso, al ir a la industria, el gran volumen de transacciones no podía soportar blockchains con altas tarifas, ya que eso desmantelaría cualquier modelo. Esto era especialmente relevante en un momento en el que Ethereum, por ejemplo, experimentaba picos altos en las tarifas.

La mayoría del desarrollo que hemos realizado ha sido en Ethereum, lo que nos ha llevado a profundizar en Solidity. Es un mundo que requiere casi tiempo completo para alcanzar una verdadera experiencia, especialmente con el crecimiento de ese lenguaje y la adopción de la tecnología. Además, cuando observamos el mercado actual de NFTs o tokens, que en última instancia son contratos inteligentes que operan por debajo, a pesar de que existen otros tipos de contratos, es evidente que hemos adquirido mucha experiencia en este ámbito. Puede que no sea la tecnología o el lenguaje más idóneo para comenzar en el desarrollo, pero es una parada obligatoria si eres desarrollador y deseas adentrarte en este mundo. Esto se debe, sobre todo, al mercado de aplicaciones disponibles para desarrolladores que quieren empezar, desde editores de código hasta extensiones. Todos los desarrolladores, en algún momento, tenemos un conjunto de herramientas que nos ayudan en nuestro día a día.

En el caso de Solidity, debo decir que me he apartado de eso desde hace tiempo, así que imagino que el mercado habrá evolucionado mucho. Sin embargo, en aquel momento, cuando estaba trabajando en ello, no era algo tan amigable. Personalmente, me he visto en la necesidad de enfrentarme a otros retos, como escalar el equipo y entender las líneas de desarrollo, así como cómo pueden afectar a la economía de la empresa al desarrollar de una forma u otra. Mi rol ha evolucionado hacia una zona en la que debo trabajar muy de la mano con el negocio, entender sus necesidades y ofrecer la mejor solución. Al final, siempre se busca algo bueno, bonito, barato y rápido, pero lo más importante es llegar.

Cuando hablamos de una tecnología descentralizada como blockchain, nos referimos a que al escribir una pieza de código en Solidity y desplegarla, estás firmando una transacción. Esa transacción es inmutable, lo que significa que lo que hayas introducido allí permanecerá. Por lo tanto, si esa pieza de código tiene un error, el error se vuelve inmutable. De hecho, uno de los miembros del equipo lo apodó "Persistir Bugs", que es uno de los inconvenientes de desarrollar aplicaciones industriales en tecnologías como blockchain. Obviamente, tienes tu entorno de staging, donde puedes realizar pruebas, pero esto cambia tu mentalidad al diseñar aplicaciones, que ya no están hechas para ser actualizadas, sino que deben ser aplicaciones cuya vida en producción sea efímera, preparándote para cambiar a una nueva versión que deberás desplegar, sin poder actualizar la antigua. El diseño de la aplicación debe permitir redirigir todo lo que hayas generado a esa nueva versión. Esto te obliga a pensarlo de otra manera, y ahí radica parte del reto, que también es parte de lo bonito. Sin embargo, tienes más variables; estás en un entorno B2B, vas a la industria, y el volumen de transacciones no solo depende de lo que has desplegado y la lógica que tienes, sino de cómo se comportará esa lógica o esa red en particular en la que se está ejecutando, así como del cliente específico o del sector que comienza a interactuar con esas transacciones.

Decidimos no reinventar la rueda. El token es un estándar, un ERC20, que ya está auditado. En nuestro caso, nos apoyamos en Open Zeppelin, que ya tiene los estándares desarrollados. No tiene sentido volver a hacerlo, ya que lo más probable es que cometas un error y no vale la pena asumir ese riesgo. Por lo tanto, utilizamos contratos inteligentes que ya están auditados y estandarizados, los desplegamos con nuestros parámetros iniciales y ya tenemos algo funcional que se comporta de manera adecuada.

En el caso del sistema de trazabilidad y la tecnología blockchain, cuando Trazable nació en 2017, estábamos en un momento en el que comenzaba a explotar el desarrollo de la capa de aplicación, pero no tanto el desarrollo de una blockchain más eficiente. Era un momento en el que se hacía blockchain para todo. Muchas veces te preguntabas: "¿Hace falta blockchain aquí?" y parecía que sí. Una de las cosas que nos sucedió es que había secretismo en torno a las estrategias de las empresas que fabricaban sistemas de trazabilidad en blockchain, lo que nos obligó a experimentar mucho. Siempre digo que hemos desarrollado alrededor de nueve sistemas de trazabilidad que, en ese momento de tanto hype, se apoyaban completamente en la tecnología blockchain. A medida que aprendimos y evolucionamos, el sistema fue pasando a capas en las que blockchain se utilizaba para lo que realmente tenía sentido, y el resto del sistema que no tenía sentido debía salir de ahí. ¡Chao!

La trazabilidad es un efecto; cuando deseas consultar la trazabilidad de algo, es porque ha habido una serie de hitos que han ocurrido antes. Esos hitos, esas piezas de Lego que forman la trazabilidad, son como las piezas de este algoritmo. Siempre que entramos con un cliente nuevo, necesitamos, primero, evaluar esas piezas y luego saber cómo montarlas para que encajen en nuestro sistema, que es el que evaluará esas piezas y el orden en que entran para poder construir ese "muñeco". Lo que tenemos diseñado es un sistema de trazabilidad que no deja de ser un proceso en el que fabricas un producto. Para ese producto, has adquirido materias primas que, para otro actor o empresa, eran su producto. Con esas materias primas, no solo las has utilizado para tu producto, sino que además lo has distribuido o utilizado, lo que puede convertirlo en un subproducto para la empresa siguiente en la cadena.

Lo que más me atrae ahora mismo, y desde el principio, es la propia criptomoneda de Ethereum, principalmente por la innovación que introdujeron al implementar la máquina virtual. Esto ya no se limitaba a una transacción en la que ibas a persistir información, sino que te permitía, con estos contratos inteligentes, persistir lógicas de negocio. Me sigue pareciendo una maravilla y creo que esa capa de aplicación aún tiene mucho por explorar. Como proyecto, te mencionaría por ejemplo Decentraland, dentro de Ethereum. Es un metaverso, un token diseñado para las personas que construyen dentro de ese entorno, pensado para seguir avanzando e innovando en blockchain. Es ideal que quienes se acerquen ya tengan una base, lo que les ayudará a entender mejor la documentación, que no sea la primera que reciban en su vida, sino que ya sepan de qué se trata. Una vez que entras, es cuestión de paciencia, prueba y error. Lo que aprenderán en Solidity es muy valioso, especialmente cuando lo mezclan con tecnologías de desarrollo web, porque ahí es donde hablamos del Web 3. Podrán crear rápidamente aplicaciones pequeñas que interactúen con contratos inteligentes que ya hayan desplegado, sin necesidad de programarlos desde cero, utilizando estándares. Así, pueden crear su propio camino de aprendizaje que los motive con pequeños hitos y, rápidamente, acabar desarrollando cosas que digan: "¡Ostras! ¡Está bastante bien!".

## E1. Ecosistema DeFi
### Ecosistema DeFi (Video)
![[247.B4E1_Ecositema_Defi.mp4]]
[Ecosistema DeFi](https://app.web3mba.io?wvideo=a3pomhoy07)

Las sidechains son cadenas de bloques paralelas a una mainnet que se han construido para mejorar las prestaciones de esa mainnet. En el caso de Ethereum, las sidechains que se han desarrollado tienen como finalidad mejorar la escalabilidad, reducir las tasas o fees por el uso de la red de Ethereum y aumentar la velocidad. Las sidechains podrían ser utilizadas para facilitar la interoperabilidad con otras cadenas de bloques que también sean principales, como por ejemplo, con Bitcoin.

En el caso de LastChain de Ethereum, utilizan el mismo código y se programan también en Solidity; sin embargo, pueden tener sus propios validadores y su propio algoritmo de consenso. Lo que hacen las sidechains es intercambiar información con la mainnet, con la red principal. En este intercambio de información, siguen unos protocolos en los que, para facilitar las transacciones que se van a realizar en las sidechains, se deben bloquear tokens o criptoactivos en la mainnet. Una vez que han sido bloqueados, la mainnet remite la información a las sidechains, que generan bloques idénticos con el mismo valor para que puedan ser utilizados en la sidechain.

Para transferir la información o los bloques de la sidechain a la mainnet, se realiza el proceso inverso, en el que la sidechain bloquea los tokens que se desean transmitir a la mainnet. Una vez que quedan bloqueados para luego ser destruidos, se liberan los que inicialmente se bloquearon en la mainnet. Las principales ventajas de las sidechains en el caso de la mainnet de Ethereum son la escalabilidad y la reducción de costes. En Ethereum, los costes se han disparado, teniendo en cuenta que es el mejor sistema para ejecutar smart contracts. La mayoría de las sidechains y de los protocolos se están construyendo sobre Ethereum, lo que está provocando una saturación de la máquina virtual de Ethereum, que es la que ejecuta los programas.

Como resultado, Ethereum, que alquila tiempo de esa máquina virtual a quienes desean utilizarla, ha incrementado los costes de uso, que se conocen como gas. Las sidechains facilitan esas transacciones de forma paralela a Ethereum, y al utilizar el mismo sistema y el mismo lenguaje de programación, Solidity, para los desarrollos, es mucho más fácil. Por ejemplo, en el caso de Polygon Network, puede ejecutar hasta 200,000 transacciones por segundo, mientras que Ethereum puede ejecutar unas 15 o 20. Esa rapidez implica un ahorro de tiempo en la máquina virtual y, por tanto, una reducción de costes, además de la escalabilidad para ejecutar muchas más transacciones por segundo.

Las sidechains más conocidas son Polygon Network, que es una solución de escalabilidad y reducción de costes, con tarifas de transacción muy, muy bajas, y que tiene su token nativo, Matic. También tenemos Harmony, Optimistic Network y ZKSync, que es una sidechain de prueba de conocimiento cero, que hace que las transacciones sean mucho más privadas y rápidas al no revelar información de las transacciones. Esto le da a la sidechain una gran ventaja y al entorno DeFi un potencial de desarrollo de aplicaciones para pequeñas transacciones que hasta ahora era desconocido. De hecho, los usuarios que movían pocos recursos o tokens muchas veces no podían hacerlo porque los costes de transacción de Ethereum eran elevadísimos. Con esta sidechain, han podido volver a operar con tranquilidad, ya que no se someten a tasas de costes de hasta 500 euros por transacción para mover un token de un valor de 100 euros, por ejemplo.

Las desventajas de las sidechains son principalmente que no heredan la seguridad de la mainnet y que suelen ser más centralizadas que las mainnets. Por tanto, esto va en contra de los principios de descentralización, dependiendo de cómo esté articulada la sidechain. El potencial futuro de las sidechains es precisamente complementar a las mainnets, reducir la volatilidad, disminuir las fees, facilitar la liquidez en las operaciones y, por tanto, implicar un mayor desarrollo de las finanzas descentralizadas, o DeFi.

Los exchanges descentralizados son una evolución de los exchanges centralizados que han dominado el mercado de las criptomonedas hasta la fecha. No obstante, también suponen un cambio de paradigma en el mundo de las finanzas, al permitir que el usuario común maneje y cree instrumentos financieros que hasta ahora eran prácticamente imposibles de acceder. Es decir, hasta la llegada de las finanzas descentralizadas construidas sobre la blockchain, era prácticamente imposible que un ciudadano promedio pudiera facilitar liquidez a un mercado de valores o dar préstamos a desconocidos y arriesgarse en las transacciones. Sin embargo, las finanzas descentralizadas han proporcionado la facilidad de creación y utilización de productos financieros a los usuarios, algo que antes era desconocido.

En el mundo de los criptoactivos, solo se podía operar a través de los exchanges. Sin embargo, con la llegada de las finanzas descentralizadas, se ha eliminado a los intermediarios, a esa autoridad central que manejaba el sistema de intercambio de tokens, permitiendo hacerlo de forma directa, anónima y descentralizada entre los usuarios. Esto ha ampliado la utilización de los criptoactivos, creando un nuevo sistema financiero paralelo al tradicional.

Las características principales de los DEX son la seguridad, ya que para utilizar los DEX se deben cumplir ciertos códigos de programación; la privacidad, porque la utilización de las finanzas descentralizadas no necesariamente requiere identificación del usuario; y el anonimato, ya que lo que se registra en la cadena de bloques no está personalizado o identificado, solo se registran las wallets y las transacciones. En los exchanges tradicionales, cuando alguien quiere hacer un intercambio de tokens o comprar un criptoactivo con fiat o convertirlo a fiat, utiliza el servicio que ofrece una empresa, una autoridad central, donde ellos ya tienen los tokens previamente comprados en sus bóvedas, y lo que hacen es hacer una anotación en cuenta. Es decir, ves un saldo, como el que puedes ver en tu cuenta bancaria, pero realmente no tienes nada.

Al utilizar las finanzas descentralizadas, cuando deseas hacer una transacción, acudes a un contrato inteligente o a un DEX, donde están las bóvedas construidas y donde aportas tu criptoactivo para intercambiarlo con otro. En ningún momento pierdes el control de tus criptoactivos. Cuando entregas el tuyo, recibes el otro. En un exchange centralizado, cuando depositas tu criptoactivo, pierdes el control de ese activo porque lo maneja el exchange centralizado, y lo que te dan en contraprestación es simplemente una anotación en cuenta; no tienes la propiedad de ese token.

Las DeFi son fomentadas por los desarrolladores o por las personas que crean los instrumentos financieros, promoviendo la participación de inversionistas, es decir, que aporten sus tokens o liquidez. Para ello, se diseñan sistemas de retribución para premiar la participación, generando un ecosistema alrededor de las DeFi que favorece la entrada de liquidez y un aumento del valor bloqueado en dólares con un crecimiento exponencial. En cuanto a los tipos de exchanges descentralizados, nos encontramos con los que son Order Book on Chain, los Order Book off Chain y los AMM.

Los Order Book on Chain son aquellos que registran sus operaciones en la blockchain. Como ventaja, tienen más transparencia; como contrapartida, tienen un mayor coste. Es decir, cuando en una web o en una app realizas una operación y se debe registrar la orden de compra o intercambio, la modificación o cancelación, eso genera unas fees. Sin embargo, en los Order Book off Chain, que no registran las órdenes en el libro de operaciones, las operaciones se realizan dentro del Smart Contract, y en la blockchain solo se registra el depósito de tu token y la salida del otro token, pero no las operaciones intermedias.

El tercer tipo de exchange descentralizado son los AMM o Automatic Market Makers, que son contratos inteligentes que utilizan oráculos para realizar intercambios. Estos oráculos consultan a un agente externo los precios de los tokens para llevar a cabo los intercambios. Además, los AMM están regidos por algoritmos que moderan el precio fijado por el oráculo en función de la demanda de un token o de otro, para no desequilibrar los pools, en este caso, los pools de liquidez. Estos AMM no requieren libros de órdenes porque los precios ya están prefijados por el oráculo y el algoritmo, por lo que no necesitan registrar órdenes de compra, órdenes de venta, ni modificaciones ni cancelaciones. En estos casos, en ningún momento se sacrifica la custodia de los tokens, ya que las operaciones son directas.

Los AMM más conocidos en el mercado son Uniswap, SushiSwap, Kyber, Balancer y Pancake Swap. Las ventajas de los DEX, como ya hemos mencionado, son la confiabilidad, el anonimato, la privacidad y la robustez de los servicios. Cuando se realizan operaciones en exchanges centralizados, existe el riesgo de que el sistema se caiga o se bloquee, lo que ha ocurrido en diversas ocasiones y ha causado enormes problemas, especialmente al ejecutar transacciones. Sin embargo, cuando se utilizan aplicaciones descentralizadas, es prácticamente imposible que el servicio se caiga.

Por otro lado, una de las ventajas más significativas de las finanzas descentralizadas es que se puede acceder a tokens que no están listados en los exchanges. Esto puede ofrecer cierta ventaja al poder acceder a esos tokens no listados antes de que salgan al público, o bien porque no van a salir nunca en los exchanges por tener otras finalidades que no sean especulativas. En cuanto a las desventajas de los exchanges descentralizados, la principal es la usabilidad. No es sencillo usarlos por primera vez, y tampoco es fácil incluso para personas que ya tienen conocimiento. Hay que estar muy atentos y saber bien cuáles son los pasos que se deben seguir para ejecutar con éxito una transacción, ya que, en caso de error, se pueden perder los fondos. De hecho, es muy recomendable que siempre que se utilice un DEX, se haga una prueba con una pequeña cantidad de tokens o de poco valor.

La interoperabilidad es otro de los inconvenientes de los DEX, ya que estos solo operan dentro de su cadena principal. Es decir, si se desea intercambiar tokens por otros que pertenecen a otra cadena, se debe recurrir a otro tipo de servicios, también descentralizados, que serían los bridges, para poder intercambiarlos. Por otro lado, las órdenes que se pueden dar en los exchanges descentralizados son bastante limitadas; son limitadas a market, y no se pueden realizar otros tipos de órdenes que sí permiten los exchanges centralizados. Además, los tiempos de operación en los exchanges descentralizados suelen ser más largos, ya que se debe ejecutar o validar la transacción dentro de la blockchain. Cuando se utiliza un exchange centralizado, la transacción se valida automáticamente por esa autoridad central, y esa validación no se registra en la blockchain.

Por último, el tema de la liquidez en los exchanges descentralizados es importante. Hay que estar atentos a la liquidez depositada, ya que a menor liquidez, mayor coste de transacción o incluso imposibilidad de realizarla. Las DAOs son organizaciones autónomas descentralizadas donde la gobernanza se ejerce por sus miembros sin la intervención de una autoridad central y sin que nadie ejerza un liderazgo. Es decir, no hay una jerarquía entre los miembros de la comunidad. Estas DAOs se rigen por potentes smart contracts, programados con determinadas reglas que se ejecutan de forma automatizada. Esto impide conflictos en la ejecución y evita que alguien pueda tomar el poder dentro de una comunidad.

Las DAOs operan sobre la blockchain, lo que tiene la ventaja de que se registran en esa blockchain todas las operaciones que se realizan, es decir, propuestas que se lanzan y resultados de las votaciones cuando se llevan a cabo. Esto permite que en cualquier momento se pueda consultar esa información, ya que es pública e inalterable, lo que le da mucha seguridad a ese sistema de gobernanza a través de la DAO. Para utilizar una DAO, se debe hacer a través de tokens de gobernanza y, a veces, se utilizan tokens de financiación. La cuestión es que para poder utilizar esos tokens de gobernanza se debe promover el uso de la DAO, y para ello, muchas veces en las finanzas centralizadas, los rendimientos que se pagan son en forma de token de gobernanza, para luego poder participar en la toma de decisiones en las DAOs.

Esto crea, a su vez, un nuevo ecosistema monetario alrededor de la DAO, en el que se puede transaccionar con esos tokens de gobernanza. En función de la implicación de cada uno, podrá adquirir más o menos tokens de gobernanza para poder votar. Por poner un ejemplo de lo que podría ser el uso de una DAO trasladado a la vida real, podríamos hablar de una comunidad de vecinos. Una comunidad de vecinos que se erija a través de una DAO, programada previamente en smart contracts, establecería una serie de reglas, como las cuotas de cada uno de los vecinos, que reflejarían sus derechos de voto, y el sistema de votaciones, adaptándolo a la ley.

Esto serviría, por ejemplo, para decidir sobre qué gastos se pueden cubrir con los fondos de la comunidad. Si se autoriza el pago de un gasto, como la reparación del ascensor, esa propuesta se presentaría a la DAO, y los vecinos votarían en función de su cuota de participación dentro de la DAO. Una vez que se aprobara la propuesta, la DAO liberaría el importe para poder pagar los gastos del ascensor. Esto impediría que, por ejemplo, el presidente de la comunidad pudiera destinar el dinero a fondos distintos que no fueran los gastos del ascensor, que era lo que se había aprobado. Por tanto, las DAOs tienen una utilidad práctica y un potencial enorme en la vida real.

Las ventajas de las DAOs son numerosas. Para empezar, no establecen un sistema de jerarquización entre sus miembros. Por otro lado, no están vinculadas a ninguna ley; es decir, las normas que regulan la DAO son las que se programan y se ejecutan. Si esa DAO se tuviera que adaptar a un uso en la vida real que estuviera regulado, lo que se regularía sería el uso, no la DAO en sí misma. Además, las DAOs otorgan un alto nivel de transparencia a los procesos de votación y a las propuestas, lo que beneficia a los usuarios al saber qué se ha aprobado y cómo se ha aprobado.

Por otro lado, son servicios que pueden ser utilizados a nivel global, ya que eliminan papeleos o votaciones presenciales, que están empezando a cambiar ahora, después de tantos años. Con una DAO, puedes votar o participar desde cualquier parte del mundo sin necesidad de estar presente en ninguna reunión. Además, la facilidad de creación de las DAOs es notable, porque, aunque sean a través de smart contracts, ya se pueden crear vía API o hay servicios donde puedes acceder a tu propia DAO, evitando gastos económicos, papeleo, la presencialidad en las reuniones y, sobre todo, tiempo, ya que es mucho más rápido votar las propuestas de una DAO que hacerlo por los sistemas ordinarios.

Las desventajas de las DAOs incluyen la necesidad de una programación correcta para evitar conflictos de ejecución y, por otro lado, la posibilidad de que, cuando empiecen a regularse en el futuro, los reguladores quieran controlarlas o controlar su uso. Un ejemplo conocido de DAO es The DAO, que estaba construida sobre Ethereum y cuya finalidad era la creación de un fondo de capital riesgo para financiar proyectos de crowdfunding. Esta DAO fue creada por los hermanos Simon y Christoph Jeff, y el problema que tuvo fue que, después de ser muy exitosa en la recaudación de fondos, alcanzando 150 millones de dólares en poco tiempo, resultó que tenía un fallo de programación. Ese fallo permitió que un hacker robara 50 millones de dólares, lo que terminó con el proyecto de DAO que tenía un gran futuro, pero estaba sometido a problemas de programación. Esta es una de las grandes desventajas que tiene una DAO si no se cuenta con la seguridad en la programación.

Otros ejemplos de DAOs conocidas son Dash DAO Governance o DigiDAOX, que tienen como finalidad la gobernanza de sus protocolos para mejorar los mismos, ya que están descentralizados y no dependen de una sola persona o empresa. Las DAOs tienen un importante potencial disruptivo, ya que crean una nueva forma de gobernanza de las comunidades, ya sean en entornos cripto o en la vida real, con un potencial de uso hasta la fecha desconocido. Las blockchains que operan en este momento son incompatibles entre sí. Sin embargo, la aparición de las finanzas descentralizadas está requiriendo la interconexión entre esas blockchains, y una de las formas en que se está logrando es a través de los bridges.

Los bridges son sistemas que se colocan entre dos blockchains y que permiten la transmisión de información entre ambas. Por ejemplo, se utilizan para realizar operaciones o para reemitir criptoactivos de una blockchain a otra. Un bridge debe ser visto como un intercambiador de tokens de una cadena por tokens de la otra cadena de bloques. Para ello, se llevan a cabo cuatro fases. La primera es que el bridge debe estar habilitado para conectar esas dos blockchains, que llamaremos blockchain A y blockchain B. Cuando queremos transmitir tokens de A a B, lo que se hace es, en la DApp creada para ello, conectar la wallet. En esa wallet que está corriendo en la red A, depositamos los tokens que queremos intercambiar, y lo que hace el smart contract que rige el bridge es bloquear esos tokens dentro de la blockchain A.

Una vez procesada la información, el bridge comunica a la blockchain B que va a reemitir los tokens. Lo que hace esa blockchain B es generar una cantidad idéntica de los mismos tokens bloqueados en A, por el mismo valor, que son depositados en la billetera previamente designada por el usuario que está haciendo el intercambio. Un bridge, por poner un ejemplo, funcionaría de la siguiente manera: si tenemos 1,000 USDT que están corriendo dentro de la blockchain de Ethereum, porque son ERC20, y los queremos enviar a la red de Polygon Network, lo que tenemos que hacer es ir a un bridge. En ese bridge, conectaríamos nuestra Metamask o nuestra wallet en la red de Ethereum, depositaríamos nuestros 1,000 USDT, y automáticamente lo que hace el smart contract es comunicar que se han bloqueado esos 1,000 USDT y que, por tanto, en Polygon Network se deben generar otros USDT que serán depositados en nuestra Metamask en la dirección que hayamos indicado.

Dentro de la red de Polygon Network, esos tokens quedan allí bloqueados. Se puede realizar el proceso inverso para liberar esos tokens que se han bloqueado en Ethereum, es decir, se puede ir de Polygon a Ethereum haciendo el proceso inverso, depositando los mismos tokens de Polygon para que sean quemados y se recuperen luego en Ethereum. Hay dos tipos de bridges: los centralizados y los descentralizados. Los bridges centralizados requieren que vayas a un CEX, donde ese propio bridge ya tiene los tokens de una y otra cadena, y lo único que hace es un intercambio interno y te devuelve los tokens que querías cambiar. Por ejemplo, tenemos el Zoom Bridge centralizado.

Luego tenemos los bridges descentralizados, que funcionan de forma autónoma sin estar sujetos a una entidad central. En este caso, lo que se hace es, como hemos explicado anteriormente, depositar el token, reenviar la información a la otra cadena para que genere los nuevos tokens en la otra cadena y bloquear los iniciales. Esto es más lento y está sujeto a mayores tasas de transacción, pero, por el contrario, uno no pierde el control de los tokens en ningún momento.

Las finanzas descentralizadas sobre blockchain han abierto un vasto mundo de instrumentos financieros que pueden ser utilizados por los usuarios para realizar todo tipo de inversiones. En el caso del lending, ofrece una gran multitud de ventajas tanto para los prestatarios como para los prestamistas. El lending tiene la ventaja de facilitar el uso de tus criptoactivos cuando no deseas desprenderte de ellos. Por ejemplo, si una persona tiene Bitcoin y no quiere desprenderse de él, pero sí desea aprovechar su valor, puede pedir un préstamo, dando esos Bitcoin como garantía. En función de cómo esté programado el contrato de préstamo, el smart contract le otorgará una cantidad de dinero. Así, conservará sus Bitcoins y, además, tendrá parte de la liquidez de esos Bitcoins que podrá utilizar.

Igualmente, aquellas personas que deseen ceder sus criptoactivos para prestárselos a otros pueden hacerlo sin correr el riesgo de impago. El lending puede funcionar de dos maneras: con garantía o sin garantía. Los préstamos con garantía, que se llaman colateralizados, son aquellos en los que el solicitante, el prestatario, solicita un préstamo depositando sus criptoactivos como garantía. En función del protocolo donde se solicite ese préstamo, se le dará acceso a un mayor o menor crédito. ¿Qué ocurre? Cuando se deposita el colateral, es decir, la garantía, se recibe a cambio un importe en otra cripto, que normalmente suele ser una stablecoin. Con esa stablecoin, luego se puede aplicar a los usos que el prestatario desee.

En el préstamo colateralizado se establecen una serie de garantías o requisitos que son el plazo de devolución, los intereses y el valor de liquidación. Los préstamos con criptoactivos se pueden hacer de dos maneras: con garantía o sin garantía. Cuando se hace con garantía, se habla de lending colateralizado, que consiste en que el prestatario solicita un préstamo dando como garantía sus criptoactivos. En función del protocolo que se esté utilizando, tendrá más o menos liquidez para obtener a cambio de su garantía, y además se le impondrán las condiciones de plazo de devolución, intereses y valor de liquidación. Es importante tener en cuenta estos tres factores, ya que los préstamos deben devolverse antes de que se cumpla el plazo, porque si no, se liquidará el colateral, es decir, se venderá en el mercado para cobrarse el préstamo, el interés y el coste que le está suponiendo.

Sobre todo, el valor de liquidación es crucial, ya que si se aporta un criptoactivo con cierta volatilidad o se encuentra en un periodo de alta volatilidad del mercado, se puede perder valor frente al préstamo recibido. En caso de que se supere el límite programado, esa garantía se venderá automáticamente para pagar el préstamo, sin contar con la intervención del deudor. Por otro lado, podemos estar en el lado del prestamista. Uno puede ceder sus préstamos con la garantía de que siempre va a cobrar, porque habrá un colateral que respalde el dinero que presta, ya sea en dinero o en tokens.

El otro tipo de lending son los flash loans, que son préstamos rápidos que se conceden y se pagan en la misma transacción, y se utilizan mucho para arbitraje. Casos habituales de lending en cripto incluyen situaciones como tener criptoactivos que no son líquidos y querer fiat. Es decir, si deseas utilizar tus ahorros para comprar, por ejemplo, Bitcoin o Ethereum, pero no quieres perder el poder adquisitivo o la liquidez que eso te proporciona, puedes depositar esos criptoactivos en un protocolo de lending. A cambio, te facilitarían una stablecoin que luego cambiarías por dinero fiat y podrías utilizar, siempre y cuando cumplas con los requisitos de pago anticipado del vencimiento o que el valor de tu colateral no se reduzca por debajo del valor de liquidación.

Puedes utilizar ese dinero que has conseguido en fiat, y cuando consideres que se ha revalorizado el colateral, puedes vender parte del colateral y pagar la deuda, o bien hacer el proceso inverso de convertir fiat a una stablecoin y pagar el préstamo que has recibido. Otra forma de utilizar el lending es como producto de inversión. Como producto de inversión, podrías prever una bajada del mercado, solicitar un préstamo en USDT contra un criptoactivo que preveas que va a reducir su valor, y cuando haya disminuido su valor, pagar el préstamo con la stablecoin. ¿Qué ocurre? Te quedas con la ganancia de la diferencia de valor, porque pagas en la cripto que has recibido.

Los NFT no son criptoactivos líquidos, y sin embargo, últimamente nos encontramos con que hay NFTs que tienen un altísimo valor, pero sus propietarios no quieren desprenderse de ellos porque no tienen la opción de fraccionarlos. El mercado, en la evolución que están teniendo las finanzas descentralizadas, ha desarrollado herramientas e instrumentos que permiten solicitar préstamos dando como garantía tu NFT. Tu NFT se convierte en un colateral; lo depositas como colateral, recibes el importe del préstamo y tienes tus condiciones de devolución. Si no se devuelve el préstamo antes del vencimiento, el prestamista se quedará con el NFT.

En cuanto al lending de NFTs, hay dos formas: peer-to-peer y peer-to-protocol. En el peer-to-peer, el préstamo se realiza a través de un smart contract entre dos personas de igual rango. El NFT se aporta como colateral y se queda bloqueado en el smart contract hasta que se cumplan las condiciones para volver a liberarlo o, en su defecto, liquidar el NFT y entregárselo al prestamista. Esto funcionaba de una manera similar a como funcionaba antiguamente Aave. Por otro lado, en el peer-to-protocol, lo que se hace es depositar el NFT en una especie de pool de liquidez, donde el prestatario, el depositante, recibe el importe del préstamo y un LP. Para poder recuperar el NFT, tendrá que devolver el importe del préstamo, y entonces se procederá a la liquidación del LP y a la entrega del NFT.

Algunas de las plataformas de lending de NFT más conocidas son NFTfi, Drops, JPG y Sodium. Los Pool Staking son una figura poco conocida en las cadenas de bloques que se han puesto de moda desde que Ethereum activó el Staking para poder ser validador de sus bloques. Para ser validador de Ethereum, hay que dejar en Staking 32 Ether, una cantidad de valor importante que no cualquier persona puede utilizar. Sin embargo, las finanzas descentralizadas permiten agruparse con otras personas para crear un Pool Staking o participar en él y así beneficiarse de las recompensas que se reparten en la validación de los bloques.

¿Cómo funciona? Existen nodos validadores de una cadena de bloques, y quienes deseen participar en la validación crean un pool para unirse a esos validadores. En función de la cuota que aporte cada uno de los participantes, se repartirán las ganancias obtenidas como consecuencia de la validación de los bloques de la cadena. Cada pool tiene sus propias condiciones y beneficios, por lo que hay que tener en cuenta en qué pool se va a hacer staking con los criptoactivos que se van a depositar. ¿Por qué? Porque puede haber pools en los que se permita participar en los procesos de decisión a la hora de ejercer los derechos de gobernanza del pool, y otros que simplemente permitirán hacer staking, dejando bloqueados tus criptoactivos durante un tiempo y limitándote a percibir los APY que se repartan.

Esto significa que se puede producir un proceso inverso a la descentralización. En un pool en el que no se te permita participar, quien gestione el pool tendrá todo el poder de decisión sobre los derechos de gobernanza que ofrecen los criptoactivos depositados. Las ventajas de participar en un pool de staking son, por un lado, las recompensas que se reparten, aunque no es el principal atractivo; la principal característica es poder participar en la validación y la gobernanza de la blockchain. Cuando depositas los criptoactivos de la blockchain dentro de los pools, transmites confianza al mercado sobre esa blockchain.

Las desventajas del pool staking son, por un lado, el bloqueo de tus tokens durante un periodo de tiempo y, por otro lado, el menor rendimiento de esos criptoactivos en comparación con si hicieras tú el staking por tu cuenta fuera del pool. Los pools de staking perciben recompensas por el trabajo de validación que realizan de los bloques, y esa recompensa se reparte proporcionalmente entre todos los participantes en función de las cantidades que hayan dejado en staking.

GameFi proviene de las palabras "game" y "finance", es decir, juego y finanzas. Es el término que se refiere a los juegos del tipo play-to-earn, es decir, aquellos juegos que recompensan a los usuarios para fomentar el uso del juego. En estas partidas, los jugadores obtienen recompensas, no solo por mejoras de armas, personajes o mascotas, sino que esa forma de recibir recompensas se hace a través de criptoactivos, lo que permite crear una economía alrededor del juego e incluso fuera de él. Dentro del juego, con esas recompensas que has obtenido, puedes venderlas, hacer staking, transaccionar con ellas o incluso llevarlas al ecosistema DeFi para utilizarlas como producto de inversión o venderlas fuera del juego.

Por ejemplo, en el caso de Decentraland, puedes comprar LAND o obtener MANA y utilizarlos dentro de Decentraland haciendo staking, o puedes ir a un mercado secundario, es decir, a un DEX, y vender o hacer staking con tus tokens obtenidos de Decentraland. El Yield Farming es uno de los conceptos que más se ha mencionado en los últimos tiempos y consiste en la agricultura de rendimiento, es decir, en obtener algún tipo de rentabilidad de todos los criptoactivos que tengamos de forma permanente y regular. El objetivo del Yield Farming es poner tus criptoactivos a producir rendimientos de forma continua, depositándolos en una DApp o en un contrato inteligente que te pague rendimientos. A su vez, el propio token que te están facilitando, incluso los rendimientos, pueden ser utilizados en otros protocolos para generar nuevos rendimientos, ya sea por intereses, por el cobro de fees o por recompensas. De esta manera, tus criptoactivos generan constantemente.

Esta es una estrategia que están utilizando inversionistas y grandes capitales para obtener altos rendimientos, ya que se pueden producir rendimientos sobre los propios rendimientos que te están dando el primer criptoactivo que invertiste. Las ventajas del Yield Farming son, por un lado, la percepción de importantes rendimientos una vez que se han producido los períodos de cosecha, que suelen ser entre seis meses y un año, en los que los inversores han acumulado suficientes recompensas y beneficios, que a su vez vuelven a reinvertir para generar mayores ganancias. Por otro lado, otra ventaja es la existencia de protocolos aprobados y fiables que brindan seguridad al ecosistema para invertir a través de ellos.

Como contrapartida, en desventajas hay que tener claro que el Yield Farming son estrategias complejas y hay que entenderlas muy bien, así como el proceso de funcionamiento, porque esa complejidad va acompañada del pago de comisiones. ¿Cómo se hace para evitar que el Yield Farming se desvanezca? Para realizar una estrategia de Yield Farming, se salta de un protocolo a otro, lo que genera nuevas comisiones, y si la estrategia no es correcta o deseas modificarla, debes deshacerla, lo que implica un importante gasto en comisiones. Esto es menos perjudicial para quienes invierten grandes cantidades de tokens de alto valor, y no para aquellos que, a lo mejor, invirtiendo tokens por valores de 500 euros, pueden dejar en comisiones 200 o 300 dólares sin ningún problema.

Por otro lado, otro de los inconvenientes del Yield Farming es que, al ir saltando de protocolo en protocolo, aumentas el riesgo de fallo del protocolo, ya sea por error de programación o porque ha sido hackeado. El hecho de que muchos de estos protocolos estén auditados no garantiza que estén bien programados. Como protocolos de referencia para desarrollar la actividad de Yield Farming, tenemos Aave, que es uno de los más veteranos, que nació en 2017 y que en su ICO consiguió recaudar 17 millones de dólares. Su finalidad es prestar un servicio de préstamos con tipos de interés calculados algorítmicamente, facilitando las transacciones de préstamo y de recepción. Esta plataforma ha tenido tanto éxito que ha llegado a tener un valor bloqueado de 1,500 millones de dólares.

Otra de las plataformas que más éxito ha tenido últimamente es Uniswap, que es un exchange descentralizado donde se pueden crear todo tipo de instrumentos financieros de forma sencilla. Cualquier persona puede crear una bóveda para formar un pool de liquidez, aportar capital a determinados rangos de precio para realizar operaciones de liquidez, y se caracteriza por su sencillez y seguridad. Como conclusión, en el ecosistema de finanzas descentralizadas, lo que podemos apreciar es que se está creando un nuevo sistema financiero paralelo al real, en el que cualquier persona puede acceder a las operaciones, tanto para invertir como para crear sus propios productos financieros, algo que antes estaba reservado a las grandes instituciones financieras e incluso a los estados.

Es cierto que la falta de regulación de estos sistemas de inversión puede provocar conflictos y situaciones complejas, generando inseguridad en el mercado. Sin embargo, también es lo que genera precisamente esa innovación y esa inversión por parte de actores cada vez más importantes, lo que le irá dando seguridad a este mercado y a este sistema de inversión en finanzas descentralizadas, que, desde luego, se puede entender como el futuro, y ya no es un monopolio ni de los estados, ni de los bancos, ni de las grandes instituciones financieras.

### Sidechains en Ethereum
Las Sidechains son cadenas de bloques alternas que nacieron para mejorar las prestaciones de una Blockchain ya existente y superar sus limitaciones.

En el caso de Ethereum, las Sidechains se enfocan, por ejemplo, en dar una solución eficiente a sus problemas de escalabilidad para reducir las tarifas prohibitivas de operar en la red y mejorar su rendimiento y eficiencia. O bien, se enfocan en optimizar la privacidad de la Blockchain.

También existen Sidechains que ofrecen interoperabilidad y ayudan a Ethereum a interconectarse con otras cadenas de bloques como Bitcoin. Lo que ha desbloqueado nuevas posibilidades y casos de uso para estas Blockchain y para la industria cripto.

**Las Sidechains o cadenas de bloques alternas se ejecutan en paralelo a la red principal, aunque operan de forma independiente y pueden utilizar sus propios algoritmos de consenso.**  
  
En el ecosistema de Ethereum, que actualmente utiliza el algoritmo de consenso Proof of Work (PoW), existen sidechains basadas en el algoritmo Proof of Stake (PoS) como Polygon Network. Otras como Harmony utilizan una variación de este mecanismo de consenso, como el ==Effective Proof-of-Stake (EPoS).==

![[248.B4E1_sidechains.png]]

#### ¿Qué son las Sidechains?
Son cadenas de bloques laterales o secundarias independientes que funcionan como un protocolo o solución que se ejecuta paralelo a la mainnet o red principal.

Su objetivo es el de complementar u optimizar el funcionamiento de las cadenas de bloques existentes. 

Las Sidechains mantienen su propio grupo de nodos o validadores, que son responsables de verificar y confirmar las transacciones que ocurran dentro de la red.

#### ¿Cómo funcionan?
Las Sidechains se crearon para facilitar la transferencia y el intercambio de activos entre las cadenas de bloques. 

De esta manera, aunque cada una cuenta con las características y capacidades con las que fue diseñada, es posible mover y gestionar criptomonedas u otros criptoactivos de forma segura entre la mainnet y la Blockchain lateral.

Aunque su funcionamiento es bastante complicado, técnicamente, para utilizar una sidechain es necesario enviar criptoactivos a una dirección específica de la red. Los activos enviados serán bloqueados mientras se comprueba que estos no están siendo utilizados en otro lugar. Este proceso de verificación se realiza para evitar el doble gasto. Una vez que la información se confirma, se envía una notificación de la transacción completada a la sidechain, para crear y liberar, de manera automática, el número exacto de activos en criptomonedas enviados a la dirección de la red lateral.  
  
El proceso a la inversa también es posible, para enviar de vuelta criptomonedas desde la sidechain a la red principal. E**sto gracias a que las Sidechains implementan un mecanismo de conexión bidireccional que permite importar o devolver activos hacia o desde la Blockchain lateral.** Además, las Sidechains facilitan este proceso de intercambio de forma segura para los usuarios.

#### Interoperabilidad entre cadenas de bloques
Aunque su diseño e implementación no es nada sencillo, las Sidechains facilitan a los desarrolladores un sinfín de tareas.

Por ejemplo, en Ethereum, gracias a que utilizan la Ethereum Virtual Machine (EVM), las Sidechains funcionan de la misma forma que lo hace la red principal.

De este modo, si un desarrollador que ha construido una aplicación descentralizada en Ethereum luego quiere implementarla en una sidechain, podrá hacerlo con solo llevar su código a la cadena de bloques lateral.

#### Rendimiento y escalabilidad
**Las Sidechains de Ethereum aumentan, significativamente, las capacidades de la red principal de gestionar transacciones y soportar su creciente uso y demanda.**

La mainnet de Ethereum es capaz de procesar unas 15-20 transacciones por segundo en su estado actual, mientras que **Sidechains como Polygon Network** ofrece un límite teórico de al menos 200 mil transacciones por segundo.

#### Las Sidechains de Ethereum
Las cadenas de bloques laterales más populares que existen en Ethereum son:
1. Polygon Network
2. Harmony
3. Optmism
4. ZKSync

##### 1 | Polygon Network
Es una plataforma centrada en ofrecer soluciones de escalabilidad a proyectos Blockchain que hacen vida en la red Ethereum.

Se trata de una plataforma abierta donde los desarrolladores pueden construir aplicaciones descentralizadas, escalables y fáciles de utilizar con tarifas de transacción muy bajas. Además, garantiza un alto nivel de seguridad y confiabilidad.  
  
**En Polygon, los desarrolladores pueden combinar lo mejor de la red Ethereum con otras cadenas de bloques.** Polygon ofrece un sistema multicadena completo con el que busca hacer de Ethereum una red y ecosistema Blockchain interoperables y más accesible a todos.

##### 2 | Harmony
Harmony es una de las Sidechains de Ethereum que ofrece uno de los ecosistemas multicadena más completos y escalables.

Los desarrolladores de esta cadena lateral aseguran una finalidad de transacción de 2 segundos y tarifas 100 veces más bajas que en la mainnet. Además de esto, Harmony ofrece interoperabilidad entre la Blockchain de Ethereum y otras 3 redes, incluidas Bitcoin y Binance Chain, permitiendo a los usuarios interactuar con DApps, smart contracts, protocolos DeFi, DAOs, NFT y Web3 de forma accesible, simple y segura.

##### Optimism Network
Optimism es una sidechain construida para ofrecer transacciones seguras, de bajo costo y ultrarrápidas en Ethereum.

Se trata de una cadena de bloques secundaria de código abierto, segura, sin permisos y descentralizada que desarrolla una solución de Optimistic Rollup **compatible con la Ethereum Virtual Machine.**

##### ZKSync
ZKSync es considerado por sus desarrolladores como “el primer paquete ZK compatible con EVM”, que permite aumentar la escalabilidad de la red Ethereum sin comprometer su seguridad.

Esta solución, centrada en la escalabilidad y privacidad, implementa las pruebas de conocimiento cero (zk) para reducir la necesidad de espacio dentro de la Blockchain, por lo que es posible realizar pagos altamente escalables y de bajo costo dentro de la red.

#### Ventajas y desventajas de las Sidechains
Una de las mayores ventajas que ofrecen las Sidechains de Ethereum es el mejoramiento del rendimiento y escalabilidad de la red principal.

**Gracias a que Ethereum es el ecosistema más prolífico para el desarrollo de aplicaciones descentralizadas y smart contracts, su popularidad le ha costado velocidad y eficiencia.** **Esta problemática la solucionan las Sidechains, que hacen frente a sus problemas de saturación, congestión y altos costes de forma efectiva y eficiente.**  
  
Asimismo, al ser compatibles con Ethereum, las Sidechains permiten conectarse a la cadena principal de forma fácil y sencilla, por lo que es posible interactuar con la mainnet aunque ambas cadenas utilicen mecanismos de consenso diferentes. Esta interoperabilidad entre cadenas también es posible fuera del ecosistema de Ethereum. De este modo, las Sidechains pueden habilitar la transferencia de bitcoins y otras criptomonedas a otras Blockchain como Ethereum.

> Otra de las ventajas que ofrecen las Sidechains es que pueden servir para agregar nuevas funcionalidades únicas a una Blockchain, sin necesidad de alterar el protocolo de la misma.
  
No obstante, aunque las cadenas de bloques laterales ofrecen un gran número de ventajas y facilitan muchas tareas, **en su mayoría sacrifican la descentralización.** Asimismo, cada cadena lateral es responsable de su propia seguridad, por lo que no por ser compatible con Ethereum significa que herede su nivel de seguridad.

#### El potencial de las Sidechains
Las Sidechains, gracias a su capacidad de facilitar el intercambio de criptoactivos entre la cadena lateral y la cadena principal, han ampliado significativamente los casos de uso y aplicación para las criptomonedas y las finanzas descentralizadas (DeFi).

Teóricamente, las Sidechains pueden contribuir a solucionar la falta de liquidez en Bitcoin, reducir la volatilidad, aumentar la seguridad y reducir la fragmentación del mercado o evitar el fraude que, en ocasiones, se ha observado con algunos proyectos de altcoins.

### Exchanges Descentralizados DEX
Los exchanges descentralizados o DEX (Decentralized Exchange) son la evolución de los exchanges tradicionales y trasladan todo su funcionamiento a la Blockchain.

Pueden definirse como casas de cambio digitales diseñadas para intercambiar tokens y criptomonedas de forma directa, anónima y sin intermediarios. 

Estas plataformas digitales utilizan potentes smart contracts para manejar todas sus operaciones.  
  
Dentro de los exchanges descentralizados o DEX, los usuarios pueden realizar operaciones de intercambio y comercio de tokens peer-to-peer, directamente entre inversores. Lo que permite que la confianza y el manejo de los fondos no recaiga en una figura central. Sino que, por el contrario, los usuarios del exchange descentralizado puedan mantener en todo momento el control absoluto sobre sus activos digitales.  
  
Esta característica, propia de los DEX, agrega un alto nivel de seguridad, privacidad e, incluso, anonimato a la hora de operar con tokens y criptomonedas dentro de este tipo de casas de cambio.

![[249.B4E1_dex.png]]

#### DEX | Exchanges descentralizados
Los exchanges descentralizados son plataformas construidas en la cadena de bloques que facilitan el intercambio de diferentes criptoactivos (como las criptomonedas, las stablecoins y otros tokens) de forma descentralizada y sin una figura central.

Su centro de servicio es operado por código, es decir, por un Smart Contract, lo que permite eliminar la necesidad de una figura central o de intermediarios al realizar intercambios. De este modo se brinda un mayor nivel de seguridad y transparencia en las operaciones de los usuarios.

#### ¿Cómo funcionan los DEX?
Los DEX funcionan como una plataforma donde los usuarios pueden realizar transacciones on chain de forma directa entre pares, sin necesidad de revelar su identidad ni ceder la custodia o control de sus activos en ningún momento.

En los DEX que utilizan libros de órdenes como los exchanges tradicionales, los contratos inteligentes registran las órdenes o peticiones de los usuarios en la cadena de bloques.

Una vez que los Smart Contracts encuentran una coincidencia para las órdenes programadas, en el par comercial y a la tasa indicada por el usuario, la ejecutan de manera automática.    
  
Otros DEX, como los creadores de mercados automatizados o ==Automated Market Maker (AMM),== no emplean libros de órdenes. Más bien, utilizan incentivos para motivar a los usuarios a proveer y aportar liquidez a los pares comerciales, creando reservas de liquidez o liquidity pools con las que se garantizan los intercambios de tokens en todo momento.  
  
**Dentro de estos DEX, que actúan como un bien comunitario, los proveedores de liquidez son compensados con tokens de liquidez, por lo que estas plataformas también permiten, en cierta forma, monetizar los servicios de intercambio de activos.**

#### Tipos de DEX
Como explicamos anteriormente, los DEX son plataformas para el intercambio descentralizado de tokens y otros activos digitales.

No obstante, debido a su gran utilidad y transparencia, el concepto de DEX ha evolucionado, dando lugar a distintos tipos de exchanges descentralizados, como se explican a continuación:
1. Order Book on-chain
2. Order Book off-chain
3. Creadores de Mercado Automatizados (AMM)

##### 1 | Order book on-chain
**Los DEX de libros de órdenes on-chain son aquellos que registran las operaciones comerciales o de intercambio de tokens en un libro de órdenes en la cadena de bloques.**  
  
Este funcionamiento tiene sus ventajas y desventajas ,y es que al registrar las operaciones en la Blockchain, se garantiza un alto nivel de transparencia. Sin embargo, esto ocurre a expensas del rendimiento y los costes de comisión. En estos DEX, los usuarios deben pagar comisiones por la colocación, modificación y cancelación de las órdenes.  
  
**Algunos exchanges descentralizados que funcionan bajo este concepto son: Stellar y EtherDelta.**

##### 2 | Order Book off-chain
**Los DEX que operan fuera de la cadena de bloques sacrifican un poco la descentralización en pro de la usabilidad.** Al no registrar sus operaciones dentro de la Blockchain, los DEX de libros de órdenes off-chain permiten mayor velocidad y rendimiento en las operaciones comerciales. No obstante, estas ocurren fuera de la cadena y pueden estar a cargo de entidades centralizadas.  
**  
DEXs como 0x, dYdX e IDEX son buenos ejemplos de exchanges descentralizados Order book off-chain.**

##### 3 | Creadores de mercado automatizados (AMM)
Los DEX AMM se basan en grupos o pools de liquidez que son alimentados por los usuarios, que reciben incentivos por su papel como proveedores de liquidez. Estos DEX utilizan los llamados oráculos Blockchain para acceder a información de otras plataformas y establecer el precio de los criptoactivos negociados.  
  
Como explicamos anteriormente, los DEX AMM no requieren de libros de órdenes para ejecutar las transacciones de intercambio de tokens. En su lugar, utilizan la liquidez bloqueada por los usuarios dentro de sus Smart Contracts para garantizar las operaciones.

> A diferencia de los anteriores, en los DEX AMM los usuarios no sacrifican la custodia de sus criptoactivos.  
  
**Dentro de esta categoría de exchanges descentralizados, Uniswap es el mejor ejemplo, aunque también existen otros DEX AMM como SushiSwap, Kyber Network, Balancer y PancakeSwap.**

#### Ventajas y desventajas
De acuerdo a su tipo y clasificación, los DEX pueden ofrecer muchas ventajas y desventajas.

##### Ventajas
1. **Confiabilidad:**  
    Las operaciones de intercambio de tokens ocurren de forma transparente. Además, los usuarios pueden visualizar cómo funciona el servicio, cómo actuará ante cualquier situación y ver en tiempo real qué ocurre dentro de él, sin manipulaciones.
2. **Seguridad y protección:**  
    Los Smart Contracts implementados en los DEX pueden garantizar un alto nivel de protección contra estafas y fraudes. Esto debido a que, al establecer un contrato con ciertas condiciones a cumplir, las partes involucradas en el intercambio deben obedecer a estas condiciones para que la operación se ejecute. No obstante, el nivel de seguridad de estas plataformas depende en gran medida de que la programación de los Smart Contract se realice correctamente. **Un fallo o error en los contratos puede permitir el robo de los fondos de los usuarios**
3. **Anonimato:**  
    Los usuarios pueden realizar operaciones de intercambio con un alto grado de anonimato, ya que no requieren que los usuarios atraviesen procesos KYC ni suministren datos e información personal.
4. **Robustez:**  
    Al no operar con un único servidor, como sí lo hacen los exchanges centralizados, las probabilidades de sufrir una caída de sistema en los DEX son casi nula.
5. **Operaciones con tokens no listados:**  
    Aunque nuevos tokens aún no estén listados en plataformas de intercambio tradicionales, los usuarios en los DEX pueden crear pares comerciales con estos criptoactivos para operar libremente con ellos, siempre que se suministre y exista liquidez.

##### Desventajas
1. **Usabilidad:**  
    Para muchos usuarios sin experiencia, los DEX pueden parecer confusos y difíciles de operar.
2. **Interoperabilidad:**  
    Los exchanges descentralizados no permiten hacer intercambios entre criptomonedas o tokens de diferentes cadenas de bloques. Es decir, dentro de los DEX no puedes hacer un swap con Bitcoin y Ethereum, por ejemplo.
3. **Tipos de órdenes:**  
    En los DEX, los tipos de órdenes que puedes colocar son muy limitadas, pudiendo poner únicamente órdenes de tipo Limit y Market.
4. **Tiempo de operación:**  
    Las operaciones dentro de un exchange descentralizado ocurren dentro de la Blockchain, en su mayoría, por lo que el proceso de intercambio de tokens es mucho más lento en comparación con las operaciones dentro de un exchange tradicional.
5. **Liquidez:**  
    Lo más importante en un DEX es la liquidez, para garantizar a los usuarios spreads bajos. Si un exchange descentralizado (DEX) tiene apenas liquidez, genera poca tracción, lo que se traduce en altos spreads y ahuyenta a cualquier usuario.
  
Por su funcionamiento y utilidad, los DEX se han convertido en un elemento clave del ecosistema de las finanzas descentralizadas (DeFi).

### DAOs: Organizaciones Autónomas Descentralizadas
Decentralized Autonomous Organization (DAO), son organizaciones que nacieron como una revolucionaria forma de organizar a la comunidad y que, gracias a la llegada de los Smart Contracts y la tecnología Blockchain, pueden brindar transparencia, inmutabilidad, autonomía y seguridad.

Crear una DAO no es tarea simple, este tipo de organizaciones autónomas descentralizadas ha cobrado cada vez más importancia en el mundo, gracias a su capacidad de garantizar la autogestión de forma transparente y mucho más eficiente.

![[250.B4E1_daos.png]]

#### ¿Qué son las DAOs?
Las DAO son organizaciones autónomas descentralizadas, donde sus propios miembros son quienes ejercen la gobernanza, sin necesidad de un liderazgo centralizado.

Esto es posible gracias a que las DAOs son controladas en su totalidad por algoritmos computacionales, conocidos como Smart Contracts.

La estructura de las DAOs puede ser adaptada a prácticamente cualquier espacio de la sociedad donde se pueda crear una organización. Por ello, además de ser una de las herramientas más potentes dentro del ecosistema descentralizado, también se han convertido en uno de los ejemplos de uso y aplicación de la tecnología Blockchain más potentes que existe en la actualidad.

**Organizaciones como Dash, SmartCash, The DAO o Digix.io son solo algunos de los ejemplos más conocidos de este tipo de organizaciones descentralizadas.**

#### ¿Cómo funcionan las DAOs?
Al ser organizaciones que se rigen por código, el funcionamiento de las DAOs difiere en varios aspectos de las organizaciones comunitarias tradicionales.

En primer lugar, sus reglas deben programarse de forma previa o anticipada a su funcionamiento. 

Para ello están los Smart Contracts, que permiten programar las acciones de la DAO y hacer que estas se ejecuten conforme a cada uno de los parámetros establecidos. Una vez programadas, las DAOs utilizan una serie de mecanismos que garantizan que sus reglas se cumplan en todo momento.  
  
Las DAOs también utilizan un protocolo de consenso que garantiza que todas las decisiones que se tomen dentro de la DAO sean tomadas por el consenso de sus miembros. **De esta manera, ningún factor externo a la organización ni quienes participen directamente en ella puede alterar o tomar decisiones de forma individual, protegiendo la descentralización y la transparencia.**  
  
Dentro de la estructura de una DAO también existen los tokens de financiación o de gobierno, que actúan como un tipo de membresía y permiten a sus titulares ganar poder voto, al mismo tiempo que garantizan un mecanismo de intercambio y recompensa económica dentro de la organización.  
  
Las DAOs también hacen uso de la cadena de bloques o Blockchain para llevar un registro detallado e inmutable de todos sus movimientos y operaciones. **El elemento Blockchain en las DAOs permite que toda la información de la organización sea almacenada de forma segura, inalterable y accesible públicamente.**

##### Ejemplo de una DAO
- Si una comunidad se organiza como una DAO para crear una asociación de vecinos, los miembros de esta podrán elegir qué actividades se realizarán o cómo se gestionarán los recursos.
- A través de un token de gobierno, los miembros de la DAO tendrían el derecho de influir y elegir, en consenso, las decisiones rutinarias de la organización.
- Si la asociación de vecinos decide que el dinero se usará para gestionar el pago de reparaciones de averías y costear mejoras en el edificio de la comunidad, este no podría utilizarse con otro fin. Tampoco ningún miembro de la DAO podría disponer de estos fondos de manera arbitraria, sin importar quien sea.
- Por lo tanto, si un miembro de la DAO debe dar un uso distinto de lo programado al dinero, entonces debe generar una petición, que será analizada y votada de forma democrática por el resto de los miembros de la organización. 
- Una vez que alcance el consenso o, se tome una decisión democrática, los fondos podrían desbloquearse para ser usados como lo especifique la propuesta o petición votada por la mayoría.

**Gracias a este funcionamiento, las DAOs garantizan una forma transparente de gestionar recursos sin dejar lugar a que alguna persona o entidad, a traición, pueda usar los recursos como desee sin el consentimiento del resto.**

#### Ventajas y Desventajas
Gracias a la naturaleza descentralizada de su estructura, las DAOs representan una poderosa innovación tecnológica para la construcción de un nuevo orden basado en la Web3.

Como todo tipo de tecnología, una DAO puede ofrecer a sus participantes diferentes ventajas y desventajas. Algo sobre todo cierto debido a que las mismas dependen de la programación o normativa de la DAO.

##### Ventajas
- Una de las características más importantes en las DAOs es que permiten crear organizaciones sin ningún tipo de jerarquización. Todos los miembros de una organización autónoma descentralizada están al mismo nivel y pueden aportar ideas y votar por las mismas en consenso, con lo que se garantiza la descentralización.
- Asimismo, las DAOs no están vinculadas a ninguna regulación o ley en particular.
- Cuentan con un nivel de transparencia muy alto heredado de la tecnología Blockchain.
- La descentralización permite que las DAO puedan ofrecer servicios de forma global, eliminando fronteras y democratizando el acceso a servicios que de otras formas no estarían disponible para muchas personas.
- Facilitan la creación de organizaciones. A diferencia de las organizaciones tradicionales, que requieren dinero, tiempo y papeleo, para crear una DAO solo necesita programarse en una Blockchain.

##### Desventajas
- La programación de una DAO no es una tarea fácil y conlleva muchos riesgos si esta no se realiza de la forma correcta.
- Debido a que la tecnología Blockchain y las criptomonedas aún no tienen una regulación clara, muchos países y reguladores se han pronunciado en contra de este tipo de organizaciones.

#### DAOs más populares en Blockchain
The DAO, en Ethereum, ha sido la organización autónoma descentralizada para el crowdfunding más popular de la industria cripto hasta ahora.

1. The Dao
2. Dash DAO Governance
3. Digix DAO
4. BitDAO
5. MakerDAO
6. MolochDAO
7. DXDAO
8. DAOHaus

Creada en 2016 por Simon Jentzsch y Christoph Jentzsch, **The DAO** nació para gestionar un fondo de capital de riesgo de forma descentralizada. 

**Esta DAO logró recaudar más de 150 millones de dólares en pocos meses. No obstante, debido a un error en su código, un hacker logró adueñarse de unos 50 millones de dólares de los fondos de la DAO, marcando el fin de esta organización.**

Otros proyectos de DAOs conocidos son Dash DAO Governance, que nació para permitir la gobernanza de Dash y democratizar sus decisiones. En esta organización participan quienes gestionan un masternodo en la red Blockchain. DigixDAO es otra organización autónoma descentralizada, creada para la gobernabilidad. Esta DAO permite controlar el crecimiento y desarrollo de todo el ecosistema Digix.  
  
**BitDAO, MakerDAO, MolochDAO, DXdao y DAOHaus son otras de las DAOs existentes y son buenos ejemplos de las distintas funciones que pueden cumplir este tipo de organizaciones.**

#### El potencial disruptivo de las DAOs
Aunque solo tienen unos pocos años de desarrollo, el potencial que ofrecen las DAOs es inimaginable. 

Actualmente, estas organizaciones son, sin lugar a duda, una de las herramientas tecnológicas más potentes que existen en la actualidad y que podrían dar lugar a una gran revolución a futuro.

En la industria Blockchain, estas organizaciones se han convertido en una forma segura y efectiva de trabajar y colaborar con extraños a través de la Internet.

### Bridges
Un bridge o puente entre cadenas es un servicio (centralizado o descentralizado) que permite crear una conexión entre dos Blockchains que normalmente no pueden comunicarse entre sí, para que, de esta forma, puedan traspasarse tokens entre ellas.

Esta es una utilidad que se ha convertido en esencial gracias a la llegada de los servicios DeFi, los cuales han llevado a la comunidad cripto a un salto enorme en el uso de la tecnología Blockchain y los tokens que hacen vida en las distintas cadenas de bloques capaces de brindar este tipo de servicios.

![[251.B4E1_bridges.png]]

#### ¿Cómo funciona un Bridge?
Un bridge se puede ver como un simple intercambiador de información entre Blockchains. 

Es decir, la principal función de un bridge es permitir el intercambio bidireccional de información entre la Blockchain A y la Blockchain B, a través de un protocolo que permite esa conexión.

Por supuesto esto es una forma fácil de ver cómo funciona un bridge, pero la idea básica es esa y tenerla muy en claro te servirá para entender exactamente cómo se realiza ese intercambio de información.

De hecho, la podemos resumir en cuatro pasos:
1. El bridge se ubica entre la cadena A y B, creando la estructura básica para su funcionamiento.
2. Si deseas pasar un token de A > B, te diriges al bridge, indicas la cantidad de tokens que deseas cambiar en A y proporcionas la dirección de destino en B.
3. Realizas el envío en A y el bridge te bloquea este saldo en un vault, y luego en B se acuña la cantidad exacta de tokens que son enviados a la dirección en B que has proporcionado.
4. Los tokens en A quedan bloqueados como garantía de los tokens en B y únicamente podrás recuperarlos haciendo el proceso contrario.

#### Explicado en mayor detalle
Pongamos un ejemplo más práctico para avanzar un poco más en cómo funcionan estos bridges.

**Imagina que deseas pasar tokens 1.000 USDT desde la red Ethereum a la red Polygon. De forma directa, pese a que las direcciones de Ethereum y Polygon son idénticas, la realidad es que sus redes Blockchain son distintas, por lo que no puedes pasar valor de forma directa entre ambas Blockchain. Para ello, debes utilizar un bridge y este se encargará de completar ese proceso.**

Dado que Ethereum y Polygon son idénticas a nivel de programación (están basadas en EVM, usan Solidity, tienen el mismo modelo de direcciones...pero tienen distintos historiales y protocolo de consenso) crear un bridge es bastante fácil. Para ello, el bridge crea una serie de contratos (en Ethereum y Polygon) que permitirán que ambas redes puedan comunicarse con un lenguaje común a través de un oráculo Blockchain. 

**El trabajo del oráculo es dar información precisa a esos contratos de lo que sucede en la otra Blockchain y viceversa. De esta forma, creamos el canal de comunicación bidireccional entre Ethereum y Polygon, en este punto la mitad del trabajo está hecho.**

Ahora, para enviar ese USDT de ETH a Polygon, deberás interactuar con el bridge del lado de ETH. Este te pedirá dos cosas:
1. Una dirección de recepción para la red Polygon.
2. Que envíes los 1.000 USDT que tienes en ETH a un vault (también en ETH) que será controlado por un smart contract del bridge. Este paso suele ser transparente al usuario.

**Al completar estos dos pasos y realizar el envío del lado de ETH, el bridge comienza su trabajo.** Lo primero que pasa, es que el oráculo detecta el envío en ETH y lo reporta a los Smart Contracts del lado de Polygon. Con este reporte, va la cantidad de tokens cambiados y la dirección destino (la que has dado) para los mismos. Una vez que la operación en ETH se completa, entonces el oráculo informa de esto y los Smart Contracts del lado de Polygon, comienzan a generar los 1.000 USDT y se envían a la dirección proporcionada.

**Los tokens generados del lado de Polygon son los mismos USDT, la misma cantidad y con el mismo valor, y esto es posible, porque el vault creado sirve de garantía de valor de esos nuevos tokens y estarán bloqueados hasta el momento en que hagas la operación contraria (pasar ese USDT de Polygon a ETH).** El bloqueo evita que se generen tokens de la nada, a la vez que mantiene la seguridad y estabilidad económica entre las cadenas y el bridge.

Cuando haces el proceso contrario para recuperar tus USDT en ETH, el bridge toma tus USDT del lado de Polygon, los quema y, una vez quemados, se te entregan los USDT correspondientes del lado de Ethereum. Con eso, termina el trabajo del bridge entre ETH y Polygon.

#### Tipos de Bridges
Los bridges pueden ser de dos tipos:

##### Centralizado
Un bridge centralizado es aquel cuya gestión recae en una entidad centralizada que toma y libera tokens entre las cadenas soportadas por dicha entidad. Básicamente funciona como un exchange, solo que en lugar de intercambiar pares, solo se dedica a tomar un token y enviarte el mismo token en la red destino que elijas. **Un ejemplo de este tipo de bridges es OKex Bridge.**

##### Descentralizado
Un bridge descentralizado es aquel que es completamente controlado por Smart Contracts y donde el control de los fondos no recae en ninguna entidad central. **Un ejemplo de este tipo de bridge es Multichain.**

#### Principales funciones de un bridge
Entre las principales funciones de los bridges podemos mencionar:
1. **Habilitar la interoperaibilidad entre cadenas.** De esa forma, los usuarios de Ethereum pueden tomar sus tokens y enviarlos a otras cadenas como BSC, sin tener que pasar por un exchange.
2. **Permite que los usuarios puedan pasar entre Layer1 y Layer2.** Por ejemplo, los usuarios de Ethereum pueden tomar sus tokens y llevarlos de Layer1 (la red Ethereum) a redes Layer2 como Polygon, Arbitrum, Optimism o xDai entre otras.
3. **Ayuda a minimizar los costes de operación,** ya que le permite al usuario buscar redes con mejores comisiones para realizar sus operaciones.
4. **Atraer valor de otras redes a redes con mejores oportunidades.** Un buen ejemplo de esto es el paso de valor de BTC a Ethereum durante el criptoinvierno. El movimiento estuvo motivado en aprovechar el naciente ecosistema DeFi y generar ganancias en momentos en el BTC mantenía un bajo valor.

### Lending, préstamos digitales
Las finanzas descentralizadas han abierto la puerta a un amplio conjunto de herramientas y productos financieros del sistema tradicional al mundo de las criptomonedas, para funcionar de forma descentralizada y más eficiente, como es el caso de los préstamos.

El Lending o los préstamos digitales son una potente herramienta del ecosistema de las finanzas descentralizadas o DeFi, que permiten a los usuarios acceder a liquidez de forma inmediata y sin intermediarios, desbloqueando el potencial de sus criptoactivos al utilizarlos como garantía o colateral.  

La Blockchain de Ethereum, la principal cadena de bloques de Smart Contracts del criptoespacio, es el hogar de los mayores protocolos de Lending en criptomonedas, como MakerDAO, Aave, Compound, Liquity y Cream Finance, que poseen más de 28.000 millones de dólares en liquidez.

![[252.B4E1_lending.png]]

#### Lending en cripto
El Lending en criptomonedas es un instrumento financiero, análogo a los préstamos tradicionales, donde los titulares de criptomonedas pueden servir como prestamistas aportando liquidez a un protocolo o, bien, como prestatarios al tomar prestado la liquidez de otros contra sus activos como garantía.

Dentro de los protocolos DeFi de Lending, los prestamistas son recompensados con intereses al poner sus criptoactivos a trabajar, para aportar liquidez al protocolo y ofrecer sus fondos en préstamo a otros; mientras que los prestatarios tienen la posibilidad de acceder a liquidez de forma directa, instantánea y descentralizada.

#### Protocolos de Lending
Básicamente consisten en Smart Contracts que permiten depositar un activo como colateral para solicitar prestado un porcentaje del valor de dicho activo puesto en garantía.

Dentro de los protocolos de Lending colateralizados es posible utilizar criptomonedas y stablecoins para tomar prestado otras criptomonedas, tokens, stablecoins o incluso, dinero Fiat.

Por ejemplo, en protocolos de Lending en criptomonedas como Aave o MakerDAO, los dos más grandes en popularidad y liquidez en el criptoespacio, los usuarios deben depositar algún tipo de garantía en criptomonedas, como ether (ETH), para luego pedir prestado contra dicha garantía otros criptoactivos o tokens.    
  
En MakerDAO, los prestatarios pueden usar ETH para pedir prestado MKR, el token nativo del protocolo de préstamos, y utilizarlo para participar en la gobernanza del mismo. También es posible solicitar otros criptoactivos que los usuarios pueden emplear para apalancar sus posiciones de arbitraje, o bien para realizar otras operaciones financieras como el trading. El potencial del Lending es enorme dentro del vasto ecosistema DeFi.

> Por otro lado, la mayoría de los protocolos de Lending permiten a los usuarios tomar prestados diferentes criptomonedas y tokens hasta un cierto porcentaje del valor de su garantía depositada. Este porcentaje varía de acuerdo a las condiciones y el poder de endeudamiento fijado por cada protocolo.

**Asimismo, existen diferentes tipos de préstamos en el mundo DeFi, como los Flash Loan o préstamos rápidos,** que no requieren de ningún tipo de garantía para tomar prestado la liquidez de un protocolo, aunque sí requieren que el préstamo sea tomado y devuelto dentro de una misma operación.  
  
En el caso de los protocolos de Lending colateralizados, al pagar el préstamo que fue solicitado, el usuario recibe de vuelta los criptoactivos puestos en garantía inicialmente.

#### Tipos de préstamos en criptomonedas
##### Préstamos colateralizados
Un préstamo colateralizado es un préstamo que está respaldado o protegido por un colateral o una garantía, en este caso por criptomonedas.

**Para que te otorguen un préstamo colateralizado, debes ofrecer tus criptomonedas como garantía, esto con el fin de garantizar préstamo.** Por su parte, la plataforma mantendrá esta garantía o colateral hasta que saldes la cantidad del préstamo completamente junto con los intereses en el término de tiempo establecido.

##### Flash Loan - Préstamos rápidos
Un Flash Loan o préstamo flash es un tipo de préstamo digital programado sobre un protocolo DeFi que es capaz de ofrecer una provisión de fondos a los usuarios sin que estos necesiten aportar una garantía al protocolo por los fondos prestados.

De esta manera, el protocolo DeFi de Lending brinda acceso al usuario a unos fondos de los que puede tomar prestado, para utilizarlos en distintos Smart Contracts ( incluyendo los de otros protocolos ) y devolverlos al protocolo de préstamo al final de esa misma operación ( incluyendo las comisiones correspondientes por la operación. )  
  
**Lo importante a destacar en este tipo de préstamos, es que toda la operación y los movimientos se realizan en una única operación, de forma instantánea, y toda ella queda registrada en un mismo bloque de la Blockchain donde se registre.**  
  
Los desarrolladores de Aave fueron quienes diseñaron esta función de préstamo flash, con el fin de permitirles a sus usuarios acceder a la liquidez del protocolo para realizar operaciones rápidas.

#### Utilidad y casos de uso para los préstamos
##### Caso 1: Acceder a liquidez o dinero Fiat
Los préstamos de criptomonedas permiten a los usuarios mantener sus criptoactivos y acceder a liquidez en el momento en que lo necesiten. 

Ejemplo:
- José es propietario de 5 ETH y necesita dinero, pero no quiere gastar sus ethers. 
- José puede acceder a un protocolo de Lending para pedir prestado contra sus ETH alguna stablecoin como USDT, cuyo valor está vinculado al dólar en relación 1:1.
- De esta manera, José no necesita vender sus ETH para tener dinero, sino que con colocar sus ethers como garantía ya podrá recibir una cierta cantidad de dinero en USDT para utilizar la liquidez que necesita.
- Cuando José reembolse el dinero del préstamo podrá tener nuevamente sus ETH de vuelta en su monedero, que quizás habrán aumentado de precio sustancialmente.

**Los protocolos colateralizados ofrecen liquidez de forma segura. No obstante, existen algunos riesgos para los criptoactivos.** En el ejemplo de José, puede llegar a perder sus ETH en garantía si llegara a incumplir alguna de las condiciones o términos establecidos en el préstamo o, bien, si el valor de su activo en garantía llegara a caer por debajo del valor del préstamo recibido.

##### Caso 2: Apalancamiento
Otra utilidad de los préstamos en cripto es servir de apalancamiento para operaciones en DeFi. Muchas plataformas DeFi te ofrecen opciones de ahorro en la que puedes introducir determinadas criptomonedas y recibir tokens por ellas. 

Estos tokens (generalmente con un valor menor al que has ingresado inicialmente) pueden usarse como medio para apalancar las posiciones DeFi o CeFi que puedas tener en otras plataformas, permitiéndote obtener mejores rendimientos por tu inversión.

Un caso de este tipo se puede ver en la plataforma LIDO de staking para ETH 2.0. Por cada ETH que ingreses a la plataforma Lido, recibes un sETH (Staking ETH) que tiene un valor cercano a ETH normal. Este sETH lo puedes usar en plataformas como Curve o Uniswap para realizar operaciones de liquidity providers (LP), intercambios o realizar otros préstamos con lo que se pueden recibir ciertas recompensas adicionales al staking realizado en LIDO.


### NFT Lending
Los tokens no fungibles (NFT) son una clase de criptoactivos que están muy de moda en estos días, con un mercado que está valorado en miles de millones de dólares.

Pero los NFT no son solo para comprar, vender y mantener, y eso es algo que las plataformas NFT Lending están cambiando.

Estas plataformas buscan que los NFTs puedan formar parte de acuerdos financieros más complejos y lucrativos, como el caso de los préstamos y la inyección de liquidez en protocolos para yield farming y más.

**Su creación responde a la necesidad de contar con instrumentos financieros en el mercado de los NFTs.** **Mientras que se puede vender bitcoin prácticamente al instante, el mercado de NFT es mucho menos líquido. Pueden pasar meses hasta que alguien compre tu NFT. Y cuando vendes tu NFT, tienes que venderlo todo.** 

Mucha gente no quiere desprenderse de sus NFT para siempre, ni siquiera en parte. Frente a esta realidad, las plataformas de NFT Lending presentan una opción valiosa: abrir las puertas para resolver el problema de liquidez en dicho mercado, estabilizar el mismo y que los NFTs sean ahora activos de garantía para acceder a préstamos y otras operaciones financieras en el ecosistema cripto.

![[253.B4E1_nft_lendings.png]]

El sector podemos ver al menos estos dos modelos bien definidos:
1. NFT Lending Peer-to-Peer (P2P).
2. NFT Lending Peer-to-Protocol.

**Sin duda las opciones se parecen mucho a lo que podemos ver en los mercados de obras de arte tradicionales.** Por otro lado, hay que recordar que la inversión financiera en NFT y finanzas descentralizadas (DeFi) -o la intersección de ambas, como en este caso- presenta un sinfín de riesgos, entre los que destacan las caídas repentinas del mercado de criptodivisas, los exploits de contratos inteligentes y las medidas regulatorias. **Aunque muchas de estas plataformas son auditadas, una auditoría no garantiza la seguridad, sólo señala los errores en el código de una plataforma hasta donde el auditor puede detectar.**

#### NFT Lending P2p
- **El NFT Lending P2P replica el modelo clásico de un mercado de préstamos: poner en contacto a prestamistas con prestatarios. Una plataforma que funciona con este sistema es NFTfi.** Esta plataforma permite que los tenedores de NFT puedan publicar los mismos y pedir una cantidad de dinero prestada por los mismos, ofertas que pueden ser aceptadas por los prestamistas tras su revisión de los mismos.
- **Una vez realizado el préstamo, el NFT queda protegido por un Smart contract** que vigila que el pago del préstamo se realice según el acuerdo entre ambas partes, ya que, de no respetarse, el NFT pasará a manos del prestamista liquidando así la deuda.
- **El sistema es parecido al que se veía por ejemplo en AAVE** en sus primeros días (por allá 2017) y resulta interesante tanto para los tenedores de NFT (porque pueden obtener préstamos por su NFTs) y los prestamistas (que pueden hacerse con NFTs por un costo inferior).
- Esto significa que **solo recibes de vuelta tu NFT cuando devuelves el préstamo antes de la fecha de vencimiento.** Si no pagas el préstamo, el prestamista recibirá tu NFT con un gran descuento. Los cambios drásticos en el precio mínimo de una colección de NFT no afectan a las condiciones del préstamo; es un acuerdo entre iguales con sus propias condiciones.
- Por supuesto, **como toda plataforma de intercambio, esta cobra a los prestamistas un 5% sobre los intereses obtenidos por los préstamos exitosos** (no hay comisión en caso de impago del préstamo). Los prestatarios utilizan la plataforma sin ninguna comisión de servicio.

#### NFT lending Peer-to-protocol
En este caso, los préstamos se realizan directamente por medio de un protocolo que maneja todo el sistema. 

Es básicamente, una plataforma de préstamos cuya liquidez proviene de un pool de liquidez (LP) que sostiene el sistema, y por el cual los tenedores de NFTs pueden pedir préstamos de forma descentralizada.

Plataformas como BendDAO y Drops, son un ejemplo del potencial de esta tecnología y modelo de funcionamiento para la creación de nuevos mercados DeFi NFT, donde no solo los NFTs encuentra una nueva utilidad, sino que al mismo tiempo se genera valor en nuevas plataformas DeFi útiles para la comunidad.

#### Plataformas de NFT Lending actuales
Pese a que el NFT Lending es de reciente creación, existen actualmente varias plataformas funcionales sobre este concepto entre las que tenemos:

1. NFTfi
2. Drops
3. JPEGD
4. BendDAO
5. Protocolo Pine
6. FluidNFT
7. Sodium
8. Nifty
9. MetaStreet
10. Gradient
11. Backed

![[253.B4E1_loans.png]]

### Pool Staking
Los pools de staking están disponibles en todas aquellas cadenas de bloques que funcionan con un mecanismo de consenso Proof of Stake (PoS).

Sin embargo, se trata de un concepto algo desconocido que algunas veces provoca cierto recelo entre algunos inversores y usuarios de criptomonedas.

Este tipo de grupos se ha popularizado desde que Ethereum activará el staking de ETH en su red Beacon Chain. Por ejemplo, para crear un nodo validador en Ethereum se necesitan 32 ETH. Al precio actual, resulta complicado para un usuario minorista gestionar un nodo por su cuenta, por lo que se suelen unir en un Pool de Staking para poder participar.

![[254.B4E1_stacking.png]]

#### ¿Qué es un Pool de Staking?
En resumen, se trata de un grupo de personas que unen sus tokens y los bloquean en una dirección concreta de la cadena de bloques o en una cartera, para aumentar las probabilidades de recibir una recompensa de bloque. 

A cambio, todos ellos reciben un porcentaje de rendimiento anual (APY).

Los tokens bloqueados se vinculan al desarrollo y a la seguridad de la Blockchain. A cambio, esta proporciona a los participantes, a través del operador del Pool público de Staking, un porcentaje de recompensas basado en el número de tokens bloqueados cada vez que verifican un bloque nuevo.

**Los pools de staking son una herramienta perfecta para grupos de inversores minoristas que quieren participar en la actividad de staking, pero sin tener que apostar grandes cantidades de un token.**

##### Ventajas
- Una de las principales ventajas de los Pool de Staking es que **ofrecen recompensas en base a la cantidad de tokens apostados.** De esta forma, los usuarios tienen la posibilidad de generar un ingreso pasivo, siempre que los tokens se mantengan bloqueados a largo plazo.
- Además, **los usuarios que invierten sus tokens no se tienen que preocupar de cómo funciona el nodo de validación,** ya que es el operador del nodo el responsable de la gestión y del funcionamiento.
- **Los participantes son recompensados con tokens recién acuñados cada vez que se valida y añade un nuevo bloque de transacciones.** Los usuarios recibirán su parte justa en proporción al número de tokens apostados y la cadena de bloques mejora su infraestructura y seguridad.

##### Desventajas
- En primer lugar, **hay que analizar en profundidad** tanto el operador de Pool que se elige, como la cadena de bloques en la que vamos a realizar el Staking.
- **Al bloquear los tokens en estas direcciones, los usuarios “pierden” el control de sus tokens,** que pasan a estar bloqueados en la dirección del nodo, que a su vez está gestionada por el validador. 
- En este sentido, **siempre es aconsejable elegir pools que permitan a los usuarios participar en el proceso y tomar decisiones,** para evitar la creación de «cárteles» de pools que acaparen el Staking y puedan llegar a manipular las transacciones.
- Por otra parte, **las recompensas de los pools son más pequeñas** que las que reciben aquellos que bloquean directamente sus tokens, ya que estas plataformas tienen que dividir los beneficios entre todos los participantes y pagar las comisiones y tasas que suelen aplicar.

#### Recompensas
A cambio de bloquear los tokens en un nodo, los participantes reciben recompensas además de sus ganancias de capital obtenidas a través de la apreciación del valor de los tokens.

En este sentido, un usuario puede participar en un Pool de Staking con una fracción del número de tokens requerido para convertirse en validador de una Blockchain, mientras que el Pool recompensa a los usuarios de forma diaria, semanal o mensual.

Habitualmente, la elección de un Pool de Staking depende de varios factores, como las tasas de comisión, la forma en la que contribuyen al ecosistema o la creación del código para proyectos que validan.

Además, muchos operadores de Staking ofrecen propuestas de valor únicas que pueden resultar atractivas para los usuarios.

### GameFi
GameFi es una fusión de las palabras "Juego" (Game) y "Finanzas" (Finance).

Este término sirve para identificar a los juegos Play-to-Earn (P2E) que tienen un sistema de incentivos económicos dentro de los mismos, con el fin de que los jugadores se sientan motivados a jugar y obtener monedas, NFTs y demás activos digitales dentro juego.

Dichas recompensas in-game son las que forman el modelo y economía del juego, y al mismo tiempo, son las que nos permiten forman la economía fuera del mismo, por medio de mercados alternos donde podemos disponer de los NFTs y monedas de forma libre.

> Todo ello, mientras dichos elementos siguen teniendo una utilidad dentro del juego (como proporcionar mejoras al personaje, armas o a nuestras mascotas in-game).

**Además, dependiendo del juego, los jugadores pueden obtener recompensas completando tareas, luchando contra otros jugadores o construyendo estructuras monetizadas.** Por otro lado, los juegos también permiten a los jugadores generar ingresos pasivos sin jugar, ya sea a través de Staking o prestando sus recursos del juego a otros jugadores.

![[255.B4E1_gamefi.png]]

#### Aplicaciones DeFi del GameFi
El modelo Play-2-Earn es el corazón de los proyectos GameFi y este modelo también puede ser la semilla para ofrecer productos y funciones DeFi, como Staking, Liquidity Mining y Yield Farming.

De esta forma, los jugadores pueden no solo obtener recompensas jugando, sino que, al mismo tiempo, pueden hacer Staking en plataformas que impulsen la utilidad del token y que le ofrezcan una forma pasiva de obtener nuevas ganancias con ese mismo token.

**De esta manera, las plataformas DeFi amplifican su alcance haciendo que los juegos cripto sean más descentralizados y brindando puertas de acceso a otros usuarios dentro del ecosistema cripto, siendo una realidad no solo aplicable a los juegos sino también a los metaversos.**

Por ejemplo, los jugadores de Decentraland pueden participar en el juego haciendo uso de su MANA y LAND, con el fin de obtener ganancias por distintos modelos económicos dentro del juego, pero también puede usar MANA para participar en Staking y Liquidity Pools que le ofrecen otra forma de obtener ganancias.

### Yield Farming
Uno de los conceptos que más fama ha tomado en el mundo DeFi actual es el “Yield Farming” o “Agricultura del Rendimiento”.

Este es un concepto que busca establecer una estrategia de inversión por la cual los tenedores de tokens buscan maximizar sus ganancias.

Para ello, los tenedores de tokens deben invertir y participar en varias plataformas DeFi mientras se busca la maximización de las ganancias en todo momento.

Sin duda alguna, una forma muy interesante de participar en el ecosistema DeFi y que ha ganado rápidamente espacios para su utilización. Pero ¿Qué más se oculta detrás de esta práctica? ¿Cuáles son sus riesgos? Eso y más lo conocerás a continuación.

![[256.B4E1_farming.png]]
  
#### Yield Farming: cosechando ganancias en los campos del DeFi
Tal como comentamos al inicio de este artículo, el Yield Farming o “agricultura del rendimiento”, es una estrategia que usan los inversionistas y grandes traders, para lograr obtener la mayor cantidad de ganancia de sus inversiones y capital.

**El objetivo es sencillo:** disponer de tu capital en una o varias plataformas de inversión, de tal forma que, pasado un tiempo, dicho capital crezca de forma significativa. En pocas palabras, los yield farmers o agricultores de rendimiento, solo buscan oportunidades de inversión que les permitan aumentar sus capitales.

**Una estrategia que por cierto se parece mucho al staking, ya que a mayor stake, mayor será la ganancia obtenida.** Sin embargo, para realizar esta actividad no existe una receta o forma única. Por el contrario, **el Yield Farming es una estrategia que debe adaptarse a las plataformas objetivos que se planean usar para tal fin.** Así por lo general, los yield farmers usan su gran capital o acuden a grandes préstamos para lograr su objetivo. **En pocas palabras, es una estrategia con muchos riesgos, pero también con grandes oportunidades.**

De hecho, dada la naturaleza del DeFi, donde puedes pedir préstamos de forma inmediata y realizar inversiones y cambios de activos de forma rápida, los yields farmers se aprovechan de este ecosistema para realizar sus inversiones y llevar a cabo sus estrategias de farming. De esta forma, un farmer puede alcanzar altísimos niveles de liquidez en periodos de tiempo muy corto, apalancado por préstamos, conversiones e inversiones bien posicionadas. 

**¿El resultado final? Grandes ganancias, no solo por los diferenciales de interés, sino también porque muchas plataformas ofrecen incentivos de uso que terminan transformándose en más capital para el farmer.**

#### El boom del Yield Farming
La práctica del Yield Farming podemos rastrearla hasta el año 2017, momento en el cual las plataformas DeFi comienzan a crecer rápidamente. 

En ese primer momento, la atracción al DeFi era particular, sobre todo por el hecho de obtener ganancias adicionales dentro del bull market que vivía el mercado cripto en ese momento.

De hecho, el proyecto MakerDAO y su DAI sentaron las bases de los primeros sistemas DeFi que permiten este tipo de prácticas. ¿La razón? DAI como stablecoin habilitaba la capacidad de ofrecer créditos con bajos riesgos de volatilidad, en un momento de mercado en donde muchos traders pedían prestados para comprar Bitcoin y otras criptomonedas al alza. Esto significaba que cualquiera que invirtiera en tokens como Maker (la moneda de gobernanza de MakerDAO) y DAI dentro de plataforma de préstamos como ETHLend (ahora AAVE), tenía ganancias importantes aseguradas.

**Eran los comienzos rudimentarios de una práctica que luego se transformó a un nivel completamente nuevo. De hecho, fue a finales de 2019 y comienzos del 2020, donde el Yield Farming alcanzó su máxima expresión con la aparición del protocolo Compound y su token de gobernanza COMP. Fue el curioso modelo de distribución de tokens COMP, lo que catapultó a la plataforma y elevó al máximo el interés sobre este sistema.**

**El protocolo Compound llamaba la atención de los inversionistas para inyectar dinero en sus liquidity pools y así obtener ganancias por sus inversiones.** Dichas ganancias provenían de dos puntos principales, la primera de los intereses de los préstamos realizados por las plataformas usando los fondos de dicho pool. Mientras que la segunda, provenía de los tokens de gobernanza que podían ganarse por participar en dicha plataforma como una recompensa. En definitiva, Compound es una plataforma que llevaba el Yield Farming a un nuevo nivel.

Como resultado, a comienzos de 2020 el ecosistema DeFi comenzó a sufrir una constante subida en su valor total bloqueado (TVL) que al momento de escribir este artículo supera ya los 11 mil millones de dólares. Una cifra récord que deja muy en claro el impacto y la importancia del DeFi en el sector de las criptomonedas.

#### Ventajas y desventajas del Yield Farming
##### Ventajas
1. **Es una estrategia que puede ser llevada en la actualidad con distintos targets o espacios.** En la actualidad, existen varios protocolos DeFi dedicados al yYield Farming, alguno de ellos con varios años de funcionamiento y solidez comprobada.
2. **Permite a los farmers obtener beneficios bastante pronunciados en sus “cosechas”**. Generalmente estas cosechas se dan en periodos de 6 meses a 1 año, y son reinvertidas para generar mayores niveles de ganancias. En efecto, el Yield Farming es una estrategia que favorece a las ==ballenas (whales)== de criptomonedas.

##### Desventajas
1. **Es una estrategia compleja y solo recomendable para personas con avanzado conocimiento financiero.**
2. **La puesta en práctica de la estrategia favorece a aquellos que tienen grandes cantidades de capital para desplegar, es decir, ballenas (whales).** Una persona con poco capital puede no percibir absolutamente nada de ganancias, y de hecho, puede perder dinero haciendo frente al pago de comisiones.
3. **Otro grave problema es la seguridad de los smart contracts de la plataforma de yield farming.** Si la plataforma no ha sido debidamente auditada, se corre el riesgo de robo de fondos y la pérdida parcial o total de los mismos. Esto no es algo aislado, de hecho, casos como lo sucedido en dYdX o bZx demuestran este punto.

#### Plataformas para aprovechar el Yield Farming
1. MakerDAO
2. Compound
3. AAVE
4. Balancer
5. Curve
6. Uniswap
7. Synthetix (SNX)

##### 1 | MakerDAO
MakerDAO es uno de los proyectos DeFi más grandes y más antiguos del criptomundo. 

Bajo su paraguas se encuentra el protocolo Maker y DAI, una stablecoin anclada al precio del dólar y cuyo funcionamiento es completamente descentralizado. Y todo ello ejecutándose sobre una serie de poderosos smart contracts en la blockchain de Ethereum.

##### 2 | Compound
Otro gran proyecto en el que podemos poner en práctica estas dos estrategias es Compound (COMP).

Este proyecto que se ejecuta sobre Ethereum creó un token de gobernanza llamado COMP, y al mismo tiempo una serie de pools de liquidez de monedas como ETH, DAI (también SAI), USDC, REP, SAI, WBTC, ZRX, y BAT.

El objetivo de esta plataforma es usar la liquidez dentro de estos pools para ofrecer préstamos de la plataforma, y brindar ganancias en forma de intereses y recompensas a quienes inyectan liquidez al protocolo. Incluso se puede realizar intercambios de criptodivisas entre los usuarios de la plataforma, como si Compound se tratase de una bolsa de valores.

##### 3 | AAVE
Anteriormente conocido como ETHLend es uno de los primeros protocolos de DeFi que existieron en el mundo de las criptomonedas.

Su lanzamiento fue a la par de MakerDAO, naciendo de una ICO que logró recaudar más de 17 millones de dólares a finales de 2017.

La idea detrás de AAVE es la de crear un mercado donde el tipo de interés se define algorítmicamente por la oferta y la demanda prácticamente al segundo para prestar o tomar prestados activos. La definición más financiera sería mercados de dinero (market money).

Su tiempo en el espacio crypto y su calidad le han valido para posicionarse en la actualidad como uno de los grandes proyectos DeFi del mundo. De hecho, al momento de escribir este artículo tiene un valor bloqueado superior a los 1,5 mil millones de dólares.

##### 4 | Balancer
Uno de los actores más recientes en el mundo DeFi es Balancer. 

Este es un protocolo creador de mercado automatizado con ciertas propiedades clave que hacen que funcione como una cartera ponderada y un sensor de precios autoequilibrados.

Balancer le da la vuelta al concepto de un fondo indexado: en lugar de pagar tarifas a los administradores de cartera para reequilibrar su cartera, cobra tarifas a los operadores, que reequilibran su cartera siguiendo las oportunidades de arbitraje.

##### 5 | Curve
Curve Finance es uno de los productos DeFi más curiosos de nuestra lista. 

La finalidad de Curve es crear grupos de liquidez y curvas de bonos que sirvan para proporcionar operaciones de monedas estables de alta eficiencia y rendimientos de bajo riesgo para los proveedores de liquidez.

De esta forma, Curve protege a los usuarios de los deslizamientos de precios que normalmente enfrentarían en los DEX cuando operan de una moneda estable a otra.

##### 5 | Uniswap
Uniswap es un protocolo que maneja un exchange descentralizado (DEX) que nos permite realizar intercambios con una gran variedad de tokens como Ether, Maker, DAI, USDC, BAT, entre otros. 

Con un parecido cercana a Curve, Uniswap busca crear un medio fácil y rápido para intercambiar valor entre distintos protocolos, incluso en medio de mercados bajistas y obtener ganancia por dichos intercambios.

##### 6 | Synthetix (SNX)
Es una plataforma que se apoya en el valor de su token en red, el SNX. 

Esta plataforma proporciona un protocolo mediante el cual se pueden comercializar activos sintéticos o Synths en Ethereum. 

Los Synths son tokens que representan a activos del mundo real como el oro, Bitcoin, dólares estadounidenses, euros, entre otros muchos activos.

## E2. Herramientas de Smart Contracts en Ethereum
### Truffle (Video)
![[257.B4E2_Herramientas_de_Smart_Contracts_en_Ethereum_-_Truffle.mp4]]
[Herramientas Smart Contracts en Ethereum - Truffle](https://app.web3mba.io?wvideo=axbk5v796j)

Una de las herramientas más utilizadas dentro del desarrollo de Ethereum y de redes compatibles con la EVM es Truffle Suite. Truffle Suite es, en realidad, una suite de tres herramientas que son conocidas como Truffle, Ganache y Drizzle.

Truffle es un sistema para desarrollar y crear entornos de desarrollo para aplicaciones descentralizadas y contratos inteligentes (Smart Contracts). Ganache es una aplicación que nos permite crear una blockchain dentro de nuestro computador, y explicaremos más adelante cómo instalarla y configurarla para que puedas interactuar con ella utilizando MetaMask en tu computador. Por último, Drizzle es simplemente una serie de herramientas que nos permiten crear frontends y manejar datos para nuestras aplicaciones descentralizadas. Estas tres herramientas conforman lo que sería la suite de Truffle.

En este caso, vamos a ver primero la red de Truffle, es decir, Truffle como tal. Vamos a ir a su GitHub y desde allí podemos ver que es completamente código libre y software libre. Podemos instalarla simplemente utilizando este comando: un comando de npm install de forma global para Truffle. En este caso, les recordamos que deben tener instaladas las últimas versiones de Node; deben ser las versiones LTS o utilizar un instalador del tipo nvm dentro de sus computadores. Con ello, podemos comenzar a generar todo lo que serían las interfaces iniciales de desarrollo de nuestro Smart Contract.

¿Qué podemos crear entonces con Truffle? Bueno, con Truffle podemos crear desde tokens ERC20 hasta NFTs o aplicaciones descentralizadas de cualquier tipo. Podemos crear entornos de desarrollo que nos permitan interactuar con IPFS, que es el sistema de almacenamiento descentralizado que utilizan muchas aplicaciones descentralizadas. O podemos simplemente crear un sistema para mintear NFTs, nuestras propias conexiones de NFTs directamente dentro de lo que sería la red Ethereum o dentro de las redes que estemos desarrollando que sean compatibles con Truffle.

Ahora bien, Ganache, por otro lado, es simplemente un software que nos permite instalar todo lo necesario para poner en funcionamiento una blockchain virtual dentro de nuestro computador. Esta blockchain virtual es completamente compatible con Ethereum, de forma que si desarrollas para esta blockchain virtual generada por Ganache, puedes simplemente tomar tu código y llevarlo a la red de Ethereum sin mayores problemas, ya que funcionará sin ninguna dificultad. De hecho, Ganache tiene la capacidad de configurarse para diferentes hard forks que están dentro del código de Ethereum.

Es fácil instalarlo; simplemente seleccionas el tipo de sistema operativo que estás utilizando. En este caso, nos aparece la instalación para Windows porque estamos en un sistema operativo Windows, pero si deseas para otros sistemas operativos, puedes hacer clic en este enlace y rápidamente verás las diferentes versiones disponibles, que en este caso son para Linux en formato AppImage, para Mac en formato DMG y también para Windows en formato ZDub y AppX. Esto significa que puedes instalar Ganache tanto para los tres sistemas: Windows, Linux y macOS. No hay ningún tipo de inconveniente y tendrás las mismas funcionalidades en cada uno de estos casos.

Finalmente, Drizzle es simplemente una colección de librerías que nos permiten manejar datos a nivel de frontend, facilitando la interacción con los usuarios y la compartición de datos entre las diferentes DApps que estemos realizando. Esto es un uso bastante más específico, pero realmente tiene su utilidad cuando hablamos de aplicaciones un poco más complejas; puede ser, por ejemplo, la construcción de un mercado del tipo OpenSea o RedLibre, en el que este tipo de funciones serían excepcionalmente útiles para crear una mejor interacción con los usuarios.

Entonces, como pueden ver, en este caso, Truffle Suite es un compendio de herramientas que nos resultan muy útiles y que facilitan mucho el desarrollo de las aplicaciones descentralizadas. No solamente porque contienen ya esqueletos o bases predefinidas para construir estas aplicaciones, sino porque cuentan con una serie de documentación que facilita mucho este desarrollo. Así que, por ello, comenzaremos a estudiar un poco esta suite y cómo podemos aprovecharla al máximo para crear nuestras aplicaciones descentralizadas sin mayores problemas.

### Ganache (Video)
![[258.B4E2_Herramientas_de_Smart_Contracts_en_Ethereum_-_Ganache.mp4]]
[Herramientas Smart Contracts en Ethereum - Ganache](https://app.web3mba.io?wvideo=ehkzbj4p0j)

Uno de los software más útiles dentro del desarrollo de Ethereum es Ganache, parte de la interfaz o suite de Truffle. Desde aquí podemos acceder y comenzar la descarga de este software, que nos permite crear una copia de una red Ethereum en nuestro computador. Básicamente, lo que hace es simular una blockchain tal como funcionaría en la realidad, permitiéndonos instalarla y utilizarla en nuestro computador como si fuese una red local. Hay varias opciones; en este caso, podemos descargarla para Windows, así como para los sistemas operativos Mac y Linux. Vamos a utilizar la versión para Windows, que simplemente descargaremos y comenzaremos con el proceso de configuración.

Una vez que hemos instalado Ganache, simplemente buscamos Ganache en nuestro computador y ya tenemos este software ejecutándose. Realizaremos una instalación rápida o una prueba rápida de las capacidades de este software y procederemos a hacer un "Quick Start". Con esto, comenzamos a ver lo siguiente. Expliquemos un poco qué es lo que estamos observando. En primer lugar, tenemos una blockchain cuyo bloque actual es el bloque cero. Contamos con un gas price o precio de gas de 2.000 millones de gwei. El límite de gas y el hard fork en este caso aplican el hard fork de Muir Glacier, que es una de las últimas versiones de Ethereum. La identificación de la red es la 5777. El servidor RPC es un servidor tipo web, con el que podemos interactuar con monederos como MetaMask. Esto será muy útil para conectar Ganache y su blockchain virtual con nuestro monedero MetaMask, permitiéndonos utilizarlo como un medio de verificación o duplicación de las actividades dentro de nuestro monedero y la red blockchain.

Podemos observar que el estatus de minería en Ganache tiene la capacidad de ser minería automática, lo que está activo, dejándonos claro que podemos ver todos los procesos que se están llevando a cabo en esta blockchain interna y que podemos interactuar con ella de forma muy rápida, creando transacciones, contratos y eventos distintos. Cada uno de estos elementos generará lo que podemos revisar, y será nuestra principal puerta para entender cómo funcionan nuestros smart contracts y todo el proceso de interacción con esta blockchain.

Ahora bien, ¿para qué autorizar un software como Ganache teniendo Ethereum dentro de nuestras posibilidades de uso? Ganache facilita la interacción. Cuando un desarrollador está frente a su computador, debe tener la capacidad de utilizar la red para la que está creando una aplicación de forma muy rápida. Podemos utilizar Ethereum, pero cada vez que hacemos una interacción con Ethereum, debemos esperar lo suficiente para que la interacción sea verificada por la red, es decir, que sea minada y agregada a la red. Esto se replica tanto en las redes mainnet, donde cada interacción cuesta dinero, como en las redes testnet, que, si bien no cuestan dinero, también tienen ese retraso en el tiempo y se necesita tener tokens de testnet, como Goerli ETH o Ropsten ETH. Ganache elimina esa dificultad, haciéndonos creer que tenemos una blockchain en nuestro computador que se ejecuta de forma automática y con la que podemos interactuar prácticamente de manera instantánea.

Siguiendo en la parte de las cuentas, tenemos aquí una mnemotécnica, que es la que vemos en pantalla, y un paquete jerárquico, que es la dirección de las cuentas que estamos observando. Cada una de estas cuentas tiene 100 Ethereum virtuales, por ejemplo, dentro de sus capacidades. Ahora bien, ¿cómo podemos utilizar esto en un entorno de desarrollo? Por ejemplo, si queremos crear una DApp y hacer pruebas de esta DApp en nuestro navegador, podemos utilizar la Wallet MetaMask para interactuar con ella. Esto es bastante sencillo y lo que haremos es lo siguiente: abriremos nuestra Wallet MetaMask y buscaremos configuraciones. Vamos a ampliar la vista, buscaremos configuraciones y, en seguridad y privacidad, veremos cuál es la frase secreta de recuperación. Simplemente colocamos la clave aquí. Ok, tenemos nuestra clave y la copiaremos. Luego, iremos a configuración y, en cuentas y claves, utilizaremos la mnemotécnica que tenemos en nuestro software MetaMask.

Una nota con respecto a esto: esto solo se debería utilizar para cuentas de desarrollo. Es decir, si tienes una Wallet MetaMask con dinero real, no uses o no realices este procedimiento con ese monedero. Busca la manera de crear otro monedero en otro navegador, que tenga otra clave, otra mnemotécnica, para utilizarla en este proceso. Esto es porque esta clave es tu monedero y debes cuidarla de forma muy responsable para evitar que puedas tener alguna filtración de esta información que termine en manos equivocadas.

Dado que nuestro monedero ha sido recientemente creado y que esta clave no se está utilizando para dinero real, simplemente la queremos utilizar para nuestro desarrollo. Vamos a agregarla aquí y a guardar y reiniciar esto. Ok, ya podemos ver que está utilizando nuestra nueva mnemotécnica, la que hemos agregado. El siguiente paso para conectar nuestra cuenta de Ganache con nuestra cuenta MetaMask es el siguiente: vamos a agregar la red con los parámetros que aparecen aquí arriba. Ahora tenemos nuestra cuenta de Ganache del lado izquierdo y del lado derecho nuestra MetaMask. Lo que haremos es agregar la red que nos está dando nuestra cuenta de Ganache para interactuar con ella. En este caso, utilizaremos "Ganache Test" como nuestro nombre de red, nuestra dirección, que es esta que está aquí, nuestro identificador de cadena, que es el 1337, y el símbolo de la moneda, que es ETH. Simplemente daremos guardar y automáticamente ya podemos ver que tenemos aquí 100 ETH y que la dirección que nos está dando es la A380 5A1A, es decir, nuestra primera cuenta.

Si queremos verificar que todo está correcto, simplemente realizaremos una operación. En este caso, haremos una transferencia a esta cuenta y transmitiremos todo el importe de ETH. Siguiente. Confirmamos y automáticamente podemos ver reflejado que el saldo que estaba en nuestra primera cuenta ha pasado a la segunda. Con ello, podemos ver que nuestro servidor de Ganache está funcionando. Si observamos aquí en los bloques, podemos ver el bloque 1, que fue minado hace unos pocos segundos. Vemos la transacción y los diferentes datos de esa transacción. En este caso, observamos que se ha movilizado un valor de 7 ETH a la dirección a la que hemos enviado. De esta manera, queda patente que Ganache está cumpliendo su función y que hemos conectado nuestra Wallet MetaMask a este software para comenzar a interactuar. Esto es muy útil porque podemos utilizar nuestra Wallet MetaMask para interactuar con las aplicaciones DApp que estemos desarrollando utilizando Truffle y Ganache. Así, podemos interactuar directamente con nuestro monedero y probar toda la funcionalidad de nuestra aplicación sin salir de nuestro computador.

### Truffle y Ganache, las herramientas básicas para desarrollar Smart Contracts en Ethereum (Video)
Si tu interés es programar en la red Ethereum y deseas tener excelentes herramientas a la mano para realizar el desarrollo de tus proyectos, entonces debes conocer Truffle. 

Truffle es una potente suite de herramientas de desarrollo de Smart Contracts para Ethereum y otras redes compatibles con la EVM y el lenguaje de programación Solidity.

![[259.B4E2_truffle_ganache.png]]

#### ¿Qué es Truffle?
Truffle es un conjunto de herramientas de programación orientado a Smart Contracts para desarrollar aplicaciones sostenibles y profesionales sobre la Blockchain utilizando para ello la Máquina Virtual de Ethereum (EVM), así como realizar las distintas pruebas en un entorno de desarrollo integrado amigable para el desarrollador.

La Máquina Virtual de Ethereum (EVM) es el entorno que permite a los desarrolladores crear contratos y aplicaciones inteligentes que la Blockchain puede entender.

La web oficial de Truffle, pone a tu disposición una serie de potentes herramientas de programación. Todas ellas pensadas en sacar el máximo partido a la red Ethereum y su EVM.

![[259.B4E2_truffle.png]]

##### Inicios del proyecto
Truffle comenzó su desarrollo en el año 2015, de la mano de Tim Coulter, quien publicó un conjunto de herramientas de programación, producto de su experiencia de trabajo como desarrollador Blockchain en Ethereum y ConsenSys, y le dio por nombre Truffle.

El proyecto comienza con el desarrollo de un conjunto de algunos scripts con el objetivo de facilitar el proceso de desarrollo de aplicaciones en la Blockchain, que evolucionó hasta convertirse en una de las herramientas más populares para desarrollar aplicaciones que corren en la Blockchain.

> Truffle proporciona un entorno en el que los desarrolladores pueden construir, probar, implementar y automatizar el flujo de trabajo para DApps basados en Blockchain de Ethereum.

##### Objetivo de Truffle
- **El objetivo principal de Truffle es proveer un entorno de desarrollo en la Blockchain que facilite la labor de los desarrolladores** que se dedican a la creación de aplicaciones (DApps) y contratos inteligentes en Ethereum y redes compatibles con la EVM y el lenguaje de programación Truffle.
- **Truffle provee un marco de prueba y una canalización de activos que hacen que el proceso de desarrollar aplicaciones sea más sencillo e intuitivo.** De igual forma, también provee de implementación pre-fabricadas de DApps que pueden ser ajustadas a las necesidades de los programadores, haciendo que el desarrollo sea mucho más rápido y sencillo de realizar.
- En la medida que evoluciona, el equipo de Truffle añade nuevas herramientas y características a este entorno, con el **objetivo de que los desarrolladores tengan dentro del mismo espacio de trabajo todo lo necesario para la creación**, prueba, simulación y otras tareas que permitan afinar las aplicaciones antes de ponerlas a disposición de los usuarios finales.
- **Otro objetivo de Truffle es el de minimizar los inconvenientes que se derivan de las pruebas de contratos inteligentes en Ethereum**, que generalmente se desarrollan utilizando su propio lenguaje de programación Solidity.
- **En este sentido, Truffle permite a los desarrolladores realizar estas pruebas sobre la Máquina Virtual de Ethereum (EVM),** para resolver estos inconvenientes cuando se trata de probar e implementar en la red Ethereum, especialmente aquellos proyectos más grandes con múltiples contratos.

##### Características de Truffle
El entorno de trabajo de Truffle consta de tres componentes principales:
1. **Truffle:** Proporciona una herramienta de desarrollo con la capacidad de probar e implementar los proyectos. Esta herramienta ha crecido notablemente en popularidad, hecho que se refleja en el aumento de las descargas desde los repositorios respectivos.
2. **Ganache:** Un simulador local de Blockchain que le permite replicar redes Blockchain o probar contratos.
3. **Drizzle:** Una biblioteca de desarrollo FrontEnd que se puede conectar a los datos de un contrato inteligente.

En general, todo este conjunto de herramientas conforma la Suite de Truffle, y con ella se pueden realizar operaciones como:
1. Soporte integrado para compilar, implementar y vincular contratos inteligentes.
2. Prueba de contrato automatizada.
3. Admite aplicaciones de consola y aplicaciones web.
4. Gestión de red y gestión de paquetes.
5. Consola Truffle para comunicarse directamente con contratos inteligentes.
6. Admite una estrecha integración
7. Canalización de compilación configurable con soporte para procesos de compilación personalizados.
8. Marco de implementación y migraciones programables.
9. Consola interactiva para comunicación contractual directa.
10. Reconstrucción instantánea de activos durante el desarrollo.
11. Ejecutor de scripts externos que ejecuta scripts dentro de un entorno Truffle.

Por lo tanto, con la Suite de Truffle se tiene un entorno de desarrollo basado en la Blockchain de Ethereum, en el que se puede desarrollar DApps, compilar contratos, implementar contratos, inyectarlos en una aplicación web, crear front-end para DApps y realizar pruebas.

##### Herramientas de Truffle
Como ya se mencionó, en la Suite de Truffle se incorporan otras herramientas que facilitan el trabajo de los desarrolladores en la creación y puesta a punto de sus aplicaciones (DApps).

Dos componentes de esta suite son:

###### 1 | Ganache
Ganache es un Blockchain personal para el desarrollo rápido de aplicaciones distribuidas en Ethereum y redes compatibles con EVM.

Puedes usar Ganache durante todo el ciclo de desarrollo; permitiéndote desarrollar, desplegar y probar tus dApps en un entorno seguro y determinista.

Ganache viene en dos sabores: una UI y una CLI. Ganache UI es una aplicación de escritorio que soporta la tecnología Ethereum y Corda. La herramienta de línea de comandos, ganache-cli (antes conocida como TestRPC), está disponible para el desarrollo.

###### 2 | Drizzle
Drizzle es una colección de bibliotecas de front-end que hacen que escribir front-ends de dapp sea más fácil y predecible.

El núcleo de Drizzle se basa en un almacén Redux, por lo que tienes acceso a las espectaculares herramientas de desarrollo en torno a Redux. 

Nosotros nos encargamos de sincronizar los datos del contrato, los datos de la transacción y más. Las cosas se mantienen rápidas porque tú declaras lo que hay que mantener sincronizado.

1. Datos de contrato totalmente reactivos, incluyendo estado, eventos y transacciones.
2. Declarativo, por lo que no está desperdiciando ciclos valiosos en datos innecesarios.
3. Mantiene el acceso a la funcionalidad subyacente. Web3 y los métodos de tu contrato siguen ahí, sin ser tocados.

## E3. Smart Contracts en Bitcoin con Miniscript
### Miniscript: Smart Contracts en Bitcoin (Video)
![[260.B4E3_Miniscript._Smart_Contracts_en_Bitcoin.mp4]]
[Miniscript Smart Contracts en Bitcoin](https://app.web3mba.io?wvideo=71z20pqqxx)

Una de las grandes características de Bitcoin es que su comunidad siempre está en constante desarrollo, y parte de ese desarrollo lo podemos ver en pantalla con este proyecto llamado Miniscript. Miniscript busca convertirse en un nuevo desarrollo para Bitcoin que permita a los desarrolladores de diferentes plataformas crear o generar Bitcoin Script de forma mucho más sencilla, utilizando otros lenguajes como pueden ser Rust, C++ o directamente lenguajes como Python. La idea es que podamos utilizar estos lenguajes de programación, que son mucho más sencillos y amigables, para generar Bitcoin Script que pueda ser leído o entendido por la red Bitcoin sin mayores modificaciones en todo lo que es el lenguaje de programación Bitcoin Script como tal. Simplemente ajustaríamos una especie de framework o conector para permitir que los desarrolladores puedan crear aplicaciones mucho más avanzadas utilizando estas funciones que Miniscript pone a disposición.

Miniscript ya lleva algún tiempo desarrollándose y todavía es considerado una tecnología previa, es decir, aún no está completamente integrada dentro de lo que sería la tecnología de Bitcoin. Los nuevos desarrolladores de Bitcoin no entenderían directamente Bitcoin Script, pero sí serían capaces de leer el resultado de ese Miniscript. Es decir, una vez que programamos en Rust y generamos todo lo que se deba generar, el código que se va a generar utilizando Miniscript sería un código de Bitcoin Script que podríamos enviar a la red y que sería leído sin mayores complicaciones. Sin embargo, la idea es integrar directamente estas capacidades a Bitcoin para que esta generación sea mucho más fácil, rápida y segura, de modo que podamos implementar nuevas funciones que nos permitan desarrollar nuevas características dentro de Bitcoin.

Parte de esos desarrollos que se dan sobre Miniscript lo vemos en Minsc. Minsc, que estamos viendo ahora en pantalla en la web principal, es un desarrollo que busca crear un lenguaje de scripting utilizando las capacidades de Miniscript. Básicamente, se trata de transformar la dificultad de Miniscript del lenguaje, como sería el uso de Rust, para crear Miniscript. Lo que se busca es facilitar esos desarrollos creando una capa de abstracción que nos permita generar scripts de Bitcoin mucho más potentes y de una forma mucho más sencilla y manejable para cualquier persona. Por ejemplo, aquí en la página principal podemos ver un compilador en vivo de este lenguaje, junto con las características o las salidas que ofrece en este caso de las políticas de Miniscript, el descriptor de Minscript y el Bitcoin Script como tal.

Abajo podemos ver algunos ejemplos; en este caso son ejemplos de operadores lógicos, pero busquemos uno en el que tengamos algunas cosas interesantes. Por ejemplo, este que estamos viendo aquí, lo voy a explicar para que ustedes entiendan qué es lo que está haciendo. En este caso, tenemos una cantidad de directores, que en este caso es esta función que está aquí, y a estos directores tenemos tres claves públicas bien identificadas que son la clave pública de A, B y C. Son nuestros tres directores. Adicionalmente a estos tres directores, tenemos una clave pública para el CEO y una clave pública que debe ser manejada por alguno de los directores.

¿Qué significa esto? Que tenemos un grupo de directores que están autorizados para hacer una transacción dentro de una dirección de Bitcoin o dentro de un grupo de direcciones de Bitcoin, y adicionalmente a esto debemos sumar la clave pública del CEO. Esto permitiría crear DAOs en las que todas las personas que están dentro de esa DAO son capaces de manejar la bóveda del dinero que está dentro de la DAO o que se maneja dentro de la DAO. En este caso, para poder realizar una operación que sea válida, sería necesaria la clave pública del CEO, es decir, que el CEO firme la transacción y que alguno de estos tres directores firme la transacción también. Es decir, sería un esquema de cuatro, en este caso cuatro porque serían las tres de los directores y la del CEO, de cuatro de dos. Es decir, de cuatro firmas que tengo para manejar, me bastan con que dos firmas estén dentro del sistema para que la transacción sea tomada como válida.

¿Qué genera esto? En primer lugar, tenemos aquí el Minsc, pero esto también deriva en una serie de código intermedio que es generado por Minscript. En este caso, el código intermedio va por la parte de las políticas, que es el que estamos viendo aquí en pantalla. Esto es la política de Minscript; como pueden ver, es bastante más complejo de leer que lo que sería el lenguaje de programación Minsc, en este caso el script Minsc. También, adicionalmente, tenemos el descriptor, el manuscript, que sería el equivalente del manuscript de lo que estamos viendo acá. Como pueden ver, también es bastante complejo de leer, pero es mucho más legible que el caso de la política.

Sin embargo, este no es el final de nuestro script de Minsc, sino que esto al final es transformado en el equivalente de Bitcoin Script, que es lo que estamos viendo ahora aquí en pantalla. Este sería el código que finalmente llegaría a las transacciones de Bitcoin y que sería revisado directamente por los nodos. Como pueden ver, se hace un empuje de datos; en este caso, esta instrucción que está aquí me pide que haga un empuje de datos de 36 bytes, y luego empiece con el proceso de verificaciones de firmas y verificaciones adicionales para ver si se cumplen las condiciones descritas por el Minsc. Al final, todas esas verificaciones se realizan y se completa con un check multisig, porque estamos ante un monedero de multifirmas, en este caso con el esquema 2 de 4.

Fácilmente se puede ver la diferencia del lenguaje y de capacidad de programación que tenemos entre Minsc, Minscript y Bitcoin Script. Bitcoin Script es el lenguaje puro de Bitcoin y es bastante complejo de leer, pero es conocido y aceptable en términos de utilización para lo que sería un programador humano. Minscript también es un poco más legible o tiene sus complejidades, pero todavía es mucho más sencillo de manejar. La Policy también es mucho más sencilla de manejar, pero con Minsc toda esta capa de intermediarios de complicaciones con la parte de lo que sería la criptografía y todo este proceso interno que se realiza dentro de estos scripts se lleva a su mínima expresión y nos permite crear código que fácilmente puede ser manejado por cualquier persona que tenga un conocimiento mínimo de este tipo de programación.

Ahora, este código que está aquí es un sistema que nos permite crear un multisig de 4-2, como habíamos comentado al principio. O sea, de cuatro firmas que hay, solo dos se necesitan para cumplir las condiciones. ¿Qué pasaría si necesitamos crear un sistema en el que todos tengan que ingresar sus firmas digitales para verificar la transacción? Pues simplemente, con cambiar una instrucción, ya estaríamos haciendo esto. Lo que hemos cambiado aquí es que de todos los directores vamos a necesitar la firma y del CEO también. Ya con este cambio, simplemente nos cambia toda la política, el Minsc y el Bitcoin Script resultante final. Y lo podemos ver en vivo, porque si volvemos al cambio anterior, rápidamente vemos el resultado de los cambios que estamos teniendo dentro de nuestro script.

Esta es una tecnología que aún está en desarrollo, al igual que otras tecnologías dentro de Bitcoin, como podría ser Taro Protocol, pero es parte fundamental de lo que se está intentando hacer dentro de Bitcoin, que es mantener la cantidad de complejidades al mínimo y, al mismo tiempo, ofrecer funciones avanzadas que le permitan a los desarrolladores crear aplicaciones mucho más complejas y completas que respondan a las necesidades de las personas que utilizan estas redes. Con eso los dejo y les invito a que utilicen este sistema para que puedan verificar y ver de primera mano el potencial que tiene.

### ¿Qué es Miniscript?
![[261.B4E3_miniscript.png]]

Miniscript es un lenguaje para escribir (un subconjunto de) Bitcoin Scripts de forma estructurada, permitiendo el análisis, la composición, la firma genérica y más.

Bitcoin Script es un lenguaje inusual basado en la pila con muchos casos límite, diseñado para implementar condiciones de gasto que consisten en varias combinaciones de firmas, bloqueos de hash y bloqueos de tiempo.

Sin embargo, a pesar de su limitada funcionalidad, sigue siendo altamente no trivial:
1. Dada una combinación de condiciones de gasto, encontrar el script más económico para implementarla.
2. Dados dos scripts, construir un script que implemente una composición de sus condiciones de gasto (por ejemplo, un multisig donde una de las "claves" es otro multisig).
3. Dada una secuencia de comandos, averigüe qué condiciones de gasto permite.
4. Dada una secuencia de comandos y el acceso a un conjunto suficiente de claves privadas, construir un testigo general satisfactorio para ella.
5. Dada una secuencia de comandos, ser capaz de predecir el coste de gastar una salida.
6. Dada una secuencia de comandos, saber si las limitaciones de recursos particulares, como el límite de operaciones, podrían ser golpeadas al gastar.

Miniscript funciona como una representación para scripts que hace posible este tipo de operaciones. 

- **Tiene una estructura que permite la composición.** Es muy fácil de analizar estáticamente para varias propiedades (condiciones de gasto, corrección, propiedades de seguridad, maleabilidad ...). 
- **Puede ser objeto de compiladores de políticas de gasto** (véase más adelante). 
- Por último, **las secuencias de comandos compatibles pueden convertirse fácilmente a la forma Miniscript,** lo que evita la necesidad de metadatos adicionales para, por ejemplo, los dispositivos de firma que lo admiten.

Por ahora, Miniscript está realmente diseñado solo para scripts incrustados P2WSH y P2SH-P2WSH. La mayoría de sus construcciones funcionan bien también en P2SH, pero algunas de las propiedades de seguridad (opcionales) dependen de reglas específicas de Segwit. Además, los compiladores de políticas implementados asumen un modelo de costes específico de Segwit.

> Miniscript fue diseñado e implementado por Pieter Wuille, Andrew Poelstra y Sanket Kanjalkar en Blockstream Research, pero es el resultado de discusiones con otras personas.

#### Historia
Bitcoin Script es un lenguaje potente pero su limitada capacidad para crear Smart Contracts avanzados limita la capacidad de Bitcoin para diseñar DApps y otras aplicaciones avanzadas con Smart  Contracts.

Esa es una realidad que ha acompañado a Bitcoin desde 2009 hasta la actualidad, siendo que Miniscript busca solucionar este problema.

Miniscript ha estado en desarrollo desde 2018 y no fue hasta agosto de 2019, cuando fue anunciado y liberado en Github. Desde entonces, el proyecto ha estado en desarrollo activo no solo en su implementación básica (desarrollada por Blockstream y disponible en este Github) sino también por varias implementaciones que buscan facilitar y ampliar las capacidades de Miniscript usando lenguajes de programación como C++ o Rust.

**De hecho, Rust Miniscript, la versión diseñada en Rust, es la versión más avanzada y con mejor soporte de Miniscript y que ha sido desarrollada por Sanket Kanjalkar y Andrew Poelstra desde el año 2019.**

#### Utilidad
Miniscript es una alternativa a Bitcoin Script que elimina la dificultad de diseñar scripts avanzados.

Permite codificar de forma eficiente y sencilla como script para asegurar que funciona en la Blockchain de Bitcoin, pero su diseño es muy diferente. 

Esencialmente, un Miniscript es una función monótona (árbol de ANDs, ORs y umbrales) de requisitos de firma, requisitos de preimagen de hash, y de tiempos. **Y todo ello, es aplicado de forma que sea mucho más legible para los seres humanos.**

**Otro objetivo muy importante de Miniscript es reemplazar cualquier clave utilizada en una política con otra política. Esto es importante** porque la gente puede tener múltiples claves y complicadas llaves de tiempo en su configuración actual. Al firmar una nueva política, querrían utilizar su configuración existente para generar también direcciones para esta nueva configuración. Esto se logra usando algo llamado “Descriptores de Salida”.

**Así, el compilador de Miniscript compila una política de gasto usando Miniscript. Esta no contiene ninguna firma, siendo principalmente un lenguaje de combinadores para diseñar condiciones de gasto.**

Por ejemplo, un Bitcoin Script para realizar un pago usando HTLC, tendría una estructura como esta:
```
OP IF
OP HASH160 <Hash160 (R)> OP EQUALVERIFY
2  <Alice2> <Bob2> OP CHECKMULTISIG
OP ELSE
2 <Alice1> <Bob1> OP CHECKMULTISIG
OP ENDIF
```

Pero en Miniscript (en su implementación base) este código se escribiría:
```
aor(and(pk(A),time(T)),and(pk(B),hash(H))))
```

Con este sencillo ejemplo, podemos ver muy claramente que la legibilidad de código y la capacidad de Miniscript de simplificar el desarrollo de funciones en Bitcoin, hace mucho más accesible esta tarea permitiendo que se puedan desarrollar aplicaciones complejas y seguras para esta red, o cualquiera que use un derivado de Bitcoin Script (como Litecoin por ejemplo).

## E4. Sidechains en Bitcoin
### Sidechains en Bitcoin (Video)
![[262.B4E4_Sidechains_en_Bitcoin.mp4]]
[Sidechains en Bitcoin](https://app.web3mba.io?wvideo=iy8zdhijlf)

¡A la próxima! A la primera e interactuar con ella. Esta nueva cadena contiene una programación distinta y unas características completamente diferentes que permiten mejorar la compatibilidad de la primera. Gracias a ello, ambas cadenas pueden comunicarse y complementar sus capacidades.

Un ejemplo: imagina que un desarrollador desea crear una DApp y desplegarla sobre la cadena Bitcoin. Lograr esto, como ya lo sabéis, es un poco complicado y complejo. Sin embargo, es posible desarrollar una sidechain que agregue esta funcionalidad, la de desplegar una DApp, y esta podría complementarse directamente con la cadena Bitcoin. Esta sidechain tendría la capacidad de desplegar las DApps e interactuar de forma bidireccional con la cadena Bitcoin, la primera. El resultado sería que es posible desarrollar y desplegar DApps que aprovechen el potencial de Bitcoin, el tema de minería y demás propiedades, gracias al uso de una cadena lateral o sidechain.

El funcionamiento de una cadena lateral no es nada sencillo. Técnicamente, es un desafío enorme y ha llevado muchos años refinarlo y perfeccionarlo. Pero a grandes rasgos, el funcionamiento de las cadenas laterales es el siguiente. Atentos. En primer lugar, se envían las criptomonedas a una dirección específica y, una vez allí, estos fondos son congelados. Nadie puede manejarlos. La única manera de acceder a dichos fondos es demostrar que estas criptomonedas no se están usando en ningún otro lugar y, a partir de aquí, se confirma que estos fondos ya no se usan en ningún otro lugar y, por tanto, la sidechain recibe una notificación y, a partir de ese momento, puede utilizarlos.

Tras ello, la sidechain creará de forma automática el mismo número exacto de activos de criptomonedas que se mandaron, claro está, usando el token que dicha sidechain maneja. El control de estos tokens será completamente tuyo. A partir de este momento, se podrán intercambiar y mover estos tokens para hacer uso del potencial de esta nueva sidechain, todo ello seguido de las directrices y el protocolo que estén estipulados en esta nueva cadena lateral. Por ejemplo, quizás la velocidad de creación de los bloques sea más rápida o quizás la comisión de transacciones sea un poco menor. A partir de aquí, como puedes apreciar, las posibilidades de testeo y pruebas son prácticamente infinitas.

¿Por qué son importantes las cadenas laterales? Bien, estas sidechains tienen una gran relevancia, pues permiten dinamizar de forma única el funcionamiento de la blockchain. Por ejemplo, la sidechain puede habilitar la transferencia de bitcoins y otras criptomonedas a otras blockchains. Es decir, gracias a estas cadenas laterales sería posible enviar BTC, bitcoin, a una sidechain que transforme dicho bitcoin a un token determinado y de allí vaya a la blockchain de, por ejemplo, Ethereum. Asimismo, las cadenas laterales pueden aumentar la seguridad, evitando problemas que se han sucedido ya en otros proyectos de altcoins; seguro que habéis conocido algún ejemplo. También las cadenas laterales pueden servir para agregar nuevas funcionalidades únicas a una blockchain sin necesidad de alterar el protocolo inicial.

Teóricamente, las cadenas laterales o sidechains pueden solucionar la falta de liquidez en Bitcoin, reducir la volatilidad, aumentar la seguridad, reducir la fragmentación de mercado o evitar el fraude, que en ocasiones se ha observado ya en algunos proyectos de altcoins. Todo esto mejoraría enormemente el ecosistema de las criptomonedas actual y abriría las puertas para nuevos usos. Todo lo que nosotros queremos. En pocas palabras, son un medio perfecto para desarrollar nuevas tecnologías que pueden ser adaptadas a la ya creada, todo ello sin grandes cambios y con la posibilidad de seguir expandiendo aún más su potencial.

Al mismo tiempo, puesto que las cadenas laterales o sidechains siguen siendo blockchains independientes, en ellas se puede experimentar toda clase de funcionalidades sin riesgo. Esto incluye nuevos diseños de transacción, modelos de confianza o modelos económicos, emisión de activos semánticos o funcionalidades de criptografía nuevas. Como habéis visto, las sidechains o cadenas laterales son bastante versátiles y permiten expandir enormemente todo este nuevo mundo de Web3.

Si tu interés es programar en la Ardecerium y deseas tener excelentes herramientas en tu mano, entonces debes conocer Tráfodo, una potente suite de herramientas de desarrollo de smart contracts para Ethereum y otras redes compatibles con EVM y el lenguaje de programación Solidity. Te lo recomiendo.

Counterparty es un protocolo para la creación y uso de instrumentos financieros descentralizados utilizando Bitcoin como capa de transporte. El protocolo implementa y soporta actualmente la creación de activos, la emisión de bonos de esos activos, el pago de dividendos, el comercio de protocolo en depósito, las apuestas binarias, los contratos por diferencia, etc. El protocolo ha estado funcionando desde enero de 2014, ya hace bastante tiempo. Para activar el protocolo, para hacer depósitos de valor, de negociación descentralizada y contratos financieros, así como apuestas binarias u otras cosas, había la necesidad de una moneda de valor común en el sistema de Counterparty.

De una manera similar, como se podría hacer a nivel personal, la moneda digital fue empleada para crear unidades de moneda nativa de Counterparty, XCP. Durante el periodo de 30 días de prueba, en enero de 2014, se crearon 2,6 millones de XCP. Las transacciones de Counterparty son transacciones Bitcoin. Dependiendo de su forma, se pueden codificar los datos adicionales en una salida OP-Return o en direcciones adicionales como un Output Multisignature. El consenso se logró después de la interpretación de datos adicionales en la blockchain de Bitcoin de manera consistente.

El uso de Counterparty gira en gran medida alrededor de Counterwallet, el software libre web ofrecido por el equipo de desarrollo. El equipo central también gestiona una wiki y su foro, además de Blockscan.com, que es un explorador de bloques Counterparty para proporcionar información sobre las transacciones de los activos, pedidos, las apuestas, las emisiones o cualquier otra cosa. El código Counterparty proporciona una interfaz RPC JSON, pero también utiliza una base de datos SQLite para almacenar su información, lo que facilita el acceso. Fuera de los servicios básicos y de información, algunos proyectos que se están desarrollando consisten en herramientas alrededor de los activos, incluidos los de crowdfunding o programas de recompensas.

El protocolo Lightning Network es un protocolo pensado para mejorar la escalabilidad de Bitcoin. Esto es posible gracias a que este protocolo trabaja en una segunda capa sobre Bitcoin, una que les permite a estas criptomonedas realizar cosas que normalmente no podrían, y más específicamente, transacciones instantáneas y con unas muy bajas comisiones. El desarrollo de este protocolo comenzó con los trabajos de Joseph Poon y Tadeusz Dridja, pero en la actualidad son empresas como Blockstream, Lightning Labs o Async las que han hecho un gran impulso en el desarrollo de esta red.

El white paper de esta red lo podéis encontrar en su web principal y la segunda es que ese objetivo es imposible de alcanzar en el estado actual de la red Bitcoin y de su software. La razón es muy sencilla: Bitcoin tiene problemas de escalabilidad. En la actualidad, Bitcoin solo puede procesar de 7 a 8 transacciones por segundo, muy pocas. Esta es una capacidad muy pequeña, como podéis comparar con Visa o Mastercard, y que no puede hacer frente al uso masivo de la criptomoneda. Como resultado, la red Bitcoin se hace lenta y muy cara a la hora de pagar comisiones. Por esta razón se necesita una nueva forma de realizar las transacciones, de forma rápida y que fuera sencilla de utilizar y, obviamente, compatible con Bitcoin. La respuesta a estas necesidades es Lightning Network, un protocolo del cual vamos a aprender un poco más a continuación.

¿Por qué se necesita mejorar la escalabilidad de Bitcoin? Seguramente te estás haciendo esta misma pregunta y estás en tu derecho. Pensarás que Bitcoin tiene una red tan poderosa y tan extensa que, bueno, es sencillo mejorar su escalabilidad o debe mejorar su escalabilidad. La respuesta es que al mejorar la escalabilidad, las transacciones se hacen más rápidas, menos costosas y, por tanto, se democratizan. Es un poco lo que todos queremos. Para explicar un poco mejor esto, vamos a hacer este pequeño ejercicio. Imagina que tienes que hacer una transacción a Bitcoin y en ese momento la red está con poco uso y el coste de la comisión es muy pequeño. Perfecto. Pero ahora imagina que el coste de las comisiones puede aumentar debido a que el uso de la red aumenta. Esto se debe a que se genera una cola o exceso de transacciones en la main pool. Y es allí cuando los mineros suelen priorizar las transacciones con mayor pago de comisiones. De esa forma, si deseas que una transacción sea procesada de forma rápida, entonces tendrás que pagar más comisiones. Pero este último caso nos indica también que los costos de las comisiones aumentarán hasta el punto que no permitamos hacer micropagos. Por ejemplo, enviar un euro o un dólar puede resultarnos en más de un euro o un dólar, cosa que no debería tener sentido. Esto es una situación que la mejora de la escalabilidad puede solucionar. Y es allí donde entra Lightning Network.

Vamos a ver un poco más su funcionamiento. El funcionamiento de la red depende de varios factores técnicos y de un proceso que resulte sencillo y fácil de usar. En primer lugar, Lightning Network depende de que la no maleabilidad de la criptomoneda esté asegurada. De esta forma, sería imposible para un tercero cambiar la información sobre las transacciones o la criptomoneda durante un proceso de verificación o generación de las mismas. En Bitcoin y Litecoin, la propiedad de no maleabilidad de las transacciones se introdujo gracias a la llegada de SegWit. Con esta mejora, Bitcoin solucionaba este problema y ponía los primeros ladrillos de la construcción para una nueva forma de escalar sus capacidades. Fue así como comenzó el desarrollo de Lightning Network y sus llamados canales de pago.

Estos canales de pago son la piedra angular del funcionamiento de Lightning Network y la llave que permite la escalabilidad sin precedentes en Bitcoin. Los canales de pago, o payment channels, son la base de Lightning Network. Un canal de pago es en realidad una transacción multifirma en la blockchain con la que al menos una de ellas esté enviando fondos. En dicho canal, cada persona tiene una clave privada y cada transacción futura podrá realizarse únicamente si las claves de las dos partes firman. Esto, como un medio de consenso de la transacción, ha sido aprobado para ejecutarse en ambas partes.

Adicionalmente, los canales de pago pueden estar abiertos por un determinado periodo de tiempo, normalmente de 10 minutos o hasta que el próximo bloque se mine. Una vez abierto el canal, los participantes del mismo pueden intercambiar activos entre ellos de forma instantánea utilizando los fondos almacenados en dicho canal. Esto significa que las partes que están en un canal de pago de Lightning Network pueden realizar pagos entre sí de forma instantánea. Pese a este comportamiento, las transacciones realizadas en dicho canal de pago son completamente válidas en la blockchain. Esto se debe a que, una vez el canal se cierra, las transacciones realizadas se emiten a la red, se verifican y se incluyen en un bloque de Bitcoin.

Para entender cómo funciona Lightning Network, lo mejor es desglosar paso a paso todo su proceso de funcionamiento. Por esta razón, te voy a explicar con un sencillo ejercicio cómo se realiza este proceso junto a otros puntos de interés para despejar tus dudas. Atento. En primer lugar, dentro de Lightning Network, tendremos dos participantes que crearán una transacción inicial de la cadena de bloques de 20 euros. Imagina que de estos 20 euros, 10 serán de Paula y otros 10 serán de John. Este reparto podría ser distinto y puede variar dentro del canal que mencionamos anteriormente, por lo que Paula podría tener 15 o John 5. Al final, da igual. Lo que Lightning hace es tomar la tecnología de estos canales de pago y crear una red que los conforma utilizando smart contracts para asegurarse de que la red puede funcionar de forma descentralizada.

Por tanto, nos quedaría el siguiente desglose de proceso. Paula abre un canal de pago con John, que a su vez abre otro canal de pago con Laura, que a su vez tiene abierto otro canal con David. Ahora mismo tenemos cuatro participantes en el canal. Paula quiere intercambiar activos con David, por lo que podrá enviar fondos a través de John y Laura para que lleguen, en última instancia, a David, el receptor. Debido a la naturaleza de Lightning Network, Paula no tendría por qué confiar ni en John ni en Laura dentro del proceso, ya que se usa criptografía para asegurar que los fondos los podrá recibir David sin ningún tipo de problema. En caso de haber algún problema o error, los fondos se devolverán automáticamente a Paula.

Nos quedamos con una serie de preguntas que son muy importantes de responder. ¿Cómo es posible confiar en el último paso? ¿Qué sucede con la disponibilidad o cómo se combate el engaño? Bueno, ¿qué pasa con la confianza? En realidad, John y Laura actúan como nodos dentro de la red que podemos equiparar a los mineros de la red Bitcoin. Esto gracias a que ellos procesan de forma descentralizada todas las transacciones sin tener el control de los fondos. Por esta razón, en ningún momento ni John ni Laura podrían robar los fondos de Paula, ya que solo se recibirán los fondos a enviar si ya se ha realizado la transacción de salida al receptor, que en este caso es David.

¿Qué sucede con la disponibilidad? Si John se desconecta, los fondos del canal, obviamente, no quedarían indefinidamente atrapados en él, sino que dentro del mecanismo de los smart contracts de Lightning Network, los usuarios pueden cerrar de forma unilateral los canales. De esta forma, John desaparecería y Paula podría recuperar su dinero de nuevo, pero gracias al atributo del tiempo añadido en el contrato. Cuando un canal se cierra, a la vez, tras haberse realizado un número indefinido de intercambios, los fondos finales en cada una de las partes constarán en la blockchain en, como hemos dicho antes, 10 minutos o lo que tarde en aparecer el próximo bloque de la red.

¿Cómo se combate el engaño? Imaginemos un caso de engaño en el que Paula vaya a mandar sus fondos a David y esta Paula intenta engañar a la blockchain cerrando la transacción y cerrando el canal con un estado previo, es decir, con un estado en el que aún es Paula la que tiene los fondos y no David. En este caso, Lightning Network se daría cuenta gracias a sus algoritmos, por lo que todo aquel que intente transmitir una transacción antigua e inválida será penalizado. Gracias a esta red de canales persona a persona, es posible encontrar un patrón dentro de la red, por lo que podréis transmitir transacciones de forma ilimitada entre ellos. Todo ello sin perder la confianza de que, posteriormente y tras cerrarse el canal, constará dentro de la blockchain de Bitcoin.

En primer lugar, Lightning Network ofrece una de las más poderosas opciones para mejorar la escalabilidad de Bitcoin. Lightning puede llevar a Bitcoin hasta niveles cercanos a 1 millón de transacciones por segundo, mucho más que las que manejamos ahora con sistemas de pago como Visa o Mastercard. Ofrece altos niveles de seguridad y anonimato. Esto se debe a que las transacciones ocurren off-chain, por lo que los pagos son prácticamente imposibles de rastrear. Lightning es compatible con otros proyectos de criptomonedas además de Bitcoin; es posible usarlo en Litecoin.

Otra ventaja es que es capaz de reducir enormemente el nivel de tráfico de las transacciones dentro de la red Bitcoin. Esto hace que la red de Bitcoin funcione mucho más eficientemente. Las transacciones usadas en Lightning Network se realizan de forma casi instantánea. Permite la realización de micropagos, lo que hemos hablado antes de 1$, e incluso permite la automatización de las mismas. También habilita la capacidad de realizar intercambios atómicos cross-chain. Esto permite que dos cadenas de bloques que usen la misma función hash puedan intercambiar tokens sin necesidad de un intermediario.

Ahora, también tiene algunas desventajas. La principal desventaja es que los pagos solo pueden realizarse a través de usuarios que estén conectados en un canal, como hemos dicho antes. Esto quiere decir que el usuario debe estar activo y conectado al canal. A diferencia de esto, las transacciones de criptomonedas tradicionales no tienen esta limitación. Lightning Network es un protocolo que aún está en constante desarrollo. De hecho, sus desarrolladores recomiendan no usar la red para operaciones muy altas. Cuidado. El protocolo limita también la liquidez del canal al total de las criptomonedas que sostienen todas las partes. Esta es otra situación un poco incómoda que atenta contra las operativas de alto valor, pues lleva a los usuarios a dividir sus fondos para tener liquidez en la blockchain normal y en los canales de Lightning Network.

Liquid es una innovadora cadena lateral (sidechain) construida sobre la red Bitcoin, que facilita transacciones más rápidas de Bitcoin entre empresas y particulares, a la vez que permite una mayor funcionalidad. Algunas de las características de Liquid incluyen el activo Liquid Bitcoin, el BTC nativo de esta red, que está respaldado por una conexión bidireccional a Bitcoin. Por tanto, puede canjearse en cualquier momento, lo que proporciona a las instituciones o a usuarios finales una forma segura y rápida de transferir bitcoins entre sí.

Otra característica son los activos emitidos de Liquid, que aportan características similares a las de Bitcoin a los activos tradicionales, como fiat tokenizado, los puntos de recompensa digitales y los activos certificados, por ejemplo, monedas de oro, eliminando la necesidad de cadenas de bloques dedicadas o software de billeteras. Otra característica es que la tecnología de transacciones confidenciales de Blockstream garantiza que la cantidad y el tipo de activos transferidos solo sean conocidos por las partes, lo que mejora la privacidad, tanto en las transacciones de LBTC como en sus activos emitidos.

Liquid permite la integración de la billetera Green Address, un nuevo cliente de billetera Liquid Wallet de código abierto y que están planteando soportar el hardware también de terceros como Ledger o Trezor. Bueno, como habéis visto, uno de los mayores problemas de las diferentes blockchains como Bitcoin es su escalabilidad. Como ya hemos visto, Bitcoin y las otras redes tienen algunos problemas como la escalabilidad y cadenas laterales como Lightning o Liquid vienen a ayudar, vienen a implementar mejoras para estos problemas y que así el Bitcoin sea mucho mejor.

La plataforma RSK es un protocolo basado en el lenguaje Solidity que funciona como una cadena lateral (sidechain) que se ejecuta en paralelo a la blockchain de Bitcoin. Este protocolo se basa en una comunicación bidireccional en la que opera como puente para conectar ambas cadenas. De esta forma, permite que la red Bitcoin pueda ayudar en su ejecución a RSK. Es por ello que la moneda o token nativo de la plataforma RSK es el RSK Smart Bitcoin (RBTC), que guarda una relación 1-1 con la moneda original de la red Bitcoin. Gracias a la nueva funcionalidad de esta plataforma, hoy en día es posible disfrutar de aplicaciones descentralizadas (DApps) y smart contracts complejos dentro de la red Bitcoin, de forma muy similar a cómo ocurre dentro de las redes de Ethereum u otras, pero con toda la seguridad y la robustez de la que goza la blockchain de Bitcoin.

¿Cómo funciona RSK? RSK es un protocolo de segundo nivel que opera en una blockchain paralela a la blockchain de Bitcoin. No obstante, ambas redes utilizan un protocolo de trabajo o Proof of Work para realizar las validaciones y generar nuevos bloques dentro de las blockchains. Asimismo, ambas redes utilizan el algoritmo de minado SHA-256, una característica que le permite a ambas blockchains realizar la minería combinada o Merged Mining, empleando los mismos equipos de minería y el mismo poder de cálculo. No obstante, RSK brinda características o funcionalidades especiales que no son posibles en la red de Bitcoin.

Por esto es un aside. Por ejemplo, la federación RSK, compuesta por empresas reconocidas y de confianza, permite que los usuarios puedan intercambiar sus monedas en ambas blockchains cuando lo necesiten, utilizando funciones de la plataforma RSK, o tener de vuelta los bitcoins enviados a la cadena paralela cuando necesiten utilizarlos en la red principal. Por otro lado, RSK permite la implementación del protocolo Decore Plus, con el que se puede llevar un control justo y equitativo entre los mineros para que realicen un trabajo completamente confiable y transparente.

Asimismo, cada vez que un usuario requiera realizar una acción en la red RSK, deberá transferir los fondos desde la red Bitcoin, los cuales van a quedar bloqueados o congelados por la federación RSK. Posteriormente, estos bitcoins son transformados al token nativo RSK, que es el RBTC, en proporción 1-1. Estos tokens serán empleados por los usuarios para pagar a los mineros por las acciones ejecutadas dentro de la plataforma RSK, como la ejecución o el procesamiento de un smart contract o la implementación de DApps. Asimismo, si los usuarios no emplean los tokens RBTC, pueden solicitar el proceso de vuelta a Bitcoin.

Sigamos hablando de la federación. Todos los miembros que sostienen el ecosistema RSK están registrados e identificados plenamente. Son los conocidos miembros de la federación y su trabajo es fundamental para el funcionamiento de la red. El funcionamiento de la federación es sencillo. Su tarea es la de bloquear y desbloquear fondos que entran y salen del ecosistema RSK. A cambio de su trabajo, a los miembros de la federación se les otorga un 1% de las tarifas de transacción generadas en esta red, para cubrir, obviamente, los costos de hardware y mantenimiento.

Básicamente, lo que pasa cuando se intercambia BTC por RBTC es que todos los nodos de la federación reciben algunos BTC y bloquean su uso dentro de la red. Al recibir estos BTC, la federación autoriza la emisión de la misma cantidad de RBTC en la red RSK en esta sidechain. Cuando RBTC necesita convertirse de nuevo en Bitcoin, se bloquea en la red RSK y la misma cantidad en Bitcoin se desbloquea en la red principal. Por tanto, lo más importante de todo esto es que la federación posee las llaves que protegen los fondos bloqueados en este sistema que acabamos de comentar. Ningún miembro puede controlar por sí mismo los BTC bloqueados; solo la mayoría de ellos tiene la capacidad de liberar fondos bloqueados. Así que, básicamente, los miembros de la federación lo que tienen es una serie de direcciones multifirma bajo su control con las cuales bloquean y desbloquean fondos según sus necesidades.

Por supuesto, existe un proceso automatizado que permite modificar la composición de esta federación. Cada miembro de la federación puede aceptar o rechazar un cambio de composición. El proceso, que es un poco frecuente, está dirigido por un contrato inteligente, un smart contract, por lo que está abierto al público. El protocolo tiene una demora forzada por consenso de una semana hasta que se active el cambio. Esto permite a los usuarios transferir los bitcoins nuevamente de la red Bitcoin en caso de que no confíen o que la nueva composición de la federación no sea correcta. A partir de enero de 2019, la federación RSK comprende 15 notarios conocidos.

Hablemos ahora de RVM, que es la máquina virtual Turing de RSK. En esta implementación es muy poco probable que el protocolo RSK funcione de la forma correcta. La máquina virtual, RUVM, permite la utilización de una plataforma Turing Complete, mediante la cual se pueden ejecutar los smart contracts y las DApps sin mayor obstáculo o inconveniente. Por lo que RUVM es el corazón de esta plataforma. Por su parte, como la máquina virtual RSK es completamente compatible con la máquina virtual de Ethereum, es posible la importación de contratos desde RSK a Ethereum y viceversa. Algo muy positivo. Un proceso que no demanda una gran cantidad de capacidad de trabajo gracias a su compatibilidad y que, a veces, no es tan fácil, ofrece grandes beneficios, como la mejora en la capacidad de procesamiento de las transacciones, permitiendo que la interacción entre los smart contracts, DApps y usuarios se realice de forma eficiente y rápida.

Bueno, vamos a hablar de las características principales de esta red. En primer lugar, la plataforma RSK permite la creación y la implementación de programas y aplicaciones distribuidas junto a contratos inteligentes, complejos o sencillos, que se realicen de forma segura y confiable. De igual forma, con todas estas funcionalidades con las que cuenta este protocolo, en RSK es posible que las operaciones de transferencias y pagos se realicen de forma mucho más rápida que en la red de Bitcoin. Por ejemplo, en RSK se implementa el protocolo GOST para agilizar el proceso de creación y validación de transacciones, permitiendo que la cadena pueda realizar entre 10 y 20 transacciones por segundo, a diferencia de las 7 o 8 que hemos visto antes con Bitcoin. A su vez, cada transacción puede ser confirmada en un periodo de 20 o 30 segundos.

Asimismo, RSK goza de todas las características propias de la red Bitcoin, como un alto nivel de seguridad, confianza, descentralización, transparencia y todo esto. Cada implementación creada en esta red se guarda de forma inalterable en la red Bitcoin. Es decir, cada acción ejecutada dentro de RSK comienza en Bitcoin, se ejecuta en RSK y se registra otra vez en la blockchain de Bitcoin. Al igual que en Bitcoin, en esta red existen propuestas de mejora. En RSK se cuentan con los RSK Hyper, que son documentos técnicos elaborados por los desarrolladores de la plataforma o de la comunidad a fin de plantear mejoras que optimicen el funcionamiento, operatividad o seguridad de la red.

Otra cualidad de la cual goza RSK es que no posee un número específico de monedas o tokens dentro de esta red, a diferencia de Bitcoin, que ya sabemos que es limitado. Sino que, por el contrario, los tokens RBTC son creados por la transferencia de bitcoins. Es imposible manipular o especular con su precio. Hablemos ahora de las ventajas y desventajas de esta sidechain. RSK permite la creación e implementación de contratos inteligentes de forma descentralizada, autónoma y los cuales pueden estar basados en casi cualquier cosa. Esto es una gran ventaja. En RSK, las tarifas de comisión por transferencia son mucho más económicas que las de Bitcoin. En promedio, un usuario puede pagar solo entre el 20 y 25% de la transacción realizada en RSK, de lo que generalmente costaría en la red Bitcoin.

Gracias a la implementación del protocolo GOST, la red RSK puede extraer bloques y validar transacciones de forma mucho más rápida que la red Bitcoin. En promedio, RSK puede procesar entre 10 y 20 transacciones por segundo, con un promedio de confirmación entre 20 y 30 segundos. No obstante, si se implementa el protocolo Lumino, la red RSK podría llegar a procesar desde 5.000 hasta 20.000 transacciones por segundo. Como esta sidechain mantiene las cualidades de la red Bitcoin, esta plataforma también mantiene el anonimato de su red principal. Aunque hay que resaltar que en RSK es mucho más factible la implementación de CoinJoin o el protocolo ZK para implementar un nivel de privacidad aún superior.

Vamos a hablar ahora de algunas pequeñas desventajas. Se podría considerar una desventaja de esta red que, al ser una sidechain o cadena lateral, esta no opera como una blockchain propia en sí, sino más bien que su trabajo y operatividad se fundamentan en otra red, en Bitcoin. Por lo que RSK funciona más como una herramienta para potenciar Bitcoin, aunque ambas blockchains son independientes entre sí. Fundaciones o empresas que utilizan la sidechain RSK son, por ejemplo, la fundación Bitgif, la cual ha sido una de las pioneras en la implementación de la tecnología blockchain desde Bitcoin y de RSK para realizar las donaciones de caridad a través de su plataforma criptográfica Giftrack. Esta emplea las tecnologías para el seguimiento de las donaciones recibidas y realizadas y los resultados de estas están en tiempo real. La plataforma Giftrack ofrece confiabilidad y responsabilidad para todos aquellos que deseéis realizar donaciones benéficas. Gracias a las características propias de la tecnología blockchain y las redes Bitcoin y RSK, como inmutabilidad, transparencia y descentralización, podemos realizar estas donaciones humanitarias.

Hablemos ahora de Sesocio, un mercado financiero de inversión que implementa la tecnología blockchain y Rootstock para brindar una mayor descentralización del mercado y así facilitar el acceso a todos aquellos pequeños y medianos inversores, como podéis ser vosotros, que deseen acceder a las distintas oportunidades de inversión que existen dentro del mercado.

TextFlight. Para nadie es un secreto que la industria de la logística y el transporte está plagada de procesos que generan retrasos inesperados y demás tiempos de entrega lentos, además de disputas, hasta casos de robo, fraude y demás. Por ello, la plataforma DexFreight, basada en la tecnología blockchain, implementa los smart contracts gracias a la plataforma Rootstock. Esto con la finalidad de mejorar de forma significativa la eficiencia del sistema y, por ende, la experiencia del usuario. Las cualidades que brinda la tecnología blockchain permiten que los procesos en el área de logística y transportes sufran ahora un giro de 360 grados. Una situación que hace posible que todos estos procesos puedan efectuarse de forma transparente, segura y confiable.

Asimismo, la plataforma Rootstock cuenta con varios casos de uso y aplicación en diferentes áreas de la vida cotidiana, como es el desarrollo de juegos, procesos de asesoría, consultorías jurídicas, procesos bancarios, distribución de cadena alimentaria y demás. Blockstack es un proyecto de software libre que está enfocado en extender la funcionalidad de la blockchain en Bitcoin. Para ello, Blockstack ha generado toda la infraestructura de apoyo dedicada a ofrecer capacidades de smart contracts y de infraestructura necesaria para crear DApps, aplicaciones descentralizadas, que funcionan de forma correcta sobre la blockchain de Bitcoin y, lo mejor, sin tener que afectar de forma negativa al protocolo de esta.

Blockstack es un protocolo de segunda capa o Layer 2, por lo que todo su funcionamiento, pese a depender de Bitcoin, no almacena información directamente dentro de la blockchain de Bitcoin, manteniendo una clara separación entre la interactividad de esta blockchain y las aplicaciones sobre Blockstack. Por otro lado, esto significa que Blockstack depende de toda una infraestructura de funcionamiento externa a la blockchain de Bitcoin y estas partes son las que realmente permiten que Blockstack ejecute aplicaciones descentralizadas. Blockstack es la blockchain que usa su cadena lateral Stack para mantener una contabilidad interna para todas sus aplicaciones. Esta es una función que salió en la segunda versión de la cadena en 2021. Desde Stack se construyen una serie de servicios y protocolos pensados para expandir las capacidades de los smart contracts y las DApps de Blockstack. Entre dichas funcionalidades podemos mencionar el servicio de almacenamiento distribuido, GAIA, el sistema de autenticación descentralizada, un sistema descentralizado DNS, servicios financieros y demás. En la actualidad, servicios como GAIA, DNS, identidad digital y demás ya se encuentran funcionando.

Finalmente, para facilitar el desarrollo de las aplicaciones, Blockstack crea una serie de protocolos bien definidos que facilitan a los programadores el acceso a todas estas funciones, permitiendo así que los desarrolladores puedan crear DApps de forma sencilla y desplegar las mismas sobre Blockstack. Hablemos ahora de Stack Token (STX), que es la moneda de la red Blockstack. En la actualidad, la generación inicial de este token responde a una emisión dada en su Genesis Block o bloque de Genesis. Esta emisión produjo un total de 1,32 mil millones de tokens cuando la red se puso en marcha en noviembre de 2018. De estos 1,32 mil millones de tokens generados en el Genesis Block, más de 800 millones se asignaron a compradores anteriores al lanzamiento del Genesis Block. Por otro lado, más de 400 millones permanecieron sin asignar. Esta asignación inicial sirvió para distribuir tokens a los inversores que participaron en la ICO y a las rondas de financiación del proyecto durante 2017 y 2018.

El resto de tokens, por su parte, fue asignado y distribuido junto con el hard fork de la red, que distribuyó los tokens vendidos o asignados como parte de varias ventas y distribuciones que tuvieron lugar en 2019. Ahora bien, en la actualidad estos tokens tienen una función que está limitada dentro de la sidechain Stack. Esto se debe a que, al movilizar tokens de STX, realmente lo que movemos es un valor de unos pocos satoshis dentro de la blockchain de Bitcoin. Y esta operación se ve reflejada tanto en la sidechain Stack como en la blockchain de Bitcoin. En pocas palabras, de momento, STX es un token dentro de la blockchain de Bitcoin y esto lleva a la plataforma a tener fuertes problemas de escalabilidad y de uso.

Para salvar estas limitaciones, Blockstack lanzó en 2021 una nueva versión donde los STX responden a nuevas reglas y tienen nuevas capacidades. La primera de ellas es que la generación de estos tokens responde a un proceso de minería utilizando el esquema que une Proof-of-Work con el de Bitcoin, prueba de trabajo con la prueba de quemado, Proof of Burn. Este nuevo esquema se llama Prueba de Transferencia o PoX. La principal característica de este sistema es que su emisión y dificultad de minería son variables, adaptándose así a las necesidades de la red y afectando lo menos posible al valor del token dentro del mercado. Así, por ejemplo, en momentos de alta actividad de la red, esta generará más tokens STX y, en momentos de menos, reducirá la emisión de los tokens, hasta un mínimo programado en el protocolo.

Ahora bien, la utilidad de PoX. Estos nuevos tokens están centrados inicialmente en registrar activos digitales en Blockstack. Los usuarios de Blockstack podrán usar sus tokens STX para registrar diferentes tipos de activos digitales como nombres de usuario, nombres de dominios, licencias de software, podcasts y más. Para ejecutar smart contracts es necesario tener GAS para financiar el coste de verificar la exactitud del smart contract y el coste de su ejecución. Los tokens STX son de valor. También pueden ser utilizados para cubrir los costes de almacenamiento del smart contract en la propia sidechain. Otra utilidad sería para las tasas de transacciones. Los tokens son utilizados para pagar las tasas derivadas de incluir transacciones dentro de la Stack Blockchain.

Como último caso de utilidad podríamos hablar de las Anchored Appchains o aplicaciones de la cadena ancladas. Para que las apps se conviertan en populares en Blockstack, nuestra blockchain tiene una rampa de escalabilidad donde la app puede inicializar su blockchain encima de Stacks. Dicha aplicación cadena quema los tokens para su minado y progresión. Hablemos ahora de Clarity, el lenguaje de programación de los smart contracts. Una de las funciones anunciadas en la versión 2 de 2021 es la capacidad de ejecutar smart contracts programados en Clarity, el lenguaje de programación de este protocolo. Clarity es un lenguaje de programación pensado en la seguridad, optimización y tener una sintaxis sencilla y muy parecida a Lisp, un conocido lenguaje de programación. Sin embargo, la principal característica de Clarity es su enfoque proactivo en la seguridad, algo que tiene mucho sentido en entornos abiertos y públicos como las blockchains. Está pensado para evitar situaciones como las de Ethereum y Solidity, donde los fallos de programación llevan a la pérdida de miles de millones de dólares o euros. Son un dolor de cabeza continuo para los desarrolladores.

Pero, ¿cómo logra entonces esto Clarity? Pues bien, lo hace siguiendo un camino distinto a Solidity. Y es que, para empezar, Clarity es un lenguaje adaptativo. Esto quiere decir que puede ser Turing incompleto o Turing completo, dependiendo de la forma en la que se analice y ejecute. Esto, por un lado, resta flexibilidad a la hora de programar, lo sé, pero brinda un mayor rango de seguridad al limitar las acciones que son posibles de realizar en este lenguaje. Además, permite crear un código más limpio, algo que nos gusta a los programadores, algo que también se traduce en menos errores de código y facilidad para analizar el código de otras personas. Esto simplifica los requisitos de ejecución de este lenguaje, haciéndolo menos exigente a nivel de potencia de cómputo con el fin de obtener resultados más escalables. Es un lenguaje interpretado, por lo que los smart contracts llegan a la blockchain tal cual han sido programados, sin ninguna ofuscación.

Hablemos ahora de la Proof of Transfer o prueba de transferencia, PoX, el corazón de Blockstack. Este es un protocolo derivado del protocolo Proof-of-Burn y que permite establecer una correlación de trabajo computacional entre la blockchain de Bitcoin y la sidechain. Vale decir que este diseño aplica solamente a la versión v2 de Blockstack que salió en 2021. El nacimiento de PoX se debe a la primera propuesta de cambio llamada Burn Election, en la que se propone un sistema conocido como pruebas ajustables. Este sistema permite elegir un líder de minería usando una serie de pruebas. De esta forma, el sistema permite iniciar una nueva cadena de bloques en la parte superior de la cadena de bloques ya existente, teniendo en cuenta dos procesos: destruyendo los tokens de la cadena de bloques existentes y generando una prueba de trabajo adjunta separada. Al final, ambas pruebas de trabajo se ponderarán para crear el protocolo de consenso final de la sidechain Stacks, donde el líder elegido puede validar las transacciones para un bloque determinado y se reinicia el proceso de selección para el nuevo bloque.

Para mejorar la seguridad del sistema, la dificultad de estas pruebas ajustables cambia regularmente a medida que más participantes o más líderes existan. Esto permite que la cadena Stacks aproveche la seguridad de la cadena de bloques establecida para preservar su historial de transacciones, mientras la participación de los líderes se baja y, con el tiempo, la transición hacia su propio grupo de líderes a medida que la cadena se vuelva más popular. Hablemos ahora de Atlas, una red P2P de alta velocidad y escalabilidad. Dado que el objetivo principal de Blockstack es generar una plataforma para el despliegue de aplicaciones descentralizadas de alta demanda, esto hace necesaria la creación de una P2P capaz de hacer frente a una altísima cantidad de datos en transición y que tenga una escalabilidad de alto nivel para ajustar el crecimiento futuro de la red.

La solución para esto es Atlas, una red P2P que está basada en el modelo de protocolo Gossip para su funcionamiento. Atlas tiene la capacidad de que cada par mantiene un registro de los pares existentes en la red y cada par intenta almacenar una copia completa de todos los datos de la red. De esta manera, se busca que la red sea altamente tolerante a fallos y, al mismo tiempo, tenga una escalabilidad de alto nivel. Junto a esto, Atlas también es una red de funcionamiento segregado. Esto quiere decir que esta red está dividida en dos partes. La primera parte de la red sirve para almacenar los datos de la blockchain propiamente, hashes, bloques de transacción, etc. Mientras que la segunda almacena los datos de esos hashes. Como mecanismo de protección, los datos almacenados en esta segunda sección están relacionados entre ellos criptográficamente para evitar ser manipulados.

Resultado: Blockstack propone que puede llegar a ser una blockchain de bajo peso, rápidamente sincronizable y replicable y con un gran nivel de escalabilidad debido a la poca cantidad de información que maneja. Por acabar, Blockstack busca crear una serie de protocolos que simplifiquen el uso de las herramientas. En este caso, Blockstack tiene en funcionamiento varios de estos protocolos y en su versión de 2021 también añadió la capacidad de interactuar con estos por medio de smart contracts, ampliando la descentralización de este sistema. Entre los protocolos iniciales de la red están Gaia, el sistema de almacenamiento de datos controlado por el usuario y de funcionamiento distribuido, que puede verse como una versión de Filecoin, IPFS o SIA. La idea es que Gaia sirva de espacio para almacenamiento necesario para la ejecución de apps descentralizadas, sosteniendo la interacción y generación de datos entre estas y los usuarios.

Otro de los protocolos es el sistema de autenticación Blockstack, un sistema de autenticación digital descentralizado que permite a los usuarios crear un ID en Blockstack para usarlo como medio de interacción con las distintas apps. Los datos son almacenados usando la sidechain Stack Gaia y el sistema de servicios de los nombres Blockstack, BNS. Otro protocolo es el servicio de nombres de Blockstack, BNS, un sistema BNS que permite registrar desde nombres de usuario hasta sitios web de forma descentralizada. Una evolución de Namecoin y contrincante de sistemas como Ethereum Name Service, ENS. El último son servicios de finanzas descentralizadas, DeFi. Con la creación de la capacidad de smart contracts y el resto de funciones añadidas, Blockstack apunta al cada vez más creciente ecosistema DeFi.

Con todas estas capacidades, Blockstack será capaz de permitir la creación de aplicaciones DeFi sin inconvenientes y, de hecho, podrían tener una mejor escalabilidad y seguridad en comparación con su contraparte de Ethereum. Como hemos visto, las cadenas laterales ofrecen mejoras y beneficios a las redes principales, como son Bitcoin. En este caso, hemos visto que RSK ofrece una reducción de comisiones y un mayor porcentaje de transacciones por segundo. Por otro lado, Stacks ofrece un montón de herramientas a los desarrolladores, como nuevas formas de crear smart contracts, nuevos lenguajes de programación o una plataforma para que podáis crear y lanzar vuestras apps descentralizadas.

En conclusión, hemos visto una gran variedad de sidechains que casi todas trabajan sobre Bitcoin en este caso, entre ellas Lightning Network, RSK, Stacks y demás. Todas ellas ofrecen mejoras y ventajas sobre la propia red de Bitcoin, pero siempre manteniendo uno de los pilares básicos de Bitcoin, que son la seguridad y la integridad.

### ¿Qué es una Sidechain?
Una cadena lateral o Sidechain es una cadena de bloques alterna que es usada para mejorar las prestaciones de una cadena de bloques o Blockchain ya existente.

Esto es posible gracias a que una cadena lateral o Sidechain permite que esta nueva cadena de bloques pueda ser conectada e interactuar con una Blockchain existente.

Esta nueva cadena contiene una programación y características completamente distinta, pero es compatible con la cadena a la que se une. Gracias a ello, ambas cadenas pueden comunicarse y complementar sus capacidades.

Un ejemplo de esto puede ser el siguiente. Imagine que un desarrollador desea crear una DApp y desplegarla sobre Bitcoin. Lograr esto directamente sobre Bitcoin de momento es extremadamente complejo. Sin embargo, es posible desarrollar una Sidechain que agregue dicha funcionalidad a Bitcoin de una forma más sencilla. Esta Sidechain tendría la capacidad de desplegar las DApps e interactuar de forma bidireccional con la cadena de Bitcoin. 

**El resultado es que sería posible desarrollar DApps que aprovechen el potencial de Bitcoin (su minería y demás propiedades) gracias al uso de esta Sidechain.**

![[263.B4E4_sidechain.png]]

#### ¿Cómo funciona la Sidechain?
El funcionamiento de una cadena lateral o Sidechain no es nada sencillo.

Técnicamente es un desafío enorme que ha llevado muchos años de desarrollo. Pero a grandes rasgos el funcionamiento de las cadenas laterales es el siguiente:
1. En primer lugar, se envían las criptomonedas a una dirección específica. Una vez allí, los fondos son congelados y nadie puede manejarlos. La única manera de acceder a dichos fondos es demostrar que dichas criptomonedas no se están usando en otro lugar. 
2. Una vez que se confirma que dichos fondos no son usados en otro lugar, se manda una notificación a la Sidechain.
3. Tras esto, la Sidechain creará de forma automática el mismo número exacto de activos de criptomoneda que se mandaron (siempre utilizando el token que dicha Sidechain maneja).
4. El control de estos tokens será completamente tuyo. 
5. A partir de este momento, se podrán intercambiar y mover estos tokens para hacer uso del potencial de esa Sidechain. Todo ello siguiendo las directrices y protocolo que esta tenga estipulado.

Por ejemplo, quizá la velocidad de creación de los bloques es más rápida en esta o quizá los scripts de transacción en esa cadena son turing completos. A partir de aquí y como puedes apreciar, las posibilidades de testeo son prácticamente ilimitadas.

#### ¿Por qué son importantes las cadenas laterales?
Las cadenas laterales o Sidechains tienen una gran relevancia pues permiten dinamizar de forma única el funcionamiento de las Blockchain. 

Por ejemplo, las Sidechain pueden habilitar la transferencia de Bitcoins y otras criptomonedas a otras Blockchain.

Es decir, gracias a las Sidechain sería posible enviar BTC, a una Sidechain que transforme dicho BTC a un token determinado, y de allí que vaya a la Blockchain de Ethereum.

Asimismo, las Sidechain **pueden aumentar la seguridad evitando problemas que se han sucedido en otros proyectos de altcoins.** También pueden servir para agregar nuevas funcionalidades únicas a una Blockchain sin necesidad de alterar el protocolo de la misma.

> Teóricamente, las Sidechains pueden solucionar la falta de liquidez en Bitcoin, reducir la volatilidad, aumentar la seguridad, reducir la fragmentación de mercado o evitar el fraude que, en ocasiones, se ha observado con proyectos de altcoins.

**Todo esto mejoraría enormemente el ecosistema de criptomonedas actual y abriría las puertas para nuevos usos. Son en pocas palabras, un medio perfecto para desarrollar nuevas tecnologías que puede ser adaptada a la ya creada.**

Todo ello sin necesidad de hacer grandes cambios y con posibilidad de seguir expandiendo su potencial.  
Al mismo tiempo, puesto que las Sidechains siguen siendo Blockchain independientes, en ellas se puede experimentar toda clase de funcionalidades sin riesgo. Esto incluye nuevos diseños de transacciones, modelos de confianza o económicos, emisión de activos semánticos o funcionalidades criptográficas nuevas.

#### Sidechain sobre Bitcoin
Si deseas programar sobre Bitcoin, las Sidechain más populares son las siguientes:
1. Counterparty
2. Lightning Network
3. Liquid Network
4. RSK
5. Stacks

### 1 | Counterparty
Counterparty es un protocolo para la creación y uso de instrumentos financieros descentralizados utilizando Bitcoin como una capa de transporte.

![[264.B4E4_Counterparty.png]]

El protocolo implementa y soporta actualmente la creación de activos, la emisión de bonos de esos activos, pago de dividendos, el comercio de protocolo en depósitos, las apuestas binarias, y los contratos-para-diferencia. El protocolo ha estado funcionando desde enero de 2014.

Para activar el protocolo para hacer depósitos de valor de negociación descentralizada y contratos financieros, así como apuestas binarias y contratos-para-diferencia (CFD), había la necesidad de una moneda de valor común en el sistema de Counterparty. 

De una manera similar a cómo se podría hacer uso a nivel personal de Bitcoin, la moneda digital fue empleada para crear unidades de la moneda nativa de Counterparty (XCP). Durante el período de 30 días de prueba en enero de 2014, se crearon 2,6 millones de XCP.

#### Consenso en la red
Las transacciones de Counterparty son transacciones Bitcoin. Dependiendo de su forma se pueden codificar los datos adicionales en una salida OP_RETURN o en direcciones adicionales como en un outut multisignature.

El consenso se logró luego de la interpretación de los datos adicionales en la Blockchain de Bitcoin consistentemente. El software de Counterparty hace un cheque en Github para la última versión mínima requerida, pero otras posibilidades están siendo consideradas para asegurar que los diferentes servicios estén interpretando de forma coherente el protocolo de Blockchain.

#### Disponibilidad del servicio
El uso de Counterparty gira en gran medida alrededor de Counterwallet, el software libre web- Wallet ofrecido por el equipo de desarrollo. 

El equipo central también gestiona un wiki y el foro. Además, Blockscan.com es un explorador de bloques para Counterparty para proporcionar información sobre las transacciones, los activos, los pedidos, las apuestas y las emisiones. El código counterpartyd proporciona una interfaz RPC JSON pero también utiliza una base de datos SQLite para almacenar su información, que facilita el acceso a la información gestionada por el protocolo.

**Fuera de los servicios básicos y de información, algunos proyectos que se están desarrollando consisten en herramientas alrededor de los activos, incluidos los de crowdfunding (Vennd.io, Koinify, Swarm) y programas de recompensas (LTBcoin.com).**

### 2 | Lightning Network
El protocolo Lightning Network, es un protocolo pensado para mejorar la escalabilidad del Bitcoin. 

![[265.B4E4_lightning.png]]

Esto es posible gracias a que Lightning Network trabaja como una segunda capa sobre Bitcoin. 

**Una que le permite a esta criptomoneda realizar cosas que normalmente no podría y más específicamente; transacciones instantáneas y con muy bajas comisiones.** El desarrollo de este protocolo comenzó con los trabajos de Joseph Poon y Thaddeus Dryja. Pero en la actualidad son empresas como Blockstream, Lightning Labs y ACINQ quienes impulsan el desarrollo del mismo. El whitepaper de este desarrollo se puede encontrar en ese enlace de su [web principal](https://lightning.network/).

Para entender un poco el potencial de esta tecnología, debemos tener presente dos cosas. La primera, es que Bitcoin se creó como una solución de dinero digital. La segunda, es que ese objetivo es imposible de alcanzar en el estado actual de la red y el software Bitcoin. 

> La razón de esto es muy sencilla: Bitcoin tiene problemas para escalar.

En la actualidad, Bitcoin solo puede procesar de 7 a 8 transacciones por segundo. Esta es una capacidad muy pequeña y que no puede hacer frente al uso masivo de la criptomoneda. Como resultado, la red Bitcoin se hace lenta y muy cara a la hora de pagar comisiones.

P**or esta razón se necesitaba una nueva forma de realizar transacciones de forma rápida, que fuera sencilla de utilizar y compatible con Bitcoin sin hacer grandes modificaciones. La respuesta a estas necesidades y más es Lightning Network, protocolo del cual aprenderemos un poco más a continuación.**

#### ¿Por qué se necesita mejorar la escalabilidad de Bitcoin?
Seguramente te estarás haciendo esta misma pregunta y estás en tu derecho. La respuesta corta es que al mejorar la escalabilidad las transacciones se hacen de forma más rápida y son menos costosas.

Para explicar la respuesta de forma larga hagamos este pequeño ejercicio: 
- Imagina que haces una transacción en Bitcoin. 
- En ese momento la red Bitcoin tiene muy poco uso y el costo en comisiones de cada transacción es muy pequeño.
- Sin embargo, **el costo de las comisiones puede aumentar debido a que el uso de la red aumenta.**  
    **Esto se debe a que se genera una cola o exceso de transacciones en la Mempool.**  
    Es allí, cuando los mineros suelen priorizar las transacciones con mayor pago de comisiones para obtener más ganancias. 
- **De esa forma, si deseas que una transacción sea procesada de forma rápida, entonces tendrás que pagar más en comisiones.**

Pero este último caso nos indica también que los costos de las comisiones aumentarán hasta el punto de no permitirnos hacer micro pagos. Por ejemplo, enviar 1 dólar puede resultarnos en más de 1 dólar por el coste de la comisión. Esta es una situación sin sentido y que la mejora de escalabilidad puede solucionar, de allí la necesidad de mejorar esta característica.

#### El funcionamiento de Lightning Network
El funcionamiento de Lightning Network depende de varios factores técnicos y de un proceso para que resulte ser seguro de usar. 

En primer lugar, Lightning Network depende de que la no maleabilidad de la criptomoneda esté asegurada. De esta forma, sería imposible para un tercero cambiar la información sobre las transacciones o criptomonedas durante el proceso de verificación o generación de las mismas.

En Bitcoin y Litecoin la propiedad de no maleabilidad de las transacciones se introdujo gracias a la llegada de SegWit (Segregated Witness). Con este soft fork, Bitcoin solucionaba este problema y ponía los primeros ladrillos de construcción para una nueva forma de escalar sus capacidades.

Fue así como comenzó el desarrollo de Lightning Network y sus llamados canales de pago. Estos canales de pago, son la piedra angular del funcionamiento de Lightning Network y la llave para permitir una escalabilidad sin precedentes en Bitcoin.

#### ¿Qué son los canales de pago?
Los canales de pago o payment channels son la base de la Lightning Network. Un canal de pago es en realidad una transacción multifirma en la blockchain con, al menos, una de ellas enviando fondos. 

**En dicho canal, cada persona tiene una clave privada y cada transacción futura podrá realizarse únicamente si las claves de las dos partes firman. Esto como un medio de consenso de que la transacción ha sido aprobada para ejecutarse por ambas partes.**

Adicionalmente, los canales de pagos pueden estar abiertos por un determinado periodo de tiempo. Normalmente este es de unos 10 minutos o lo que tarde en minarse el próximo bloque en la blockchain. **Pero una vez abierto el canal, los participantes del mismo pueden intercambiar activos entre ellos de forma instantánea utilizando los fondos almacenados en dicho canal.** Esto en pocas palabras, significa que las partes que forman parte de un canal de pago Lightning Netwok, pueden realizar pagos entre sí de forma instantánea.

Pese a este comportamiento, las transacciones realizadas en dicho canal de pago son completamente válidas en el blockchain. Esto se debe a que una vez se cierra el canal, las transacciones realizadas se emiten a la red, se verifican y se incluyen en un bloque Bitcoin.

#### Explicando paso a paso el funcionamiento de Lightning Network
Para entender como funciona Lightning Network lo mejor es desglosar paso a paso todo su proceso de funcionamiento. 

Por esa razón, te explicaremos con un sencillo ejercicio como se realiza este proceso junto a otros puntos de interés para despejar todas tus dudas.

En primer lugar, dentro de Lightning tendremos dos participantes que crearán una transacción inicial en la cadena de bloques de 20$. De esos 20$, 10$ serán de Paula y 10$ de Jon. Este reparto podría ser distinto y puede variar dentro del canal que mencionábamos anteriormente, por lo que Paula podría tener 15$ y Jon 5$ al final de todos los intercambios.

**Lo que Lightning hace es tomar la tecnología tras los canales de pago y crear una red que los conforma utilizando smart contracts para asegurarse de que la red puede funcionar de forma descentralizada.**

En tal sentido, nos quedaría el siguiente desglose del proceso:
1. Paula abre un canal de pago con Jon que a su vez tiene un canal con Laura, que a su vez tiene un canal abierto con David.
2. Ahora mismo tenemos 4 partes participando en distintos canales de pago o payment channels.
3. Paula quiere intercambiar activos con David, por lo que podrá enviar fondos a través de Jon y Laura para que lleguen en última instancia a David, el receptor.

Debido a la naturaleza de la Lightning Network, Paula no tendría por qué confiar en Jon y Laura dentro del proceso ya que se usa la criptografía para asegurarse de que los fondos que recibirá David serán exactamente los mismos que ha mandado Paula. Si no, se devolverán de forma automática a Paula.

Ahora bien nos quedamos con una serie de preguntas que son muy importantes responder: **¿Cómo es posible confiar en el paso 3?,** ¿Qué sucede con la disponibilidad? y ¿Cómo se combate el engaño?.Estas tres preguntas las responderemos a continuación.

##### ¿Cómo es posible confiar en el paso 3?
En realidad, Jon y Laura actúan como nodos dentro de la red que podemos equiparar a los mineros de la red Bitcoin. Esto gracias a que ellos procesan de forma descentralizada todas las transacciones sin tener control de los fondos que ayudan a mover.

Por esa razón, en ningún momento Jon y Laura podrían robar los fondos de Paula ya que tan solo se recibirán los fondos a enviar si ya se ha realizado la transacción de salida al recipiente final que en este caso es David.  
¿Qué sucede con la disponibilidad?

Si Jon se desconecta, los fondos del canal no quedarían indefinidamente atrapados en él, sino que dentro del mecanismo de smart contract de Lightning Network, los usuarios pueden cerrar de forma unilateral los canales. De esta forma, si Jon desapareciera Paula podría recuperar su dinero de nuevo gracias al atributo de tiempo añadido en el contrato.  
Cuando un canal se cierre a la vez tras haberse realizado un número de intercambios indefinido en él, los fondos finales de cada parte constarán en la blockchain en 10 minutos o lo que tarde en aparecer el próximo bloque de la red.

##### ¿Cómo se combate el engaño?
Si Paula enviara fondos de su dirección multifirma a David en la Lightning Network pero no cumple y lo que hace es emitir una transacción antigua en la blockchain para cerrar el canal en el estado en el que estaba antes de enviar la transacción a David, el propio software en búsqueda de este tipo de acciones hará que Paula pierda todos sus fondos enviados a David.

Esto como penalización a tal acción, por lo que todo aquel que intente transmitir una transacción antigua e inválida será penalizado.

Gracias a esta red de canales persona a persona es posible encontrar un patrón dentro de la red por el que poder transmitir transacciones fuera de la cadena de bloques sin límites. Todo ello sin perder la confianza de que posteriormente y tras cerrarse el canal constará dentro de la blockchain Bitcoin.

#### Ventajas y desventajas de Lightning Network
##### Ventajas
1. **Lightning ofrece una de las más poderosas opciones para mejorar la escalabilidad de Bitcoin.** Lightning puede llevar a Bitcoin hasta niveles cercanos a 1 millón de transacciones por segundos, mucho más que las manejadas por sistemas de pago como VISA o MasterCard.
2. **Ofrece altos niveles de seguridad y anonimato.** Esto debido a que las transacciones ocurren off-chain por lo que los pagos son prácticamente imposible de rastrear.
3. **Lightning es compatible con otros proyectos de criptomonedas además de Bitcoin.** Por ejemplo, es posible usar Lightning con Litecoin.
4. **Es capaz de reducir enormemente el nivel de tráfico de transacciones dentro de la red Bitcoin.** Esto haría que la red funcione de forma mucho más eficiente.
5. **Las transacciones usando Lightning Network se realizan de forma casi instantánea.**
6. **Permite la realización de micropagos e incluso permite la automatización de los mismos.**
7. **Habilita la capacidad de realizar intercambios atómicos cross-chain.** Esto permite que dos cadenas de bloques que usen la misma función hash, puedan intercambiar tokens sin necesidad de un intermediario como un exchange.

##### Desventajas
1. **Una de las principales desventajas de Lightning es que los pagos solo pueden realizarse a usuarios que estén conectados a un canal de pago.** Esto quiere decir, que el usuario debe estar activo y conectado al canal. A diferencia de esto, las transacciones de criptomonedas tradicionales no tienen esta limitación.
2. **Lightning Network es un protocolo que aún está en constante desarrollo.** Prueba de ello, es que sus creadores aún recomiendan no usar Lightning para operaciones con altas sumas de dinero.
3. **El protocolo limita la liquidez del canal al total de criptomonedas que sostienen todas las partes.** Esta es otra situación que atenta contra las operaciones de alto valor, pues lleva a los usuarios a dividir sus fondos para tener liquidez en la blockchain normal y en los canales Lightning.

### 3 | Liquid Network
Liquid es una innovadora cadena lateral construida sobre la red Bitcoin, que facilita transacciones más rápidas de bitcoin entre empresas y particulares, a la vez que permite una mayor funcionalidad.

![[266.B4E4_liquid.png]]

Algunas de las características de Liquid incluyen:
1. **El activo Liquid Bitcoin (L-BTC) nativo de Liquid está respaldado por una conexión bidireccional a Bitcoin** (BTC) y puede canjearse en cualquier momento, lo que proporciona a las instituciones y a los usuarios finales una forma segura y rápida de transferir bitcoin entre los miembros con una liquidación completa en dos minutos.
2. **Los Activos Emitidos de Liquid aportan características similares de bitcoin a los activos tradicionales,** como el fiat tokenizado, los puntos de recompensa digitales y los activos certificados (por ejemplo, monedas de oro), eliminando la necesidad de cadenas de bloques dedicadas o software de billetera.
3. **La tecnología de transacciones confidenciales de Blockstream garantiza que la cantidad y el tipo de activos transferidos solo sean conocidos por las partes,** lo que mejora la privacidad tanto de las transacciones de L-BTC como de los activos emitidos.

Liquid permite la integración de la billetera GreenAddress, un nuevo cliente de billetera Liquid Wallet de código abierto, y planes de soporte para la billetera de hardware de terceros por parte de Ledger y Trezor.

### 4 | RSK
La plataforma RSK es un protocolo basado en el lenguaje Solidity que funciona como una Sidechain que se ejecuta en paralelo a la Blockchain de Bitcoin. 

![[267.B4E4_rsk.png]]

Este protocolo se basa en una comunicación bidireccional que opera como puente para conectar a ambas cadenas.

De esta forma, permite que la red Bitcoin pueda ayudar en su ejecución a RSK. Es por ello, que la moneda o token nativo de la plataforma RSK es el RSK smart bitcoin (RBTC), que guarda una relación de 1:1 con la moneda original de la red Bitcoin, el bitcoin (BTC).

Gracias a la funcionalidad de esta plataforma, hoy en día es posible disfrutar de aplicaciones descentralizadas (DApps) y Smart Contracts complejos dentro de la red Bitcoin, de forma muy similar a como ocurren dentro de las redes de Ethereum, EOS y otros. Pero con toda la seguridad y la robustez que goza la Blockchain de Bitcoin gracias a su gran poder computacional.

#### ¿Cómo funciona RSK?
RSK es un protocolo de segundo nivel que opera en una Blockchain paralela a la Blockchain de Bitcoin. 

No obstante, ambas redes utilizan el protocolo Proof of Work (PoW) para realizar las validaciones y generar nuevos bloques dentro de sus Blockchain. Asimismo, ambas redes utilizan el algoritmo de minado SHA-256. Una característica que le permite a ambas Blockchain realizar la minería combinada o ==merged mining== empleando los mismos equipos de minería y el mismo poder de cálculo computacional.

> RSK brinda características o funcionalidades especiales que no son posibles en la red Bitcoin como la Federación RSK.

- La Federación RSK está compuesta por empresas reconocidas y de confianza que permiten que los usuarios puedan intercambiar sus monedas en ambas Blockchain cuando necesiten utilizar funciones de la plataforma RSK o tener de vuelta los bitcoins enviados a la cadena paralela cuando necesiten utilizarlos en la red principal. 
- RSK permite la implementación del protocolo DECOR+, con el que se puede llevar un control justo y equitativo entre los mineros para que realicen su trabajo de forma completamente confiable y transparente.
- Cada vez que un usuario requiera realizar una acción dentro de la red RSK, deberá transferir fondos desde la red Bitcoin, los cuales serán bloqueados o congelados por la Federación RSK. Una vez hecho esto, esos bitcoins son transformados en el token nativo de RSK, RBTC en proporción 1:1. 
- Estos tokens serán empleados por los usuarios para pagar a los mineros por las acciones ejecutadas dentro de la plataforma RSK, como la ejecución o procesamiento de Smart Contracts o la implementación de DApps. 
- Asimismo, si los usuarios no emplean los tokens RBTC, pueden solicitar el proceso de vuelta de los RBTC a BTC, para usarlos en la cadena principal, es decir, en Bitcoin.

##### Federación: los miembros aprobados de RSK
RSK tiene un funcionamiento interno del tipo permisionado y de carácter federado. Es decir, todos los miembros que sostienen el ecosistema RSK están registrados e identificados plenamente. Son los conocidos miembros de la Federación y su trabajo es fundamental para el funcionamiento de RSK.

> El funcionamiento de la Federación es sencillo, su tarea es la de bloquear y desbloquear fondos que entran y salen del ecosistema RSK. A cambio de su trabajo, a los miembros de la Federación se les otorga el 1% de las tarifas de transacción generadas en RSK, para cubrir los costos de hardware y mantenimiento.

Básicamente lo que pasa cuando se intercambia BTC por RBTC (RSK BTC), es que los nodos de la Federación reciben algunos BTC y bloquean su uso dentro de la red. Al recibir estos BTC, la Federación autoriza la emisión de la misma cantidad de RBTC en la red RSK. Cuando RBTC necesita convertirse de nuevo en BTC, el RBTC se bloquea en la red RSK y la misma cantidad de BTC se desbloquea en la red Bitcoin. Una estructura de swap que permite la participación en RSK de forma segura.

**Pero para lograr esta funcionalidad sin usar Smart Contracts Turing Completo (que no son soportados en Bitcoin) RSK usa un sistema de clavija bidireccional que requiere de la confianza en un conjunto de terceros semi-confiables (STTP).** Estos terceros semi-confiables y plenamente identificados son la Federación. Así la Federación posee las llaves que protegen los fondos bloqueados en el sistema de dos vías. Ningún STTP puede controlar por sí solo los BTC bloqueados, pero solo la mayoría de ellos tiene la capacidad de liberar fondos BTC. Asi que, básicamente, los miembros de la Federación lo que tienen es una serie de direcciones multifirmas bajo su control, con el cual bloquean y desbloquean fondos según se necesite.

**Por supuesto, existe un proceso automatizado que permite  modificar la composición de esta Federación. Cada miembro de la Federación puede aceptar o rechazar un cambio de composición.** **El proceso, que es poco frecuente, está dirigido por un contrato inteligente, por lo que está abierto al público.** El protocolo tiene una demora forzada por consenso de una semana hasta que se active el cambio. Esto permite a los usuarios transferir los Bitcoins nuevamente a la red Bitcoin en caso de que no confíen en la nueva composición de la Federación. A partir de enero de 2019, la Federación RSK comprende 15 notarios conocidos.

##### RVM: RSK Máquina virtual Turing Complete
**Sin esta implementación es muy poco probable que el protocolo RSK funcione de la forma correcta.** La máquina virtual de RSK (RVM) permite la utilización de una plataforma Turing Complete mediante la cual se pueden ejecutar los Smart Contracts y las DApps sin mayores obstáculos o inconvenientes. Por lo que la RVM es el corazón de la plataforma RSK.

**Por su parte, como la máquina virtual de RSK es compatible con la máquina virtual de la plataforma Ethereum, la EVM, es posible la importación de contratos desde RSK a Ethereum, o viceversa.** Un proceso que no demanda de una gran capacidad de trabajo gracias a su compatibilidad, y que a su vez ofrece grandes beneficios. Como la mejora en la capacidad de procesamiento de las transacciones, permitiendo que la interacción entre los Smart Contracts, las DApps y los usuarios se realice de forma mucho más rápida y eficiente.

#### Características principales de RSK
La plataforma RSK permite la creación y la implementación de programas y aplicaciones distribuidas, junto a contratos inteligentes complejos, de forma segura y confiable.

De igual forma, con todas las funcionalidades con las que cuenta este protocolo, en RSK es posible que las operaciones de transferencias y pagos se realicen de forma mucho más rápida que en la red Bitcoin.

**Por ejemplo, en RSK se implementa el protocolo GHOST para agilizar el proceso de creación y validación de transacciones.** Permitiendo que la cadena pueda realizar entre 10 a 20 transacciones por segundo (TPS); y a su vez, cada transacción puede ser confirmada en un período de 20 hasta 30 segundos.

Asimismo, RSK goza de todas las características propias de la red Bitcoin, como un alto nivel de seguridad y confiabilidad, descentralización, transparencia y mucho más. Cada implementación creada en la red RSK se guarda de forma inalterable en la red Bitcoin. **Es decir, cada acción ejecutada dentro de RSK comienza en la red Bitcoin, se ejecuta en RSK y se registra en la Blockchain Bitcoin.**

Al igual que en Bitcoin, existen BIP para proponer mejoras en aras del avance y perfeccionamiento de la tecnología, en RSK se cuenta con los RSKIP. Son documentos técnicos elaborados por los desarrolladores de la plataforma o la comunidad a fin de plantear mejoras que optimicen el funcionamiento y la operatividad de la red.

Otra cualidad de la que goza RSK es que no posee un número específico de monedas o tokens dentro de su red. Sino que, por el contrario, los tokens RBTC son creados por la transferencia de bitcoins a la red de RSK. Por lo que es imposible manipular o especular con su precio, manteniendo y asegurando un equilibrio dentro del ecosistema de esta plataforma.

#### Ventajas y desventajas de RSK
##### Ventajas
1. RSK permite la creación e implementación de contratos inteligentes de forma descentralizada y autónoma, los cuales pueden estar basados en casi cualquier cosa.
2. En RSK las tarifas de comisión por transacción son mucho más económicas que en la red Bitcoin. En promedio, un usuario puede pagar solo entre el 20% o 25% por una transacción realizada en RSK, de lo que generalmente costaría la misma transacción en la red Bitcoin.
3. Gracias a la implementación del protocolo GHOST, la red RSK puede extraer bloques y validar transacciones de forma mucho más rápida que en la red Bitcoin. En promedio RSK puede procesar entre 10 y 20 TPS, con un promedio de confirmación entre 20 y 30 segundos por transacción. No obstante, si se implementa el protocolo Lumino, la red RSK podría llegar a procesar desde 5.000 hasta 20.000 TPS.
4. Como RSK mantiene las cualidades de la red Bitcoin, esta plataforma también sostiene el mismo grado de pseudo anonimato que posee Bitcoin. Aunque hay que resaltar que en RSK es mucho más factible la implementación de CoinJoin o del protocolo ZK para incrementar el nivel de privacidad de la red.

##### Desventajas
1. Podría considerar una desventaja de la red RSK, que al ser una Sidechain o cadena lateral, esta no opera como una Blockchain propia en sí. Si no más bien que su trabajo y operatividad se fundamenta en otra red, como lo es la Blockchain de Bitcoin. Por lo que RSK funciona más como una herramienta para potenciar a Bitcoin; aunque ambas Blockchain son independientes entre sí.

#### Casos de uso de la plataforma RSK
##### BitGive
La fundación BitGive es pionera en la implementación de la tecnología Blockchain de Bitcoin y de RSK para la realización de donaciones de caridad, a través de su plataforma criptográfica GiveTrack. 

Emplea estas tecnologías para el seguimiento de las donaciones recibidas y realizadas y los resultados de éstas en tiempo real.

La plataforma GiveTrack ofrece confiabilidad y responsabilidad para todos aquellos que deseen realizar donaciones humanitarias. Gracias a las características propias de la tecnología Blockchain y las redes Bitcoin y RSK, como inmutabilidad, transparencia y descentralización.

##### SeSocio
Un mercado financiero de inversión que implementa la tecnología Blockchain y RootStock para brindar una mayor descentralización del mercado. 

También facilita el acceso a todos aquellos pequeños y medianos inversores que deseen acceder a las distintas oportunidades de inversión que existen dentro del mercado.

##### DexFreight
La industria de la logística y transporte está plagada de procesos burocráticos que generan muchos retrasos innecesarios en los tiempos de entregas. 

Además de disputas y hasta casos de robo o fraude. Por ello, la plataforma DexFreight, basada en la tecnología Blockchain, implementa los Smart Contracts gracias a la plataforma RootStock. Esto con la finalidad de mejorar de forma significativa la eficiencia del sistema y por ende, la experiencia de los usuarios.

> Las cualidades que brinda la tecnología Blockchain permite que los procesos en el área de logística y transporte sufran un giro de 360º. Una situación que hace posible que todos estos procesos puedan efectuarse de forma transparente, segura y confiable.

Asimismo, la plataforma RootStock cuenta con varios casos de uso y aplicación en diferentes áreas de la vida cotidiana. Como el desarrollo de juegos, procesos de asesorías y consultorías jurídicas, procesos bancarios, distribución de la cadena alimentaria, y hasta la implementación por parte de los gobiernos en pro de la transparencia y la fiabilidad de los distintos procesos que ejecutan.

### 5 | Stacks
Blockstack es un proyecto de software libre que está enfocado en extender la funcionalidad de la Blockchain de Bitcoin.

![[268.B4E4_stacks.png]]

Blockcstack ha generado toda una infraestructura de apoyo dedicada a ofrecer capacidades de Smart Contracts y toda la infraestructura necesaria para que las DApps funcionen de forma correcta sobre la Blockchain de Bitcoin, y lo mejor, sin tener que afectar de forma negativa el protocolo de Bitcoin.

#### ¿Cómo funciona Blockstack?
- **Es un protocolo de segunda capa:** Por lo que todo su funcionamiento, pese a depender de Bitcoin, no almacena información directamente dentro de la Blockchain de Bitcoin, manteniendo una clara separación entre la interactividad de la Blockchain y las aplicaciones sobre Blockstack.
- **Blockstack depende de toda una infraestructura de funcionamiento externa a la Blockchain de Bitcoin,** y estas partes son las que realmente permiten que Blockstack ejecute sus DApps.
- **La estructura de funcionamiento de Blockstack actual cambió significativamente con la llegada de su versión 2 en 2021.** Blockstack usa su Sidechain ,Stack, para tener una contabilidad interna para todas sus aplicaciones. Con la segunda versión, se permite desplegar smarts contracts y otros tokens.
- **Sobre la Sidechain de Stack, se construyen una serie de servicios y protocolos pensados para expandir las capacidades de Smart Contracts y DApps de Blockstack.** Entre dichas funciones podemos mencionar su servicio de almacenamiento distribuido (Gaia), el sistema de autenticación descentralizada, un sistema descentralizado DNS, servicios financieros y demás servicios que se deseen añadir a futuro. En la actualidad, servicios como Gaia, DNS e identidad digital distribuida se han mejorado con la versión 2.
- **Para facilitar el desarrollo de aplicaciones, Blockstack crea una serie de protocolos que facilitan el acceso a todas estas funciones.** Esto permite que los desarrolladores puedan crear DApps de forma sencilla y desplegar las mismas sobre Blockstack, cerrando con ello el ciclo de desarrollo de una DApps sobre esta plataforma.

##### Stack Tokens (STX), una moneda para la plataforma
Blockstack cuenta con su propio token, el cual se llama Stack Token (STX). En su actual red, la generación inicial de este token responde a una emisión dada en su Genesis Block o bloque génesis. 

Esta emisión produjo un total de 1,32 mil millones de tokens cuando la red se puso en marcha en noviembre de 2018. De estos, 1,32 mil millones de tokens del Genesis Block, se asignaron un total de 866.827.880 tokens de Stacks a compradores anteriores con el lanzamiento del Genesis Block, mientras que 453.172.120 permanecieron sin asignar.

**Esta asignación inicial sirvió para distribuir tokens a los inversores que participaron en la ICO y las rondas de financiación del proyecto durante 2017 y 2018. El resto de tokens por su parte, fue asignado y distribuido junto con el hard fork de la red que distribuyó los tokens vendidos o asignados como parte de varias ventas y distribuciones que tuvo lugar en 2019.**

Ahora bien, en la actualidad estos tokens tienen una función que está limitada dentro de la Sidechain Stack. Esto se debe a que, al movilizar tokens STX, realmente lo que movemos es un valor de unos pocos satoshis dentro de la Blockchain de Bitcoin, y esta operación se ve reflejada tanto en la Sidechain Stack (para contabilidad interna) como en la Blockchain de Bitcoin. **En pocas palabras, de momento STX es un token dentro de la Blockchain de Bitcoin, y esto lleva a la plataforma a tener fuertes problemas de escalabilidad y uso.**

> Para salvar las limitaciones de este modelo, Blockstack busca lanzar su segunda versión donde el token STX responderá a nuevas reglas y tendrá nuevas capacidades. La primera de ellas, es que la generación de tokens STX responderá a un proceso de minería utilizando un esquema que une la Prueba de Trabajo (PoW) con la Prueba de Quemado (PoB). **Este nuevo esquema se llama Prueba de Transferencia o PoX.**

La principal característica de este sistema es que su emisión y dificultad de minería es variable, adaptándose así a las necesidades de la red y afectando lo menos posible el valor del token dentro de los mercados. Así por ejemplo en momentos de alta actividad de la red, la misma generará más tokens STX, y en momentos de menos actividad, reducirá la emisión de estos tokens hasta un mínimo programado en el protocolo. **Vale destacar que este proceso es automático y es controlado directamente por el protocolo de Blockstack.**

Ahora bien la utilidad de estos nuevos tokens estará centrada inicialmente en:
1. **Registrar activos digitales en Blockstack.**  
    Los usuarios de Blockstack podrán usar sus tokens STX para registrar diferentes tipos de activos digitales como nombres de usuarios, nombres de dominios, licencias de software, podcasts y mucho más.
2. **Registrar y ejecutar Smart Contracts.**  
    Para ejecutar Smart Contracts es necesario tener “Gas” para financiar el coste de verificar la exactitud del Smart contract y el coste de su ejecución. Los tokens Stacks también pueden ser utilizados para cubrir los costes de almacenamiento del smart contract en la Stacks Blockchain.
3. **Tasas de las transacciones.**  
    Los tokens Stacks son utilizados para pagar las tasas derivadas de incluir una transacción dentro de la Stack Blockchain.
4. **Anchored app chains (Aplicaciones de la cadena ancladas).**  
    Para que las apps se conviertan populares en Blockstack, nuestra Blockchain tiene una “rampa de escalabilidad” donde una app puede inicializar su Blockchain encima de la Stacks Blockchain. Dicha “aplicación cadena” quema los tokens Stacks para su minado y progresión.

##### Clarity, el lenguaje de programación de Smart Contracts
Una de las nuevas funciones de Blockstack v2 es su capacidad de ejecutar Smart Contracts programados en Clarity, el lenguaje de programación de este protocolo. 

Clarity es un lenguaje de programación pensado en la seguridad, optimización y tener una sintaxis sencilla y muy parecida a Lisp, un conocido lenguaje de programación.

**Sin embargo, la principal característica de Clarity es su enfoque proactivo en la seguridad, algo que tiene mucho sentido en entornos abiertos y públicos como las Blockchain.** Esto está pensado para evitar situaciones como las de Ethereum y Solidity, donde los fallos de programación llevan a la pérdida de miles de millones de dólares y son un dolor de cabeza continuo para los desarrolladores.

Pero, ¿cómo logra esto Clarity? Pues bien, lo hace siguiendo un camino distinto a Solidity, y es que para empezar **Clarity es un lenguaje adaptativo.** **Esto quiere decir que puede ser Turing Incompleto o Turing Completo, dependiendo de la forma en cómo se analice y ejecute.** Esto por un lado resta flexibilidad a la hora de programar, pero brinda un mayor rango de seguridad al limitar las acciones que son posibles de realizar con este lenguaje.

> Además, permite crear un código más limpio, algo que también se traduce en menos errores de código y facilidad para analizar por otras personas y crear herramientas de análisis y depuración.

Esto simplifica los requisitos de ejecución de ese lenguaje, haciéndolo menos exigente a nivel de potencia de cómputo con el fin de obtener resultados más escalables. Es un lenguaje interpretado por lo que los Smart Contracts llegan a la Blockchain tal cual han sido programados sin ninguna ofuscación o codificación inteligible para cualquier persona.

##### Proof of Transfer o Prueba de Transferencia (PoX), el corazón de Blockstack
El corazón de la próxima versión de Blockstack es su protocolo de consenso llamado Proof of Transfer o Prueba de Transferencia (PoX). 

Este es un protocolo derivado del protocolo Proof of Burn (PoB) y que permite establecer una correlación de trabajo computacional entre la Blockchain de Bitcoin y la Sidechain Stacks de Blockstack.

El nacimiento de PoX se debe gracias a la creación del SIP-001, llamado Burn Election, en el cual se propone un sistema conocido como Pruebas Ajustables o Tunables Proof. Este sistema permite elegir un líder de minería usando una serie de pruebas. De esta forma, **el sistema permite iniciar una nueva cadena de bloques en la parte superior de una cadena de bloques existente teniendo en cuenta dos procesos:**

1. Destruyendo los tokens de la cadena de bloques existente (generando una prueba de quemado).
2. Generando una prueba de trabajo adjunta separada.

**Al final, ambas pruebas de trabajos se ponderan para crear el protocolo de consenso final de la Sidechain Stack, donde el líder elegido puede validar las transacciones para un bloque determinado, y se reinicia el proceso de selección para el nuevo bloque.**

Para mejorar la seguridad del sistema, la dificultad de estas Pruebas Ajustables cambia regularmente a medida que participan más y más líderes. Esto permite que la cadena Stacks aproveche la seguridad de una cadena de bloques establecida para preservar sus historiales de transacciones mientras la participación de los líderes es baja (como durante la infancia de la cadena) y, con el tiempo, la transición hacia su propio grupo de líderes a medida que la cadena se vuelve más popular.

##### Atlas, una red P2P de alta velocidad y escalabilidad
Dado que el objetivo principal de Blockstack es generar una plataforma para el despliegue de aplicaciones DApps de alta demanda, esto hace necesario la creación de una P2P capaz de hacer frente a una altísima cantidad de datos en tránsito y que tenga una escalabilidad de alto nivel para ajustarse al crecimiento futuro de la red.

**La solución para esto es Atlas, una red P2P que está basada en el modelo del protocolo gossip para su funcionamiento.** Atlas tiene la capacidad de que cada par mantiene un registro de los pares existentes en la red, y cada par intenta almacenar una copia completa de todos los datos de la red. De esta manera, se busca que la red sea altamente tolerable a fallos y al mismo tiempo tenga una escalabilidad de alto nivel.

Junto a esto, Atlas es una red de funcionamiento segregado. Esto quiere decir que la red está dividida en dos partes. La primera parte de la red sirve para almacenar los datos de la Blockchain propiamente (hashes de bloques y de transacciones), Mientras que la segunda almacena los datos de esos hashes. Como mecanismo de protección, los datos almacenados en la segunda sección están relacionados criptográficamente a los fines de evitar manipulaciones.

¿Resultado? Blockstack propone que puede llegar a ser una Blockchain de bajo peso, rápidamente sincronizable y replicable y con gran nivel de escalabilidad debido a la poca cantidad de información que maneja.

##### Extendiendo la funcionalidad de Blockstack
Finalmente, Blockstack busca crear una serie de protocolos que simplifiquen el uso de sus herramientas. 

En este caso, Blockstack actualmente tiene en funcionamiento varios de estos protocolos, pero en su segunda versión añadirá la capacidad de interactuar con estos por medio de Smart Contracts, ampliando la descentralización de este sistema.

Entre los protocolos iniciales de esta red están:
1. **Gaia:**  
    un sistema de almacenamiento de datos controlado por el usuario y de funcionamiento distribuido. Puede verse como una versión de Filecoin, IPFS o Sia, proyecto que tienen amplia trayectoria en este tipo de desarrollos. La idea es que Gaia sirva de espacio de almacenamiento necesario para la ejecución de las DApps, sosteniendo la interacción y generación de datos entre estas y los usuarios.
2. **Sistema de Autenticación Blockstack:**  
    Un sistema de autenticación digital descentralizado que permitirá a los usuarios crear un ID en Blockstack para usarlo como medio de interacción con las DApps de la plataforma. Los datos son almacenados usando la Sidechain Stack, Gaia y el sistema de Servicios de Nombres de Blockstack (BNS).
3. **Servicio de Nombres de Blockstack (BNS):**  
    Un sistema DNS que permite registrar desde nombres de usuario o sitios web de forma descentralizada. Una evolución de Namecoin y contrincante de sistemas como Ethereum Nameservice (ENS).
4. **Servicios de Finanzas Descentralizadas (DeFi):**  
    Con la creación de la capacidad de Smart Contracts y el resto de funciones añadidas, Blockstack apunta al cada vez más creciente ecosistema DeFi. Con todas estas capacidades, Blockstack será capaz de permitir la creación de aplicaciones DeFi sin inconvenientes, y de hecho, podrían tener una mejor escalabilidad y seguridad en comparación con su contraparte, Ethereum.