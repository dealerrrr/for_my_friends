---
title: Destripando Blockchain | José Maldonado
URL: https://app.web3mba.io/courses/take/bloque-1-introduccion-a-las-criptomonedas/lessons/38965117-destripando-blockchain-jose-maldonado
Tags/Keywords: #Bloque 1 #Introduccion a las cirptomonedas #B1U2 #Blockchain #tecnologia para descentralizar el dinero #tecnologia para descentralizar #descentralizar el dinero #Criptomonedas #Revolucion del dinero #Practica #Destripando Blockchain #José Maldonado
lang: es-AR
---
# Destripando Blockchain
![[42.B1_Destripando_Blockchain.mp4]]
[Destripando Blockchain](https://app.web3mba.io/courses/take/bloque-1-introduccion-a-las-criptomonedas/lessons/38965117-destripando-blockchain-jose-maldonado)

Los simuladores usados en este vídeo pueden ser accedidos por medio de estos enlaces:
1. [**Simulador de redes blockchain**](https://simewu.com/blockchain-simulator/)
2. [**Simulador de redes blockchain - Simplificado**](https://yukiteruamano.github.io/#!/)

Ambos simuladores están construidos en base a software libre y el código de los mismos puede ser accedido por medio de estos enlaces ([**#1**](https://github.com/yukiteruamano/blockchain-simulator-networks) y [**#2**](https://github.com/yukiteruamano/yukiteruamano.github.io)).

Saludos y bienvenidos a este nuevo video en el que explicaremos cómo funciona una blockchain utilizando un sencillo simulador para este tipo de red. En primer lugar, el funcionamiento de una blockchain depende mucho, o depende totalmente, del software de los nodos que permiten el funcionamiento de esta red. Este software, por ejemplo, en el caso de Bitcoin, sería Bitcoin Core, que es el software oficial que nos permite acceder y crear o formar parte de la red Bitcoin. En el caso de Ethereum, estaríamos hablando de software de tipo Geth o Besu, que son programas que nos permiten generar todo lo que necesitamos para conectarnos a estas redes y ser parte de lo que serían sus protocolos de comunicación, de consenso y de todo este tipo de funcionamiento necesario para la blockchain.

En este caso, en este simulador que estamos probando aquí, que están viendo en pantalla, el cual pueden conseguir a través de un enlace justo debajo de este video, nos permitirá configurar una blockchain sencilla en la que utilizaríamos el protocolo de Proof-of-Work para generar una serie de nodos que se conectan en una cierta topología, con una determinada capacidad de interconexión entre ellos, para generar diferentes bloques y así crear lo que sería una blockchain como tal. Para empezar a utilizar este simulador, lo primero que debemos hacer es ir a "Topología" y vamos a generar una topología dentro de lo que sería la red. En este caso, vamos a utilizar la topología del modelo de Bitcoin. Aquí está seleccionada. Y frente a nuestra pantalla, podemos ver que tenemos una generación de topología tipo Bitcoin. Aquí está, y con un número de peers o nodos de 1000. Vamos a reducirlo un poco para simplificarlo. Vamos a poner 10. El número de conexiones de salida lo vamos a dejar en 4. Y el poder mínimo de hash lo vamos a dejar en 10, y el máximo en 100. El resto no lo vamos a mover, simplemente lo dejaremos así. Y vamos a hacer clic en "Generar".

Muy bien, aquí tenemos entonces nuestros diez nodos generados de acuerdo a la información que acabamos de proporcionar. Por ejemplo, el nodo 1 tiene un poder de minería de 40 H/s y una latencia de 129 en su conexión. Está conectado con cuatro pares, que son los nodos 4, 2, 7 y 8. ¿Qué significa esto? En una red blockchain desplegada a nivel real, los nodos se conectan unos con otros para generar caminos de comunicación. En este caso, el nodo 1 está conectado con los nodos 4, 2, 7 y 8. El nodo 1 envía y recibe información de cada uno de estos cuatro nodos. Si uno de estos nodos cayera, por ejemplo, si el nodo 4 desapareciera, quedarían los nodos 2, 7 y 8 para comunicar al nodo 1 con el resto de los nodos.

Lo mismo ocurre, por ejemplo, si vamos al nodo 2. Vemos que el nodo 2 tiene un poder de minería de 54, una latencia de 129 milisegundos y está conectado con los nodos 4, 7, 8, 1, 3, 5, 6, 9 y 10. ¿Qué significa esto? Que el nodo 2 tiene 9 nodos a los que enviar y recibir información. Es decir, tiene una mayor capacidad para resistir la censura. Si, por ejemplo, el nodo 4 o el nodo 7 cayeran o no estuvieran en servicio dentro de la red, simplemente el nodo 2 tendría que enviar información al nodo 8, al nodo 1, al nodo 3 o al resto de nodos que están conectados para enviar y recibir información de la red. Esto es un modelo descentralizado que permite resistir la censura, además de generar redes mucho más fiables, en el sentido de que no importa dónde estés en el mundo, siempre vas a tener un nodo de conexión para acceder a la red, ya sea de Bitcoin o de cualquier otro tipo de blockchain que funcione con esta tecnología.

Lo mismo se repite con el resto de nodos. Podemos ver que existen nodos que están conectados con ocho pares, con siete, etc. En este caso, los nodos pueden decidir o tener diferentes números de conexiones. Generalmente, por ejemplo, en Bitcoin, se generan 8 conexiones con otros nodos. Es la norma general, aunque se puede ampliar o reducir dependiendo de las necesidades que tenga la persona o el operador del nodo. ¿Para qué se necesita todo esto? Para generar lo que sería la red descentralizada, las conexiones entre esos nodos que nos permitan enviar y recibir información sin mayores problemas.

¿Cómo podemos ver esto a nivel real? Es decir, ¿qué es lo que realmente veríamos si pudiéramos desplegar gráficamente esta red? Bueno, este simulador nos permite eso utilizando la opción "Display" y activando la opción "Tool Grid Visualizations". Cuando activamos la visualización, podemos ver abajo cómo se vería nuestra red. Esta sería nuestra red interconectada. Podemos ver que aquí están todos nuestros nodos con conexiones entre ellos que nos permiten enviar y recibir información al resto de nodos con los que estamos conectados. Vamos a desconectarlo un momento para que veamos cómo es la topología. Aquí podemos ir a "Topología", desconectar todos los nodos, y podemos ver nuestros 10 nodos completamente desconectados.

En este caso, ya los nodos están completamente desconectados, pero si estuvieran desconectados, no estaríamos dentro de una blockchain, estaríamos dentro de lo que serían nodos centralizados, porque cada nodo sería capaz de generar su propio historial de lo que sería la blockchain dentro de sus propias reglas o reglas de consenso que pertenecerían a las redes que están desplegando. Por ejemplo, si yo llegara a crear nodos con software para desplegar redes Ethereum y pusiera a funcionar esos nodos de forma desconectada, lo que tendríamos serían 10 versiones diferentes de la red Ethereum. ¿Por qué? Porque los nodos están desconectados y no hay manera de que puedan compartir información y generar una red única con un consenso e historial único. En este caso, si los dejamos así, crearíamos lo que serían hard forks. Cada nodo tendría su propia versión o su propia idea de lo que es una red Ethereum o una red Bitcoin, o cualquier otro tipo de red, dependiendo del software que ejecutemos.

Ahora bien, en este punto no estamos haciendo ningún proceso de minería, simplemente estamos presentando los nodos. Vamos a reconectarlos nuevamente, podemos ir a "Topología" y conectar todos los nodos. Y automáticamente comienza la conexión. En este caso, no estamos haciendo ninguna minería, podemos ver un poco más abajo cómo se comporta el poder de minería. En este caso, vemos que tenemos nuestros diez nodos. No tenemos ningún balance porque no se ha generado ningún bloque dentro de lo que sería la blockchain. Y, por tanto, ningún nodo ha podido reclamar lo que sería una recompensa. Vemos que el porcentaje de generación ha sido cero. El poder de minería de cada uno de los nodos está aquí desplegado, como lo podemos ver. Poder en hashes por segundo. También podemos ver el porcentaje de esa potencia de minería aquí, desplegado con respecto al total de la red.

Para comenzar con lo que sería el proceso de minería, o el proceso de generación de bloques, todo lo que tenemos que hacer es ir aquí arriba y hacer clic en "Start All Miners". Si yo doy clic, podemos ver abajo cómo empiezan las redes a funcionar. Cada uno de los nodos que estás diseñando está generando un bloque, y el que genera el bloque válido, en este caso, es quien se lleva la recompensa. Para saber cómo va el proceso de generación, lo que tenemos que hacer en este caso es simplemente hacer un refresh, y allí podemos ver cómo va el proceso de generación de minería. Simplemente vamos a ir actualizando y vemos que ya en este punto nuestro bloque número 1 y el bloque número 8 son los dos bloques más potentes. De hecho, tienen el 27% y el 17% de todo lo generado dentro de la red porque su poder, si vemos aquí, el poder de minería del nodo 8 es 65 hashes por segundo y el del nodo 1 es 40 hashes por segundo.

Expliquemos un poco esto. A medida que los nodos o los mineros tienen mayor potencia para minar y generar nuevos bloques, mayor será su oportunidad para recibir la recompensa por los bloques que se tienen que generar dentro de la red. Aquí podemos ver claramente cómo se cumple esta situación porque los dos nodos con mayor potencia, que son en este caso el nodo 1 y el nodo 8, son aquellos que generan mayor cantidad de bloques. Si seguimos haciendo el refresh, vemos cómo ha ido actualizando la situación. Ahora tenemos al nodo 8 con 38 en su balance, 38 monedas en su balance, y al nodo 1 con 16 monedas en su balance, y el resto de nodos que tienen un poder de minería más o menos parecido, también tienen una determinada cantidad de balances dentro de lo que sería su sistema.

Ahora bien, ¿dónde podemos ver cuántos bloques se han generado y qué consenso existe sobre la red? En este caso, aquí podemos ver el total de bloques generados, que en este caso son 136 bloques, pero hay una pequeña discrepancia. Siempre en una red blockchain no hay una sincronización total de la red. Siempre hay pequeños delays o pequeños retrasos entre los diferentes nodos y la comunicación que se da entre ellos. Esto es normal. Y los protocolos que generalmente se aplican a este tipo de nodos tienen previsto este tipo de comportamiento. Por ejemplo, en Bitcoin, es posible llegar y generar un bloque con una diferencia horaria importante, pero que todos los nodos son capaces de reconocer para llegar y detectar esa diferencia horaria y verificar si ese bloque ha sido producido primero y de forma correcta, cumpliendo los protocolos de la red, para llegar e incluirlo o no dentro de lo que sería un bloque en la historia de la blockchain de Bitcoin.

Eso es un proceso que ya se da por sentado dentro de lo que serían los reglamentos de inclusión de bloques dentro de la red Bitcoin. ¿Qué significa esto? Significa que se tiene en cuenta en las redes blockchain la capacidad de interconectar diferentes nodos a nivel mundial y que esa conexión no siempre es la más óptima o la más inmediata posible. Por tanto, se tiene en cuenta una serie de variables, como sería el ancho de banda que hay disponible para un determinado nodo o para los determinados nodos, para que puedan sincronizarse y mantener siempre un historial muy parecido o con un consenso muy similar. En redes como Bitcoin, generalmente un bloque llega y se toma como consenso final cuando el 51% de toda la red está de acuerdo en que ese bloque es correcto. Es decir, con el 51% de toda la red Bitcoin aceptando un bloque, ese bloque ya forma parte de la red y la red ya no tiene por qué bifurcarse, por qué hacer un hard fork estando en desacuerdo con la generación o la inclusión de un bloque determinado.

Es decir, en Bitcoin se generan los bloques y se agregan por mayoría. La mayoría es la que tiene el voto final sobre qué es el historial o cuál será el historial final de la red blockchain. Y esto también lo podemos ver claramente aquí, porque si vemos el nodo 1, nodo 2, nodo 3, todos nuestros nodos, la mayoría tiene 136 bloques generados, y los únicos dos que están con datos diferentes serían el nodo 7 y el nodo 8. Es decir, aquí tenemos más del 80%, o tenemos el 80% de los nodos de acuerdo en que hay 136 bloques dentro de lo que sería la blockchain, y que esos 136 bloques son el historial correcto de lo que sería nuestra blockchain generada por este simulador.

Si hacemos un refresh, podemos ver que ahora el total sube a 495 y que ahora los nodos que están desincronizados no son el nodo 7 y el nodo 8, sino el nodo 9 y el nodo 10. Es decir, siempre los delays mantienen la diferencia mínima de la sincronización final de lo que sería la blockchain. Si seguimos haciendo el refresh, vemos ahora que tenemos 529 y en este caso, los delays no han jugado en contra de la red y todos los nodos tienen el consenso de que hay 529 bloques dentro de lo que sería la blockchain como tal. Es decir, todos los nodos están de acuerdo en que la blockchain tiene 529 bloques y ese es el historial completo de la blockchain como tal.

Ahora bien, aquí podemos ver que tenemos bloques con mayor o menor potencia y esa potencia les permite generar más cantidad de bloques a favor o en contra. Podemos verlo fácilmente con el balance, en este caso el de mayor balance es el nodo 2. Tenemos que el nodo 2 tiene 82 monedas en su poder, todo eso porque tiene un poder de hash de 54. Pero, ¿qué pasa cuando el balance de poder de los nodos mineros se desvanece? Se mueve, comienza a variar. Vamos a ir arriba y vamos a buscar uno de estos nodos, vamos a buscar el nodo 1. Y aquí hay una opción muy interesante que se llama "Power", que en este caso el nodo tiene un poder de 40, 40 hashes por segundo. Vamos a duplicárselo, vamos a ponerlo a 80. Y aquí rápidamente podemos ver la diferencia. Si hacemos un refresh, vemos que el poder ahora de la red está en 80% para... 80 hashes por segundo para el nodo 1. Y vemos que eso representa el 17% de todo el poder minero de la red. Si hacemos un refresh, podemos ver que ha detenido la minería. En este caso, simplemente detenemos y volvemos a empezar los mineros para que empiece el proceso nuevamente.

Muy bien. Seguimos haciéndolo refresh. Y aquí podemos ver ya la diferencia de generación de bloques. Aquí ya se están generando los bloques. Vemos que el nodo 1, ahora que tiene 80 hashes por segundo, que es superior a todo el resto de nodos de la red, va a empezar a generar muchos más bloques de forma repetitiva y podemos verlo en los balances. Ahora tiene 86 en su balance. Vemos que la red está con... lo siguiente. Fíjense en este punto. Cuando un nodo tiene un mayor poder de hash, tiene la capacidad de generar los hashes de forma mucho más rápida y, por lo tanto, de adelantar o desvirtuar el futuro de lo que sería el historial de la blockchain como tal. Y esto lo podemos ver aquí muy claramente. El nodo 1 tiene el mayor poder de hash. Y por tanto, es el que mayor oportunidad tiene de generar los bloques, los bloques que encabezaría el historial de la blockchain. Aquí vemos que el bloque que tiene o la cantidad de bloques que tiene la blockchain del nodo 1 es de 684. Pero el resto de la red me dice que solo hay 683. ¿Qué significa esto? Que el nodo 1 ha generado un nuevo bloque y ha comenzado a llevarlo o a enviarlo a toda la red.

Una vez que toda la red recibe este nuevo bloque generado y que pasan las reglas de consenso, es decir, se verifica que el bloque está bien formado y que respeta las reglas de consenso de la red, entonces comenzará a ser agregado a lo que sería el historial final de la blockchain para todos ellos. Hacemos otro refresh y vemos nuevamente la misma situación, pero en este caso es el bloque 2 que tiene 813 bloques generados y el resto tiene 812 bloques dentro de lo que sería su red o su historial de la blockchain. Si volvemos a hacer el refresh, vemos que todos están en sincronía y nuevamente se repite la situación que habíamos comentado antes, de que hay momentos en los que el historial de la blockchain en los nodos es variable, no es exactamente el mismo, hasta que no se realiza la sincronización de toda la red y todo el proceso de validación se da para que ese bloque nuevo sea incluido o sea rechazado de acuerdo a las reglas que tiene la red como tal.

En sus pantallas pueden ver el segundo simulador de blockchain. En este caso, este simulador es un poco más sencillo. Es para ejemplificar y mostrar cómo funcionan las funciones hash, la generación de bloques, la generación de consenso distribuido y la transmisión de lo que son las criptomonedas y la generación de la recompensa dentro de cada una de las blockchains, siguiendo un modelo muy parecido a lo que podemos ver dentro de Bitcoin. En este caso, vamos a empezar con cómo funciona la generación de hash y podemos ver aquí rápidamente que tenemos una explicación sencilla de cómo funciona un hash, en este caso SHA-256, que es el estándar que se aplica dentro de Bitcoin y de muchas otras criptomonedas. Por ejemplo, se puede ver en criptomonedas como Getacash, que también utiliza este tipo de procesos que identifican la información dentro de esta red.

SHA-256 es un estándar de hashing muy conocido a nivel mundial en informática y es ampliamente utilizado en diferentes espacios. Por ejemplo, cada vez que te conectas a internet y lo haces a través de un protocolo seguro como HTTPS, utilizando un certificado del tipo TLS, SHA-256 está presente, aunque no puedas verlo directamente. ¿Cómo está presente? Pues bien, SHA-256 se utiliza para generar una firma única que identifique a ese certificado de comunicaciones. Esa firma única le permite a los navegadores web identificar si el certificado con el que estás trabajando o con el que te estás comunicando con un servidor es correcto y efectivamente puede ser utilizado sin ningún problema. De esta forma se aseguran las conexiones que realizamos normalmente por internet y lo puedes revisar fácilmente simplemente viendo el certificado que estás utilizando con algún servicio web, puede ser Facebook, puede ser Google, todo este tipo de servicios utilizan este tipo de conexiones, y ver cuál es el SHA-256 del certificado que estás utilizando. Vas a ver que, sin importar en qué máquina estés utilizándolo, el SHA-256 nunca cambia. El certificado es el mismo y, por lo tanto, el resultado del SHA-256 del hash nunca va a cambiar. Y eso es lo que vamos a ver precisamente ahora.

Aquí abajo podemos ver que tenemos una data introducida y se genera un hash SHA-256 que en este caso es el que está aquí para la nada. Si agregamos información, por ejemplo, "hola mundo", podemos ver cómo va cambiando el hash y en este caso tenemos este hash que está aquí. Este es nuestro hash SHA-256 para la palabra "hola mundo". Si yo llego y cambio una letra, "Hola, Munda", todo el hash cambia radicalmente. Si vuelvo al estado anterior, me va a generar el mismo hash, "shadd5c". ¿Qué significa esto? SHA-256 funciona como una caja negra. Ingresas una determinada información, se procesa en esta caja negra y te ofrece una salida que tiene estas características: un sistema de caracteres que utiliza el alfanumérico, utiliza números y letras, que tiene 64 caracteres en total y que nunca se va a repetir, jamás se va a repetir para una entrada de datos determinada. Si la entrada de datos es idéntica, tal como podemos ver en este caso con "HolaMundo", vas a obtener el mismo hash. Pero si cambia aunque sea un poco, un espacio, una coma o lo que sea, no vas a obtener el mismo hash que obtuviste antes.

Esto es importante porque, en blockchain, cada una de las operaciones que se realizan siempre tienen que ser distintas, nunca pueden ser iguales. Puede ser el tiempo en el que se generan, la firma, la forma en cómo se está generando, diferentes procesos, la programación que está incluida dentro de la misma transacción. Todo esto suma a lo que sería la entropía para generar el hash SHA-256 único que identifique a cada una de tus operaciones. ¿En qué podemos ver SHA-256 aplicado dentro de lo que serían las redes blockchain? Bueno, puedes verlo en los TXID o en los identificadores de transacción. Los identificadores de transacción de, por ejemplo, Bitcoin y Ethereum utilizan SHA-256 para generarse y de esta forma ser completamente únicos y nunca se van a repetir. Nunca vas a ver dos TXID, dos identificadores de transacción que sean idénticos porque no hay dos transacciones idénticas; siempre va a haber un TXID, una diferencia, sea por tiempo o por cualquier otra sumatoria de elementos que se tomen en cuenta dentro de lo que serían cada una de las reglas de consenso o de generación de este tipo de transacciones.

Entonces, podemos ver que SHA-256 es un pilar fundamental de la criptografía, porque esto es criptografía, un pilar fundamental de la criptografía dentro de lo que sería el funcionamiento de las blockchains. Y tal como puedes ver, no importa, podemos llegar y poner un punto. El hash cambia, cambia totalmente. Y esto es vital para mantener no solamente la seguridad de la red, porque el hecho de que tú cambies un punto y te genere un hash completamente distinto evita que alguien, un tercero malicioso, pueda generar una transacción que se parezca a algo que tú hiciste o algo que algún tercero hizo y que pueda utilizarlo para subvertir el sistema y robar fondos. Este sistema impide ese tipo de acciones porque fácilmente puede ser detectado. Mira, esta información no tiene que ir a la analista y al analizarla y generar el SHA-256 correspondiente y ver que no es idéntico, simplemente lo rechazaría porque sabe que la información ha sido manipulada y que, obviamente, no concuerda con las reglas de consenso que debería tener el nodo. Así de sencillo funcionaría SHA-256 para mantener la seguridad de nuestras transacciones dentro de Bitcoin.

Sea como sea, estas funciones hash, el hashing, son una de las partes más importantes dentro de lo que sería el funcionamiento de una blockchain. Y aquí, en este simulador, puedes verlo muy fácilmente. Probar cómo funciona y cómo cambian, cómo se generan dinámicamente este tipo de situaciones. Lo siguiente que vamos a ver es cómo se genera un bloque. En este caso, vamos aquí a "Block". Y tenemos rápidamente aquí la información de un bloque. Vemos que el primer dato es nuestro número de bloque, en este caso es el bloque número uno, y tenemos un dato muy interesante aquí que es el nonce. El nonce es un número que se genera de forma dinámica dentro de las redes del tipo PoW, sobre todo, también se puede generar en redes del tipo PoS, dependiendo de cómo funcionen este tipo de redes, pero sobre todo se utiliza en redes PoW porque es un número que se genera. El nonce es parte fundamental de lo que sería el objetivo que se busca dentro del trabajo de Proof-of-Work. El nonce nos dice: "Yo quiero que tengas un número de este tipo y que lo tomes para llegar y generar un trabajo de minería que me dé un hash que respete las reglas de consenso que yo acabo de aplicar".

En este caso, tenemos ese bloque con un nonce de 23,344, un número decimal. También se puede representar en forma hexadecimal. Generalmente se representa de esta forma dentro de lo que sería las redes blockchain. Pero vamos a darle al decimal para que sea mucho más legible, en este caso. Vemos también una parte de data, que en este caso puede ser la información dentro de lo que sería el bloque. Puede ser cualquier cosa. Las blockchains no solamente pueden almacenar información de transacciones, también pueden almacenar información de, por ejemplo, video. Si pudiéramos crear una red blockchain que pudiera almacenar puros videos, podríamos hacerlo, puede ser perfectamente plausible. La información que puedas almacenar en los bloques dentro de una blockchain no tiene límites. El único límite es que podamos inyectar o establecer dentro de este tipo de cosas va de acuerdo a las necesidades del programador y de la red que queramos construir. Por ejemplo, podemos llegar a construir una red de bloques pequeños como lo tiene Bitcoin, que en este caso pueden ser bloques de 2 a 4 megas, o podemos hacer una red como lo hizo Bitcoin Satoshi Vision (BSV), que tiene bloques que pueden llegar hasta 2 o 4 GB si se requieren. En este caso no se requieren, y obviamente ese tipo de bloques, con bloques de este tamaño, también tienen un enorme problema porque transportar la información, transmitir la información por toda la red, es mucho más complejo.

En este caso, las redes blockchain tienen que ajustarse a las necesidades y a las realidades que tienen que atender. Y, por ejemplo, en Bitcoin, con 2 o 4 megas, se genera una capacidad de manejo de información bastante importante para este tipo de cosas. Esos 2 o 4 megas incluyen toda la información de bloques, en este caso sería el número de bloques, el nonce, el TXID, toda esa cuestión, pero también incluye lo que sería la carga útil, el payload, que en este caso es lo que llamamos aquí la data, la información que podamos almacenar. La información que podemos almacenar, por ejemplo, en este caso puede ser muy sencilla. Podemos ver, podemos agregar simplemente una cadena de texto, "Big2Me, MVA, web3mba". Y en este caso, como hemos agregado una data, podemos ver que ha cambiado el hash. Y aquí tenemos un dato muy importante, que es el dato previo. El dato previo en este caso nos quiere decir un bloque anterior dentro de lo que sería la blockchain. Como estamos hablando de que es el bloque 1, no hay ningún bloque anterior. Este es el bloque génesis. Estamos creando el bloque génesis de una blockchain. Y por lo tanto, el hash previo, que en este caso lo que estamos viendo aquí, es cero. No existe. Simplemente es nuestro bloque génesis y, por lo tanto, el hash previo no hay ninguno que podamos hacer.

Ahora bien, si vemos, voy a explicar aquí, pendiente con esta parte del hash. Si yo llego y modifico, automáticamente se modifica. Es una función SHA-256 la que se está aplicando aquí. Pero, ¿qué pasa? Porque de repente el bloque estaba todo marcado en verde y ahora me lo marca en rojo. En este caso, en este momento, el bloque es inválido. ¿Por qué es inválido? Porque no respeta las reglas de consenso que se tienen que aplicar sobre la red. En este caso, vamos a activar el modo experto. Y vemos que hay un dato muy importante que se llama dificultad de bloque. Y la dificultad de bloque en este caso está marcada en 4. ¿Qué significa esto? Significa que este hash que está aquí, que es el hash del bloque, que se va a aplicar o que se va a generar, tiene que cumplir con una regla, y la regla es que los primeros 4 dígitos tienen que ser ceros. Puede parecer sencillo, pero no lo es. Generar un hash SHA-256 que tenga esa particularidad. Generar un hash SHA-256 que tenga una determinada cantidad de ceros al principio y que cumpla con el nonce y las reglas de consenso que se tienen que aplicar. No es fácil y este es el trabajo que hace un minero. El minero lo que hace es repetir, iterar una y otra vez, hasta conseguir que este hash, el hash SHA-256, cumpla con la regla de consenso que aparece aquí, que es generar un hash con cuatro ceros al principio, y que esté dentro de los parámetros del nonce y de la dificultad de bloques que me están pidiendo dentro de la red.

Por eso, aquí podemos ver el botón "Minar", y si yo doy clic para minar, va a hacer el proceso de minería. Vamos a hacer clic. Y efectivamente ha generado nuestro primer bloque. Este es el proceso que se genera cada vez que un nodo o un minero está generando un bloque. Él llega, agarra y toda la información que tiene la transforma en lo siguiente: un hash único y repetible con una determinada información dentro. ¿Qué pasa, por ejemplo, si ya hemos generado el bloque y un actor malicioso quiere cambiar la información? Si lo hace, lo que va a pasar es que simplemente se invalida. Puede llegar un actor malicioso y tratar de modificar la información que está dentro de una blockchain porque tenga el poder o porque tenga la capacidad de hacerlo de alguna manera. Pero la existencia de los hashes le permitiría al resto de nodos que están dentro de lo que serían las reglas sinceras de lo que sería el funcionamiento de la blockchain detectar esta manipulación. Y al detectarla, simplemente la desecharían y dirían que esto no es o no está dentro de los parámetros que se están esperando y simplemente llegarían y desecharían el bloque, marcándolo como inválido. Tal como podemos ver nuevamente aquí.

¿Qué tendría que hacer un atacante en este caso? Bueno, tendría que generar el bloque nuevamente. Si yo llego y hago el cambio de información, en este caso fue borrar un punto, si yo hago el cambio de información y mino el bloque, efectivamente el bloque es nuevamente validado. Pero para que un atacante pueda hacer esto en todo el proceso de una red, como ejemplo Bitcoin, tendría que llegar y modificar bloque a bloque cada uno de los más de 700,000 bloques que hay dentro de Bitcoin. Y no solamente bloque a bloque, sino que tiene que hacerlo en el periodo de tiempo que la red Bitcoin especifica, que son los 10 minutos. Por lo tanto, esto es lo que hace que PoW sea tan seguro. Podemos llegar y manipular un bloque, pero no podemos manipular 700,000 bloques al mismo tiempo dentro de las reglas de consenso o dentro de las reglas esperadas de consenso de la red que estamos hablando, en este caso Bitcoin, porque eso es un trabajo enorme que ningún minero podría realizar. No lo podría realizar en un tiempo prudencial que le permita llegar y manipular la red a su antojo, ni siquiera teniendo el 100% del poder de la minería podría llegar y manipular la red.

Entonces, esto es una de las formas en cómo se generan los bloques. Vemos que automáticamente, al minar, se genera toda la información necesaria. Se cumple la regla de la dificultad, se genera el hash esperado, en este caso con los cuatro ceros, y automáticamente se empieza a escribir la historia de cada uno de los bloques dentro de lo que sería la blockchain. Ahora bien, esto también tiene consecuencias dentro de lo que sería el consenso, es decir, la interconexión de lo que sería el bloque anterior con el bloque siguiente y así sucesivamente hasta el infinito. Porque las redes blockchain pueden funcionar de forma infinita siempre y cuando se mantengan todos sus nodos conectados. Esto es lo que veremos a continuación con el sistema distribuido de consensos. Y aquí es muy sencillo porque lo que vemos es lo siguiente. Vemos que tenemos un peer A, un peer B y un peer C. Tenemos tres nodos, todos ellos con la misma información. Tenemos que el primer bloque en el peer A tiene un nonce de 23,344. El peer B tiene el mismo bloque con la misma información. El peer C también tiene el mismo bloque con la misma información. Y todos los bloques son válidos dentro de las reglas de consenso.

Tenemos un total aquí, podemos ver, de cinco bloques, todos son válidos. Y el último hash, en este caso, es este que está aquí. Podemos verlo rápidamente. Efectivamente, el último hash es este que está acá, el bloque cinco. Aquí es importante ver lo siguiente. Tenemos tres peers, tres nodos, que tienen todos ellos la misma información. ¿Qué pasa si yo cambio la información en uno de ellos? Por ejemplo, en el bloque 1, si yo cambio la información, yo puedo ver que automáticamente el peer A invalida todos los bloques anteriores. Lo que habíamos hablado anteriormente en la generación de bloques. Como se ha cambiado la data, el payload de este bloque, los bloques que le siguen no van a tener o no van a respetar la regla de consenso. Ahora bien, si yo lo mino, efectivamente, podemos ver la situación. Pero, ¿qué pasa con el resto de bloques? ¿El resto de bloques no tienen la misma información? Si yo lo mino, él va a dar que este bloque es efectivo, pero no va a estar en sincronía. La información de este peer o de este nodo, que es el nodo A, es diferente al nodo B. Y si yo sigo minando el resto de bloques, yo voy a llegar a un punto en el que mi peer A va a tener un hash diferente al del peer B.

¿Qué significa esto? Cuando intente conectar mi peer A con mi peer B dentro de una red blockchain, cuando estos dos nodos empiezan a compartir información y empiezan a ver: "Mira, esta es la información de mis bloques y este es mi último bloque o mi último hash de bloque", al final, los dos bloques van a entender que están siguiendo historiales diferentes. Y por lo tanto, va a haber un hard fork. Es decir, el bloque A no va a aceptar la información del bloque B y el bloque B no va a aceptar la información del bloque A y se va a generar un hard fork. En este caso, como estamos hablando de dos nodos nada más, estamos hablando de 50-50. Es decir, va a haber un historial para el peer A y un historial para el peer B, y no va a haber ningún problema. Cada bloque o cada nodo va a tener su propio historial y podemos hablar de que están siguiendo historiales de blockchain distintos. Pero si incluimos un tercer bloque o un tercer nodo, quiero decir, en este caso ya no estamos hablando de un 50-50, estamos hablando de un 33% para cada uno. Y en este punto, lo que van a hacer los nodos B y C es desechar la información del bloque A y seguir el historial que B y C tienen. Es decir, la información que el nodo A nos ofrece es inválida, pero la información del nodo B y el nodo C son idénticas, tal como podemos ver en el último bloque que se ha generado, el hash que tienen.

En este punto, B y C son iguales, y por lo tanto el consenso entre estas dos redes va a seguir siendo válido y se va a mantener un historial adecuado para estas dos formas. Aquí, en este punto, B y C pueden comunicarse y mantener sincronizados sus bloques, de manera que estemos hablando de una misma blockchain en dos nodos distintos. Y de esta manera se genera el consenso distribuido dentro de las redes blockchain. Ahora bien, queda por ver la parte de las Coinbase y la generación de movimientos de lo que serían las criptomonedas. En este caso, vamos a verificarlo con un solo ejemplo. Vamos a utilizar nada más el peer-to-peer. Y podemos ver que tenemos un bloque 1, en el que tenemos una Coinbase de 100 euros que se ha entregado al minero de la base, Oli, que en este caso es el minero que se ha ejemplificado para este caso. Si yo mino el bloque, efectivamente ya Oli, que es nuestro minero en este caso, tiene 100 monedas en su haber. Yo puedo entonces en el siguiente bloque, que ya Oli tiene el dinero en su poder, mover, movilizar saldos tal como podemos ver aquí. Podemos ver que en el bloque 2 tenemos una Coinbase de 100 que es la recompensa que se da y esa misma recompensa llega a Oli, pero Oli en este punto puede hacer un movimiento de saldos, puede hacer un movimiento de 10 euros de Oli a un tercero, en este caso lo vamos a llamar Robin, y podemos llegar y hacer este proceso. Y efectivamente se puede hacer porque Oli ya no tiene 100 monedas, tiene 200 en su haber y solo hemos gastado 10 de ellas.

Seguidamente, si vamos al bloque 3, podemos ver que simplemente hay un movimiento de generación de saldos, de movimiento de saldos. Podemos llegar y moverlo de Robin a Lara, que en este caso recordemos que Robin ha recibido 10 euros y por lo tanto puede gastar esos 5 y enviárselos a Lara. Si hacemos la minería, efectivamente esto es positivo porque hay saldos suficientes para hacer ese movimiento y así sucesivamente podemos llegar a ir trabajando con los movimientos de dinero de uno a otro porque el sistema de entradas y de salidas, de saldos dentro de lo que sería este tipo de redes, nos permitiría este tipo de funcionamiento. Aquí quiero hacer una acotación. Este es el sistema que estamos viendo aquí de que se entrega un saldo de una persona A a una persona B, y de esos saldos se van movilizando unos con otros. Generalmente recibe el nombre de UTXO, o transacciones no gastadas. Yo tengo una salida, tengo una entrada y tengo una salida. Tengo una entrada de dinero y tengo una salida de dinero. Si tengo 100 dólares, puedo mandar 100 dólares. Pero no puedo mandar 110 porque no tengo la entrada suficiente para llegar y hacer esa transacción. El modelo UTXO fue diseñado para facilitar este tipo de operaciones dentro de lo que serían las redes blockchain. Satoshi Nakamoto, cuando lo utilizó dentro de Bitcoin, vio que este modelo era bastante más sencillo de realizar que un modelo de tipo cuentas. El modelo de tipo cuentas o account model es el que utilizan, en este caso, las redes Ethereum o redes que son parecidas a Ethereum, como serían Polkadot, que también utiliza este tipo de modelo.

¿Qué quiere decir esto? Que la forma en cómo los saldos se mueven y se generan las Coinbase y todo el proceso de movilización de saldos puede variar dependiendo de las redes y de las necesidades de cada una de ellas. Por ejemplo, ya hablamos de que Bitcoin utiliza UTXO y de que Ethereum utiliza lo que sería el modo de cuentas. Pero un modo mixto también es posible. Por ejemplo, en Cardano podemos ver un modo mixto. En Cardano existen lo que se llama EUTXO o UTXO avanzadas, que no son más que un sistema mixto que une las ventajas del UTXO con algunas particularidades especiales que pueden ser aplicadas gracias al modelo de cuentas. Esto aquí, tal como lo podemos ver, nos deja claro que es factible llegar y realizar diferentes movimientos de este tipo, pero ¿qué pasa si llegamos y hacemos un movimiento inesperado? Recordemos que Oli había recibido 200 euros. Si hacemos que Oli mueva más de 200 euros, ¿qué pasaría si agregáramos eso? Vamos a hacer un ejemplo. Efectivamente, no puede hacer el movimiento porque Oli no tiene esa cantidad de saldos. Y al no tenerla y al no cumplir con esa capacidad, simplemente no puede llegar y mover la cantidad de dinero que trata de mover. Esto es posible gracias al modelo de UTXO y al seguimiento que se realiza no solamente de las Coinbase o las recompensas que se generan en cada bloque y que llegan a cada una de las personas que son los mineros en este caso, sino también al movimiento que se sigue de cada una de las operaciones que estas personas pueden realizar y los saldos que tengan asignados o que tengan bajo su control.

Como pueden ver, el movimiento o el funcionamiento de las redes blockchain es bastante complejo. Pero estos simuladores ayudan mucho a entenderlo y a comprenderlo de forma mucho más gráfica y más fácil. Son capaces de hacernos ver cómo pequeñas cosas que simplemente podríamos pasar por alto en lo que sería un whitepaper o en una explicación del tipo texto, como esas pequeñas cosas pueden marcar la diferencia entre el funcionamiento seguro o inseguro de una red. Espero que les haya gustado este video y nos vemos en otra próxima entrega.