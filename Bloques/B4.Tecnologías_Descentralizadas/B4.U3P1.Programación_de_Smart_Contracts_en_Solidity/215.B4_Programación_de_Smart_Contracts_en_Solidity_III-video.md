---
title: Práctica | Programación de Smart Contracts en Solidity | Eladio Sánchez - III
URL: https://app.web3mba.io/courses/take/bloque-4-tecnologias-descentralizadas/lessons/39464363-practica-programacion-de-smart-contracts-en-solidity-eladio-sanchez-iii
Tags/Keywords: #Bloque 4 #tecnologias descentralizadas #B4U3 #smart contracts #programacion de smart contracts #solidity #Práctica #Programación de Smart Contracts en Solidity #Eladio Sánchez
lang: es-AR
---
# Programación de Smart Contracts en Solidity III
![[215.B4_Programación_de_Smart_Contracts_en_Solidity_III.mp4]]
[Programacion de Smart Contracts en Solidity III](https://app.web3mba.io?wvideo=wswph1psja)

En este nuevo vídeo, vamos a explorar otro concepto de Solidity: las interfaces. Las interfaces, básicamente, proporcionan una lista de funciones que los smart contracts que las implementen deben tener y deben implementar todas sus funciones. Las interfaces contienen simplemente el nombre de la función, los parámetros, lo que devuelven, etc., pero no contienen la funcionalidad, es decir, la implementación de esa función. No contienen un código ejecutable; son simplemente una guía de lo que deben tener los smart contracts que implementen esa interfaz.

Para ello, vamos a crear una interfaz de oráculo y una serie de oráculos que nos proporcionarán el precio de algunos tokens. Por ejemplo, vamos a hacer que nos den el precio de USDT y el precio de MATIC en la red mainnet de Ethereum. De acuerdo, primero vamos a crear una carpeta llamada "oracles" y dentro de esta carpeta, comenzaremos creando la interfaz "IOracle". Es recomendable que el nombre de la interfaz empiece por "I" para que sea fácil identificar que es una interfaz en lugar de un contrato normal. Para acelerar el proceso, vamos a copiar la licencia y la versión.

Normalmente, cuando hemos creado otros contratos, hemos puesto "contract" y el nombre del contrato, pero al ser esto una interfaz, hay que poner "interface" y el nombre de la interfaz, que es "IOracle". ¿Qué queremos que contenga? Queremos que incluya las funciones que tendrá la interfaz. En este caso, solo nos interesa una: obtener el precio. Así que la llamaremos "function getPrice". No recibe parámetros y lo que nos devolverá es el precio.

Hemos visto antes otros tipos de visibilidad, como "public" y "private". Aquí vamos a poner "external", porque las funciones de las interfaces deben ser externas. "External" significa que solo se puede llamar a la función desde fuera del contrato, es decir, desde otro contrato o desde una dirección, como una wallet, pero no desde el propio contrato. Todas las funciones de las interfaces son externas. En este caso, será una función "view" porque no modificará el estado de la blockchain; simplemente leerá y devolverá un tipo "uint256".

De acuerdo, esta sería nuestra interfaz. Como veis, es muy sencilla; únicamente contiene esta función. Ahora vamos a crear un oráculo que implemente esta interfaz. Creamos un nuevo archivo que llamaremos "StableOracle.sol". ¿Por qué "Stable"? Porque este será un oráculo que nos dará el precio de monedas estables, como USDT, USDC, DAI u otras similares. Para simplificar, lo que haremos es un contrato que nos devolverá siempre un valor fijo, que será 1. Normalmente, cuando se obtienen los precios de tokens, se suelen hacer relativos al dólar estadounidense (USD).

Entonces, aquí hacemos "contract StableOracle". Este será el contrato, pero queremos que implemente la interfaz. Para eso, tenemos que importarla en este contrato. Así que utilizamos la palabra "import". Debemos poner la ruta relativa donde está el contrato; al estar en la misma carpeta, será "./IOracle.sol". Ahora tenemos que decirle que este contrato es un "IOracle". ¿Qué implica eso? Estamos diciendo que este contrato debe implementar todas las funciones de esta interfaz. Si no lo hace, nos mostrará un error.

Vamos a hacerlo. La función debe llamarse igual, por supuesto. Tiene que recibir los mismos parámetros; en este caso, ninguno. Esto será una función "external view". Vamos a poner lo mismo. Aquí vamos a poner "override" porque estamos indicando que estamos sobrescribiendo la función de la interfaz. De esta manera, vemos que esta es una función de interfaz y devolverá lo mismo. Como esto será en stablecoin y lo haremos de manera sencilla, devolveremos 1, ya que representa 1 USD o 1 USDT.

Lo que sucede es que en Solidity no existen los decimales; lo que se hace es escalar, es decir, se multiplica y se añaden ceros en lugar de usar decimales. Normalmente, depende de la moneda, pero muchas veces es un estándar utilizar 18 decimales, que es lo que utiliza Solidity para el Ether, que son 10 elevado a 18 wei. Entonces, multiplicaremos esto por 10 elevado a 18, es decir, será un 1 seguido de 18 ceros. De manera simplificada, se puede poner como "1e18", que es 1 por 10 elevado a 18.

Aquí nos sale un warning que nos dice que esto no está leyendo nada de este smart contract, así que en lugar de "view", se puede poner "pure". Sin problema, lo ponemos como "pure". Con esto ya tenemos un oráculo que implementa esta interfaz. Ahora podemos crear otro oráculo que también implemente esta interfaz. Vamos a hacer uno para MATIC. Lo llamaremos "MaticOracle.sol". Para acelerar, vamos a copiar esto y pegarlo aquí. En lugar de "Stable", ahora será "Matic".

Como MATIC no es una stablecoin y tiene un valor que varía, vamos a poner una propiedad que será el precio, que es la que devolveremos cada vez. Entonces, creamos la propiedad "uint256 price", pero la pondremos como privada porque queremos que no se interactúe con este contrato directamente, sino que se haga a través de la interfaz "IOracle". Así que ya tenemos la función "getPrice".

Ahora aquí lo que podremos hacer es, en lugar de devolver 1e18, devolver la propiedad "price". Esto ya no será "view", ahora será "view" porque estamos leyendo algo del smart contract. Sin embargo, ahora mismo no le estamos asignando valor. Vamos a cambiar esto. Cuando despleguemos el smart contract, le pondremos en el constructor un parámetro "price" que será el que asignaremos a la propiedad "price". Esto es lo mismo que hemos hecho en otras ocasiones.

Cuando desplegamos el smart contract, le decimos que el MATIC vale tanto y se almacena esa variable. Cuando llamemos a "getPrice", será ese valor. Pero claro, MATIC es un token que cambia de precio, así que deberíamos tener aquí una función que nos permita cambiar ese valor. Vamos a hacer un "setPrice". Esto es muy parecido a lo que hemos hecho en vídeos anteriores. Establecemos el "price", esto será "public". No es "view" porque estamos cambiando el precio, así que esto será una transacción que modifica el estado.

Vale, pues ya tenemos dos contratos distintos, dos oráculos distintos, pero ambos implementan la misma interfaz "IOracle". Así que, como hemos dicho, nos da igual cómo esté implementado cada uno de estos smart contracts, porque nosotros solo utilizaremos esta interfaz. Vamos a llamar a "getPrice". Nos da igual cómo esté implementado, qué tiene por dentro, si llama a otros contratos; eso nos es indiferente.

Ahora vamos a crear otro smart contract que nos permita interactuar con estos. Vamos a crear uno que se llame "PriceChecker". Copiamos esto, el contrato se llamará "PriceChecker". Este contrato no le pondremos "is IOracle" porque no implementará "IOracle"; lo que hará es llamar a esos otros oráculos. En lugar de importar cada uno de ellos, podríamos hacer un "import MaticOracle.sol" e interactuar con "MaticOracle". Pero la gracia de esto es que basta con tener esta interfaz; podemos comunicarnos con cualquiera de ellos simplemente usando la interfaz y haciendo referencia al address de cada uno de esos contratos.

Vamos a hacerlo bastante genérico. Haremos un mapping, que es algo que ya hemos visto en el vídeo anterior, cuya clave será un address, que será el address del token cuyo precio queremos comprobar, y cuyo valor será un "IOracle", es decir, un objeto, un contrato que implementa la interfaz "IOracle". Lo pondremos como público y lo llamaremos "oracles". Básicamente, es un mapping que nos dice para cada token cuál es su oráculo.

¿Qué tenemos que hacer ahora? Haremos un setter para poder rellenar eso. Este recibirá el token al que queremos consultar el precio y el address del oráculo que nos dará esa información. Será público. Entonces, lo que hacemos, como hemos hecho en otros vídeos, es "oracles[token] = IOracle(oracle)". Con esto estamos instanciando un contrato que sigue esta interfaz con esta dirección. Entonces, esto es un objeto al que podremos llamar a todas sus funciones. Bueno, a todas, en este caso, es únicamente "getPrice".

Con esto ya no necesitamos nada más. Con acceder a "oracles[token]" ya tendremos acceso a esa función. Pero también queremos que nos diga el precio, así que vamos a crear una función que llamaremos "checkPrice". Aquí le diremos que reciba la dirección del token. Es decir, cuando le diga aquí la dirección del token USDT, por ejemplo, me devolverá 1, porque llamará internamente a través de la interfaz de "IOracle", llamará al "StableOracle" y me devolverá lo que sea que implemente esa función.

Vale, pues esto será "public view" y nos devolverá un "uint256". Entonces, esto nos devolverá lo que haya en "oracles[token]", que nos devolverá el objeto "IOracle", y de este llamaremos a su función "getPrice". Y ya está. Con esto ya tendríamos un contrato que podemos surtir de todos los oráculos que creemos, asociados a cada uno de los tokens, y podemos consultar los precios de cada uno de esos tokens.

Ahora vamos a desplegarlos, a compilarlos y a ver que todo funciona bien. Como está en "autocompile", aquí no habrá ningún problema. Vamos a empezar desplegando, por ejemplo, el "StableOracle", que es el primero que hemos hecho. La interfaz no se despliega; lo que desplegamos son cada uno de estos oráculos que implementan esa interfaz. Desplegamos el "StableOracle". Ha ido todo bien y aquí lo tenemos. De hecho, si le diésemos aquí a "getPrice", nos devolvería un 1 seguido de 18 ceros. Perfecto, lo mismo que esperábamos.

Ahora vamos a desplegar el de MATIC. Aquí nos pide un parámetro. Nos venimos aquí y decimos: "¿Cuánto vale ahora mismo un MATIC en USD?". Esto lo tenemos que transformar a... lo tenemos que escalar, es decir, multiplicar por 10 elevado a 18, para que tenga el mismo número de decimales que todos los demás oráculos. Así que lo que hacemos es pegar aquí el número, cambiamos la coma por un punto y decimos "por 10^18". Y entonces esto nos tiene que devolver el valor. Aquí está.

Vale, pues cogemos este número, que es 0.84 x 10^18, lo pegamos aquí y desplegamos el smart contract. Vale, ya tenemos aquí desplegados el "StableOracle" y el "MaticOracle". Lo mismo aquí, si le damos a "getPrice", nos devuelve ese valor. Podríamos actualizar el valor si luego cambiásemos, pero ahora no lo vamos a hacer. Por último, vamos a desplegar el "PriceChecker". Lo desplegamos y aquí lo tenemos.

Ahora mismo no tenemos ningún oráculo dentro de este mapping, así que lo que vamos a hacer es rellenarlo. Vamos a poner un oráculo para el USDT y otro oráculo para MATIC. ¿Cuál es el address del token? Yo lo tengo aquí ya abierto. En Etherscan, puedes buscar cualquier token. Aquí están los USDT, que son los más famosos. Aquí nos viene su dirección, que es la dirección del contrato. Al final, todos los tokens... Esto es un ERC20, es un smart contract que está desplegado. Copiamos su address y lo ponemos aquí en "setOracle". El token será este y el oráculo será el stable, así que como lo tenemos aquí desplegado, le damos al botón de copiar y lo pegamos.

Entonces estamos asociando la dirección de este token con la dirección de este oráculo. Llamamos a la transacción y se ha hecho correctamente. Ahora vamos a añadir, vamos a borrarlo para que no haya confusión. Ahora vamos a añadir el de MATIC. Vale, pues aquí lo mismo, tenemos aquí el token MATIC en la mainnet de Ethereum. Copiamos el address del token y ahora copiamos la dirección del oráculo de MATIC, que es este de aquí. Lo copiamos, lo pegamos y hacemos "Transact".

Muy bien, pues ya tenemos ambos oráculos. Si quisiésemos hacer una comprobación, copiamos aquí el address de MATIC y si le doy, me va a devolver 0.84, que es el oráculo de MATIC. Vale, pues entonces ya podemos consultar directamente los precios de cada uno de ellos. Vamos a consultar el de MATIC, que lo tenemos aquí a mano. Meto el address, estamos llamando a esta función de aquí, "checkPrice". Le vamos a meter el address del token de MATIC y a ver qué nos devuelve.

Vale, pues esto es lo que hemos puesto antes: 0.84 por 10^18. ¡Gracias por ver el vídeo! Y si queremos comprobar el precio del USDT, lo mismo. Vamos aquí a "checkPrice": 1 seguido de 18 ceros. Funciona perfectamente. Como veis, aquí estamos utilizando simplemente "IOracle" para interactuar con distintos smart contracts que están implementados de distinta manera. Cada uno tiene sus particularidades, pero la interfaz nos permite ser agnósticos a la implementación de ese smart contract. Lo único que nos interesa es la interfaz que presenta y la función "getPrice".

También podemos hacer ahora una modificación. Supongamos que el MATIC ha cambiado de precio. Vamos a simular que ha cambiado. Aquí tenemos este número, vamos a decir que en lugar de 0.84, sube a 0.87. Hacemos la transacción y copiamos de nuevo el número, la dirección de MATIC, "checkPrice", 0.87. Hemos cambiado el valor dentro del contrato del oráculo de MATIC y eso nos ha permitido que, cuando lo volvemos a consultar desde el contrato de "PriceChecker", obtenemos un valor distinto.

Y bueno, esto sería todo. Con esto hemos repasado un poco. Hemos visto cómo funcionan las interfaces. Hemos visto que son simplemente funciones sin cuerpo. Hemos visto cómo se importan contratos o interfaces de uno a otro. Hemos visto cómo hacer que un smart contract implemente una interfaz, poniéndole "is IOracle" y el nombre de la interfaz que hemos importado, y poniendo el cuerpo de la función, indicando que estamos haciendo un "override" de esa función. Luego, desde aquí, hemos visto cómo interactuar con distintos contratos a través de una interfaz unificada. ¡Gracias por ver el vídeo!