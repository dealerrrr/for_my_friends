---
title: Hacking a a un Smart Contract | Iulian Ghigheci
URL: https://app.web3mba.io/courses/take/bloque-7-ciberseguridad/lessons/38969860-practica-hacking-a-a-un-smart-contract-iulian-ghigheci
Tags/Keywords: #Bloque 7 #Ciberseguridad #B7U7 #practica #Hacking a un Smart Contract #Iulian Ghigheci #hacking
lang: es-AR
---
# Hacking a a un Smart Contract
![[420.B7_Hacking_a_a_un_Smart_Contract.mp4]]
[Hacking un Smart Contract](https://app.web3mba.io?wvideo=v3ngnt4n1x)

En este video vamos a hacer una demostración de un hackeo a un contrato inteligente que contiene una vulnerabilidad. Para ello, hemos elegido el mismo tipo de ataque que provocó en 2016 la separación de la red Ethereum en dos redes: Ethereum y Ethereum Classic, en el que el atacante logró robar 60 millones de dólares. Este ataque se denomina "entrance attack" y es muy peligroso, ya que permite robar todos los Ethereum del contrato víctima.

Para esta demostración, vamos a usar el entorno de desarrollo Remix, el cual nos proporciona una red blockchain local para poder desplegar los contratos e interactuar con ellos. El contrato que vamos a atacar es un contrato sencillo que representa un banco y que implementa la misma vulnerabilidad que el contrato DAO del ataque de 2016. Este contrato contiene un mapping para guardar las direcciones de los usuarios y el balance de sus cuentas. También implementa un método para hacer depósitos, que simplemente incrementa el balance del usuario con el valor que ha enviado, y tiene una función de retiro, la cual comprueba que el usuario tiene saldo positivo en su cuenta, imprime por pantalla el balance del banco y el balance del usuario, y después hace el envío del total del balance del usuario a su cuenta, a su wallet. Después de esto, actualiza el saldo de su cuenta a cero, ya que ha enviado todo el saldo que tenía. Además, hay un método para comprobar el balance total del banco.

Vamos a desplegar el contrato y comprobar cómo funciona. Aquí lo tenemos. Vamos a hacer algún depósito. Vamos a depositar y efectivamente tenemos 10 ETH en la cuenta del banco, y el usuario tiene 10 ETH. Aquí se ven los decimales de ETH y son 10 ETH. Vamos a hacer otro depósito con otra cuenta. Aquí tenemos 25 ETH en la cuenta del banco, y el balance total del banco, y el usuario tiene en su cuenta 15 ETH. Vamos a hacer un retiro de esos 15 ETH. Podemos comprobar que el banco tenía 25 ETH y el usuario tenía 15 ETH, y después de la ejecución, el balance del banco está en 10 ETH. Vamos a intentar hacer otro retiro, a ver si nos deja. Y efectivamente, no ha pasado el check de aquí, el require, ya que el usuario ya no tenía saldo. El usuario actualmente tiene 0 saldo, por lo que no ha funcionado.

Aparentemente, el contrato funciona correctamente. Pero como sabemos, con un contrato podemos interactuar a través de una cuenta de un usuario privado o a través de otro smart contract, lo que nos da una forma de poder hackear este contrato. Aquí tenemos un contrato atacante que usaremos para atacarlo, el cual define una interfaz que representa el contrato del banco. Este contrato contiene la dirección del contrato a atacar y la dirección del owner del contrato atacante, que se establece en el constructor. Aquí tenemos un método para poder establecer el contrato que vamos a atacar. El método para atacar será un depósito y, acto seguido, un retiro.

Como sabemos, para que un contrato pueda recibir Ethereum, necesita implementar un método que sea payable. Esta parte sería mejor explicarla con una imagen, así que de esa manera se entiende mejor. El ataque funciona de la siguiente manera: se llama a este método y se haría un depósito, se llamaría al método de depósito del contrato del banco, se incrementaría el valor del balance del usuario y después se haría un retiro. Se llamaría a la función de retiro, donde se comprueba que el balance del usuario es positivo, por lo que se procede a enviar el dinero al usuario. En el momento de hacer el envío al contrato, se ejecutaría el método Reset del contrato que es Payment. Este método lo que hace es comprobar que el banco todavía tiene dinero y, en este caso, volvería a llamar, haría una llamada recursiva a la función de retiro.

Hay que tener en cuenta que todavía no hemos llegado a esta línea de código, que es la que actualiza el estado del balance del usuario a cero. Por lo tanto, cuando lleguemos aquí, el usuario todavía tiene el mismo saldo que antes, un saldo positivo, por lo que esta aprobación se cumpliría y se volvería a hacer la llamada para enviarle fondos otra vez al usuario, que en este caso es el contrato. Esto se haría de forma recursiva hasta que esta condición deje de cumplirse, es decir, que el banco ya no tenga ningún saldo en su cuenta. En ese momento, entraría en el else y se haría una transferencia de la cuenta del contrato atacante a la cuenta del wallet del atacante.

Podemos comprobar cómo funciona desplegando el contrato. Vamos a desplegar el contrato. Seleccionamos una cuenta diferente para el atacante y vamos a desplegar el contrato atacante. Por aquí tenemos el contrato atacante. En el banco todavía tenemos 10 ETH. Vamos a establecer el contrato al que vamos a atacar. Ya lo tenemos establecido y ahora lo único que nos queda es atacar. Vamos a hacer un depósito de 2 ETH en el contrato a través del método ATTACK. Lo retiramos y ya vamos de forma recursiva hasta que se vacíe la cuenta del contrato. Vamos a verlo en acción. Ampliamos un poco.

Como podemos comprobar, el contrato anteriormente tenía 10 ETH. Se han depositado los 2 ETH del atacante desde el contrato atacante. Por lo tanto, el usuario que representa el contrato atacante tiene 2 ETH en balance, y se devuelven al contrato esos dos ETH, por lo cual el contrato del banco solamente tiene 10 ETH. Se le vuelve a enviar dos de forma recursiva hasta que el banco se queda sin fondos. Como podemos comprobar, el banco tiene cero ETH, por lo que se le vació la cuenta.

Para poder solucionar esta vulnerabilidad, lo podemos hacer de dos formas. Una de ellas es simplemente, aquí en el contrato del banco, actualizar el estado de la cuenta del banco antes de hacer el envío del valor al usuario o al contrato. En este caso, lo tenemos aquí cambiado. Aquí lo único que cambia es lo que hemos dicho: subir esta línea arriba para actualizar antes de hacer la llamada. Esto es usar el patrón "checks-effects-interactions". Este patrón lo que dice es que primero se hagan las comprobaciones, luego se actualiza el estado y después se interactúa con un contrato que no conocemos, un contrato inseguro.

Podemos desplegar este contrato y ver que realmente soluciona el ataque. Vamos a seleccionarlo, contrato A, desplegamos y aquí tenemos el contrato A, el contrato anterior, el vulnerable. Vamos a hacer algún depósito en este contrato. Vamos a depositar 40 ETH desde otra cuenta. Hemos dicho, vale, depositamos. Efectivamente, tenemos, creo que he marcado otra cosa. Vamos a probar otra vez, vamos a depositar 40 aquí y depositamos 40, 40, efectivamente. Vale, ahora el banco tiene 40. Perdón, la cuenta del usuario tiene 40 ETH en su cuenta, que es lo mismo que la cuenta del banco. Vamos a intentar atacarlo, por lo que vamos a establecer el contrato a atacar y vamos a atacarlo haciendo un depósito, un depósito de 5 ETH. El contrato que vamos a atacar es 8CA8C6A, es el mismo. Genial, pues vamos a proceder a pagarlo.

Efectivamente, podemos comprobar que el banco tenía 40 ETH. Se ha intentado depositar 5 ETH, por lo que el banco tendría 45 ETH y 5 ETH el usuario. Pero al intentar hacer la segunda llamada para poder retirar más fondos, el banco ha decidido que no se puede hacer. Por lo tanto, el banco ha decidido que no se puede hacer. Como el estado ya se había actualizado en la segunda llamada, ya no se pasaba este require, por lo que ya no se podía hackear.

La segunda forma de solucionar esta vulnerabilidad es haciendo uso de esta librería de OpenZeppelin. Esta librería nos proporciona un modificador de acceso que se llama "nonReentrant", el cual funciona de la misma forma que un candado. Tiene un booleano que se establece en true antes de que se ejecute el código. Como podemos ver aquí, es el mismo código de antes, del mismo código vulnerable. Pero al usar este "nonReentrant", que es un candado, antes de ejecutar todo este código, se establece ese valor a true. Y se comprueba, cada vez que se ejecuta ese método, que ese valor esté en false. Inicialmente está en false, cuando se ejecuta, antes de ejecutar el código, se establece en true y al final de la ejecución se establece en false otra vez, por lo que mientras se esté ejecutando ese código, no se podría volver a llamar a este método.

Vamos a desplegar este contrato y comprobar que realmente funciona. Aquí lo tenemos, vamos a hacer algún depósito desde una cuenta. Vamos a poner 50 ETH y hacemos un depósito. Efectivamente, el banco ahora tiene 50 ETH, por lo que vamos a intentar hackearlo. Vamos a la cuenta del atacante, vamos a establecer el contrato que vamos a atacar, que es este, lo he copiado, ya está establecido y ahora vamos a atacarlo con 5 ETH, depositamos 5 ETH y lo retiramos de forma iterativa hasta que se vacíe. Vamos a intentarlo. Lo normal es que no funcione y ya está.

Y efectivamente, se ha revertido la transacción. Se ha intentado depositar los 5 ETH, por lo que el banco tendría 55, pero en la segunda ya se ha revertido. Por lo cual, esta solución también funciona. Espero que os haya gustado el video y que haya ayudado a entender cómo funciona esta vulnerabilidad. ¡Muchas gracias!